(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod16) => function __require() {
    return mod16 || (0, cb[__getOwnPropNames(cb)[0]])((mod16 = { exports: {} }).exports, mod16), mod16.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod16, isNodeMode, target) => (target = mod16 != null ? __create(__getProtoOf(mod16)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod16 || !mod16.__esModule ? __defProp(target, "default", { value: mod16, enumerable: true }) : target,
    mod16
  ));

  // node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "node_modules/dayjs/dayjs.min.js"(exports, module) {
      !function(t2, e2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define(e2) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs = e2();
      }(exports, function() {
        "use strict";
        var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h3 = "year", d3 = "date", l4 = "Invalid Date", $3 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
          return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
        } }, m2 = function(t3, e3, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
        }, v3 = { s: m2, z: function(t3) {
          var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        }, m: function t3(e3, n3) {
          if (e3.date() < n3.date()) return -t3(n3, e3);
          var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
          return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: c2, y: h3, w: o2, d: a2, D: d3, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g2 = "en", D2 = {};
        D2[g2] = M2;
        var p2 = "$isDayjsObject", S2 = function(t3) {
          return t3 instanceof _3 || !(!t3 || !t3[p2]);
        }, w3 = function t3(e3, n3, r3) {
          var i3;
          if (!e3) return g2;
          if ("string" == typeof e3) {
            var s3 = e3.toLowerCase();
            D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
            var u3 = e3.split("-");
            if (!i3 && u3.length > 1) return t3(u3[0]);
          } else {
            var a3 = e3.name;
            D2[a3] = e3, i3 = a3;
          }
          return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
        }, O = function(t3, e3) {
          if (S2(t3)) return t3.clone();
          var n3 = "object" == typeof e3 ? e3 : {};
          return n3.date = t3, n3.args = arguments, new _3(n3);
        }, b3 = v3;
        b3.l = w3, b3.i = S2, b3.w = function(t3, e3) {
          return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _3 = function() {
          function M3(t3) {
            this.$L = w3(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
          }
          var m3 = M3.prototype;
          return m3.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n3 = t4.utc;
              if (null === e3) return /* @__PURE__ */ new Date(NaN);
              if (b3.u(e3)) return /* @__PURE__ */ new Date();
              if (e3 instanceof Date) return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match($3);
                if (r3) {
                  var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
                }
              }
              return new Date(e3);
            }(t3), this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return b3;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l4);
          }, m3.isSame = function(t3, e3) {
            var n3 = O(t3);
            return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
          }, m3.isAfter = function(t3, e3) {
            return O(t3) < this.startOf(e3);
          }, m3.isBefore = function(t3, e3) {
            return this.endOf(e3) < O(t3);
          }, m3.$g = function(t3, e3, n3) {
            return b3.u(t3) ? this[e3] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e3) {
            var n3 = this, r3 = !!b3.u(e3) || e3, f3 = b3.p(t3), l5 = function(t4, e4) {
              var i3 = b3.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
              return r3 ? i3 : i3.endOf(a2);
            }, $4 = function(t4, e4) {
              return b3.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
            }, y4 = this.$W, M4 = this.$M, m4 = this.$D, v4 = "set" + (this.$u ? "UTC" : "");
            switch (f3) {
              case h3:
                return r3 ? l5(1, 0) : l5(31, 11);
              case c2:
                return r3 ? l5(1, M4) : l5(0, M4 + 1);
              case o2:
                var g3 = this.$locale().weekStart || 0, D3 = (y4 < g3 ? y4 + 7 : y4) - g3;
                return l5(r3 ? m4 - D3 : m4 + (6 - D3), M4);
              case a2:
              case d3:
                return $4(v4 + "Hours", 0);
              case u2:
                return $4(v4 + "Minutes", 1);
              case s2:
                return $4(v4 + "Seconds", 2);
              case i2:
                return $4(v4 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e3) {
            var n3, o3 = b3.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l5 = (n3 = {}, n3[a2] = f3 + "Date", n3[d3] = f3 + "Date", n3[c2] = f3 + "Month", n3[h3] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $4 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
            if (o3 === c2 || o3 === h3) {
              var y4 = this.clone().set(d3, 1);
              y4.$d[l5]($4), y4.init(), this.$d = y4.set(d3, Math.min(this.$D, y4.daysInMonth())).$d;
            } else l5 && this.$d[l5]($4);
            return this.init(), this;
          }, m3.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m3.get = function(t3) {
            return this[b3.p(t3)]();
          }, m3.add = function(r3, f3) {
            var d4, l5 = this;
            r3 = Number(r3);
            var $4 = b3.p(f3), y4 = function(t3) {
              var e3 = O(l5);
              return b3.w(e3.date(e3.date() + Math.round(t3 * r3)), l5);
            };
            if ($4 === c2) return this.set(c2, this.$M + r3);
            if ($4 === h3) return this.set(h3, this.$y + r3);
            if ($4 === a2) return y4(1);
            if ($4 === o2) return y4(7);
            var M4 = (d4 = {}, d4[s2] = e2, d4[u2] = n2, d4[i2] = t2, d4)[$4] || 1, m4 = this.$d.getTime() + r3 * M4;
            return b3.w(m4, this);
          }, m3.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m3.format = function(t3) {
            var e3 = this, n3 = this.$locale();
            if (!this.isValid()) return n3.invalidDate || l4;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b3.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h4 = function(t4, n4, i4, s4) {
              return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
            }, d4 = function(t4) {
              return b3.s(s3 % 12 || 12, t4, "0");
            }, $4 = f3 || function(t4, e4, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y3, function(t4, r4) {
              return r4 || function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return b3.s(e3.$y, 4, "0");
                  case "M":
                    return a3 + 1;
                  case "MM":
                    return b3.s(a3 + 1, 2, "0");
                  case "MMM":
                    return h4(n3.monthsShort, a3, c3, 3);
                  case "MMMM":
                    return h4(c3, a3);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return b3.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h4(n3.weekdaysMin, e3.$W, o3, 2);
                  case "ddd":
                    return h4(n3.weekdaysShort, e3.$W, o3, 3);
                  case "dddd":
                    return o3[e3.$W];
                  case "H":
                    return String(s3);
                  case "HH":
                    return b3.s(s3, 2, "0");
                  case "h":
                    return d4(1);
                  case "hh":
                    return d4(2);
                  case "a":
                    return $4(s3, u3, true);
                  case "A":
                    return $4(s3, u3, false);
                  case "m":
                    return String(u3);
                  case "mm":
                    return b3.s(u3, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return b3.s(e3.$s, 2, "0");
                  case "SSS":
                    return b3.s(e3.$ms, 3, "0");
                  case "Z":
                    return i3;
                }
                return null;
              }(t4) || i3.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d4, l5) {
            var $4, y4 = this, M4 = b3.p(d4), m4 = O(r3), v4 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
              return b3.m(y4, m4);
            };
            switch (M4) {
              case h3:
                $4 = D3() / 12;
                break;
              case c2:
                $4 = D3();
                break;
              case f2:
                $4 = D3() / 3;
                break;
              case o2:
                $4 = (g3 - v4) / 6048e5;
                break;
              case a2:
                $4 = (g3 - v4) / 864e5;
                break;
              case u2:
                $4 = g3 / n2;
                break;
              case s2:
                $4 = g3 / e2;
                break;
              case i2:
                $4 = g3 / t2;
                break;
              default:
                $4 = g3;
            }
            return l5 ? $4 : b3.a($4);
          }, m3.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m3.$locale = function() {
            return D2[this.$L];
          }, m3.locale = function(t3, e3) {
            if (!t3) return this.$L;
            var n3 = this.clone(), r3 = w3(t3, e3, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return b3.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), k2 = _3.prototype;
        return O.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h3], ["$D", d3]].forEach(function(t3) {
          k2[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), O.extend = function(t3, e3) {
          return t3.$i || (t3(e3, _3, O), t3.$i = true), O;
        }, O.locale = w3, O.isDayjs = S2, O.unix = function(t3) {
          return O(1e3 * t3);
        }, O.en = D2[g2], O.Ls = D2, O.p = {}, O;
      });
    }
  });

  // lib/lesli_assets_js/lesli_chart.js
  var require_lesli_chart = __commonJS({
    "lib/lesli_assets_js/lesli_chart.js"(exports, module) {
      var LesliChart2 = class {
        /**
         * Render a chart inside a container
         *
         * @param {Object} config
         * @param {String} config.id        DOM id
         * @param {String} config.type      "bar" | "line"
         * @param {Array}  config.series    Apex-style series
         * @param {Array}  config.labels    X-axis labels
         * @param {Boolean} config.compact  Sparkline mode
         */
        constructor(config) {
          const container = document.getElementById(config.id);
          if (!container) return;
          const hasMultipleDatasets = config.datasets.length > 1;
          container.innerHTML = "";
          const canvas = document.createElement("canvas");
          container.appendChild(canvas);
          const ctx = canvas.getContext("2d");
          const chartConfig = {
            // Chart type: "bar" or "line"
            type: config.type,
            // Chart data definition
            data: {
              // X-axis labels
              labels: config.labels,
              // Series data
              datasets: config.datasets
            },
            // Chart behavior and appearance options
            options: {
              layout: {
                padding: {
                  top: 20,
                  left: 20,
                  right: 20,
                  bottom: 20
                }
              },
              // Automatically resize with container
              responsive: true,
              // Allow manual height control via CSS
              maintainAspectRatio: false,
              // Plugin configuration
              plugins: {
                // Legend configuration
                legend: {
                  display: hasMultipleDatasets,
                  position: "top",
                  align: "center"
                },
                // Tooltip behavior
                tooltip: {
                  enabled: true
                }
              },
              // Axis configuration
              scales: {
                x: {
                  // Show X axis
                  display: true,
                  // X-axis label styling
                  ticks: {
                    maxRotation: 65,
                    font: { size: 15 }
                  },
                  // Hide vertical grid lines
                  grid: {
                    display: false
                  }
                },
                y: {
                  // Show Y axis
                  display: true,
                  // Hide horizontal grid lines
                  grid: {
                    display: false
                  }
                }
              },
              // Click handler for points/bars.
              onClick: (event, elements2) => {
                if (!elements2.length) return;
                const element = elements2[0];
                emit("markerClick", {
                  seriesIndex: element.datasetIndex,
                  dataPointIndex: element.index
                });
              }
            }
          };
          if (config.compact) {
            chartConfig.options.plugins.legend.display = false;
            chartConfig.options.scales.x.display = false;
            chartConfig.options.scales.y.display = false;
            chartConfig.options.layout.padding.top = 8;
            chartConfig.options.layout.padding.left = 0;
            chartConfig.options.layout.padding.right = 0;
            chartConfig.options.layout.padding.bottom = 6;
            if (config.type === "line") {
              chartConfig.options.layout.padding.top = 10;
              chartConfig.options.layout.padding.bottom = 6;
            }
          }
          ChartJs.defaults.elements.line.tension = 0.4;
          ChartJs.defaults.elements.line.borderCapStyle = "round";
          ChartJs.defaults.elements.bar.borderRadius = 6;
          ChartJs.defaults.elements.bar.borderSkipped = false;
          ChartJs.defaults.font.family = "'Source Sans 3', system-ui, sans-serif";
          ChartJs.defaults.font.size = 14;
          ChartJs.defaults.color = "#4a4a4a";
          new ChartJs(ctx, chartConfig);
        }
      };
      module.exports = LesliChart2;
    }
  });

  // node_modules/lesli-js/node_modules/dayjs/dayjs.min.js
  var require_dayjs_min2 = __commonJS({
    "node_modules/lesli-js/node_modules/dayjs/dayjs.min.js"(exports, module) {
      !function(t2, e2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define(e2) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs = e2();
      }(exports, function() {
        "use strict";
        var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h3 = "quarter", c2 = "year", d3 = "date", $3 = "Invalid Date", l4 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m2 = function(t3, e3, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
        }, g2 = { s: m2, z: function(t3) {
          var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        }, m: function t3(e3, n3) {
          if (e3.date() < n3.date()) return -t3(n3, e3);
          var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, f2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), f2);
          return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: f2, y: c2, w: o2, d: a2, D: d3, h: u2, m: s2, s: i2, ms: r2, Q: h3 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, D2 = "en", v3 = {};
        v3[D2] = M2;
        var p2 = function(t3) {
          return t3 instanceof _3;
        }, S2 = function(t3, e3, n3) {
          var r3;
          if (!t3) return D2;
          if ("string" == typeof t3) v3[t3] && (r3 = t3), e3 && (v3[t3] = e3, r3 = t3);
          else {
            var i3 = t3.name;
            v3[i3] = t3, r3 = i3;
          }
          return !n3 && r3 && (D2 = r3), r3 || !n3 && D2;
        }, w3 = function(t3, e3) {
          if (p2(t3)) return t3.clone();
          var n3 = "object" == typeof e3 ? e3 : {};
          return n3.date = t3, n3.args = arguments, new _3(n3);
        }, O = g2;
        O.l = S2, O.i = p2, O.w = function(t3, e3) {
          return w3(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _3 = function() {
          function M3(t3) {
            this.$L = S2(t3.locale, null, true), this.parse(t3);
          }
          var m3 = M3.prototype;
          return m3.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n3 = t4.utc;
              if (null === e3) return /* @__PURE__ */ new Date(NaN);
              if (O.u(e3)) return /* @__PURE__ */ new Date();
              if (e3 instanceof Date) return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match(l4);
                if (r3) {
                  var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
                }
              }
              return new Date(e3);
            }(t3), this.$x = t3.x || {}, this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return O;
          }, m3.isValid = function() {
            return !(this.$d.toString() === $3);
          }, m3.isSame = function(t3, e3) {
            var n3 = w3(t3);
            return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
          }, m3.isAfter = function(t3, e3) {
            return w3(t3) < this.startOf(e3);
          }, m3.isBefore = function(t3, e3) {
            return this.endOf(e3) < w3(t3);
          }, m3.$g = function(t3, e3, n3) {
            return O.u(t3) ? this[e3] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e3) {
            var n3 = this, r3 = !!O.u(e3) || e3, h4 = O.p(t3), $4 = function(t4, e4) {
              var i3 = O.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
              return r3 ? i3 : i3.endOf(a2);
            }, l5 = function(t4, e4) {
              return O.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
            }, y4 = this.$W, M4 = this.$M, m4 = this.$D, g3 = "set" + (this.$u ? "UTC" : "");
            switch (h4) {
              case c2:
                return r3 ? $4(1, 0) : $4(31, 11);
              case f2:
                return r3 ? $4(1, M4) : $4(0, M4 + 1);
              case o2:
                var D3 = this.$locale().weekStart || 0, v4 = (y4 < D3 ? y4 + 7 : y4) - D3;
                return $4(r3 ? m4 - v4 : m4 + (6 - v4), M4);
              case a2:
              case d3:
                return l5(g3 + "Hours", 0);
              case u2:
                return l5(g3 + "Minutes", 1);
              case s2:
                return l5(g3 + "Seconds", 2);
              case i2:
                return l5(g3 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e3) {
            var n3, o3 = O.p(t3), h4 = "set" + (this.$u ? "UTC" : ""), $4 = (n3 = {}, n3[a2] = h4 + "Date", n3[d3] = h4 + "Date", n3[f2] = h4 + "Month", n3[c2] = h4 + "FullYear", n3[u2] = h4 + "Hours", n3[s2] = h4 + "Minutes", n3[i2] = h4 + "Seconds", n3[r2] = h4 + "Milliseconds", n3)[o3], l5 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
            if (o3 === f2 || o3 === c2) {
              var y4 = this.clone().set(d3, 1);
              y4.$d[$4](l5), y4.init(), this.$d = y4.set(d3, Math.min(this.$D, y4.daysInMonth())).$d;
            } else $4 && this.$d[$4](l5);
            return this.init(), this;
          }, m3.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m3.get = function(t3) {
            return this[O.p(t3)]();
          }, m3.add = function(r3, h4) {
            var d4, $4 = this;
            r3 = Number(r3);
            var l5 = O.p(h4), y4 = function(t3) {
              var e3 = w3($4);
              return O.w(e3.date(e3.date() + Math.round(t3 * r3)), $4);
            };
            if (l5 === f2) return this.set(f2, this.$M + r3);
            if (l5 === c2) return this.set(c2, this.$y + r3);
            if (l5 === a2) return y4(1);
            if (l5 === o2) return y4(7);
            var M4 = (d4 = {}, d4[s2] = e2, d4[u2] = n2, d4[i2] = t2, d4)[l5] || 1, m4 = this.$d.getTime() + r3 * M4;
            return O.w(m4, this);
          }, m3.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m3.format = function(t3) {
            var e3 = this, n3 = this.$locale();
            if (!this.isValid()) return n3.invalidDate || $3;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, f3 = n3.months, h4 = function(t4, n4, i4, s4) {
              return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].substr(0, s4);
            }, c3 = function(t4) {
              return O.s(s3 % 12 || 12, t4, "0");
            }, d4 = n3.meridiem || function(t4, e4, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            }, l5 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O.s(a3 + 1, 2, "0"), MMM: h4(n3.monthsShort, a3, f3, 3), MMMM: h4(f3, a3), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h4(n3.weekdaysMin, this.$W, o3, 2), ddd: h4(n3.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d4(s3, u3, true), A: d4(s3, u3, false), m: String(u3), mm: O.s(u3, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i3 };
            return r3.replace(y3, function(t4, e4) {
              return e4 || l5[t4] || i3.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d4, $4) {
            var l5, y4 = O.p(d4), M4 = w3(r3), m4 = (M4.utcOffset() - this.utcOffset()) * e2, g3 = this - M4, D3 = O.m(this, M4);
            return D3 = (l5 = {}, l5[c2] = D3 / 12, l5[f2] = D3, l5[h3] = D3 / 3, l5[o2] = (g3 - m4) / 6048e5, l5[a2] = (g3 - m4) / 864e5, l5[u2] = g3 / n2, l5[s2] = g3 / e2, l5[i2] = g3 / t2, l5)[y4] || g3, $4 ? D3 : O.a(D3);
          }, m3.daysInMonth = function() {
            return this.endOf(f2).$D;
          }, m3.$locale = function() {
            return v3[this.$L];
          }, m3.locale = function(t3, e3) {
            if (!t3) return this.$L;
            var n3 = this.clone(), r3 = S2(t3, e3, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return O.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), b3 = _3.prototype;
        return w3.prototype = b3, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d3]].forEach(function(t3) {
          b3[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), w3.extend = function(t3, e3) {
          return t3.$i || (t3(e3, _3, w3), t3.$i = true), w3;
        }, w3.locale = S2, w3.isDayjs = p2, w3.unix = function(t3) {
          return w3(1e3 * t3);
        }, w3.en = v3[D2], w3.Ls = v3, w3.p = {}, w3;
      });
    }
  });

  // node_modules/lesli-js/src/debug/utils.js
  var require_utils = __commonJS({
    "node_modules/lesli-js/src/debug/utils.js"(exports, module) {
      var dayjs2 = require_dayjs_min2();
      var Utils = class {
        // · 
        buildDate() {
          return dayjs2().format("MM/DD HH:mm").toString();
        }
        // · 
        buildMessage(message, module2, level) {
          let newMessage = `[${this.buildDate()}] [${level.toUpperCase()}]`;
          if (module2) {
            newMessage += ` (${module2})`;
          }
          newMessage = newMessage.concat(" - ").concat(message);
          return newMessage;
        }
        // · 
        stylesForBrowser(type) {
          let lineheight = "1.5;";
          let fontsize = "14px;";
          let padding = "2px;";
          let info = "background-color:#3498db;color:#ffffff;";
          let warn2 = "background-color:#f1c40f;color:#000000;";
          let error2 = "background-color:#e74c3c;color:#ffffff;";
          let fatal = "background-color:#c0392b;color:#fff394;";
          let success = "background-color:##48c774;color:#000000;";
          let style = "";
          switch (type) {
            case "info":
              style = info;
              break;
            case "warn":
              style = warn2;
              break;
            case "error":
              style = error2;
              break;
            case "fatal":
              style = fatal;
              break;
            case "success":
              style = success;
              break;
          }
          style += "padding:" + padding;
          style += "font-size:" + fontsize;
          style += "line-height:" + lineheight;
          return style;
        }
        // · 
        print_r(data2, level = 1) {
          let isArray3 = Array.isArray(data2);
          let comma = ",";
          let string = "";
          let padding_key = "";
          let padding_prop = "";
          let newline = "\n";
          for (let i2 = 0; i2 < 4 * level; i2++) {
            padding_prop += " ";
          }
          if (level > 1) {
            padding_key = padding_prop.slice(0, padding_prop.length - 4);
          }
          if (typeof data2 == "object" && !Array.isArray(data2)) {
            string += padding_key + "{" + newline;
            for (let property in data2) {
              if (typeof data2[property] == "object") {
                string += padding_prop + property + ": " + this.print_r(data2[property], level + 1) + comma + newline;
              } else {
                string += padding_prop + property + ": " + data2[property] + comma + newline;
              }
            }
            string += padding_key + "}";
          }
          if (typeof data2 == "object" && Array.isArray(data2)) {
            string += "[" + newline;
            for (let property in data2) {
              if (typeof data2[property] == "object") {
                string += this.print_r(data2[property], level + 1) + comma + newline;
              } else {
                string += padding_prop + data2[property] + newline;
              }
            }
            string += padding_key + "]";
          }
          return string;
        }
      };
      module.exports = new Utils();
    }
  });

  // node_modules/lesli-js/src/debug/browser.js
  var require_browser = __commonJS({
    "node_modules/lesli-js/src/debug/browser.js"(exports, module) {
      var utils = require_utils();
      var BrowserDebugService = class {
        build(message, modulo, level) {
          return utils.buildMessage(message, modulo, level);
        }
        // · write information message
        log(message, modulo = null) {
          console.log(utils.buildMessage(message, modulo, "log"));
        }
        // · write information message
        msg(message, modulo = null) {
          console.log(utils.buildMessage(message, modulo, "msg"));
        }
        // · write informatie message
        info(message, modulo = null) {
          console.info("%c" + utils.buildMessage(message, modulo, "info"), utils.stylesForBrowser("info"));
        }
        // · write success message
        success(message, modulo = null) {
          console.log(utils.buildMessage(message, modulo, "msg"));
        }
        // · write warning message
        warn(message, modulo = null) {
          console.warn("%c" + utils.buildMessage(message, modulo, "warn"), utils.stylesForBrowser("warn"));
        }
        // · write warning message
        error(message, modulo = null) {
          console.error("%c" + utils.buildMessage(message, modulo, "error"), utils.stylesForBrowser("error"));
        }
        // · write warning message
        fatal(message, modulo = null) {
          console.error("%c" + utils.buildMessage(message, modulo, "error"), utils.stylesForBrowser("fatal"));
        }
        message(title, messages, more_information = null) {
          console.log("%c" + title, "color:#3689e6;font-size:35px;font-weight:600;line-height:1;");
          if (typeof messages === "string") messages = [messages];
          console.log("%c" + messages.join("\n"), "background-color:#ffffff;color:#1a1a1a;font-size:18px;font-weight:400;line-height:1.1;");
          if (more_information) {
            console.log("%c" + more_information, "background-color:#ffffff;color:#1a1a1a;font-size:14px;font-weight:400;line-height:2;");
          }
        }
        lesli_message_warning(title = "LESLI", support = "For mor information contact your system administrator") {
          this.message(title, [
            "This is a browser feature intended for developers.",
            "For security reasons, DO NOT copy or paste any information, text, or code here."
          ], support);
        }
      };
      module.exports = new BrowserDebugService();
    }
  });

  // node_modules/lesli-js/debug/browser.js
  var require_browser2 = __commonJS({
    "node_modules/lesli-js/debug/browser.js"(exports, module) {
      module.exports = require_browser();
    }
  });

  // node_modules/prismjs/prism.js
  var require_prism = __commonJS({
    "node_modules/prismjs/prism.js"(exports, module) {
      var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
      var Prism3 = function(_self2) {
        var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
        var uniqueId = 0;
        var plainTextGrammar = {};
        var _3 = {
          /**
           * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
           * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
           * additional languages or plugins yourself.
           *
           * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
           *
           * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
           * empty Prism object into the global scope before loading the Prism script like this:
           *
           * ```js
           * window.Prism = window.Prism || {};
           * Prism.manual = true;
           * // add a new <script> to load Prism's script
           * ```
           *
           * @default false
           * @type {boolean}
           * @memberof Prism
           * @public
           */
          manual: _self2.Prism && _self2.Prism.manual,
          /**
           * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
           * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
           * own worker, you don't want it to do this.
           *
           * By setting this value to `true`, Prism will not add its own listeners to the worker.
           *
           * You obviously have to change this value before Prism executes. To do this, you can add an
           * empty Prism object into the global scope before loading the Prism script like this:
           *
           * ```js
           * window.Prism = window.Prism || {};
           * Prism.disableWorkerMessageHandler = true;
           * // Load Prism's script
           * ```
           *
           * @default false
           * @type {boolean}
           * @memberof Prism
           * @public
           */
          disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
          /**
           * A namespace for utility methods.
           *
           * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
           * change or disappear at any time.
           *
           * @namespace
           * @memberof Prism
           */
          util: {
            encode: function encode(tokens) {
              if (tokens instanceof Token) {
                return new Token(tokens.type, encode(tokens.content), tokens.alias);
              } else if (Array.isArray(tokens)) {
                return tokens.map(encode);
              } else {
                return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
              }
            },
            /**
             * Returns the name of the type of the given value.
             *
             * @param {any} o
             * @returns {string}
             * @example
             * type(null)      === 'Null'
             * type(undefined) === 'Undefined'
             * type(123)       === 'Number'
             * type('foo')     === 'String'
             * type(true)      === 'Boolean'
             * type([1, 2])    === 'Array'
             * type({})        === 'Object'
             * type(String)    === 'Function'
             * type(/abc+/)    === 'RegExp'
             */
            type: function(o2) {
              return Object.prototype.toString.call(o2).slice(8, -1);
            },
            /**
             * Returns a unique number for the given object. Later calls will still return the same number.
             *
             * @param {Object} obj
             * @returns {number}
             */
            objId: function(obj) {
              if (!obj["__id"]) {
                Object.defineProperty(obj, "__id", { value: ++uniqueId });
              }
              return obj["__id"];
            },
            /**
             * Creates a deep clone of the given object.
             *
             * The main intended use of this function is to clone language definitions.
             *
             * @param {T} o
             * @param {Record<number, any>} [visited]
             * @returns {T}
             * @template T
             */
            clone: function deepClone(o2, visited) {
              visited = visited || {};
              var clone5;
              var id2;
              switch (_3.util.type(o2)) {
                case "Object":
                  id2 = _3.util.objId(o2);
                  if (visited[id2]) {
                    return visited[id2];
                  }
                  clone5 = /** @type {Record<string, any>} */
                  {};
                  visited[id2] = clone5;
                  for (var key in o2) {
                    if (o2.hasOwnProperty(key)) {
                      clone5[key] = deepClone(o2[key], visited);
                    }
                  }
                  return (
                    /** @type {any} */
                    clone5
                  );
                case "Array":
                  id2 = _3.util.objId(o2);
                  if (visited[id2]) {
                    return visited[id2];
                  }
                  clone5 = [];
                  visited[id2] = clone5;
                  /** @type {Array} */
                  /** @type {any} */
                  o2.forEach(function(v3, i2) {
                    clone5[i2] = deepClone(v3, visited);
                  });
                  return (
                    /** @type {any} */
                    clone5
                  );
                default:
                  return o2;
              }
            },
            /**
             * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
             *
             * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
             *
             * @param {Element} element
             * @returns {string}
             */
            getLanguage: function(element) {
              while (element) {
                var m2 = lang.exec(element.className);
                if (m2) {
                  return m2[1].toLowerCase();
                }
                element = element.parentElement;
              }
              return "none";
            },
            /**
             * Sets the Prism `language-xxxx` class of the given element.
             *
             * @param {Element} element
             * @param {string} language
             * @returns {void}
             */
            setLanguage: function(element, language) {
              element.className = element.className.replace(RegExp(lang, "gi"), "");
              element.classList.add("language-" + language);
            },
            /**
             * Returns the script element that is currently executing.
             *
             * This does __not__ work for line script element.
             *
             * @returns {HTMLScriptElement | null}
             */
            currentScript: function() {
              if (typeof document === "undefined") {
                return null;
              }
              if (document.currentScript && document.currentScript.tagName === "SCRIPT" && 1 < 2) {
                return (
                  /** @type {any} */
                  document.currentScript
                );
              }
              try {
                throw new Error();
              } catch (err) {
                var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                if (src) {
                  var scripts = document.getElementsByTagName("script");
                  for (var i2 in scripts) {
                    if (scripts[i2].src == src) {
                      return scripts[i2];
                    }
                  }
                }
                return null;
              }
            },
            /**
             * Returns whether a given class is active for `element`.
             *
             * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
             * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
             * given class is just the given class with a `no-` prefix.
             *
             * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
             * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
             * ancestors have the given class or the negated version of it, then the default activation will be returned.
             *
             * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
             * version of it, the class is considered active.
             *
             * @param {Element} element
             * @param {string} className
             * @param {boolean} [defaultActivation=false]
             * @returns {boolean}
             */
            isActive: function(element, className, defaultActivation) {
              var no = "no-" + className;
              while (element) {
                var classList = element.classList;
                if (classList.contains(className)) {
                  return true;
                }
                if (classList.contains(no)) {
                  return false;
                }
                element = element.parentElement;
              }
              return !!defaultActivation;
            }
          },
          /**
           * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
           *
           * @namespace
           * @memberof Prism
           * @public
           */
          languages: {
            /**
             * The grammar for plain, unformatted text.
             */
            plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
             * Creates a deep copy of the language with the given id and appends the given tokens.
             *
             * If a token in `redef` also appears in the copied language, then the existing token in the copied language
             * will be overwritten at its original position.
             *
             * ## Best practices
             *
             * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
             * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
             * understand the language definition because, normally, the order of tokens matters in Prism grammars.
             *
             * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
             * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
             *
             * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
             * @param {Grammar} redef The new tokens to append.
             * @returns {Grammar} The new language created.
             * @public
             * @example
             * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
             *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
             *     // at its original position
             *     'comment': { ... },
             *     // CSS doesn't have a 'color' token, so this token will be appended
             *     'color': /\b(?:red|green|blue)\b/
             * });
             */
            extend: function(id2, redef) {
              var lang2 = _3.util.clone(_3.languages[id2]);
              for (var key in redef) {
                lang2[key] = redef[key];
              }
              return lang2;
            },
            /**
             * Inserts tokens _before_ another token in a language definition or any other grammar.
             *
             * ## Usage
             *
             * This helper method makes it easy to modify existing languages. For example, the CSS language definition
             * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
             * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
             * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
             * this:
             *
             * ```js
             * Prism.languages.markup.style = {
             *     // token
             * };
             * ```
             *
             * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
             * before existing tokens. For the CSS example above, you would use it like this:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'cdata', {
             *     'style': {
             *         // token
             *     }
             * });
             * ```
             *
             * ## Special cases
             *
             * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
             * will be ignored.
             *
             * This behavior can be used to insert tokens after `before`:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'comment', {
             *     'comment': Prism.languages.markup.comment,
             *     // tokens after 'comment'
             * });
             * ```
             *
             * ## Limitations
             *
             * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
             * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
             * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
             * deleting properties which is necessary to insert at arbitrary positions.
             *
             * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
             * Instead, it will create a new object and replace all references to the target object with the new one. This
             * can be done without temporarily deleting properties, so the iteration order is well-defined.
             *
             * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
             * you hold the target object in a variable, then the value of the variable will not change.
             *
             * ```js
             * var oldMarkup = Prism.languages.markup;
             * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
             *
             * assert(oldMarkup !== Prism.languages.markup);
             * assert(newMarkup === Prism.languages.markup);
             * ```
             *
             * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
             * object to be modified.
             * @param {string} before The key to insert before.
             * @param {Grammar} insert An object containing the key-value pairs to be inserted.
             * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
             * object to be modified.
             *
             * Defaults to `Prism.languages`.
             * @returns {Grammar} The new grammar object.
             * @public
             */
            insertBefore: function(inside, before, insert, root) {
              root = root || /** @type {any} */
              _3.languages;
              var grammar = root[inside];
              var ret = {};
              for (var token in grammar) {
                if (grammar.hasOwnProperty(token)) {
                  if (token == before) {
                    for (var newToken in insert) {
                      if (insert.hasOwnProperty(newToken)) {
                        ret[newToken] = insert[newToken];
                      }
                    }
                  }
                  if (!insert.hasOwnProperty(token)) {
                    ret[token] = grammar[token];
                  }
                }
              }
              var old = root[inside];
              root[inside] = ret;
              _3.languages.DFS(_3.languages, function(key, value) {
                if (value === old && key != inside) {
                  this[key] = ret;
                }
              });
              return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o2, callback2, type, visited) {
              visited = visited || {};
              var objId = _3.util.objId;
              for (var i2 in o2) {
                if (o2.hasOwnProperty(i2)) {
                  callback2.call(o2, i2, o2[i2], type || i2);
                  var property = o2[i2];
                  var propertyType = _3.util.type(property);
                  if (propertyType === "Object" && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback2, null, visited);
                  } else if (propertyType === "Array" && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback2, i2, visited);
                  }
                }
              }
            }
          },
          plugins: {},
          /**
           * This is the most high-level function in Prism’s API.
           * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
           * each one of them.
           *
           * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
           *
           * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
           * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
           * @memberof Prism
           * @public
           */
          highlightAll: function(async, callback2) {
            _3.highlightAllUnder(document, async, callback2);
          },
          /**
           * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
           * {@link Prism.highlightElement} on each one of them.
           *
           * The following hooks will be run:
           * 1. `before-highlightall`
           * 2. `before-all-elements-highlight`
           * 3. All hooks of {@link Prism.highlightElement} for each element.
           *
           * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
           * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
           * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
           * @memberof Prism
           * @public
           */
          highlightAllUnder: function(container, async, callback2) {
            var env = {
              callback: callback2,
              container,
              selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _3.hooks.run("before-highlightall", env);
            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
            _3.hooks.run("before-all-elements-highlight", env);
            for (var i2 = 0, element; element = env.elements[i2++]; ) {
              _3.highlightElement(element, async === true, env.callback);
            }
          },
          /**
           * Highlights the code inside a single element.
           *
           * The following hooks will be run:
           * 1. `before-sanity-check`
           * 2. `before-highlight`
           * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
           * 4. `before-insert`
           * 5. `after-highlight`
           * 6. `complete`
           *
           * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
           * the element's language.
           *
           * @param {Element} element The element containing the code.
           * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
           * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
           * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
           * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
           *
           * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
           * asynchronous highlighting to work. You can build your own bundle on the
           * [Download page](https://prismjs.com/download.html).
           * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
           * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
           * @memberof Prism
           * @public
           */
          highlightElement: function(element, async, callback2) {
            var language = _3.util.getLanguage(element);
            var grammar = _3.languages[language];
            _3.util.setLanguage(element, language);
            var parent = element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") {
              _3.util.setLanguage(parent, language);
            }
            var code = element.textContent;
            var env = {
              element,
              language,
              grammar,
              code
            };
            function insertHighlightedCode(highlightedCode) {
              env.highlightedCode = highlightedCode;
              _3.hooks.run("before-insert", env);
              env.element.innerHTML = env.highlightedCode;
              _3.hooks.run("after-highlight", env);
              _3.hooks.run("complete", env);
              callback2 && callback2.call(env.element);
            }
            _3.hooks.run("before-sanity-check", env);
            parent = env.element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
              parent.setAttribute("tabindex", "0");
            }
            if (!env.code) {
              _3.hooks.run("complete", env);
              callback2 && callback2.call(env.element);
              return;
            }
            _3.hooks.run("before-highlight", env);
            if (!env.grammar) {
              insertHighlightedCode(_3.util.encode(env.code));
              return;
            }
            if (async && _self2.Worker) {
              var worker = new Worker(_3.filename);
              worker.onmessage = function(evt) {
                insertHighlightedCode(evt.data);
              };
              worker.postMessage(JSON.stringify({
                language: env.language,
                code: env.code,
                immediateClose: true
              }));
            } else {
              insertHighlightedCode(_3.highlight(env.code, env.grammar, env.language));
            }
          },
          /**
           * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
           * and the language definitions to use, and returns a string with the HTML produced.
           *
           * The following hooks will be run:
           * 1. `before-tokenize`
           * 2. `after-tokenize`
           * 3. `wrap`: On each {@link Token}.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @param {string} language The name of the language definition passed to `grammar`.
           * @returns {string} The highlighted HTML.
           * @memberof Prism
           * @public
           * @example
           * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
           */
          highlight: function(text2, grammar, language) {
            var env = {
              code: text2,
              grammar,
              language
            };
            _3.hooks.run("before-tokenize", env);
            if (!env.grammar) {
              throw new Error('The language "' + env.language + '" has no grammar.');
            }
            env.tokens = _3.tokenize(env.code, env.grammar);
            _3.hooks.run("after-tokenize", env);
            return Token.stringify(_3.util.encode(env.tokens), env.language);
          },
          /**
           * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
           * and the language definitions to use, and returns an array with the tokenized code.
           *
           * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
           *
           * This method could be useful in other contexts as well, as a very crude parser.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @returns {TokenStream} An array of strings and tokens, a token stream.
           * @memberof Prism
           * @public
           * @example
           * let code = `var foo = 0;`;
           * let tokens = Prism.tokenize(code, Prism.languages.javascript);
           * tokens.forEach(token => {
           *     if (token instanceof Prism.Token && token.type === 'number') {
           *         console.log(`Found numeric literal: ${token.content}`);
           *     }
           * });
           */
          tokenize: function(text2, grammar) {
            var rest = grammar.rest;
            if (rest) {
              for (var token in rest) {
                grammar[token] = rest[token];
              }
              delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text2);
            matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
            return toArray2(tokenList);
          },
          /**
           * @namespace
           * @memberof Prism
           * @public
           */
          hooks: {
            all: {},
            /**
             * Adds the given callback to the list of callbacks for the given hook.
             *
             * The callback will be invoked when the hook it is registered for is run.
             * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
             *
             * One callback function can be registered to multiple hooks and the same hook multiple times.
             *
             * @param {string} name The name of the hook.
             * @param {HookCallback} callback The callback function which is given environment variables.
             * @public
             */
            add: function(name, callback2) {
              var hooks = _3.hooks.all;
              hooks[name] = hooks[name] || [];
              hooks[name].push(callback2);
            },
            /**
             * Runs a hook invoking all registered callbacks with the given environment variables.
             *
             * Callbacks will be invoked synchronously and in the order in which they were registered.
             *
             * @param {string} name The name of the hook.
             * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
             * @public
             */
            run: function(name, env) {
              var callbacks = _3.hooks.all[name];
              if (!callbacks || !callbacks.length) {
                return;
              }
              for (var i2 = 0, callback2; callback2 = callbacks[i2++]; ) {
                callback2(env);
              }
            }
          },
          Token
        };
        _self2.Prism = _3;
        function Token(type, content, alias, matchedStr) {
          this.type = type;
          this.content = content;
          this.alias = alias;
          this.length = (matchedStr || "").length | 0;
        }
        Token.stringify = function stringify(o2, language) {
          if (typeof o2 == "string") {
            return o2;
          }
          if (Array.isArray(o2)) {
            var s2 = "";
            o2.forEach(function(e2) {
              s2 += stringify(e2, language);
            });
            return s2;
          }
          var env = {
            type: o2.type,
            content: stringify(o2.content, language),
            tag: "span",
            classes: ["token", o2.type],
            attributes: {},
            language
          };
          var aliases = o2.alias;
          if (aliases) {
            if (Array.isArray(aliases)) {
              Array.prototype.push.apply(env.classes, aliases);
            } else {
              env.classes.push(aliases);
            }
          }
          _3.hooks.run("wrap", env);
          var attributes = "";
          for (var name in env.attributes) {
            attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
          }
          return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
        };
        function matchPattern(pattern, pos, text2, lookbehind) {
          pattern.lastIndex = pos;
          var match = pattern.exec(text2);
          if (match && lookbehind && match[1]) {
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
          }
          return match;
        }
        function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
          for (var token in grammar) {
            if (!grammar.hasOwnProperty(token) || !grammar[token]) {
              continue;
            }
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            for (var j2 = 0; j2 < patterns.length; ++j2) {
              if (rematch && rematch.cause == token + "," + j2) {
                return;
              }
              var patternObj = patterns[j2];
              var inside = patternObj.inside;
              var lookbehind = !!patternObj.lookbehind;
              var greedy = !!patternObj.greedy;
              var alias = patternObj.alias;
              if (greedy && !patternObj.pattern.global) {
                var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
              }
              var pattern = patternObj.pattern || patternObj;
              for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
                if (rematch && pos >= rematch.reach) {
                  break;
                }
                var str = currentNode.value;
                if (tokenList.length > text2.length) {
                  return;
                }
                if (str instanceof Token) {
                  continue;
                }
                var removeCount = 1;
                var match;
                if (greedy) {
                  match = matchPattern(pattern, pos, text2, lookbehind);
                  if (!match || match.index >= text2.length) {
                    break;
                  }
                  var from2 = match.index;
                  var to2 = match.index + match[0].length;
                  var p2 = pos;
                  p2 += currentNode.value.length;
                  while (from2 >= p2) {
                    currentNode = currentNode.next;
                    p2 += currentNode.value.length;
                  }
                  p2 -= currentNode.value.length;
                  pos = p2;
                  if (currentNode.value instanceof Token) {
                    continue;
                  }
                  for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to2 || typeof k2.value === "string"); k2 = k2.next) {
                    removeCount++;
                    p2 += k2.value.length;
                  }
                  removeCount--;
                  str = text2.slice(pos, p2);
                  match.index -= pos;
                } else {
                  match = matchPattern(pattern, 0, str, lookbehind);
                  if (!match) {
                    continue;
                  }
                }
                var from2 = match.index;
                var matchStr = match[0];
                var before = str.slice(0, from2);
                var after = str.slice(from2 + matchStr.length);
                var reach = pos + str.length;
                if (rematch && reach > rematch.reach) {
                  rematch.reach = reach;
                }
                var removeFrom = currentNode.prev;
                if (before) {
                  removeFrom = addAfter(tokenList, removeFrom, before);
                  pos += before.length;
                }
                removeRange(tokenList, removeFrom, removeCount);
                var wrapped = new Token(token, inside ? _3.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                currentNode = addAfter(tokenList, removeFrom, wrapped);
                if (after) {
                  addAfter(tokenList, currentNode, after);
                }
                if (removeCount > 1) {
                  var nestedRematch = {
                    cause: token + "," + j2,
                    reach
                  };
                  matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                  if (rematch && nestedRematch.reach > rematch.reach) {
                    rematch.reach = nestedRematch.reach;
                  }
                }
              }
            }
          }
        }
        function LinkedList() {
          var head = { value: null, prev: null, next: null };
          var tail = { value: null, prev: head, next: null };
          head.next = tail;
          this.head = head;
          this.tail = tail;
          this.length = 0;
        }
        function addAfter(list, node, value) {
          var next = node.next;
          var newNode = { value, prev: node, next };
          node.next = newNode;
          next.prev = newNode;
          list.length++;
          return newNode;
        }
        function removeRange(list, node, count) {
          var next = node.next;
          for (var i2 = 0; i2 < count && next !== list.tail; i2++) {
            next = next.next;
          }
          node.next = next;
          next.prev = node;
          list.length -= i2;
        }
        function toArray2(list) {
          var array = [];
          var node = list.head.next;
          while (node !== list.tail) {
            array.push(node.value);
            node = node.next;
          }
          return array;
        }
        if (!_self2.document) {
          if (!_self2.addEventListener) {
            return _3;
          }
          if (!_3.disableWorkerMessageHandler) {
            _self2.addEventListener("message", function(evt) {
              var message = JSON.parse(evt.data);
              var lang2 = message.language;
              var code = message.code;
              var immediateClose = message.immediateClose;
              _self2.postMessage(_3.highlight(code, _3.languages[lang2], lang2));
              if (immediateClose) {
                _self2.close();
              }
            }, false);
          }
          return _3;
        }
        var script = _3.util.currentScript();
        if (script) {
          _3.filename = script.src;
          if (script.hasAttribute("data-manual")) {
            _3.manual = true;
          }
        }
        function highlightAutomaticallyCallback() {
          if (!_3.manual) {
            _3.highlightAll();
          }
        }
        if (!_3.manual) {
          var readyState = document.readyState;
          if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
            document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
          } else {
            if (window.requestAnimationFrame) {
              window.requestAnimationFrame(highlightAutomaticallyCallback);
            } else {
              window.setTimeout(highlightAutomaticallyCallback, 16);
            }
          }
        }
        return _3;
      }(_self);
      if (typeof module !== "undefined" && module.exports) {
        module.exports = Prism3;
      }
      if (typeof global !== "undefined") {
        global.Prism = Prism3;
      }
      Prism3.languages.markup = {
        "comment": {
          pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
          greedy: true
        },
        "prolog": {
          pattern: /<\?[\s\S]+?\?>/,
          greedy: true
        },
        "doctype": {
          // https://www.w3.org/TR/xml/#NT-doctypedecl
          pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
          greedy: true,
          inside: {
            "internal-subset": {
              pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
              lookbehind: true,
              greedy: true,
              inside: null
              // see below
            },
            "string": {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: true
            },
            "punctuation": /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            "name": /[^\s<>'"]+/
          }
        },
        "cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          greedy: true
        },
        "tag": {
          pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
          greedy: true,
          inside: {
            "tag": {
              pattern: /^<\/?[^\s>\/]+/,
              inside: {
                "punctuation": /^<\/?/,
                "namespace": /^[^\s>\/:]+:/
              }
            },
            "special-attr": [],
            "attr-value": {
              pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
              inside: {
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  {
                    pattern: /^(\s*)["']|["']$/,
                    lookbehind: true
                  }
                ]
              }
            },
            "punctuation": /\/?>/,
            "attr-name": {
              pattern: /[^\s>\/]+/,
              inside: {
                "namespace": /^[^\s>\/:]+:/
              }
            }
          }
        },
        "entity": [
          {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
          },
          /&#x?[\da-f]{1,8};/i
        ]
      };
      Prism3.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism3.languages.markup["entity"];
      Prism3.languages.markup["doctype"].inside["internal-subset"].inside = Prism3.languages.markup;
      Prism3.hooks.add("wrap", function(env) {
        if (env.type === "entity") {
          env.attributes["title"] = env.content.replace(/&amp;/, "&");
        }
      });
      Object.defineProperty(Prism3.languages.markup.tag, "addInlined", {
        /**
         * Adds an inlined language to markup.
         *
         * An example of an inlined language is CSS with `<style>` tags.
         *
         * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addInlined('style', 'css');
         */
        value: function addInlined2(tagName, lang) {
          var includedCdataInside = {};
          includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism3.languages[lang]
          };
          includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
          var inside = {
            "included-cdata": {
              pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
              inside: includedCdataInside
            }
          };
          inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism3.languages[lang]
          };
          var def = {};
          def[tagName] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
              return tagName;
            }), "i"),
            lookbehind: true,
            greedy: true,
            inside
          };
          Prism3.languages.insertBefore("markup", "cdata", def);
        }
      });
      Object.defineProperty(Prism3.languages.markup.tag, "addAttribute", {
        /**
         * Adds an pattern to highlight languages embedded in HTML attributes.
         *
         * An example of an inlined language is CSS with `style` attributes.
         *
         * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addAttribute('style', 'css');
         */
        value: function(attrName, lang) {
          Prism3.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(
              /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
              "i"
            ),
            lookbehind: true,
            inside: {
              "attr-name": /^[^\s=]+/,
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  "value": {
                    pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                    lookbehind: true,
                    alias: [lang, "language-" + lang],
                    inside: Prism3.languages[lang]
                  },
                  "punctuation": [
                    {
                      pattern: /^=/,
                      alias: "attr-equals"
                    },
                    /"|'/
                  ]
                }
              }
            }
          });
        }
      });
      Prism3.languages.html = Prism3.languages.markup;
      Prism3.languages.mathml = Prism3.languages.markup;
      Prism3.languages.svg = Prism3.languages.markup;
      Prism3.languages.xml = Prism3.languages.extend("markup", {});
      Prism3.languages.ssml = Prism3.languages.xml;
      Prism3.languages.atom = Prism3.languages.xml;
      Prism3.languages.rss = Prism3.languages.xml;
      (function(Prism4) {
        var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism4.languages.css = {
          "comment": /\/\*[\s\S]*?\*\//,
          "atrule": {
            pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
            inside: {
              "rule": /^@[\w-]+/,
              "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: true,
                alias: "selector"
              },
              "keyword": {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: true
              }
              // See rest below
            }
          },
          "url": {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: true,
            inside: {
              "function": /^url/i,
              "punctuation": /^\(|\)$/,
              "string": {
                pattern: RegExp("^" + string.source + "$"),
                alias: "url"
              }
            }
          },
          "selector": {
            pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
            lookbehind: true
          },
          "string": {
            pattern: string,
            greedy: true
          },
          "property": {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
          },
          "important": /!important\b/i,
          "function": {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
          },
          "punctuation": /[(){};:,]/
        };
        Prism4.languages.css["atrule"].inside.rest = Prism4.languages.css;
        var markup = Prism4.languages.markup;
        if (markup) {
          markup.tag.addInlined("style", "css");
          markup.tag.addAttribute("style", "css");
        }
      })(Prism3);
      Prism3.languages.clike = {
        "comment": [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        "string": {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: true,
          inside: {
            "punctuation": /[.\\]/
          }
        },
        "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        "boolean": /\b(?:false|true)\b/,
        "function": /\b\w+(?=\()/,
        "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        "punctuation": /[{}[\];(),.:]/
      };
      Prism3.languages.javascript = Prism3.languages.extend("clike", {
        "class-name": [
          Prism3.languages.clike["class-name"],
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
          }
        ],
        "keyword": [
          {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
          },
          {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
          }
        ],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        "number": {
          pattern: RegExp(
            /(^|[^\w$])/.source + "(?:" + // constant
            (/NaN|Infinity/.source + "|" + // binary integer
            /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
            /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
            /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
            /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
            /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
          ),
          lookbehind: true
        },
        "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      });
      Prism3.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
      Prism3.languages.insertBefore("javascript", "keyword", {
        "regex": {
          pattern: RegExp(
            // lookbehind
            // eslint-disable-next-line regexp/no-dupe-characters-character-class
            /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
            // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
            // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
            // with the only syntax, so we have to define 2 different regex patterns.
            /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
            /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
            /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            "regex-source": {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: true,
              alias: "language-regex",
              inside: Prism3.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
          }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        "function-variable": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        },
        "parameter": [
          {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism3.languages.javascript
          },
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism3.languages.javascript
          },
          {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism3.languages.javascript
          },
          {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism3.languages.javascript
          }
        ],
        "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      });
      Prism3.languages.insertBefore("javascript", "string", {
        "hashbang": {
          pattern: /^#!.*/,
          greedy: true,
          alias: "comment"
        },
        "template-string": {
          pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
          greedy: true,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            "interpolation": {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
              lookbehind: true,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: Prism3.languages.javascript
              }
            },
            "string": /[\s\S]+/
          }
        },
        "string-property": {
          pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
          lookbehind: true,
          greedy: true,
          alias: "property"
        }
      });
      Prism3.languages.insertBefore("javascript", "operator", {
        "literal-property": {
          pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
          lookbehind: true,
          alias: "property"
        }
      });
      if (Prism3.languages.markup) {
        Prism3.languages.markup.tag.addInlined("script", "javascript");
        Prism3.languages.markup.tag.addAttribute(
          /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
          "javascript"
        );
      }
      Prism3.languages.js = Prism3.languages.javascript;
      (function() {
        if (typeof Prism3 === "undefined" || typeof document === "undefined") {
          return;
        }
        if (!Element.prototype.matches) {
          Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }
        var LOADING_MESSAGE = "Loading\u2026";
        var FAILURE_MESSAGE = function(status, message) {
          return "\u2716 Error " + status + " while fetching file: " + message;
        };
        var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
        var EXTENSIONS = {
          "js": "javascript",
          "py": "python",
          "rb": "ruby",
          "ps1": "powershell",
          "psm1": "powershell",
          "sh": "bash",
          "bat": "batch",
          "h": "c",
          "tex": "latex"
        };
        var STATUS_ATTR = "data-src-status";
        var STATUS_LOADING = "loading";
        var STATUS_LOADED = "loaded";
        var STATUS_FAILED = "failed";
        var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
        function loadFile(src, success, error2) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", src, true);
          xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
              if (xhr.status < 400 && xhr.responseText) {
                success(xhr.responseText);
              } else {
                if (xhr.status >= 400) {
                  error2(FAILURE_MESSAGE(xhr.status, xhr.statusText));
                } else {
                  error2(FAILURE_EMPTY_MESSAGE);
                }
              }
            }
          };
          xhr.send(null);
        }
        function parseRange(range2) {
          var m2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range2 || "");
          if (m2) {
            var start3 = Number(m2[1]);
            var comma = m2[2];
            var end = m2[3];
            if (!comma) {
              return [start3, start3];
            }
            if (!end) {
              return [start3, void 0];
            }
            return [start3, Number(end)];
          }
          return void 0;
        }
        Prism3.hooks.add("before-highlightall", function(env) {
          env.selector += ", " + SELECTOR;
        });
        Prism3.hooks.add("before-sanity-check", function(env) {
          var pre = (
            /** @type {HTMLPreElement} */
            env.element
          );
          if (pre.matches(SELECTOR)) {
            env.code = "";
            pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
            var code = pre.appendChild(document.createElement("CODE"));
            code.textContent = LOADING_MESSAGE;
            var src = pre.getAttribute("data-src");
            var language = env.language;
            if (language === "none") {
              var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
              language = EXTENSIONS[extension] || extension;
            }
            Prism3.util.setLanguage(code, language);
            Prism3.util.setLanguage(pre, language);
            var autoloader = Prism3.plugins.autoloader;
            if (autoloader) {
              autoloader.loadLanguages(language);
            }
            loadFile(
              src,
              function(text2) {
                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
                var range2 = parseRange(pre.getAttribute("data-range"));
                if (range2) {
                  var lines = text2.split(/\r\n?|\n/g);
                  var start3 = range2[0];
                  var end = range2[1] == null ? lines.length : range2[1];
                  if (start3 < 0) {
                    start3 += lines.length;
                  }
                  start3 = Math.max(0, Math.min(start3 - 1, lines.length));
                  if (end < 0) {
                    end += lines.length;
                  }
                  end = Math.max(0, Math.min(end, lines.length));
                  text2 = lines.slice(start3, end).join("\n");
                  if (!pre.hasAttribute("data-start")) {
                    pre.setAttribute("data-start", String(start3 + 1));
                  }
                }
                code.textContent = text2;
                Prism3.highlightElement(code);
              },
              function(error2) {
                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
                code.textContent = error2;
              }
            );
          }
        });
        Prism3.plugins.fileHighlight = {
          /**
           * Executes the File Highlight plugin for all matching `pre` elements under the given container.
           *
           * Note: Elements which are already loaded or currently loading will not be touched by this method.
           *
           * @param {ParentNode} [container=document]
           */
          highlight: function highlight(container) {
            var elements2 = (container || document).querySelectorAll(SELECTOR);
            for (var i2 = 0, element; element = elements2[i2++]; ) {
              Prism3.highlightElement(element);
            }
          }
        };
        var logged = false;
        Prism3.fileHighlight = function() {
          if (!logged) {
            console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
            logged = true;
          }
          Prism3.plugins.fileHighlight.highlight.apply(this, arguments);
        };
      })();
    }
  });

  // node_modules/@rails/activestorage/app/assets/javascripts/activestorage.esm.js
  var activestorage_esm_exports = {};
  __export(activestorage_esm_exports, {
    DirectUpload: () => DirectUpload,
    DirectUploadController: () => DirectUploadController,
    DirectUploadsController: () => DirectUploadsController,
    start: () => start2
  });
  function getMetaValue(name) {
    const element = findElement(document.head, `meta[name="${name}"]`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  function findElements(root, selector) {
    if (typeof root == "string") {
      selector = root;
      root = document;
    }
    const elements2 = root.querySelectorAll(selector);
    return toArray(elements2);
  }
  function findElement(root, selector) {
    if (typeof root == "string") {
      selector = root;
      root = document;
    }
    return root.querySelector(selector);
  }
  function dispatchEvent(element, type, eventInit = {}) {
    const { disabled } = element;
    const { bubbles, cancelable, detail } = eventInit;
    const event = document.createEvent("Event");
    event.initEvent(type, bubbles || true, cancelable || true);
    event.detail = detail || {};
    try {
      element.disabled = false;
      element.dispatchEvent(event);
    } finally {
      element.disabled = disabled;
    }
    return event;
  }
  function toArray(value) {
    if (Array.isArray(value)) {
      return value;
    } else if (Array.from) {
      return Array.from(value);
    } else {
      return [].slice.call(value);
    }
  }
  function notify(object, methodName, ...messages) {
    if (object && typeof object[methodName] == "function") {
      return object[methodName](...messages);
    }
  }
  function start2() {
    if (!started2) {
      started2 = true;
      document.addEventListener("click", didClick, true);
      document.addEventListener("submit", didSubmitForm, true);
      document.addEventListener("ajax:before", didSubmitRemoteElement);
    }
  }
  function didClick(event) {
    const button = event.target.closest("button, input");
    if (button && button.type === "submit" && button.form) {
      submitButtonsByForm.set(button.form, button);
    }
  }
  function didSubmitForm(event) {
    handleFormSubmissionEvent(event);
  }
  function didSubmitRemoteElement(event) {
    if (event.target.tagName == "FORM") {
      handleFormSubmissionEvent(event);
    }
  }
  function handleFormSubmissionEvent(event) {
    const form = event.target;
    if (form.hasAttribute(processingAttribute)) {
      event.preventDefault();
      return;
    }
    const controller = new DirectUploadsController(form);
    const { inputs } = controller;
    if (inputs.length) {
      event.preventDefault();
      form.setAttribute(processingAttribute, "");
      inputs.forEach(disable);
      controller.start((error2) => {
        form.removeAttribute(processingAttribute);
        if (error2) {
          inputs.forEach(enable);
        } else {
          submitForm(form);
        }
      });
    }
  }
  function submitForm(form) {
    let button = submitButtonsByForm.get(form) || findElement(form, "input[type=submit], button[type=submit]");
    if (button) {
      const { disabled } = button;
      button.disabled = false;
      button.focus();
      button.click();
      button.disabled = disabled;
    } else {
      button = document.createElement("input");
      button.type = "submit";
      button.style.display = "none";
      form.appendChild(button);
      button.click();
      form.removeChild(button);
    }
    submitButtonsByForm.delete(form);
  }
  function disable(input) {
    input.disabled = true;
  }
  function enable(input) {
    input.disabled = false;
  }
  function autostart() {
    if (window.ActiveStorage) {
      start2();
    }
  }
  var sparkMd5, SparkMD5, fileSlice, FileChecksum, BlobRecord, BlobUpload, id, DirectUpload, DirectUploadController, inputSelector, DirectUploadsController, processingAttribute, submitButtonsByForm, started2;
  var init_activestorage_esm = __esm({
    "node_modules/@rails/activestorage/app/assets/javascripts/activestorage.esm.js"() {
      sparkMd5 = {
        exports: {}
      };
      (function(module, exports) {
        (function(factory) {
          {
            module.exports = factory();
          }
        })(function(undefined$1) {
          var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
          function md5cycle(x2, k2) {
            var a2 = x2[0], b3 = x2[1], c2 = x2[2], d3 = x2[3];
            a2 += (b3 & c2 | ~b3 & d3) + k2[0] - 680876936 | 0;
            a2 = (a2 << 7 | a2 >>> 25) + b3 | 0;
            d3 += (a2 & b3 | ~a2 & c2) + k2[1] - 389564586 | 0;
            d3 = (d3 << 12 | d3 >>> 20) + a2 | 0;
            c2 += (d3 & a2 | ~d3 & b3) + k2[2] + 606105819 | 0;
            c2 = (c2 << 17 | c2 >>> 15) + d3 | 0;
            b3 += (c2 & d3 | ~c2 & a2) + k2[3] - 1044525330 | 0;
            b3 = (b3 << 22 | b3 >>> 10) + c2 | 0;
            a2 += (b3 & c2 | ~b3 & d3) + k2[4] - 176418897 | 0;
            a2 = (a2 << 7 | a2 >>> 25) + b3 | 0;
            d3 += (a2 & b3 | ~a2 & c2) + k2[5] + 1200080426 | 0;
            d3 = (d3 << 12 | d3 >>> 20) + a2 | 0;
            c2 += (d3 & a2 | ~d3 & b3) + k2[6] - 1473231341 | 0;
            c2 = (c2 << 17 | c2 >>> 15) + d3 | 0;
            b3 += (c2 & d3 | ~c2 & a2) + k2[7] - 45705983 | 0;
            b3 = (b3 << 22 | b3 >>> 10) + c2 | 0;
            a2 += (b3 & c2 | ~b3 & d3) + k2[8] + 1770035416 | 0;
            a2 = (a2 << 7 | a2 >>> 25) + b3 | 0;
            d3 += (a2 & b3 | ~a2 & c2) + k2[9] - 1958414417 | 0;
            d3 = (d3 << 12 | d3 >>> 20) + a2 | 0;
            c2 += (d3 & a2 | ~d3 & b3) + k2[10] - 42063 | 0;
            c2 = (c2 << 17 | c2 >>> 15) + d3 | 0;
            b3 += (c2 & d3 | ~c2 & a2) + k2[11] - 1990404162 | 0;
            b3 = (b3 << 22 | b3 >>> 10) + c2 | 0;
            a2 += (b3 & c2 | ~b3 & d3) + k2[12] + 1804603682 | 0;
            a2 = (a2 << 7 | a2 >>> 25) + b3 | 0;
            d3 += (a2 & b3 | ~a2 & c2) + k2[13] - 40341101 | 0;
            d3 = (d3 << 12 | d3 >>> 20) + a2 | 0;
            c2 += (d3 & a2 | ~d3 & b3) + k2[14] - 1502002290 | 0;
            c2 = (c2 << 17 | c2 >>> 15) + d3 | 0;
            b3 += (c2 & d3 | ~c2 & a2) + k2[15] + 1236535329 | 0;
            b3 = (b3 << 22 | b3 >>> 10) + c2 | 0;
            a2 += (b3 & d3 | c2 & ~d3) + k2[1] - 165796510 | 0;
            a2 = (a2 << 5 | a2 >>> 27) + b3 | 0;
            d3 += (a2 & c2 | b3 & ~c2) + k2[6] - 1069501632 | 0;
            d3 = (d3 << 9 | d3 >>> 23) + a2 | 0;
            c2 += (d3 & b3 | a2 & ~b3) + k2[11] + 643717713 | 0;
            c2 = (c2 << 14 | c2 >>> 18) + d3 | 0;
            b3 += (c2 & a2 | d3 & ~a2) + k2[0] - 373897302 | 0;
            b3 = (b3 << 20 | b3 >>> 12) + c2 | 0;
            a2 += (b3 & d3 | c2 & ~d3) + k2[5] - 701558691 | 0;
            a2 = (a2 << 5 | a2 >>> 27) + b3 | 0;
            d3 += (a2 & c2 | b3 & ~c2) + k2[10] + 38016083 | 0;
            d3 = (d3 << 9 | d3 >>> 23) + a2 | 0;
            c2 += (d3 & b3 | a2 & ~b3) + k2[15] - 660478335 | 0;
            c2 = (c2 << 14 | c2 >>> 18) + d3 | 0;
            b3 += (c2 & a2 | d3 & ~a2) + k2[4] - 405537848 | 0;
            b3 = (b3 << 20 | b3 >>> 12) + c2 | 0;
            a2 += (b3 & d3 | c2 & ~d3) + k2[9] + 568446438 | 0;
            a2 = (a2 << 5 | a2 >>> 27) + b3 | 0;
            d3 += (a2 & c2 | b3 & ~c2) + k2[14] - 1019803690 | 0;
            d3 = (d3 << 9 | d3 >>> 23) + a2 | 0;
            c2 += (d3 & b3 | a2 & ~b3) + k2[3] - 187363961 | 0;
            c2 = (c2 << 14 | c2 >>> 18) + d3 | 0;
            b3 += (c2 & a2 | d3 & ~a2) + k2[8] + 1163531501 | 0;
            b3 = (b3 << 20 | b3 >>> 12) + c2 | 0;
            a2 += (b3 & d3 | c2 & ~d3) + k2[13] - 1444681467 | 0;
            a2 = (a2 << 5 | a2 >>> 27) + b3 | 0;
            d3 += (a2 & c2 | b3 & ~c2) + k2[2] - 51403784 | 0;
            d3 = (d3 << 9 | d3 >>> 23) + a2 | 0;
            c2 += (d3 & b3 | a2 & ~b3) + k2[7] + 1735328473 | 0;
            c2 = (c2 << 14 | c2 >>> 18) + d3 | 0;
            b3 += (c2 & a2 | d3 & ~a2) + k2[12] - 1926607734 | 0;
            b3 = (b3 << 20 | b3 >>> 12) + c2 | 0;
            a2 += (b3 ^ c2 ^ d3) + k2[5] - 378558 | 0;
            a2 = (a2 << 4 | a2 >>> 28) + b3 | 0;
            d3 += (a2 ^ b3 ^ c2) + k2[8] - 2022574463 | 0;
            d3 = (d3 << 11 | d3 >>> 21) + a2 | 0;
            c2 += (d3 ^ a2 ^ b3) + k2[11] + 1839030562 | 0;
            c2 = (c2 << 16 | c2 >>> 16) + d3 | 0;
            b3 += (c2 ^ d3 ^ a2) + k2[14] - 35309556 | 0;
            b3 = (b3 << 23 | b3 >>> 9) + c2 | 0;
            a2 += (b3 ^ c2 ^ d3) + k2[1] - 1530992060 | 0;
            a2 = (a2 << 4 | a2 >>> 28) + b3 | 0;
            d3 += (a2 ^ b3 ^ c2) + k2[4] + 1272893353 | 0;
            d3 = (d3 << 11 | d3 >>> 21) + a2 | 0;
            c2 += (d3 ^ a2 ^ b3) + k2[7] - 155497632 | 0;
            c2 = (c2 << 16 | c2 >>> 16) + d3 | 0;
            b3 += (c2 ^ d3 ^ a2) + k2[10] - 1094730640 | 0;
            b3 = (b3 << 23 | b3 >>> 9) + c2 | 0;
            a2 += (b3 ^ c2 ^ d3) + k2[13] + 681279174 | 0;
            a2 = (a2 << 4 | a2 >>> 28) + b3 | 0;
            d3 += (a2 ^ b3 ^ c2) + k2[0] - 358537222 | 0;
            d3 = (d3 << 11 | d3 >>> 21) + a2 | 0;
            c2 += (d3 ^ a2 ^ b3) + k2[3] - 722521979 | 0;
            c2 = (c2 << 16 | c2 >>> 16) + d3 | 0;
            b3 += (c2 ^ d3 ^ a2) + k2[6] + 76029189 | 0;
            b3 = (b3 << 23 | b3 >>> 9) + c2 | 0;
            a2 += (b3 ^ c2 ^ d3) + k2[9] - 640364487 | 0;
            a2 = (a2 << 4 | a2 >>> 28) + b3 | 0;
            d3 += (a2 ^ b3 ^ c2) + k2[12] - 421815835 | 0;
            d3 = (d3 << 11 | d3 >>> 21) + a2 | 0;
            c2 += (d3 ^ a2 ^ b3) + k2[15] + 530742520 | 0;
            c2 = (c2 << 16 | c2 >>> 16) + d3 | 0;
            b3 += (c2 ^ d3 ^ a2) + k2[2] - 995338651 | 0;
            b3 = (b3 << 23 | b3 >>> 9) + c2 | 0;
            a2 += (c2 ^ (b3 | ~d3)) + k2[0] - 198630844 | 0;
            a2 = (a2 << 6 | a2 >>> 26) + b3 | 0;
            d3 += (b3 ^ (a2 | ~c2)) + k2[7] + 1126891415 | 0;
            d3 = (d3 << 10 | d3 >>> 22) + a2 | 0;
            c2 += (a2 ^ (d3 | ~b3)) + k2[14] - 1416354905 | 0;
            c2 = (c2 << 15 | c2 >>> 17) + d3 | 0;
            b3 += (d3 ^ (c2 | ~a2)) + k2[5] - 57434055 | 0;
            b3 = (b3 << 21 | b3 >>> 11) + c2 | 0;
            a2 += (c2 ^ (b3 | ~d3)) + k2[12] + 1700485571 | 0;
            a2 = (a2 << 6 | a2 >>> 26) + b3 | 0;
            d3 += (b3 ^ (a2 | ~c2)) + k2[3] - 1894986606 | 0;
            d3 = (d3 << 10 | d3 >>> 22) + a2 | 0;
            c2 += (a2 ^ (d3 | ~b3)) + k2[10] - 1051523 | 0;
            c2 = (c2 << 15 | c2 >>> 17) + d3 | 0;
            b3 += (d3 ^ (c2 | ~a2)) + k2[1] - 2054922799 | 0;
            b3 = (b3 << 21 | b3 >>> 11) + c2 | 0;
            a2 += (c2 ^ (b3 | ~d3)) + k2[8] + 1873313359 | 0;
            a2 = (a2 << 6 | a2 >>> 26) + b3 | 0;
            d3 += (b3 ^ (a2 | ~c2)) + k2[15] - 30611744 | 0;
            d3 = (d3 << 10 | d3 >>> 22) + a2 | 0;
            c2 += (a2 ^ (d3 | ~b3)) + k2[6] - 1560198380 | 0;
            c2 = (c2 << 15 | c2 >>> 17) + d3 | 0;
            b3 += (d3 ^ (c2 | ~a2)) + k2[13] + 1309151649 | 0;
            b3 = (b3 << 21 | b3 >>> 11) + c2 | 0;
            a2 += (c2 ^ (b3 | ~d3)) + k2[4] - 145523070 | 0;
            a2 = (a2 << 6 | a2 >>> 26) + b3 | 0;
            d3 += (b3 ^ (a2 | ~c2)) + k2[11] - 1120210379 | 0;
            d3 = (d3 << 10 | d3 >>> 22) + a2 | 0;
            c2 += (a2 ^ (d3 | ~b3)) + k2[2] + 718787259 | 0;
            c2 = (c2 << 15 | c2 >>> 17) + d3 | 0;
            b3 += (d3 ^ (c2 | ~a2)) + k2[9] - 343485551 | 0;
            b3 = (b3 << 21 | b3 >>> 11) + c2 | 0;
            x2[0] = a2 + x2[0] | 0;
            x2[1] = b3 + x2[1] | 0;
            x2[2] = c2 + x2[2] | 0;
            x2[3] = d3 + x2[3] | 0;
          }
          function md5blk(s2) {
            var md5blks = [], i2;
            for (i2 = 0; i2 < 64; i2 += 4) {
              md5blks[i2 >> 2] = s2.charCodeAt(i2) + (s2.charCodeAt(i2 + 1) << 8) + (s2.charCodeAt(i2 + 2) << 16) + (s2.charCodeAt(i2 + 3) << 24);
            }
            return md5blks;
          }
          function md5blk_array(a2) {
            var md5blks = [], i2;
            for (i2 = 0; i2 < 64; i2 += 4) {
              md5blks[i2 >> 2] = a2[i2] + (a2[i2 + 1] << 8) + (a2[i2 + 2] << 16) + (a2[i2 + 3] << 24);
            }
            return md5blks;
          }
          function md51(s2) {
            var n2 = s2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi;
            for (i2 = 64; i2 <= n2; i2 += 64) {
              md5cycle(state, md5blk(s2.substring(i2 - 64, i2)));
            }
            s2 = s2.substring(i2 - 64);
            length = s2.length;
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (i2 = 0; i2 < length; i2 += 1) {
              tail[i2 >> 2] |= s2.charCodeAt(i2) << (i2 % 4 << 3);
            }
            tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
            if (i2 > 55) {
              md5cycle(state, tail);
              for (i2 = 0; i2 < 16; i2 += 1) {
                tail[i2] = 0;
              }
            }
            tmp = n2 * 8;
            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
            lo = parseInt(tmp[2], 16);
            hi = parseInt(tmp[1], 16) || 0;
            tail[14] = lo;
            tail[15] = hi;
            md5cycle(state, tail);
            return state;
          }
          function md51_array(a2) {
            var n2 = a2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi;
            for (i2 = 64; i2 <= n2; i2 += 64) {
              md5cycle(state, md5blk_array(a2.subarray(i2 - 64, i2)));
            }
            a2 = i2 - 64 < n2 ? a2.subarray(i2 - 64) : new Uint8Array(0);
            length = a2.length;
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (i2 = 0; i2 < length; i2 += 1) {
              tail[i2 >> 2] |= a2[i2] << (i2 % 4 << 3);
            }
            tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
            if (i2 > 55) {
              md5cycle(state, tail);
              for (i2 = 0; i2 < 16; i2 += 1) {
                tail[i2] = 0;
              }
            }
            tmp = n2 * 8;
            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
            lo = parseInt(tmp[2], 16);
            hi = parseInt(tmp[1], 16) || 0;
            tail[14] = lo;
            tail[15] = hi;
            md5cycle(state, tail);
            return state;
          }
          function rhex(n2) {
            var s2 = "", j2;
            for (j2 = 0; j2 < 4; j2 += 1) {
              s2 += hex_chr[n2 >> j2 * 8 + 4 & 15] + hex_chr[n2 >> j2 * 8 & 15];
            }
            return s2;
          }
          function hex2(x2) {
            var i2;
            for (i2 = 0; i2 < x2.length; i2 += 1) {
              x2[i2] = rhex(x2[i2]);
            }
            return x2.join("");
          }
          if (hex2(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") ;
          if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
            (function() {
              function clamp(val, length) {
                val = val | 0 || 0;
                if (val < 0) {
                  return Math.max(val + length, 0);
                }
                return Math.min(val, length);
              }
              ArrayBuffer.prototype.slice = function(from2, to2) {
                var length = this.byteLength, begin = clamp(from2, length), end = length, num, target, targetArray, sourceArray;
                if (to2 !== undefined$1) {
                  end = clamp(to2, length);
                }
                if (begin > end) {
                  return new ArrayBuffer(0);
                }
                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);
                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);
                return target;
              };
            })();
          }
          function toUtf8(str) {
            if (/[\u0080-\uFFFF]/.test(str)) {
              str = unescape(encodeURIComponent(str));
            }
            return str;
          }
          function utf8Str2ArrayBuffer(str, returnUInt8Array) {
            var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i2;
            for (i2 = 0; i2 < length; i2 += 1) {
              arr[i2] = str.charCodeAt(i2);
            }
            return returnUInt8Array ? arr : buff;
          }
          function arrayBuffer2Utf8Str(buff) {
            return String.fromCharCode.apply(null, new Uint8Array(buff));
          }
          function concatenateArrayBuffers(first, second, returnUInt8Array) {
            var result = new Uint8Array(first.byteLength + second.byteLength);
            result.set(new Uint8Array(first));
            result.set(new Uint8Array(second), first.byteLength);
            return returnUInt8Array ? result : result.buffer;
          }
          function hexToBinaryString(hex3) {
            var bytes = [], length = hex3.length, x2;
            for (x2 = 0; x2 < length - 1; x2 += 2) {
              bytes.push(parseInt(hex3.substr(x2, 2), 16));
            }
            return String.fromCharCode.apply(String, bytes);
          }
          function SparkMD52() {
            this.reset();
          }
          SparkMD52.prototype.append = function(str) {
            this.appendBinary(toUtf8(str));
            return this;
          };
          SparkMD52.prototype.appendBinary = function(contents) {
            this._buff += contents;
            this._length += contents.length;
            var length = this._buff.length, i2;
            for (i2 = 64; i2 <= length; i2 += 64) {
              md5cycle(this._hash, md5blk(this._buff.substring(i2 - 64, i2)));
            }
            this._buff = this._buff.substring(i2 - 64);
            return this;
          };
          SparkMD52.prototype.end = function(raw2) {
            var buff = this._buff, length = buff.length, i2, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
            for (i2 = 0; i2 < length; i2 += 1) {
              tail[i2 >> 2] |= buff.charCodeAt(i2) << (i2 % 4 << 3);
            }
            this._finish(tail, length);
            ret = hex2(this._hash);
            if (raw2) {
              ret = hexToBinaryString(ret);
            }
            this.reset();
            return ret;
          };
          SparkMD52.prototype.reset = function() {
            this._buff = "";
            this._length = 0;
            this._hash = [1732584193, -271733879, -1732584194, 271733878];
            return this;
          };
          SparkMD52.prototype.getState = function() {
            return {
              buff: this._buff,
              length: this._length,
              hash: this._hash.slice()
            };
          };
          SparkMD52.prototype.setState = function(state) {
            this._buff = state.buff;
            this._length = state.length;
            this._hash = state.hash;
            return this;
          };
          SparkMD52.prototype.destroy = function() {
            delete this._hash;
            delete this._buff;
            delete this._length;
          };
          SparkMD52.prototype._finish = function(tail, length) {
            var i2 = length, tmp, lo, hi;
            tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
            if (i2 > 55) {
              md5cycle(this._hash, tail);
              for (i2 = 0; i2 < 16; i2 += 1) {
                tail[i2] = 0;
              }
            }
            tmp = this._length * 8;
            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
            lo = parseInt(tmp[2], 16);
            hi = parseInt(tmp[1], 16) || 0;
            tail[14] = lo;
            tail[15] = hi;
            md5cycle(this._hash, tail);
          };
          SparkMD52.hash = function(str, raw2) {
            return SparkMD52.hashBinary(toUtf8(str), raw2);
          };
          SparkMD52.hashBinary = function(content, raw2) {
            var hash = md51(content), ret = hex2(hash);
            return raw2 ? hexToBinaryString(ret) : ret;
          };
          SparkMD52.ArrayBuffer = function() {
            this.reset();
          };
          SparkMD52.ArrayBuffer.prototype.append = function(arr) {
            var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i2;
            this._length += arr.byteLength;
            for (i2 = 64; i2 <= length; i2 += 64) {
              md5cycle(this._hash, md5blk_array(buff.subarray(i2 - 64, i2)));
            }
            this._buff = i2 - 64 < length ? new Uint8Array(buff.buffer.slice(i2 - 64)) : new Uint8Array(0);
            return this;
          };
          SparkMD52.ArrayBuffer.prototype.end = function(raw2) {
            var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i2, ret;
            for (i2 = 0; i2 < length; i2 += 1) {
              tail[i2 >> 2] |= buff[i2] << (i2 % 4 << 3);
            }
            this._finish(tail, length);
            ret = hex2(this._hash);
            if (raw2) {
              ret = hexToBinaryString(ret);
            }
            this.reset();
            return ret;
          };
          SparkMD52.ArrayBuffer.prototype.reset = function() {
            this._buff = new Uint8Array(0);
            this._length = 0;
            this._hash = [1732584193, -271733879, -1732584194, 271733878];
            return this;
          };
          SparkMD52.ArrayBuffer.prototype.getState = function() {
            var state = SparkMD52.prototype.getState.call(this);
            state.buff = arrayBuffer2Utf8Str(state.buff);
            return state;
          };
          SparkMD52.ArrayBuffer.prototype.setState = function(state) {
            state.buff = utf8Str2ArrayBuffer(state.buff, true);
            return SparkMD52.prototype.setState.call(this, state);
          };
          SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
          SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
          SparkMD52.ArrayBuffer.hash = function(arr, raw2) {
            var hash = md51_array(new Uint8Array(arr)), ret = hex2(hash);
            return raw2 ? hexToBinaryString(ret) : ret;
          };
          return SparkMD52;
        });
      })(sparkMd5);
      SparkMD5 = sparkMd5.exports;
      fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
      FileChecksum = class _FileChecksum {
        static create(file, callback2) {
          const instance = new _FileChecksum(file);
          instance.create(callback2);
        }
        constructor(file) {
          this.file = file;
          this.chunkSize = 2097152;
          this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
          this.chunkIndex = 0;
        }
        create(callback2) {
          this.callback = callback2;
          this.md5Buffer = new SparkMD5.ArrayBuffer();
          this.fileReader = new FileReader();
          this.fileReader.addEventListener("load", (event) => this.fileReaderDidLoad(event));
          this.fileReader.addEventListener("error", (event) => this.fileReaderDidError(event));
          this.readNextChunk();
        }
        fileReaderDidLoad(event) {
          this.md5Buffer.append(event.target.result);
          if (!this.readNextChunk()) {
            const binaryDigest = this.md5Buffer.end(true);
            const base64digest = btoa(binaryDigest);
            this.callback(null, base64digest);
          }
        }
        fileReaderDidError(event) {
          this.callback(`Error reading ${this.file.name}`);
        }
        readNextChunk() {
          if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
            const start3 = this.chunkIndex * this.chunkSize;
            const end = Math.min(start3 + this.chunkSize, this.file.size);
            const bytes = fileSlice.call(this.file, start3, end);
            this.fileReader.readAsArrayBuffer(bytes);
            this.chunkIndex++;
            return true;
          } else {
            return false;
          }
        }
      };
      BlobRecord = class {
        constructor(file, checksum, url, customHeaders = {}) {
          this.file = file;
          this.attributes = {
            filename: file.name,
            content_type: file.type || "application/octet-stream",
            byte_size: file.size,
            checksum
          };
          this.xhr = new XMLHttpRequest();
          this.xhr.open("POST", url, true);
          this.xhr.responseType = "json";
          this.xhr.setRequestHeader("Content-Type", "application/json");
          this.xhr.setRequestHeader("Accept", "application/json");
          this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
          Object.keys(customHeaders).forEach((headerKey) => {
            this.xhr.setRequestHeader(headerKey, customHeaders[headerKey]);
          });
          const csrfToken = getMetaValue("csrf-token");
          if (csrfToken != void 0) {
            this.xhr.setRequestHeader("X-CSRF-Token", csrfToken);
          }
          this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
          this.xhr.addEventListener("error", (event) => this.requestDidError(event));
        }
        get status() {
          return this.xhr.status;
        }
        get response() {
          const { responseType, response } = this.xhr;
          if (responseType == "json") {
            return response;
          } else {
            return JSON.parse(response);
          }
        }
        create(callback2) {
          this.callback = callback2;
          this.xhr.send(JSON.stringify({
            blob: this.attributes
          }));
        }
        requestDidLoad(event) {
          if (this.status >= 200 && this.status < 300) {
            const { response } = this;
            const { direct_upload } = response;
            delete response.direct_upload;
            this.attributes = response;
            this.directUploadData = direct_upload;
            this.callback(null, this.toJSON());
          } else {
            this.requestDidError(event);
          }
        }
        requestDidError(event) {
          this.callback(`Error creating Blob for "${this.file.name}". Status: ${this.status}`);
        }
        toJSON() {
          const result = {};
          for (const key in this.attributes) {
            result[key] = this.attributes[key];
          }
          return result;
        }
      };
      BlobUpload = class {
        constructor(blob) {
          this.blob = blob;
          this.file = blob.file;
          const { url, headers } = blob.directUploadData;
          this.xhr = new XMLHttpRequest();
          this.xhr.open("PUT", url, true);
          this.xhr.responseType = "text";
          for (const key in headers) {
            this.xhr.setRequestHeader(key, headers[key]);
          }
          this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
          this.xhr.addEventListener("error", (event) => this.requestDidError(event));
        }
        create(callback2) {
          this.callback = callback2;
          this.xhr.send(this.file.slice());
        }
        requestDidLoad(event) {
          const { status, response } = this.xhr;
          if (status >= 200 && status < 300) {
            this.callback(null, response);
          } else {
            this.requestDidError(event);
          }
        }
        requestDidError(event) {
          this.callback(`Error storing "${this.file.name}". Status: ${this.xhr.status}`);
        }
      };
      id = 0;
      DirectUpload = class {
        constructor(file, url, delegate, customHeaders = {}) {
          this.id = ++id;
          this.file = file;
          this.url = url;
          this.delegate = delegate;
          this.customHeaders = customHeaders;
        }
        create(callback2) {
          FileChecksum.create(this.file, (error2, checksum) => {
            if (error2) {
              callback2(error2);
              return;
            }
            const blob = new BlobRecord(this.file, checksum, this.url, this.customHeaders);
            notify(this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
            blob.create((error3) => {
              if (error3) {
                callback2(error3);
              } else {
                const upload = new BlobUpload(blob);
                notify(this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
                upload.create((error4) => {
                  if (error4) {
                    callback2(error4);
                  } else {
                    callback2(null, blob.toJSON());
                  }
                });
              }
            });
          });
        }
      };
      DirectUploadController = class {
        constructor(input, file) {
          this.input = input;
          this.file = file;
          this.directUpload = new DirectUpload(this.file, this.url, this);
          this.dispatch("initialize");
        }
        start(callback2) {
          const hiddenInput = document.createElement("input");
          hiddenInput.type = "hidden";
          hiddenInput.name = this.input.name;
          this.input.insertAdjacentElement("beforebegin", hiddenInput);
          this.dispatch("start");
          this.directUpload.create((error2, attributes) => {
            if (error2) {
              hiddenInput.parentNode.removeChild(hiddenInput);
              this.dispatchError(error2);
            } else {
              hiddenInput.value = attributes.signed_id;
            }
            this.dispatch("end");
            callback2(error2);
          });
        }
        uploadRequestDidProgress(event) {
          const progress = event.loaded / event.total * 100;
          if (progress) {
            this.dispatch("progress", {
              progress
            });
          }
        }
        get url() {
          return this.input.getAttribute("data-direct-upload-url");
        }
        dispatch(name, detail = {}) {
          detail.file = this.file;
          detail.id = this.directUpload.id;
          return dispatchEvent(this.input, `direct-upload:${name}`, {
            detail
          });
        }
        dispatchError(error2) {
          const event = this.dispatch("error", {
            error: error2
          });
          if (!event.defaultPrevented) {
            alert(error2);
          }
        }
        directUploadWillCreateBlobWithXHR(xhr) {
          this.dispatch("before-blob-request", {
            xhr
          });
        }
        directUploadWillStoreFileWithXHR(xhr) {
          this.dispatch("before-storage-request", {
            xhr
          });
          xhr.upload.addEventListener("progress", (event) => this.uploadRequestDidProgress(event));
        }
      };
      inputSelector = "input[type=file][data-direct-upload-url]:not([disabled])";
      DirectUploadsController = class {
        constructor(form) {
          this.form = form;
          this.inputs = findElements(form, inputSelector).filter((input) => input.files.length);
        }
        start(callback2) {
          const controllers2 = this.createDirectUploadControllers();
          const startNextController = () => {
            const controller = controllers2.shift();
            if (controller) {
              controller.start((error2) => {
                if (error2) {
                  callback2(error2);
                  this.dispatch("end");
                } else {
                  startNextController();
                }
              });
            } else {
              callback2();
              this.dispatch("end");
            }
          };
          this.dispatch("start");
          startNextController();
        }
        createDirectUploadControllers() {
          const controllers2 = [];
          this.inputs.forEach((input) => {
            toArray(input.files).forEach((file) => {
              const controller = new DirectUploadController(input, file);
              controllers2.push(controller);
            });
          });
          return controllers2;
        }
        dispatch(name, detail = {}) {
          return dispatchEvent(this.form, `direct-uploads:${name}`, {
            detail
          });
        }
      };
      processingAttribute = "data-direct-uploads-processing";
      submitButtonsByForm = /* @__PURE__ */ new WeakMap();
      started2 = false;
      setTimeout(autostart, 1);
    }
  });

  // lib/lesli_assets_js/application.js
  var import_dayjs = __toESM(require_dayjs_min());

  // node_modules/alpinejs/dist/module.esm.js
  var flushPending = false;
  var flushing = false;
  var queue = [];
  var lastFlushedIndex = -1;
  function scheduler(callback2) {
    queueJob(callback2);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function dequeueJob(job) {
    let index2 = queue.indexOf(job);
    if (index2 !== -1 && index2 > lastFlushedIndex)
      queue.splice(index2, 1);
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i2 = 0; i2 < queue.length; i2++) {
      queue[i2]();
      lastFlushedIndex = i2;
    }
    queue.length = 0;
    lastFlushedIndex = -1;
    flushing = false;
  }
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback2) {
    shouldSchedule = false;
    callback2();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback2) => engine.effect(callback2, { scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    } });
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback2) => {
      let effectReference = effect(callback2);
      if (!el._x_effects) {
        el._x_effects = /* @__PURE__ */ new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i2) => i2());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
      return effectReference;
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  function watch(getter, callback2) {
    let firstTime = true;
    let oldValue;
    let effectReference = effect(() => {
      let value = getter();
      JSON.stringify(value);
      if (!firstTime) {
        queueMicrotask(() => {
          callback2(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    });
    return () => release(effectReference);
  }
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback2) {
    onElAddeds.push(callback2);
  }
  function onElRemoved(el, callback2) {
    if (typeof callback2 === "function") {
      if (!el._x_cleanups)
        el._x_cleanups = [];
      el._x_cleanups.push(callback2);
    } else {
      callback2 = el;
      onElRemoveds.push(callback2);
    }
  }
  function onAttributesAdded(callback2) {
    onAttributeAddeds.push(callback2);
  }
  function onAttributeRemoved(el, name, callback2) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback2);
  }
  function cleanupAttributes(el, names2) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      if (names2 === void 0 || names2.includes(name)) {
        value.forEach((i2) => i2());
        delete el._x_attributeCleanups[name];
      }
    });
  }
  function cleanupElement(el) {
    el._x_effects?.forEach(dequeueJob);
    while (el._x_cleanups?.length)
      el._x_cleanups.pop()();
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    flushObserver();
    observer.disconnect();
    currentlyObserving = false;
  }
  var queuedMutations = [];
  function flushObserver() {
    let records = observer.takeRecords();
    queuedMutations.push(() => records.length > 0 && onMutate(records));
    let queueLengthWhenTriggered = queuedMutations.length;
    queueMicrotask(() => {
      if (queuedMutations.length === queueLengthWhenTriggered) {
        while (queuedMutations.length > 0)
          queuedMutations.shift()();
      }
    });
  }
  function mutateDom(callback2) {
    if (!currentlyObserving)
      return callback2();
    stopObservingMutations();
    let result = callback2();
    startObservingMutations();
    return result;
  }
  var isCollecting = false;
  var deferredMutations = [];
  function deferMutations() {
    isCollecting = true;
  }
  function flushAndStopDeferringMutations() {
    isCollecting = false;
    onMutate(deferredMutations);
    deferredMutations = [];
  }
  function onMutate(mutations) {
    if (isCollecting) {
      deferredMutations = deferredMutations.concat(mutations);
      return;
    }
    let addedNodes = [];
    let removedNodes = /* @__PURE__ */ new Set();
    let addedAttributes = /* @__PURE__ */ new Map();
    let removedAttributes = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < mutations.length; i2++) {
      if (mutations[i2].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i2].type === "childList") {
        mutations[i2].removedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (!node._x_marker)
            return;
          removedNodes.add(node);
        });
        mutations[i2].addedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (removedNodes.has(node)) {
            removedNodes.delete(node);
            return;
          }
          if (node._x_marker)
            return;
          addedNodes.push(node);
        });
      }
      if (mutations[i2].type === "attributes") {
        let el = mutations[i2].target;
        let name = mutations[i2].attributeName;
        let oldValue = mutations[i2].oldValue;
        let add2 = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
        };
        let remove = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add2();
        } else if (el.hasAttribute(name)) {
          remove();
          add2();
        } else {
          remove();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i2) => i2(el, attrs));
    });
    for (let node of removedNodes) {
      if (addedNodes.some((i2) => i2.contains(node)))
        continue;
      onElRemoveds.forEach((i2) => i2(node));
    }
    for (let node of addedNodes) {
      if (!node.isConnected)
        continue;
      onElAddeds.forEach((i2) => i2(node));
    }
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }
  function scope(node) {
    return mergeProxies(closestDataStack(node));
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i2) => i2 !== data2);
    };
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    return new Proxy({ objects }, mergeProxyTrap);
  }
  var mergeProxyTrap = {
    ownKeys({ objects }) {
      return Array.from(
        new Set(objects.flatMap((i2) => Object.keys(i2)))
      );
    },
    has({ objects }, name) {
      if (name == Symbol.unscopables)
        return false;
      return objects.some(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)
      );
    },
    get({ objects }, name, thisProxy) {
      if (name == "toJSON")
        return collapseProxies;
      return Reflect.get(
        objects.find(
          (obj) => Reflect.has(obj, name)
        ) || {},
        name,
        thisProxy
      );
    },
    set({ objects }, name, value, thisProxy) {
      const target = objects.find(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name)
      ) || objects[objects.length - 1];
      const descriptor = Object.getOwnPropertyDescriptor(target, name);
      if (descriptor?.set && descriptor?.get)
        return descriptor.set.call(thisProxy, value) || true;
      return Reflect.set(target, name, value);
    }
  };
  function collapseProxies() {
    let keys = Reflect.ownKeys(this);
    return keys.reduce((acc, key) => {
      acc[key] = Reflect.get(this, key);
      return acc;
    }, {});
  }
  function initInterceptors(data2) {
    let isObject22 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
        if (enumerable === false || value === void 0)
          return;
        if (typeof value === "object" && value !== null && value.__v_skip)
          return;
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject22(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback2, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback2(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }
  var magics = {};
  function magic(name, callback2) {
    magics[name] = callback2;
  }
  function injectMagics(obj, el) {
    let memoizedUtilities = getUtilities(el);
    Object.entries(magics).forEach(([name, callback2]) => {
      Object.defineProperty(obj, `$${name}`, {
        get() {
          return callback2(el, memoizedUtilities);
        },
        enumerable: false
      });
    });
    return obj;
  }
  function getUtilities(el) {
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    let utils = { interceptor, ...utilities };
    onElRemoved(el, cleanup2);
    return utils;
  }
  function tryCatch(el, expression, callback2, ...args) {
    try {
      return callback2(...args);
    } catch (e2) {
      handleError(e2, el, expression);
    }
  }
  function handleError(error2, el, expression = void 0) {
    error2 = Object.assign(
      error2 ?? { message: "No error message given." },
      { el, expression }
    );
    console.warn(`Alpine Expression Error: ${error2.message}

${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
    setTimeout(() => {
      throw error2;
    }, 0);
  }
  var shouldAutoEvaluateFunctions = true;
  function dontAutoEvaluateFunctions(callback2) {
    let cache = shouldAutoEvaluateFunctions;
    shouldAutoEvaluateFunctions = false;
    let result = callback2();
    shouldAutoEvaluateFunctions = cache;
    return result;
  }
  function evaluate(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression, el) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
    const safeAsyncFunction = () => {
      try {
        let func2 = new AsyncFunction(
          ["__self", "scope"],
          `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
        );
        Object.defineProperty(func2, "name", {
          value: `[Alpine] ${expression}`
        });
        return func2;
      } catch (error2) {
        handleError(error2, el, expression);
        return Promise.resolve();
      }
    };
    let func = safeAsyncFunction();
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression, el) {
    let func = generateFunctionFromString(expression, el);
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope2, ...dataStack]);
      if (typeof func === "function") {
        let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));
        if (func.finished) {
          runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
          func.result = void 0;
        } else {
          promise.then((result) => {
            runIfTypeOfFunction(receiver, result, completeScope, params, el);
          }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
        }
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope2, params, el) {
    if (shouldAutoEvaluateFunctions && typeof value === "function") {
      let result = value.apply(scope2, params);
      if (result instanceof Promise) {
        result.then((i2) => runIfTypeOfFunction(receiver, i2, scope2, params)).catch((error2) => handleError(error2, el, value));
      } else {
        receiver(result);
      }
    } else if (typeof value === "object" && value instanceof Promise) {
      value.then((i2) => receiver(i2));
    } else {
      receiver(value);
    }
  }
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback2) {
    directiveHandlers[name] = callback2;
    return {
      before(directive2) {
        if (!directiveHandlers[directive2]) {
          console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
          return;
        }
        const pos = directiveOrder.indexOf(directive2);
        directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
      }
    };
  }
  function directiveExists(name) {
    return Object.keys(directiveHandlers).includes(name);
  }
  function directives(el, attributes, originalAttributeOverride) {
    attributes = Array.from(attributes);
    if (el._x_virtualDirectives) {
      let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
      let staticAttributes = attributesOnly(vAttributes);
      vAttributes = vAttributes.map((attribute) => {
        if (staticAttributes.find((attr) => attr.name === attribute.name)) {
          return {
            name: `x-bind:${attribute.name}`,
            value: `"${attribute.value}"`
          };
        }
        return attribute;
      });
      attributes = attributes.concat(vAttributes);
    }
    let transformedAttributeMap = {};
    let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  function attributesOnly(attributes) {
    return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
  }
  var isDeferringHandlers = false;
  var directiveHandlerStacks = /* @__PURE__ */ new Map();
  var currentHandlerStackKey = Symbol();
  function deferHandlingDirectives(callback2) {
    isDeferringHandlers = true;
    let key = Symbol();
    currentHandlerStackKey = key;
    directiveHandlerStacks.set(key, []);
    let flushHandlers = () => {
      while (directiveHandlerStacks.get(key).length)
        directiveHandlerStacks.get(key).shift()();
      directiveHandlerStacks.delete(key);
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback2(flushHandlers);
    stopDeferring();
  }
  function getElementBoundUtilities(el) {
    let cleanups = [];
    let cleanup2 = (callback2) => cleanups.push(callback2);
    let [effect32, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect32,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate.bind(evaluate, el)
    };
    let doCleanup = () => cleanups.forEach((i2) => i2());
    return [utilities, doCleanup];
  }
  function getDirectiveHandler(el, directive2) {
    let noop3 = () => {
    };
    let handler4 = directiveHandlers[directive2.type] || noop3;
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    onAttributeRemoved(el, directive2.original, cleanup2);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler4.inline && handler4.inline(el, directive2, utilities);
      handler4 = handler4.bind(handler4, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
    };
    fullHandler.runCleanups = cleanup2;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({ name, value }) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return { name, value };
  };
  var into = (i2) => i2;
  function toTransformedAttributes(callback2 = () => {
  }) {
    return ({ name, value }) => {
      let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, { name, value });
      if (newName !== name)
        callback2(newName, name);
      return { name: newName, value: newValue };
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback2) {
    attributeTransformers.push(callback2);
  }
  function outNonAlpineAttributes({ name }) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({ name, value }) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i2) => i2.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "id",
    "anchor",
    "bind",
    "init",
    "for",
    "model",
    "modelable",
    "transition",
    "show",
    "if",
    DEFAULT,
    "teleport"
  ];
  function byPriority(a2, b3) {
    let typeA = directiveOrder.indexOf(a2.type) === -1 ? DEFAULT : a2.type;
    let typeB = directiveOrder.indexOf(b3.type) === -1 ? DEFAULT : b3.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(
      new CustomEvent(name, {
        detail,
        bubbles: true,
        // Allows events to pass the shadow DOM barrier.
        composed: true,
        cancelable: true
      })
    );
  }
  function walk(el, callback2) {
    if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback2));
      return;
    }
    let skip2 = false;
    callback2(el, () => skip2 = true);
    if (skip2)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback2, false);
      node = node.nextElementSibling;
    }
  }
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }
  var started = false;
  function start() {
    if (started)
      warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
    started = true;
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => destroyTree(el));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
    Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
    setTimeout(() => {
      warnAboutMissingPlugins();
    });
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el, includeInitSelectors = false) {
    return findClosest(el, (element) => {
      const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
      if (selectors.some((selector) => element.matches(selector)))
        return true;
    });
  }
  function findClosest(el, callback2) {
    if (!el)
      return;
    if (callback2(el))
      return el;
    if (el._x_teleportBack)
      el = el._x_teleportBack;
    if (!el.parentElement)
      return;
    return findClosest(el.parentElement, callback2);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  var initInterceptors2 = [];
  function interceptInit(callback2) {
    initInterceptors2.push(callback2);
  }
  var markerDispenser = 1;
  function initTree(el, walker = walk, intercept = () => {
  }) {
    if (findClosest(el, (i2) => i2._x_ignore))
      return;
    deferHandlingDirectives(() => {
      walker(el, (el2, skip2) => {
        if (el2._x_marker)
          return;
        intercept(el2, skip2);
        initInterceptors2.forEach((i2) => i2(el2, skip2));
        directives(el2, el2.attributes).forEach((handle) => handle());
        if (!el2._x_ignore)
          el2._x_marker = markerDispenser++;
        el2._x_ignore && skip2();
      });
    });
  }
  function destroyTree(root, walker = walk) {
    walker(root, (el) => {
      cleanupElement(el);
      cleanupAttributes(el);
      delete el._x_marker;
    });
  }
  function warnAboutMissingPlugins() {
    let pluginDirectives = [
      ["ui", "dialog", ["[x-dialog], [x-popover]"]],
      ["anchor", "anchor", ["[x-anchor]"]],
      ["sort", "sort", ["[x-sort]"]]
    ];
    pluginDirectives.forEach(([plugin2, directive2, selectors]) => {
      if (directiveExists(directive2))
        return;
      selectors.some((selector) => {
        if (document.querySelector(selector)) {
          warn(`found "${selector}", but missing ${plugin2} plugin`);
          return true;
        }
      });
    });
  }
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback2 = () => {
  }) {
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
    return new Promise((res) => {
      tickStack.push(() => {
        callback2();
        res();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let split = (classString2) => classString2.split(" ").filter(Boolean);
    let missingClasses = (classString2) => classString2.split(" ").filter((i2) => !el.classList.contains(i2)).filter(Boolean);
    let addClassesAndReturnUndo = (classes) => {
      el.classList.add(...classes);
      return () => {
        el.classList.remove(...classes);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i2) => {
      if (el.classList.contains(i2)) {
        el.classList.remove(i2);
        removed.push(i2);
      }
    });
    forAdd.forEach((i2) => {
      if (!el.classList.contains(i2)) {
        el.classList.add(i2);
        added.push(i2);
      }
    });
    return () => {
      removed.forEach((i2) => el.classList.add(i2));
      added.forEach((i2) => el.classList.remove(i2));
    };
  }
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      if (!key.startsWith("--")) {
        key = kebabCase(key);
      }
      el.style.setProperty(key, value2);
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache || "");
    };
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function once(callback2, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback2.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }
  directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (expression === false)
      return;
    if (!expression || typeof expression === "boolean") {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      "enter": (classes) => {
        el._x_transition.enter.during = classes;
      },
      "enter-start": (classes) => {
        el._x_transition.enter.start = classes;
      },
      "enter-end": (classes) => {
        el._x_transition.enter.end = classes;
      },
      "leave": (classes) => {
        el._x_transition.leave.during = classes;
      },
      "leave-start": (classes) => {
        el._x_transition.leave.start = classes;
      },
      "leave-end": (classes) => {
        el._x_transition.leave.end = classes;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i2, index2) => index2 < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i2, index2) => index2 > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;
    let delay = modifierValue(modifiers, "delay", 0) / 1e3;
    let origin = modifierValue(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: `${delay}s`,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: `${delay}s`,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: { during: defaultValue, start: defaultValue, end: defaultValue },
        leave: { during: defaultValue, start: defaultValue, end: defaultValue },
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
    let clickAwayCompatibleShow = () => nextTick2(show);
    if (value) {
      if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
        el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
      } else {
        el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      }
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve2, reject) => {
      el._x_transition.out(() => {
      }, () => resolve2(hide));
      el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        nextTick2(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i2]) => i2?.());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e2) => {
            if (!e2.isFromCancelledTransition)
              throw e2;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, { during, start: start22, end } = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start22).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start22);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    });
  }
  function performTransition(el, stages) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback2) {
        this.beforeCancels.push(callback2);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        ;
        finish();
      }),
      finish
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration === 0)
        duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration + delay);
        reachedEnd = true;
      });
    });
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration" || key === "delay") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }
  var isCloning = false;
  function skipDuringClone(callback2, fallback = () => {
  }) {
    return (...args) => isCloning ? fallback(...args) : callback2(...args);
  }
  function onlyDuringClone(callback2) {
    return (...args) => isCloning && callback2(...args);
  }
  var interceptors = [];
  function interceptClone(callback2) {
    interceptors.push(callback2);
  }
  function cloneNode(from2, to2) {
    interceptors.forEach((i2) => i2(from2, to2));
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      initTree(to2, (el, callback2) => {
        callback2(el, () => {
        });
      });
    });
    isCloning = false;
  }
  var isCloningLegacy = false;
  function clone(oldEl, newEl) {
    if (!newEl._x_dataStack)
      newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    isCloningLegacy = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
    isCloningLegacy = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback2) => {
      walk(el2, (el3, skip2) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip2();
        hasRunThroughFirstEl = true;
        callback2(el3, skip2);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback2) {
    let cache = effect;
    overrideEffect((callback22, el) => {
      let storedEffect = cache(callback22);
      release(storedEffect);
      return () => {
      };
    });
    callback2();
    overrideEffect(cache);
  }
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      case "selected":
      case "checked":
        bindAttributeAndProperty(el, name, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (isRadio(el)) {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        if (typeof value === "boolean") {
          el.checked = safeParseBoolean(el.value) === value;
        } else {
          el.checked = checkedAttrLooseCompare(el.value, value);
        }
      }
    } else if (isCheckbox(el)) {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value === void 0 ? "" : value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttributeAndProperty(el, name, value) {
    bindAttribute(el, name, value);
    setPropertyIfChanged(el, name, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function setPropertyIfChanged(el, propName, value) {
    if (el[propName] !== value) {
      el[propName] = value;
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function safeParseBoolean(rawValue) {
    if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
      return true;
    }
    if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
      return false;
    }
    return rawValue ? Boolean(rawValue) : null;
  }
  var booleanAttributes = /* @__PURE__ */ new Set([
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "inert",
    "ismap",
    "itemscope",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected",
    "shadowrootclonable",
    "shadowrootdelegatesfocus",
    "shadowrootserializable"
  ]);
  function isBooleanAttr(attrName) {
    return booleanAttributes.has(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
  }
  function getBinding(el, name, fallback) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    return getAttributeBinding(el, name, fallback);
  }
  function extractProp(el, name, fallback, extract = true) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
      let binding = el._x_inlineBindings[name];
      binding.extract = extract;
      return dontAutoEvaluateFunctions(() => {
        return evaluate(el, binding.expression);
      });
    }
    return getAttributeBinding(el, name, fallback);
  }
  function getAttributeBinding(el, name, fallback) {
    let attr = el.getAttribute(name);
    if (attr === null)
      return typeof fallback === "function" ? fallback() : fallback;
    if (attr === "")
      return true;
    if (isBooleanAttr(name)) {
      return !![name, "true"].includes(attr);
    }
    return attr;
  }
  function isCheckbox(el) {
    return el.type === "checkbox" || el.localName === "ui-checkbox" || el.localName === "ui-switch";
  }
  function isRadio(el) {
    return el.type === "radio" || el.localName === "ui-radio";
  }
  function debounce(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
    let firstRun = true;
    let outerHash;
    let innerHash;
    let reference = effect(() => {
      let outer = outerGet();
      let inner = innerGet();
      if (firstRun) {
        innerSet(cloneIfObject(outer));
        firstRun = false;
      } else {
        let outerHashLatest = JSON.stringify(outer);
        let innerHashLatest = JSON.stringify(inner);
        if (outerHashLatest !== outerHash) {
          innerSet(cloneIfObject(outer));
        } else if (outerHashLatest !== innerHashLatest) {
          outerSet(cloneIfObject(inner));
        } else {
        }
      }
      outerHash = JSON.stringify(outerGet());
      innerHash = JSON.stringify(innerGet());
    });
    return () => {
      release(reference);
    };
  }
  function cloneIfObject(value) {
    return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
  }
  function plugin(callback2) {
    let callbacks = Array.isArray(callback2) ? callback2 : [callback2];
    callbacks.forEach((i2) => i2(alpine_default));
  }
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    initInterceptors(stores[name]);
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
  }
  function getStores() {
    return stores;
  }
  var binds = {};
  function bind2(name, bindings) {
    let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
    if (name instanceof Element) {
      return applyBindingsObject(name, getBindings());
    } else {
      binds[name] = getBindings;
    }
    return () => {
    };
  }
  function injectBindingProviders(obj) {
    Object.entries(binds).forEach(([name, callback2]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback2(...args);
          };
        }
      });
    });
    return obj;
  }
  function applyBindingsObject(el, obj, original) {
    let cleanupRunners = [];
    while (cleanupRunners.length)
      cleanupRunners.pop()();
    let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(attributes);
    attributes = attributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    directives(el, attributes, original).map((handle) => {
      cleanupRunners.push(handle.runCleanups);
      handle();
    });
    return () => {
      while (cleanupRunners.length)
        cleanupRunners.pop()();
    };
  }
  var datas = {};
  function data(name, callback2) {
    datas[name] = callback2;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback2]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback2.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }
  var Alpine = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.14.9",
    flushAndStopDeferringMutations,
    dontAutoEvaluateFunctions,
    disableEffectScheduling,
    startObservingMutations,
    stopObservingMutations,
    setReactivityEngine,
    onAttributeRemoved,
    onAttributesAdded,
    closestDataStack,
    skipDuringClone,
    onlyDuringClone,
    addRootSelector,
    addInitSelector,
    interceptClone,
    addScopeToNode,
    deferMutations,
    mapAttributes,
    evaluateLater,
    interceptInit,
    setEvaluator,
    mergeProxies,
    extractProp,
    findClosest,
    onElRemoved,
    closestRoot,
    destroyTree,
    interceptor,
    // INTERNAL: not public API and is subject to change without major release.
    transition,
    // INTERNAL
    setStyles,
    // INTERNAL
    mutateDom,
    directive,
    entangle,
    throttle,
    debounce,
    evaluate,
    initTree,
    nextTick,
    prefixed: prefix,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone,
    // INTERNAL
    cloneNode,
    // INTERNAL
    bound: getBinding,
    $data: scope,
    watch,
    walk,
    data,
    bind: bind2
  };
  var alpine_default = Alpine;
  function makeMap(str, expectsLowerCase) {
    const map3 = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i2 = 0; i2 < list.length; i2++) {
      map3[list[i2]] = true;
    }
    return expectsLowerCase ? (val) => !!map3[val.toLowerCase()] : (val) => !!map3[val];
  }
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
  var EMPTY_OBJ = true ? Object.freeze({}) : {};
  var EMPTY_ARR = true ? Object.freeze([]) : [];
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_3, c2) => c2 ? c2.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  var targetMap = /* @__PURE__ */ new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol(true ? "iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect2(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect32 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect32();
    }
    return effect32;
  }
  function stop(effect32) {
    if (effect32.active) {
      cleanup(effect32);
      if (effect32.options.onStop) {
        effect32.options.onStop();
      }
      effect32.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect32 = function reactiveEffect() {
      if (!effect32.active) {
        return fn();
      }
      if (!effectStack.includes(effect32)) {
        cleanup(effect32);
        try {
          enableTracking();
          effectStack.push(effect32);
          activeEffect = effect32;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect32.id = uid++;
    effect32.allowRecurse = !!options.allowRecurse;
    effect32._isEffect = true;
    effect32.active = true;
    effect32.raw = fn;
    effect32.deps = [];
    effect32.options = options;
    return effect32;
  }
  function cleanup(effect32) {
    const { deps } = effect32;
    if (deps.length) {
      for (let i2 = 0; i2 < deps.length; i2++) {
        deps[i2].delete(effect32);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = /* @__PURE__ */ new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects2 = /* @__PURE__ */ new Set();
    const add2 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect32) => {
          if (effect32 !== activeEffect || effect32.allowRecurse) {
            effects2.add(effect32);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add2);
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add2(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add2(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            add2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            add2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect32) => {
      if (effect32.options.onTrigger) {
        effect32.options.onTrigger({
          effect: effect32,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect32.options.scheduler) {
        effect32.options.scheduler(effect32);
      } else {
        effect32();
      }
    };
    effects2.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i2 = 0, l4 = this.length; i2 < l4; i2++) {
          track(arr, "get", i2 + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  function createSetter(shallow = false) {
    return function set32(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      if (true) {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      if (true) {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var toReactive = (value) => isObject(value) ? reactive2(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v3) => Reflect.getPrototypeOf(v3);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "get", key);
    }
    !isReadonly && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly = false) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "has", key);
    }
    !isReadonly && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback2, thisArg) {
      const observed = this;
      const target = observed[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback2.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (true) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value[
      "__v_skip"
      /* SKIP */
    ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (target && target[
      "__v_isReadonly"
      /* IS_READONLY */
    ]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (true) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target[
      "__v_raw"
      /* RAW */
    ] && !(isReadonly && target[
      "__v_isReactive"
      /* IS_REACTIVE */
    ])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function toRaw(observed) {
    return observed && toRaw(observed[
      "__v_raw"
      /* RAW */
    ]) || observed;
  }
  function isRef(r2) {
    return Boolean(r2 && r2.__v_isRef === true);
  }
  magic("nextTick", () => nextTick);
  magic("dispatch", (el) => dispatch.bind(dispatch, el));
  magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback2) => {
    let evaluate2 = evaluateLater2(key);
    let getter = () => {
      let value;
      evaluate2((i2) => value = i2);
      return value;
    };
    let unwatch = watch(getter, callback2);
    cleanup2(unwatch);
  });
  magic("store", getStores);
  magic("data", (el) => scope(el));
  magic("root", (el) => closestRoot(el));
  magic("refs", (el) => {
    if (el._x_refs_proxy)
      return el._x_refs_proxy;
    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
    return el._x_refs_proxy;
  });
  function getArrayOfRefObject(el) {
    let refObjects = [];
    findClosest(el, (i2) => {
      if (i2._x_refs)
        refObjects.push(i2._x_refs);
    });
    return refObjects;
  }
  var globalIdMemo = {};
  function findAndIncrementId(name) {
    if (!globalIdMemo[name])
      globalIdMemo[name] = 0;
    return ++globalIdMemo[name];
  }
  function closestIdRoot(el, name) {
    return findClosest(el, (element) => {
      if (element._x_ids && element._x_ids[name])
        return true;
    });
  }
  function setIdRoot(el, name) {
    if (!el._x_ids)
      el._x_ids = {};
    if (!el._x_ids[name])
      el._x_ids[name] = findAndIncrementId(name);
  }
  magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
    let cacheKey = `${name}${key ? `-${key}` : ""}`;
    return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
      let root = closestIdRoot(el, name);
      let id2 = root ? root._x_ids[name] : findAndIncrementId(name);
      return key ? `${name}-${id2}-${key}` : `${name}-${id2}`;
    });
  });
  interceptClone((from2, to2) => {
    if (from2._x_id) {
      to2._x_id = from2._x_id;
    }
  });
  function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback2) {
    if (!el._x_id)
      el._x_id = {};
    if (el._x_id[cacheKey])
      return el._x_id[cacheKey];
    let output = callback2();
    el._x_id[cacheKey] = output;
    cleanup2(() => {
      delete el._x_id[cacheKey];
    });
    return output;
  }
  magic("el", (el) => el);
  warnMissingPluginMagic("Focus", "focus", "focus");
  warnMissingPluginMagic("Persist", "persist", "persist");
  function warnMissingPluginMagic(name, magicName, slug) {
    magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  directive("modelable", (el, { expression }, { effect: effect32, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let func = evaluateLater2(expression);
    let innerGet = () => {
      let result;
      func((i2) => result = i2);
      return result;
    };
    let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
    let innerSet = (val) => evaluateInnerSet(() => {
    }, { scope: { "__placeholder": val } });
    let initialValue = innerGet();
    innerSet(initialValue);
    queueMicrotask(() => {
      if (!el._x_model)
        return;
      el._x_removeModelListeners["default"]();
      let outerGet = el._x_model.get;
      let outerSet = el._x_model.set;
      let releaseEntanglement = entangle(
        {
          get() {
            return outerGet();
          },
          set(value) {
            outerSet(value);
          }
        },
        {
          get() {
            return innerGet();
          },
          set(value) {
            innerSet(value);
          }
        }
      );
      cleanup2(releaseEntanglement);
    });
  });
  directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-teleport can only be used on a <template> tag", el);
    let target = getTarget(expression);
    let clone22 = el.content.cloneNode(true).firstElementChild;
    el._x_teleport = clone22;
    clone22._x_teleportBack = el;
    el.setAttribute("data-teleport-template", true);
    clone22.setAttribute("data-teleport-target", true);
    if (el._x_forwardEvents) {
      el._x_forwardEvents.forEach((eventName) => {
        clone22.addEventListener(eventName, (e2) => {
          e2.stopPropagation();
          el.dispatchEvent(new e2.constructor(e2.type, e2));
        });
      });
    }
    addScopeToNode(clone22, {}, el);
    let placeInDom = (clone32, target2, modifiers2) => {
      if (modifiers2.includes("prepend")) {
        target2.parentNode.insertBefore(clone32, target2);
      } else if (modifiers2.includes("append")) {
        target2.parentNode.insertBefore(clone32, target2.nextSibling);
      } else {
        target2.appendChild(clone32);
      }
    };
    mutateDom(() => {
      placeInDom(clone22, target, modifiers);
      skipDuringClone(() => {
        initTree(clone22);
      })();
    });
    el._x_teleportPutBack = () => {
      let target2 = getTarget(expression);
      mutateDom(() => {
        placeInDom(el._x_teleport, target2, modifiers);
      });
    };
    cleanup2(
      () => mutateDom(() => {
        clone22.remove();
        destroyTree(clone22);
      })
    );
  });
  var teleportContainerDuringClone = document.createElement("div");
  function getTarget(expression) {
    let target = skipDuringClone(() => {
      return document.querySelector(expression);
    }, () => {
      return teleportContainerDuringClone;
    })();
    if (!target)
      warn(`Cannot find x-teleport element for selector: "${expression}"`);
    return target;
  }
  var handler = () => {
  };
  handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);
  directive("effect", skipDuringClone((el, { expression }, { effect: effect32 }) => {
    effect32(evaluateLater(el, expression));
  }));
  function on(el, event, modifiers, callback2) {
    let listenerTarget = el;
    let handler4 = (e2) => callback2(e2);
    let options = {};
    let wrapHandler = (callback22, wrapper) => (e2) => wrapper(callback22, e2);
    if (modifiers.includes("dot"))
      event = dotSyntax(event);
    if (modifiers.includes("camel"))
      event = camelCase2(event);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("capture"))
      options.capture = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = debounce(handler4, wait);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = throttle(handler4, wait);
    }
    if (modifiers.includes("prevent"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.preventDefault();
        next(e2);
      });
    if (modifiers.includes("stop"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.stopPropagation();
        next(e2);
      });
    if (modifiers.includes("once")) {
      handler4 = wrapHandler(handler4, (next, e2) => {
        next(e2);
        listenerTarget.removeEventListener(event, handler4, options);
      });
    }
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler4 = wrapHandler(handler4, (next, e2) => {
        if (el.contains(e2.target))
          return;
        if (e2.target.isConnected === false)
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        if (el._x_isShown === false)
          return;
        next(e2);
      });
    }
    if (modifiers.includes("self"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.target === el && next(e2);
      });
    if (isKeyEvent(event) || isClickEvent(event)) {
      handler4 = wrapHandler(handler4, (next, e2) => {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers)) {
          return;
        }
        next(e2);
      });
    }
    listenerTarget.addEventListener(event, handler4, options);
    return () => {
      listenerTarget.removeEventListener(event, handler4, options);
    };
  }
  function dotSyntax(subject) {
    return subject.replace(/-/g, ".");
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase2(subject) {
    if ([" ", "_"].includes(
      subject
    ))
      return subject;
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event) {
    return ["keydown", "keyup"].includes(event);
  }
  function isClickEvent(event) {
    return ["contextmenu", "click", "mouse"].some((i2) => event.includes(i2));
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers) {
    let keyModifiers = modifiers.filter((i2) => {
      return !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive"].includes(i2);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.includes("throttle")) {
      let debounceIndex = keyModifiers.indexOf("throttle");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyToModifiers(e2.key).includes(keyModifiers[0]))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i2) => !selectedSystemKeyModifiers.includes(i2));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e2[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (isClickEvent(e2.type))
          return false;
        if (keyToModifiers(e2.key).includes(keyModifiers[0]))
          return false;
      }
    }
    return true;
  }
  function keyToModifiers(key) {
    if (!key)
      return [];
    key = kebabCase2(key);
    let modifierToKeyMap = {
      "ctrl": "control",
      "slash": "/",
      "space": " ",
      "spacebar": " ",
      "cmd": "meta",
      "esc": "escape",
      "up": "arrow-up",
      "down": "arrow-down",
      "left": "arrow-left",
      "right": "arrow-right",
      "period": ".",
      "comma": ",",
      "equal": "=",
      "minus": "-",
      "underscore": "_"
    };
    modifierToKeyMap[key] = key;
    return Object.keys(modifierToKeyMap).map((modifier) => {
      if (modifierToKeyMap[modifier] === key)
        return modifier;
    }).filter((modifier) => modifier);
  }
  directive("model", (el, { modifiers, expression }, { effect: effect32, cleanup: cleanup2 }) => {
    let scopeTarget = el;
    if (modifiers.includes("parent")) {
      scopeTarget = el.parentNode;
    }
    let evaluateGet = evaluateLater(scopeTarget, expression);
    let evaluateSet;
    if (typeof expression === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
    } else if (typeof expression === "function" && typeof expression() === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
    } else {
      evaluateSet = () => {
      };
    }
    let getValue = () => {
      let result;
      evaluateGet((value) => result = value);
      return isGetterSetter(result) ? result.get() : result;
    };
    let setValue = (value) => {
      let result;
      evaluateGet((value2) => result = value2);
      if (isGetterSetter(result)) {
        result.set(value);
      } else {
        evaluateSet(() => {
        }, {
          scope: { "__placeholder": value }
        });
      }
    };
    if (typeof expression === "string" && el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let removeListener2 = isCloning ? () => {
    } : on(el, event, modifiers, (e2) => {
      setValue(getInputValue(el, modifiers, e2, getValue()));
    });
    if (modifiers.includes("fill")) {
      if ([void 0, null, ""].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === "select" && el.multiple) {
        setValue(
          getInputValue(el, modifiers, { target: el }, getValue())
        );
      }
    }
    if (!el._x_removeModelListeners)
      el._x_removeModelListeners = {};
    el._x_removeModelListeners["default"] = removeListener2;
    cleanup2(() => el._x_removeModelListeners["default"]());
    if (el.form) {
      let removeResetListener = on(el.form, "reset", [], (e2) => {
        nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));
      });
      cleanup2(() => removeResetListener());
    }
    el._x_model = {
      get() {
        return getValue();
      },
      set(value) {
        setValue(value);
      }
    };
    el._x_forceModelUpdate = (value) => {
      if (value === void 0 && typeof expression === "string" && expression.match(/\./))
        value = "";
      window.fromModel = true;
      mutateDom(() => bind(el, "value", value));
      delete window.fromModel;
    };
    effect32(() => {
      let value = getValue();
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate(value);
    });
  });
  function getInputValue(el, modifiers, event, currentValue) {
    return mutateDom(() => {
      if (event instanceof CustomEvent && event.detail !== void 0)
        return event.detail !== null && event.detail !== void 0 ? event.detail : event.target.value;
      else if (isCheckbox(el)) {
        if (Array.isArray(currentValue)) {
          let newValue = null;
          if (modifiers.includes("number")) {
            newValue = safeParseNumber(event.target.value);
          } else if (modifiers.includes("boolean")) {
            newValue = safeParseBoolean(event.target.value);
          } else {
            newValue = event.target.value;
          }
          return event.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
        } else {
          return event.target.checked;
        }
      } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
        if (modifiers.includes("number")) {
          return Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          });
        } else if (modifiers.includes("boolean")) {
          return Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseBoolean(rawValue);
          });
        }
        return Array.from(event.target.selectedOptions).map((option) => {
          return option.value || option.text;
        });
      } else {
        let newValue;
        if (isRadio(el)) {
          if (event.target.checked) {
            newValue = event.target.value;
          } else {
            newValue = currentValue;
          }
        } else {
          newValue = event.target.value;
        }
        if (modifiers.includes("number")) {
          return safeParseNumber(newValue);
        } else if (modifiers.includes("boolean")) {
          return safeParseBoolean(newValue);
        } else if (modifiers.includes("trim")) {
          return newValue.trim();
        } else {
          return newValue;
        }
      }
    });
  }
  function safeParseNumber(rawValue) {
    let number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number) ? number : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function isGetterSetter(value) {
    return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
  }
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "string") {
      return !!expression.trim() && evaluate2(expression, {}, false);
    }
    return evaluate2(expression, {}, false);
  }));
  directive("text", (el, { expression }, { effect: effect32, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect32(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });
  directive("html", (el, { expression }, { effect: effect32, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect32(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.innerHTML = value;
          el._x_ignoreSelf = true;
          initTree(el);
          delete el._x_ignoreSelf;
        });
      });
    });
  });
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  var handler2 = (el, { value, modifiers, expression, original }, { effect: effect32, cleanup: cleanup2 }) => {
    if (!value) {
      let bindingProviders = {};
      injectBindingProviders(bindingProviders);
      let getBindings = evaluateLater(el, expression);
      getBindings((bindings) => {
        applyBindingsObject(el, bindings, original);
      }, { scope: bindingProviders });
      return;
    }
    if (value === "key")
      return storeKeyForXFor(el, expression);
    if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
      return;
    }
    let evaluate2 = evaluateLater(el, expression);
    effect32(() => evaluate2((result) => {
      if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
        result = "";
      }
      mutateDom(() => bind(el, value, result, modifiers));
    }));
    cleanup2(() => {
      el._x_undoAddedClasses && el._x_undoAddedClasses();
      el._x_undoAddedStyles && el._x_undoAddedStyles();
    });
  };
  handler2.inline = (el, { value, modifiers, expression }) => {
    if (!value)
      return;
    if (!el._x_inlineBindings)
      el._x_inlineBindings = {};
    el._x_inlineBindings[value] = { expression, extract: false };
  };
  directive("bind", handler2);
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
    if (shouldSkipRegisteringDataDuringClone(el))
      return;
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate(el, expression, { scope: dataProviderContext });
    if (data2 === void 0 || data2 === true)
      data2 = {};
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors(reactiveData);
    let undo2 = addScopeToNode(el, reactiveData);
    reactiveData["init"] && evaluate(el, reactiveData["init"]);
    cleanup2(() => {
      reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
      undo2();
    });
  });
  interceptClone((from2, to2) => {
    if (from2._x_dataStack) {
      to2._x_dataStack = from2._x_dataStack;
      to2.setAttribute("data-has-alpine-state", true);
    }
  });
  function shouldSkipRegisteringDataDuringClone(el) {
    if (!isCloning)
      return false;
    if (isCloningLegacy)
      return true;
    return el.hasAttribute("data-has-alpine-state");
  }
  directive("show", (el, { modifiers, expression }, { effect: effect32 }) => {
    let evaluate2 = evaluateLater(el, expression);
    if (!el._x_doHide)
      el._x_doHide = () => {
        mutateDom(() => {
          el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
        });
      };
    if (!el._x_doShow)
      el._x_doShow = () => {
        mutateDom(() => {
          if (el.style.length === 1 && el.style.display === "none") {
            el.removeAttribute("style");
          } else {
            el.style.removeProperty("display");
          }
        });
      };
    let hide = () => {
      el._x_doHide();
      el._x_isShown = false;
    };
    let show = () => {
      el._x_doShow();
      el._x_isShown = true;
    };
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once(
      (value) => value ? show() : hide(),
      (value) => {
        if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
          el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
        } else {
          value ? clickAwayCompatibleShow() : hide();
        }
      }
    );
    let oldValue;
    let firstTime = true;
    effect32(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });
  directive("for", (el, { expression }, { effect: effect32, cleanup: cleanup2 }) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(
      el,
      // the x-bind:key expression is stored for our use instead of evaluated.
      el._x_keyExpression || "index"
    );
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect32(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => mutateDom(
        () => {
          destroyTree(el2);
          el2.remove();
        }
      ));
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject22 = (i2) => typeof i2 === "object" && !Array.isArray(i2);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i2) => i2 + 1);
      }
      if (items === void 0)
        items = [];
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject22(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => {
            if (keys.includes(value2))
              warn("Duplicate key on x-for", el);
            keys.push(value2);
          }, { scope: { index: key, ...scope2 } });
          scopes.push(scope2);
        });
      } else {
        for (let i2 = 0; i2 < items.length; i2++) {
          let scope2 = getIterationScopeVariables(iteratorNames, items[i2], i2, items);
          evaluateKey((value) => {
            if (keys.includes(value))
              warn("Duplicate key on x-for", el);
            keys.push(value);
          }, { scope: { index: i2, ...scope2 } });
          scopes.push(scope2);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i2 = 0; i2 < prevKeys.length; i2++) {
        let key = prevKeys[i2];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i2 = 0; i2 < keys.length; i2++) {
        let key = keys[i2];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i2, 0, key);
          adds.push([lastKey, i2]);
        } else if (prevIndex !== i2) {
          let keyInSpot = prevKeys.splice(i2, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i2, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i2 = 0; i2 < removes.length; i2++) {
        let key = removes[i2];
        if (!(key in lookup))
          continue;
        mutateDom(() => {
          destroyTree(lookup[key]);
          lookup[key].remove();
        });
        delete lookup[key];
      }
      for (let i2 = 0; i2 < moves.length; i2++) {
        let [keyInSpot, keyForSpot] = moves[i2];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          if (!elForSpot)
            warn(`x-for ":key" is undefined or invalid`, templateEl, keyForSpot, lookup);
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
          marker.before(elInSpot);
          elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
          marker.remove();
        });
        elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i2 = 0; i2 < adds.length; i2++) {
        let [lastKey2, index2] = adds[i2];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        if (lastEl._x_currentIfEl)
          lastEl = lastEl._x_currentIfEl;
        let scope2 = scopes[index2];
        let key = keys[index2];
        let clone22 = document.importNode(templateEl.content, true).firstElementChild;
        let reactiveScope = reactive(scope2);
        addScopeToNode(clone22, reactiveScope, templateEl);
        clone22._x_refreshXForScope = (newScope) => {
          Object.entries(newScope).forEach(([key2, value]) => {
            reactiveScope[key2] = value;
          });
        };
        mutateDom(() => {
          lastEl.after(clone22);
          skipDuringClone(() => initTree(clone22))();
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone22;
      }
      for (let i2 = 0; i2 < sames.length; i2++) {
        lookup[sames[i2]]._x_refreshXForScope(scopes[keys.indexOf(sames[i2])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index2, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names2 = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i2) => i2.trim());
      names2.forEach((name, i2) => {
        scopeVariables[name] = item[i2];
      });
    } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
      let names2 = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i2) => i2.trim());
      names2.forEach((name) => {
        scopeVariables[name] = item[name];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index2;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function handler3() {
  }
  handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler3);
  directive("if", (el, { expression }, { effect: effect32, cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-if can only be used on a <template> tag", el);
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone22 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone22, {}, el);
      mutateDom(() => {
        el.after(clone22);
        skipDuringClone(() => initTree(clone22))();
      });
      el._x_currentIfEl = clone22;
      el._x_undoIf = () => {
        mutateDom(() => {
          destroyTree(clone22);
          clone22.remove();
        });
        delete el._x_currentIfEl;
      };
      return clone22;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect32(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });
  directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
    let names2 = evaluate2(expression);
    names2.forEach((name) => setIdRoot(el, name));
  });
  interceptClone((from2, to2) => {
    if (from2._x_ids) {
      to2._x_ids = from2._x_ids;
    }
  });
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    if (el.tagName.toLowerCase() === "template") {
      if (!el._x_forwardEvents)
        el._x_forwardEvents = [];
      if (!el._x_forwardEvents.includes(value))
        el._x_forwardEvents.push(value);
    }
    let removeListener2 = on(el, value, modifiers, (e2) => {
      evaluate2(() => {
      }, { scope: { "$event": e2 }, params: [e2] });
    });
    cleanup2(() => removeListener2());
  }));
  warnMissingPluginDirective("Collapse", "collapse", "collapse");
  warnMissingPluginDirective("Intersect", "intersect", "intersect");
  warnMissingPluginDirective("Focus", "trap", "focus");
  warnMissingPluginDirective("Mask", "mask", "mask");
  function warnMissingPluginDirective(name, directiveName, slug) {
    directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  alpine_default.setEvaluator(normalEvaluator);
  alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
  var src_default = alpine_default;
  var module_default = src_default;

  // node_modules/@kurkle/color/dist/color.esm.js
  function round(v3) {
    return v3 + 0.5 | 0;
  }
  var lim = (v3, l4, h3) => Math.max(Math.min(v3, h3), l4);
  function p2b(v3) {
    return lim(round(v3 * 2.55), 0, 255);
  }
  function n2b(v3) {
    return lim(round(v3 * 255), 0, 255);
  }
  function b2n(v3) {
    return lim(round(v3 / 2.55) / 100, 0, 1);
  }
  function n2p(v3) {
    return lim(round(v3 * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b3) => hex[b3 & 15];
  var h2 = (b3) => hex[(b3 & 240) >> 4] + hex[b3 & 15];
  var eq = (b3) => (b3 & 240) >> 4 === (b3 & 15);
  var isShort = (v3) => eq(v3.r) && eq(v3.g) && eq(v3.b) && eq(v3.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a2, f2) => a2 < 255 ? f2(a2) : "";
  function hexString(v3) {
    var f2 = isShort(v3) ? h1 : h2;
    return v3 ? "#" + f2(v3.r) + f2(v3.g) + f2(v3.b) + alpha(v3.a, f2) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h3, s2, l4) {
    const a2 = s2 * Math.min(l4, 1 - l4);
    const f2 = (n2, k2 = (n2 + h3 / 30) % 12) => l4 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
    return [f2(0), f2(8), f2(4)];
  }
  function hsv2rgbn(h3, s2, v3) {
    const f2 = (n2, k2 = (n2 + h3 / 60) % 6) => v3 - v3 * s2 * Math.max(Math.min(k2, 4 - k2, 1), 0);
    return [f2(5), f2(3), f2(1)];
  }
  function hwb2rgbn(h3, w3, b3) {
    const rgb = hsl2rgbn(h3, 1, 0.5);
    let i2;
    if (w3 + b3 > 1) {
      i2 = 1 / (w3 + b3);
      w3 *= i2;
      b3 *= i2;
    }
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] *= 1 - w3 - b3;
      rgb[i2] += w3;
    }
    return rgb;
  }
  function hueValue(r2, g2, b3, d3, max) {
    if (r2 === max) {
      return (g2 - b3) / d3 + (g2 < b3 ? 6 : 0);
    }
    if (g2 === max) {
      return (b3 - r2) / d3 + 2;
    }
    return (r2 - g2) / d3 + 4;
  }
  function rgb2hsl(v3) {
    const range2 = 255;
    const r2 = v3.r / range2;
    const g2 = v3.g / range2;
    const b3 = v3.b / range2;
    const max = Math.max(r2, g2, b3);
    const min = Math.min(r2, g2, b3);
    const l4 = (max + min) / 2;
    let h3, s2, d3;
    if (max !== min) {
      d3 = max - min;
      s2 = l4 > 0.5 ? d3 / (2 - max - min) : d3 / (max + min);
      h3 = hueValue(r2, g2, b3, d3, max);
      h3 = h3 * 60 + 0.5;
    }
    return [h3 | 0, s2 || 0, l4];
  }
  function calln(f2, a2, b3, c2) {
    return (Array.isArray(a2) ? f2(a2[0], a2[1], a2[2]) : f2(a2, b3, c2)).map(n2b);
  }
  function hsl2rgb(h3, s2, l4) {
    return calln(hsl2rgbn, h3, s2, l4);
  }
  function hwb2rgb(h3, w3, b3) {
    return calln(hwb2rgbn, h3, w3, b3);
  }
  function hsv2rgb(h3, s2, v3) {
    return calln(hsv2rgbn, h3, s2, v3);
  }
  function hue(h3) {
    return (h3 % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m2 = HUE_RE.exec(str);
    let a2 = 255;
    let v3;
    if (!m2) {
      return;
    }
    if (m2[5] !== v3) {
      a2 = m2[6] ? p2b(+m2[5]) : n2b(+m2[5]);
    }
    const h3 = hue(+m2[2]);
    const p1 = +m2[3] / 100;
    const p2 = +m2[4] / 100;
    if (m2[1] === "hwb") {
      v3 = hwb2rgb(h3, p1, p2);
    } else if (m2[1] === "hsv") {
      v3 = hsv2rgb(h3, p1, p2);
    } else {
      v3 = hsl2rgb(h3, p1, p2);
    }
    return {
      r: v3[0],
      g: v3[1],
      b: v3[2],
      a: a2
    };
  }
  function rotate(v3, deg) {
    var h3 = rgb2hsl(v3);
    h3[0] = hue(h3[0] + deg);
    h3 = hsl2rgb(h3);
    v3.r = h3[0];
    v3.g = h3[1];
    v3.b = h3[2];
  }
  function hslString(v3) {
    if (!v3) {
      return;
    }
    const a2 = rgb2hsl(v3);
    const h3 = a2[0];
    const s2 = n2p(a2[1]);
    const l4 = n2p(a2[2]);
    return v3.a < 255 ? `hsla(${h3}, ${s2}%, ${l4}%, ${b2n(v3.a)})` : `hsl(${h3}, ${s2}%, ${l4}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i2, j2, k2, ok, nk;
    for (i2 = 0; i2 < keys.length; i2++) {
      ok = nk = keys[i2];
      for (j2 = 0; j2 < tkeys.length; j2++) {
        k2 = tkeys[j2];
        nk = nk.replace(k2, map[k2]);
      }
      k2 = parseInt(names$1[ok], 16);
      unpacked[nk] = [k2 >> 16 & 255, k2 >> 8 & 255, k2 & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a2 = names[str.toLowerCase()];
    return a2 && {
      r: a2[0],
      g: a2[1],
      b: a2[2],
      a: a2.length === 4 ? a2[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m2 = RGB_RE.exec(str);
    let a2 = 255;
    let r2, g2, b3;
    if (!m2) {
      return;
    }
    if (m2[7] !== r2) {
      const v3 = +m2[7];
      a2 = m2[8] ? p2b(v3) : lim(v3 * 255, 0, 255);
    }
    r2 = +m2[1];
    g2 = +m2[3];
    b3 = +m2[5];
    r2 = 255 & (m2[2] ? p2b(r2) : lim(r2, 0, 255));
    g2 = 255 & (m2[4] ? p2b(g2) : lim(g2, 0, 255));
    b3 = 255 & (m2[6] ? p2b(b3) : lim(b3, 0, 255));
    return {
      r: r2,
      g: g2,
      b: b3,
      a: a2
    };
  }
  function rgbString(v3) {
    return v3 && (v3.a < 255 ? `rgba(${v3.r}, ${v3.g}, ${v3.b}, ${b2n(v3.a)})` : `rgb(${v3.r}, ${v3.g}, ${v3.b})`);
  }
  var to = (v3) => v3 <= 31308e-7 ? v3 * 12.92 : Math.pow(v3, 1 / 2.4) * 1.055 - 0.055;
  var from = (v3) => v3 <= 0.04045 ? v3 / 12.92 : Math.pow((v3 + 0.055) / 1.055, 2.4);
  function interpolate(rgb1, rgb2, t2) {
    const r2 = from(b2n(rgb1.r));
    const g2 = from(b2n(rgb1.g));
    const b3 = from(b2n(rgb1.b));
    return {
      r: n2b(to(r2 + t2 * (from(b2n(rgb2.r)) - r2))),
      g: n2b(to(g2 + t2 * (from(b2n(rgb2.g)) - g2))),
      b: n2b(to(b3 + t2 * (from(b2n(rgb2.b)) - b3))),
      a: rgb1.a + t2 * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v3, i2, ratio) {
    if (v3) {
      let tmp = rgb2hsl(v3);
      tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v3.r = tmp[0];
      v3.g = tmp[1];
      v3.b = tmp[2];
    }
  }
  function clone2(v3, proto) {
    return v3 ? Object.assign(proto || {}, v3) : v3;
  }
  function fromObject(input) {
    var v3 = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v3 = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v3.a = n2b(input[3]);
        }
      }
    } else {
      v3 = clone2(input, { r: 0, g: 0, b: 0, a: 1 });
      v3.a = n2b(v3.a);
    }
    return v3;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class _Color {
    constructor(input) {
      if (input instanceof _Color) {
        return input;
      }
      const type = typeof input;
      let v3;
      if (type === "object") {
        v3 = fromObject(input);
      } else if (type === "string") {
        v3 = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v3;
      this._valid = !!v3;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v3 = clone2(this._rgb);
      if (v3) {
        v3.a = b2n(v3.a);
      }
      return v3;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c2 = color2.rgb;
        let w22;
        const p2 = weight === w22 ? 0.5 : weight;
        const w3 = 2 * p2 - 1;
        const a2 = c1.a - c2.a;
        const w1 = ((w3 * a2 === -1 ? w3 : (w3 + a2) / (1 + w3 * a2)) + 1) / 2;
        w22 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w22 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w22 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w22 * c2.b + 0.5;
        c1.a = p2 * c1.a + (1 - p2) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t2) {
      if (color2) {
        this._rgb = interpolate(this._rgb, color2._rgb, t2);
      }
      return this;
    }
    clone() {
      return new _Color(this.rgb);
    }
    alpha(a2) {
      this._rgb.a = n2b(a2);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v3 = this._rgb;
      v3.r = 255 - v3.r;
      v3.g = 255 - v3.g;
      v3.b = 255 - v3.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };

  // node_modules/chart.js/dist/chunks/helpers.dataset.js
  function noop() {
  }
  var uid2 = /* @__PURE__ */ (() => {
    let id2 = 0;
    return () => id2++;
  })();
  function isNullOrUndef(value) {
    return value === null || value === void 0;
  }
  function isArray2(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject2(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
  }
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === "function") {
      return fn.apply(thisArg, args);
    }
  }
  function each(loopable, fn, thisArg, reverse) {
    let i2, len, keys;
    if (isArray2(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i2 = len - 1; i2 >= 0; i2--) {
          fn.call(thisArg, loopable[i2], i2);
        }
      } else {
        for (i2 = 0; i2 < len; i2++) {
          fn.call(thisArg, loopable[i2], i2);
        }
      }
    } else if (isObject2(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i2 = 0; i2 < len; i2++) {
        fn.call(thisArg, loopable[keys[i2]], keys[i2]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i2, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
      v0 = a0[i2];
      v1 = a1[i2];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone3(source) {
    if (isArray2(source)) {
      return source.map(clone3);
    }
    if (isObject2(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k2 = 0;
      for (; k2 < klen; ++k2) {
        target[keys[k2]] = clone3(source[keys[k2]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone3(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray2(source) ? source : [
      source
    ];
    const ilen = sources.length;
    if (!isObject2(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for (let i2 = 0; i2 < ilen; ++i2) {
      current = sources[i2];
      if (!isObject2(current)) {
        continue;
      }
      const keys = Object.keys(current);
      for (let k2 = 0, klen = keys.length; k2 < klen; ++k2) {
        merger(keys[k2], target, current, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, {
      merger: _mergerIf
    });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone3(sval);
    }
  }
  var keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (v3) => v3,
    // default resolvers
    x: (o2) => o2.x,
    y: (o2) => o2.y
  };
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k2 of keys) {
        if (k2 === "") {
          break;
        }
        obj = obj && obj[k2];
      }
      return obj;
    };
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction = (value) => typeof value === "function";
  var setsEqual = (a2, b3) => {
    if (a2.size !== b3.size) {
      return false;
    }
    for (const item of a2) {
      if (!b3.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e2) {
    return e2.type === "mouseup" || e2.type === "click" || e2.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function almostEquals(x2, y3, epsilon) {
    return Math.abs(x2 - y3) < epsilon;
  }
  function niceNum(range2) {
    const roundedRange = Math.round(range2);
    range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
    const niceRange = Math.pow(10, Math.floor(log10(range2)));
    const fraction = range2 / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i2;
    for (i2 = 1; i2 < sqrt; i2++) {
      if (value % i2 === 0) {
        result.push(i2);
        result.push(value / i2);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a2, b3) => a2 - b3).pop();
    return result;
  }
  function isNonPrimitive(n2) {
    return typeof n2 === "symbol" || typeof n2 === "object" && n2 !== null && !(Symbol.toPrimitive in n2 || "toString" in n2 || "valueOf" in n2);
  }
  function isNumber(n2) {
    return !isNonPrimitive(n2) && !isNaN(parseFloat(n2)) && isFinite(n2);
  }
  function almostWhole(x2, epsilon) {
    const rounded = Math.round(x2);
    return rounded - epsilon <= x2 && rounded + epsilon >= x2;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i2, ilen, value;
    for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
      value = array[i2][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x2) {
    if (!isNumberFinite(x2)) {
      return;
    }
    let e2 = 1;
    let p2 = 0;
    while (Math.round(x2 * e2) / e2 !== x2) {
      e2 *= 10;
      p2++;
    }
    return p2;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a2, b3) {
    return (a2 - b3 + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a2) {
    return (a2 % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start3, end, sameAngleIsFullCircle) {
    const a2 = _normalizeAngle(angle);
    const s2 = _normalizeAngle(start3);
    const e2 = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s2 - a2);
    const angleToEnd = _normalizeAngle(e2 - a2);
    const startToAngle = _normalizeAngle(a2 - s2);
    const endToAngle = _normalizeAngle(a2 - e2);
    return a2 === s2 || a2 === e2 || sameAngleIsFullCircle && s2 === e2 || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start3, end, epsilon = 1e-6) {
    return value >= Math.min(start3, end) - epsilon && value <= Math.max(start3, end) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index2) => table[index2] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return {
      lo,
      hi
    };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
    const ti = table[index2][key];
    return ti < value || ti === value && table[index2 + 1][key] === value;
  } : (index2) => table[index2][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
  function _filterBetween(values, min, max) {
    let start3 = 0;
    let end = values.length;
    while (start3 < end && values[start3] < min) {
      start3++;
    }
    while (end > start3 && values[end - 1] > max) {
      end--;
    }
    return start3 > 0 || end < values.length ? values.slice(start3, end) : values;
  }
  var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          listener
        ]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 !== -1) {
      listeners.splice(index2, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set4 = new Set(items);
    if (set4.size === items.length) {
      return items;
    }
    return Array.from(set4);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
      argsToUse = args;
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn.apply(thisArg, argsToUse);
        });
      }
    };
  }
  function debounce2(fn, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn, delay, args);
      } else {
        fn.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start3, end) => align === "start" ? start3 : align === "end" ? end : (start3 + end) / 2;
  var _textX = (align, left, right, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start3 = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, vScale, _parsed } = meta;
      const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
      const axis = iScale.axis;
      const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start3 = Math.min(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, axis, min).lo,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
        );
        if (spanGaps) {
          const distanceToDefinedLo = _parsed.slice(0, start3 + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          start3 -= Math.max(0, distanceToDefinedLo);
        }
        start3 = _limitValue(start3, 0, pointCount - 1);
      }
      if (maxDefined) {
        let end = Math.max(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
        );
        if (spanGaps) {
          const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          end += Math.max(0, distanceToDefinedHi);
        }
        count = _limitValue(end, start3, pointCount) - start3;
      } else {
        count = pointCount - start3;
      }
    }
    return {
      start: start3,
      count
    };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t2) => t2 === 0 || t2 === 1;
  var elasticIn = (t2, s2, p2) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s2) * TAU / p2));
  var elasticOut = (t2, s2, p2) => Math.pow(2, -10 * t2) * Math.sin((t2 - s2) * TAU / p2) + 1;
  var effects = {
    linear: (t2) => t2,
    easeInQuad: (t2) => t2 * t2,
    easeOutQuad: (t2) => -t2 * (t2 - 2),
    easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
    easeInCubic: (t2) => t2 * t2 * t2,
    easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
    easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
    easeInQuart: (t2) => t2 * t2 * t2 * t2,
    easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
    easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
    easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
    easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
    easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
    easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
    easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
    easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
    easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
    easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
    easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
    easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
    easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
    easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
    easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
    easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
    easeInOutElastic(t2) {
      const s2 = 0.1125;
      const p2 = 0.45;
      return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s2, p2) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s2, p2);
    },
    easeInBack(t2) {
      const s2 = 1.70158;
      return t2 * t2 * ((s2 + 1) * t2 - s2);
    },
    easeOutBack(t2) {
      const s2 = 1.70158;
      return (t2 -= 1) * t2 * ((s2 + 1) * t2 + s2) + 1;
    },
    easeInOutBack(t2) {
      let s2 = 1.70158;
      if ((t2 /= 0.5) < 1) {
        return 0.5 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2));
      }
      return 0.5 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
    },
    easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
    easeOutBounce(t2) {
      const m2 = 7.5625;
      const d3 = 2.75;
      if (t2 < 1 / d3) {
        return m2 * t2 * t2;
      }
      if (t2 < 2 / d3) {
        return m2 * (t2 -= 1.5 / d3) * t2 + 0.75;
      }
      if (t2 < 2.5 / d3) {
        return m2 * (t2 -= 2.25 / d3) * t2 + 0.9375;
      }
      return m2 * (t2 -= 2.625 / d3) * t2 + 0.984375;
    },
    easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ];
  var colors = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function applyAnimationsDefaults(defaults2) {
    defaults2.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    defaults2.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
    });
    defaults2.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers
      }
    });
    defaults2.describe("animations", {
      _fallback: "animation"
    });
    defaults2.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v3) => v3 | 0
          }
        }
      }
    });
  }
  function applyLayoutsDefaults(defaults2) {
    defaults2.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var formatters = {
    values(value) {
      return isArray2(value) ? value : "" + value;
    },
    numeric(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = {
        notation,
        minimumFractionDigits: numDecimal,
        maximumFractionDigits: numDecimal
      };
      Object.assign(options, this.options.ticks.format);
      return formatNumber(tickValue, locale, options);
    },
    logarithmic(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if ([
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(remain) || index2 > 0.8 * ticks.length) {
        return formatters.numeric.call(this, tickValue, index2, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = {
    formatters
  };
  function applyScaleDefaults(defaults2) {
    defaults2.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      clip: true,
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options) => options.lineWidth,
        tickColor: (_ctx, options) => options.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults2.route("scale.ticks", "color", "", "color");
    defaults2.route("scale.grid", "color", "", "borderColor");
    defaults2.route("scale.border", "color", "", "borderColor");
    defaults2.route("scale.title", "color", "", "color");
    defaults2.describe("scale", {
      _fallback: false,
      _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
      _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
    });
    defaults2.describe("scales", {
      _fallback: "scale"
    });
    defaults2.describe("scale.ticks", {
      _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
      _indexable: (name) => name !== "backdropPadding"
    });
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i2 = 0, n2 = keys.length; i2 < n2; ++i2) {
      const k2 = keys[i2];
      node = node[k2] || (node[k2] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set3(root, scope2, values) {
    if (typeof scope2 === "string") {
      return merge(getScope$1(root, scope2), values);
    }
    return merge(getScope$1(root, ""), scope2);
  }
  var Defaults = class {
    constructor(_descriptors2, _appliers) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
      this.apply(_appliers);
    }
    set(scope2, values) {
      return set3(this, scope2, values);
    }
    get(scope2) {
      return getScope$1(this, scope2);
    }
    describe(scope2, values) {
      return set3(descriptors, scope2, values);
    }
    override(scope2, values) {
      return set3(overrides, scope2, values);
    }
    route(scope2, name, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope2);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name],
          writable: true
        },
        [name]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject2(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
    apply(appliers) {
      appliers.forEach((apply2) => apply2(this));
    }
  };
  var defaults = /* @__PURE__ */ new Defaults({
    _scriptable: (name) => !name.startsWith("on"),
    _indexable: (name) => name !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
  ]);
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data2, gc, longest, string) {
    let textWidth = data2[string];
    if (!textWidth) {
      textWidth = data2[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data2 = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
      data2 = cache.data = {};
      gc = cache.garbageCollect = [];
      cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i2, j2, jlen, thing, nestedThing;
    for (i2 = 0; i2 < ilen; i2++) {
      thing = arrayOfThings[i2];
      if (thing !== void 0 && thing !== null && !isArray2(thing)) {
        longest = _measureText(ctx, data2, gc, longest, thing);
      } else if (isArray2(thing)) {
        for (j2 = 0, jlen = thing.length; j2 < jlen; j2++) {
          nestedThing = thing[j2];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray2(nestedThing)) {
            longest = _measureText(ctx, data2, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i2 = 0; i2 < gcLen; i2++) {
        delete data2[gc[i2]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    if (!ctx && !canvas) {
      return;
    }
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x2, y3) {
    drawPointLegend(ctx, options, x2, y3, null);
  }
  function drawPointLegend(ctx, options, x2, y3, w3) {
    let type, xOffset, yOffset, size2, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x2, y3);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      // Default includes circle
      default:
        if (w3) {
          ctx.ellipse(x2, y3, w3 / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x2, y3, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        width = w3 ? w3 / 2 : radius;
        ctx.moveTo(x2 + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x2 + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x2 + Math.sin(rad) * width, y3 - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size2 = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size2;
        xOffsetW = Math.cos(rad + QUARTER_PI) * (w3 ? w3 / 2 - cornerRadius : size2);
        yOffset = Math.sin(rad + QUARTER_PI) * size2;
        yOffsetW = Math.sin(rad + QUARTER_PI) * (w3 ? w3 / 2 - cornerRadius : size2);
        ctx.arc(x2 - xOffsetW, y3 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x2 + yOffsetW, y3 - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x2 + xOffsetW, y3 + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x2 - yOffsetW, y3 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size2 = Math.SQRT1_2 * radius;
          width = w3 ? w3 / 2 : size2;
          ctx.rect(x2 - width, y3 - size2, 2 * width, 2 * size2);
          break;
        }
        rad += QUARTER_PI;
      /* falls through */
      case "rectRot":
        xOffsetW = Math.cos(rad) * (w3 ? w3 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w3 ? w3 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
        ctx.lineTo(x2 + yOffsetW, y3 - xOffset);
        ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
        ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      /* falls through */
      case "cross":
        xOffsetW = Math.cos(rad) * (w3 ? w3 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w3 ? w3 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
        ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
        ctx.moveTo(x2 + yOffsetW, y3 - xOffset);
        ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
        break;
      case "star":
        xOffsetW = Math.cos(rad) * (w3 ? w3 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w3 ? w3 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
        ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
        ctx.moveTo(x2 + yOffsetW, y3 - xOffset);
        ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
        rad += QUARTER_PI;
        xOffsetW = Math.cos(rad) * (w3 ? w3 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w3 ? w3 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
        ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
        ctx.moveTo(x2 + yOffsetW, y3 - xOffset);
        ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
        break;
      case "line":
        xOffset = w3 ? w3 / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x2 - xOffset, y3 - yOffset);
        ctx.lineTo(x2 + xOffset, y3 + yOffset);
        break;
      case "dash":
        ctx.moveTo(x2, y3);
        ctx.lineTo(x2 + Math.cos(rad) * (w3 ? w3 / 2 : radius), y3 + Math.sin(rad) * radius);
        break;
      case false:
        ctx.closePath();
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x2, y3, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left = x2 - metrics.actualBoundingBoxLeft;
      const right = x2 + metrics.actualBoundingBoxRight;
      const top = y3 - metrics.actualBoundingBoxAscent;
      const bottom = y3 + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left, yDecoration);
      ctx.lineTo(right, yDecoration);
      ctx.stroke();
    }
  }
  function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
  }
  function renderText(ctx, text2, x2, y3, font, opts = {}) {
    const lines = isArray2(text2) ? text2 : [
      text2
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i2, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i2 = 0; i2 < lines.length; ++i2) {
      line = lines[i2];
      if (opts.backdrop) {
        drawBackdrop(ctx, opts.backdrop);
      }
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x2, y3, opts.maxWidth);
      }
      ctx.fillText(line, x2, y3, opts.maxWidth);
      decorateText(ctx, x2, y3, line, opts);
      y3 += Number(font.lineHeight);
    }
    ctx.restore();
  }
  function addRoundedRectPath(ctx, rect) {
    const { x: x2, y: y3, w: w3, h: h3, radius } = rect;
    ctx.arc(x2 + radius.topLeft, y3 + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    ctx.lineTo(x2, y3 + h3 - radius.bottomLeft);
    ctx.arc(x2 + radius.bottomLeft, y3 + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x2 + w3 - radius.bottomRight, y3 + h3);
    ctx.arc(x2 + w3 - radius.bottomRight, y3 + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x2 + w3, y3 + radius.topRight);
    ctx.arc(x2 + w3 - radius.topRight, y3 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x2 + radius.topLeft, y3);
  }
  var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function toLineHeight(value, size2) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
      return size2 * 1.2;
    }
    value = +matches[2];
    switch (matches[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size2 * value;
  }
  var numberOrZero = (v3) => +v3 || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject2(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size2 = valueOrDefault(options.size, fallback.size);
    if (typeof size2 === "string") {
      size2 = parseInt(size2, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = void 0;
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size2),
      size: size2,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index2, info) {
    let cacheable = true;
    let i2, ilen, value;
    for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
      value = inputs[i2];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index2 !== void 0 && isArray2(value)) {
        value = value[index2 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min, max } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add2) => beginAtZero && value === 0 ? 0 : value + add2;
    return {
      min: keepZero(min, -Math.abs(change)),
      max: keepZero(max, change)
    };
  }
  function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [
    ""
  ], rootScopes, fallback, getTarget2 = () => scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") {
      fallback = _resolve("_fallback", scopes);
    }
    const cache = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: finalRootScopes,
      _fallback: fallback,
      _getTarget: getTarget2,
      override: (scope2) => _createResolver([
        scope2,
        ...scopes
      ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget2());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope2) => _attachContext(proxy.override(scope2), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults2 = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix2, name) => prefix2 ? prefix2 + _capitalize(name) : name;
  var needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray2(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) {
      return value[_context.index % value.length];
    } else if (isObject2(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set4, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope2 = getScope(key, parent);
      if (scope2) {
        set4.add(scope2);
        const fallback = resolveFallback(scope2._fallback, key, value);
        if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope2 === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
      ...parentScopes,
      ...rootScopes
    ];
    const set4 = /* @__PURE__ */ new Set();
    set4.add(value);
    let key = addScopesFromKey(set4, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (typeof fallback !== "undefined" && fallback !== prop) {
      key = addScopesFromKey(set4, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set4), [
      ""
    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set4, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set4, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray2(target) && isObject2(value)) {
      return value;
    }
    return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix2 of prefixes) {
      value = _resolve(readKey(prefix2, prop), scopes);
      if (typeof value !== "undefined") {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope2 of scopes) {
      if (!scope2) {
        continue;
      }
      const value = scope2[key];
      if (typeof value !== "undefined") {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set4 = /* @__PURE__ */ new Set();
    for (const scope2 of scopes) {
      for (const key of Object.keys(scope2).filter((k2) => !k2.startsWith("_"))) {
        set4.add(key);
      }
    }
    return Array.from(set4);
  }
  function _parseObjectDataRadialScale(meta, data2, start3, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start3;
      item = data2[index2];
      parsed[i2] = {
        r: iScale.parse(resolveObjectKey(item, key), index2)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i2) => i2 < points.length && !points[i2].skip && points[i2];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t2 * s01;
    const fb = t2 * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i2], 0, EPSILON)) {
        mK[i2] = mK[i2 + 1] = 0;
        continue;
      }
      alphaK = mK[i2] / deltaK[i2];
      betaK = mK[i2 + 1] / deltaK[i2];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i2] = alphaK * tauK * deltaK[i2];
      mK[i2 + 1] = betaK * tauK * deltaK[i2];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i2 = 0; i2 < pointsLen; ++i2) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i2];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i2];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i2, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i2 = 0; i2 < pointsLen; ++i2) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign(deltaK[i2 - 1]) !== sign(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
  }
  function capBezierPoints(points, area) {
    let i2, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i2];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop2, indexAxis) {
    let i2, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop2 ? points[points.length - 1] : points[0];
      for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
        point = points[i2];
        controlPoints = splineCurve(prev, point, points[Math.min(i2 + 1, ilen - (loop2 ? 0 : 1)) % ilen], options.tension);
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle2(el).getPropertyValue(property);
  }
  var positions = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i2 = 0; i2 < 4; i2++) {
      const pos = positions[i2];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x2, y3, target) => (x2 > 0 || y3 > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e2, canvas) {
    const touches = e2.touches;
    const source = touches && touches.length ? touches[0] : e2;
    const { offsetX, offsetY } = source;
    let box = false;
    let x2, y3;
    if (useOffsetPos(offsetX, offsetY, e2.target)) {
      x2 = offsetX;
      y3 = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x2 = source.clientX - rect.left;
      y3 = source.clientY - rect.top;
      box = true;
    }
    return {
      x: x2,
      y: y3,
      box
    };
  }
  function getRelativePosition(event, chart) {
    if ("native" in event) {
      return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x: x2, y: y3, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x2 - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y3 - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = canvas && _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v3) => Math.round(v3 * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
      height = containerSize.height;
      width = round1(Math.floor(height * aspectRatio));
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = round1(chart.height * pixelRatio);
    const deviceWidth = round1(chart.width * pixelRatio);
    chart.height = round1(chart.height);
    chart.width = round1(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      if (_isDomSupported()) {
        window.addEventListener("test", null, options);
        window.removeEventListener("test", null, options);
      }
    } catch (e2) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
  }
  function _pointInLine(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: p1.y + t2 * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t2, mode) {
    const cp1 = {
      x: p1.cp2x,
      y: p1.cp2y
    };
    const cp2 = {
      x: p2.cp1x,
      y: p2.cp1y
    };
    const a2 = _pointInLine(p1, cp1, t2);
    const b3 = _pointInLine(cp1, cp2, t2);
    const c2 = _pointInLine(cp2, p2, t2);
    const d3 = _pointInLine(a2, b3, t2);
    const e2 = _pointInLine(b3, c2, t2);
    return _pointInLine(d3, e2, t2);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x2) {
        return rectX + rectX + width - x2;
      },
      setWidth(w3) {
        width = w3;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x2, value) {
        return x2 - value;
      },
      leftForLtr(x2, itemWidth) {
        return x2 - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x2) {
        return x2;
      },
      setWidth(w3) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x2, value) {
        return x2 + value;
      },
      leftForLtr(x2, _itemWidth) {
        return x2;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a2, b3) => a2 - b3,
      normalize: (x2) => x2
    };
  }
  function normalizeSegment({ start: start3, end, count, loop: loop2, style }) {
    return {
      start: start3 % count,
      end: end % count,
      loop: loop2 && (end - start3 + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start: start3, end, loop: loop2 } = segment;
    let i2, ilen;
    if (loop2) {
      start3 += count;
      end += count;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        if (!between(normalize(points[start3 % count][property]), startBound, endBound)) {
          break;
        }
        start3--;
        end--;
      }
      start3 %= count;
      end %= count;
    }
    if (end < start3) {
      end += count;
    }
    return {
      start: start3,
      end,
      loop: loop2,
      style: segment.style
    };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [
        segment
      ];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start: start3, end, loop: loop2, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i2 = start3, prev = start3; i2 <= end; ++i2) {
      point = points[i2 % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i2 : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({
          start: subStart,
          end: i2,
          loop: loop2,
          count,
          style
        }));
        subStart = null;
      }
      prev = i2;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({
        start: subStart,
        end,
        loop: loop2,
        count,
        style
      }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i2 = 0; i2 < segments.length; i2++) {
      const sub = _boundSegment(segments[i2], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop2, spanGaps) {
    let start3 = 0;
    let end = count - 1;
    if (loop2 && !spanGaps) {
      while (start3 < count && !points[start3].skip) {
        start3++;
      }
    }
    while (start3 < count && points[start3].skip) {
      start3++;
    }
    start3 %= count;
    if (loop2) {
      end += start3;
    }
    while (end > start3 && points[end % count].skip) {
      end--;
    }
    end %= count;
    return {
      start: start3,
      end
    };
  }
  function solidSegments(points, start3, max, loop2) {
    const count = points.length;
    const result = [];
    let last = start3;
    let prev = points[start3];
    let end;
    for (end = start3 + 1; end <= max; ++end) {
      const cur = points[end % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop2 = false;
          result.push({
            start: start3 % count,
            end: (end - 1) % count,
            loop: loop2
          });
          start3 = last = cur.stop ? end : null;
        }
      } else {
        last = end;
        if (prev.skip) {
          start3 = end;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({
        start: start3 % count,
        end: last % count,
        loop: loop2
      });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop2 = !!line._loop;
    const { start: start3, end } = findStartAndEnd(points, count, loop2, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [
        {
          start: start3,
          end,
          loop: loop2
        }
      ], points, segmentOptions);
    }
    const max = end < start3 ? end + count : end;
    const completeLoop = !!line._fullLoop && start3 === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start3, max, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start3 = segments[0].start;
    let i2 = start3;
    function addStyle(s2, e2, l4, st2) {
      const dir = spanGaps ? -1 : 1;
      if (s2 === e2) {
        return;
      }
      s2 += count;
      while (points[s2 % count].skip) {
        s2 -= dir;
      }
      while (points[e2 % count].skip) {
        e2 += dir;
      }
      if (s2 % count !== e2 % count) {
        result.push({
          start: s2 % count,
          end: e2 % count,
          loop: l4,
          style: st2
        });
        prevStyle = st2;
        start3 = e2 % count;
      }
    }
    for (const segment of segments) {
      start3 = spanGaps ? start3 : segment.start;
      let prev = points[start3 % count];
      let style;
      for (i2 = start3 + 1; i2 <= segment.end; i2++) {
        const pt = points[i2 % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt,
          p0DataIndex: (i2 - 1) % count,
          p1DataIndex: i2 % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start3, i2 - 1, segment.loop, prevStyle);
        }
        prev = pt;
        prevStyle = style;
      }
      if (start3 < i2 - 1) {
        addStyle(start3, i2 - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    if (!prevStyle) {
      return false;
    }
    const cache = [];
    const replacer = function(key, value) {
      if (!isPatternOrGradient(value)) {
        return value;
      }
      if (!cache.includes(value)) {
        cache.push(value);
      }
      return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
  }
  function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
  }
  function getDatasetArea(meta, chartArea) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
      return {
        left: getSizeForArea(xScale, chartArea, "left"),
        right: getSizeForArea(xScale, chartArea, "right"),
        top: getSizeForArea(yScale, chartArea, "top"),
        bottom: getSizeForArea(yScale, chartArea, "bottom")
      };
    }
    return chartArea;
  }
  function getDatasetClipArea(chart, meta) {
    const clip = meta._clip;
    if (clip.disabled) {
      return false;
    }
    const area = getDatasetArea(meta, chart.chartArea);
    return {
      left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
      right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),
      top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
      bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)
    };
  }

  // node_modules/chart.js/dist/chart.js
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn) => fn({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i2 = items.length - 1;
        let draw2 = false;
        let item;
        for (; i2 >= 0; --i2) {
          item = items[i2];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i2] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i2 = items.length - 1;
      for (; i2 >= 0; --i2) {
        items[i2].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = /* @__PURE__ */ new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from2, to2, factor) {
      return factor > 0.5 ? to2 : from2;
    },
    color(from2, to2, factor) {
      const c0 = color(from2 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from2, to2, factor) {
      return from2 + (to2 - from2) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      const from2 = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from2;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        this._from = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from2 = this._from;
      const loop2 = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from2 !== to2 && (loop2 || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from2;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop2 && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from2, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({
          res,
          rej
        });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i2 = 0; i2 < promises.length; i2++) {
        promises[i2][method]();
      }
    }
  };
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject2(config)) {
        return;
      }
      const animationOptions = Object.keys(defaults.animation);
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject2(cfg)) {
          return;
        }
        const resolved = {};
        for (const option of animationOptions) {
          resolved[option] = cfg[option];
        }
        (isArray2(cfg.properties) && cfg.properties || [
          key
        ]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i2;
      for (i2 = props.length - 1; i2 >= 0; --i2) {
        const prop = props[i2];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const anim = animations[keys[i2]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
      });
    }
    return options;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === void 0 ? allowedOverflow : 0;
    const max = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max : min,
      end: reverse ? min : max
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x2 = scaleClip(xScale, allowedOverflow);
    const y3 = scaleClip(yScale, allowedOverflow);
    return {
      top: y3.end,
      right: x2.end,
      bottom: y3.start,
      left: x2.start
    };
  }
  function toClip(value) {
    let t2, r2, b3, l4;
    if (isObject2(value)) {
      t2 = value.top;
      r2 = value.right;
      b3 = value.bottom;
      l4 = value.left;
    } else {
      t2 = r2 = b3 = l4 = value;
    }
    return {
      top: t2,
      right: r2,
      bottom: b3,
      left: l4,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      keys.push(metasets[i2].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i2, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    let found = false;
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
      datasetIndex = +keys[i2];
      if (datasetIndex === dsIndex) {
        found = true;
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
        value += otherValue;
      }
    }
    if (!found && !options.all) {
      return 0;
    }
    return value;
  }
  function convertObjectDataToArray(data2, meta) {
    const { iScale, vScale } = meta;
    const iAxisKey = iScale.axis === "x" ? "x" : "y";
    const vAxisKey = vScale.axis === "x" ? "x" : "y";
    const keys = Object.keys(data2);
    const adata = new Array(keys.length);
    let i2, ilen, key;
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
      key = keys[i2];
      adata[i2] = {
        [iAxisKey]: key,
        [vAxisKey]: data2[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min, max, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i2 = 0; i2 < ilen; ++i2) {
      const item = parsed[i2];
      const { [iAxis]: index2, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      const visualValues = stack._visualValues || (stack._visualValues = {});
      visualValues[datasetIndex] = value;
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index2) {
    return createContext(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index2,
      index: index2,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index2, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index2,
      parsed: void 0,
      raw: void 0,
      element,
      index: index2,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
      if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
        delete stacks[axis]._visualValues[datasetIndex];
      }
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
    keys: getSortedDatasetIndices(chart, true),
    values: null
  };
  var DatasetController = class {
    static defaults = {};
    static datasetElementType = null;
    static dataElementType = null;
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.datasetElementType = new.target.datasetElementType;
      this.dataElementType = new.target.dataElementType;
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
      if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
        console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x2, y3, r2) => axis === "x" ? x2 : axis === "r" ? r2 : y3;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta = this._cachedMeta;
      return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data2 = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject2(data2)) {
        const meta = this._cachedMeta;
        this._data = convertObjectDataToArray(data2, meta);
      } else if (_data !== data2) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data2 && Object.isExtensible(data2)) {
          listenArrayEvents(data2, this);
        }
        this._syncList = [];
        this._data = data2;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
        meta._stacked = isStacked(meta.vScale, meta);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start3, count) {
      const { _cachedMeta: meta, _data: data2 } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start3 === 0 && count === data2.length ? true : meta._sorted;
      let prev = start3 > 0 && meta._parsed[start3 - 1];
      let i2, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data2;
        meta._sorted = true;
        parsed = data2;
      } else {
        if (isArray2(data2[start3])) {
          parsed = this.parseArrayData(meta, data2, start3, count);
        } else if (isObject2(data2[start3])) {
          parsed = this.parseObjectData(meta, data2, start3, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data2, start3, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i2 = 0; i2 < count; ++i2) {
          meta._parsed[i2 + start3] = cur = parsed[i2];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data2, start3, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i2, ilen, index2;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        index2 = i2 + start3;
        parsed[i2] = {
          [iAxis]: singleScale || iScale.parse(labels[index2], index2),
          [vAxis]: vScale.parse(data2[index2], index2)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data2, start3, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i2, ilen, index2, item;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        index2 = i2 + start3;
        item = data2[index2];
        parsed[i2] = {
          x: xScale.parse(item[0], index2),
          y: yScale.parse(item[1], index2)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data2, start3, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i2, ilen, index2, item;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        index2 = i2 + start3;
        item = data2[index2];
        parsed[i2] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
        };
      }
      return parsed;
    }
    getParsed(index2) {
      return this._cachedMeta._parsed[index2];
    }
    getDataElement(index2) {
      return this._cachedMeta.data[index2];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]._visualValues
      };
      return applyStack(stack, value, meta.index, {
        mode
      });
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range2.min = Math.min(range2.min, value);
      range2.max = Math.max(range2.max, value);
    }
    getMinMax(scale, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta, this.chart);
      const range2 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i2, parsed;
      function _skip() {
        parsed = _parsed[i2];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i2 = 0; i2 < ilen; ++i2) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i2 = ilen - 1; i2 >= 0; --i2) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range2, scale, parsed, stack);
          break;
        }
      }
      return range2;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i2, ilen, value;
      for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
        value = parsed[i2][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements2 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start3 = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start3;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i2;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start3, count);
      }
      for (i2 = start3; i2 < start3 + count; ++i2) {
        const element = elements2[i2];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i2 = 0; i2 < active.length; ++i2) {
        active[i2].draw(ctx, area);
      }
    }
    getStyle(index2, active) {
      const mode = active ? "active" : "default";
      return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
    }
    getContext(index2, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index2];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
        context.parsed = this.getParsed(index2);
        context.raw = dataset.data[index2];
        context.index = context.dataIndex = index2;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index2, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index2);
    }
    _resolveElementOptions(elementType, mode = "default", index2) {
      const active = mode === "active";
      const cache = this._cachedDataOpts;
      const cacheKey = elementType + "-" + mode;
      const cached = cache[cacheKey];
      const sharing = this.enableOptionSharing && defined(index2);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
      const prefixes = active ? [
        `${elementType}Hover`,
        "hover",
        elementType,
        ""
      ] : [
        elementType,
        ""
      ];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType]);
      const context = () => this.getContext(index2, active, mode);
      const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index2, transition2, active) {
      const chart = this.chart;
      const cache = this._cachedDataOpts;
      const cacheKey = `animation-${transition2}`;
      const cached = cache[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition2);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index2, active, transition2));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start3, mode) {
      const firstOpts = this.resolveDataElementOptions(start3, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return {
        sharedOptions,
        includeOptions
      };
    }
    updateElement(element, index2, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index2, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index2, mode, active) {
      element.active = active;
      const options = this.getStyle(index2, active);
      this._resolveAnimations(index2, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", false);
    }
    setHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data2 = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data2.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start3, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data2 = meta.data;
      const end = start3 + count;
      let i2;
      const move = (arr) => {
        arr.length += count;
        for (i2 = arr.length - 1; i2 >= end; i2--) {
          arr[i2] = arr[i2 - count];
        }
      };
      move(data2);
      for (i2 = start3; i2 < end; ++i2) {
        data2[i2] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start3, count);
      if (resetNewElements) {
        this.updateElements(data2, start3, count, "reset");
      }
    }
    updateElements(element, start3, count, mode) {
    }
    _removeElements(start3, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start3, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start3, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([
        this.index,
        ...args
      ]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - count,
        count
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(start3, count) {
      if (count) {
        this._sync([
          "_removeElements",
          start3,
          count
        ]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync([
          "_insertElements",
          start3,
          newCount
        ]);
      }
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  };
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
        values = values.concat(visibleMetas[i2].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a2, b3) => a2 - b3));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i2, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min = Math.min(min, Math.abs(curr - prev) || min);
      }
      prev = curr;
    };
    for (i2 = 0, ilen = values.length; i2 < ilen; ++i2) {
      curr = scale.getPixelForValue(values[i2]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i2 = 0, ilen = scale.ticks.length; i2 < ilen; ++i2) {
      curr = scale.getPixelForTick(i2);
      updateMinAndPrev();
    }
    return min;
  }
  function computeFitCategoryTraits(index2, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size2, ratio;
    if (isNullOrUndef(thickness)) {
      size2 = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size2 = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size2 / stackCount,
      ratio,
      start: ruler.pixels[index2] - size2 / 2
    };
  }
  function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index2];
    let prev = index2 > 0 ? pixels[index2 - 1] : null;
    let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start3 = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size2 = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size2 / stackCount,
      ratio: options.barPercentage,
      start: start3
    };
  }
  function parseFloatBar(entry, item, vScale, i2) {
    const startValue = vScale.parse(entry[0], i2);
    const endValue = vScale.parse(entry[1], i2);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
      barStart = max;
      barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min,
      max
    };
  }
  function parseValue(entry, item, vScale, i2) {
    if (isArray2(entry)) {
      parseFloatBar(entry, item, vScale, i2);
    } else {
      item[vScale.axis] = vScale.parse(entry, i2);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data2, start3, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i2, ilen, item, entry;
    for (i2 = start3, ilen = start3 + count; i2 < ilen; ++i2) {
      entry = data2[i2];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i2], i2);
      parsed.push(parseValue(entry, item, vScale, i2));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size2, vScale, actualBase) {
    if (size2 !== 0) {
      return sign(size2);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start3, end, top, bottom;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start3 = "left";
      end = "right";
    } else {
      reverse = properties.base < properties.y;
      start3 = "bottom";
      end = "top";
    }
    if (reverse) {
      top = "end";
      bottom = "start";
    } else {
      top = "start";
      bottom = "end";
    }
    return {
      start: start3,
      end,
      reverse,
      top,
      bottom
    };
  }
  function setBorderSkipped(properties, options, stack, index2) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start: start3, end, reverse, top, bottom } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index2) {
        edge = top;
      } else if ((stack._bottom || 0) === index2) {
        edge = bottom;
      } else {
        res[parseEdge(bottom, start3, end, reverse)] = true;
        edge = top;
      }
    }
    res[parseEdge(edge, start3, end, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a2, b3, reverse) {
    if (reverse) {
      edge = swap(edge, a2, b3);
      edge = startEnd(edge, b3, a2);
    } else {
      edge = startEnd(edge, a2, b3);
    }
    return edge;
  }
  function swap(orig, v1, v22) {
    return orig === v1 ? v22 : orig === v22 ? v1 : orig;
  }
  function startEnd(v3, start3, end) {
    return v3 === "start" ? start3 : v3 === "end" ? end : v3;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    static id = "bar";
    static defaults = {
      datasetElementType: false,
      dataElementType: "bar",
      categoryPercentage: 0.8,
      barPercentage: 0.9,
      grouped: true,
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "base",
            "width",
            "height"
          ]
        }
      }
    };
    static overrides = {
      scales: {
        _index_: {
          type: "category",
          offset: true,
          grid: {
            offset: true
          }
        },
        _value_: {
          type: "linear",
          beginAtZero: true
        }
      }
    };
    parsePrimitiveData(meta, data2, start3, count) {
      return parseArrayOrPrimitive(meta, data2, start3, count);
    }
    parseArrayData(meta, data2, start3, count) {
      return parseArrayOrPrimitive(meta, data2, start3, count);
    }
    parseObjectData(meta, data2, start3, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i2, ilen, item, obj;
      for (i2 = start3, ilen = start3 + count; i2 < ilen; ++i2) {
        obj = data2[i2];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
      }
      return parsed;
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      super.updateRangeFromParsed(range2, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range2.min = Math.min(range2.min, custom.min);
        range2.max = Math.max(range2.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start3, count, mode) {
      const reset = mode === "reset";
      const { index: index2, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      for (let i2 = start3; i2 < start3 + count; i2++) {
        const parsed = this.getParsed(i2);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
          base,
          head: base
        } : this._calculateBarValuePixels(i2);
        const ipixels = this._calculateBarIndexPixels(i2, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
        }
        const options = properties.options || bars[i2].options;
        setBorderSkipped(properties, options, stack, index2);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i2], i2, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
      const iScaleValue = currentParsed && currentParsed[iScale.axis];
      const skipNull = (meta) => {
        const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index2) {
      return this._getStacks(void 0, index2).length;
    }
    _getAxisCount() {
      return this._getAxis().length;
    }
    getFirstScaleIdForIndexAxis() {
      const scales2 = this.chart.scales;
      const indexScaleId = this.chart.options.indexAxis;
      return Object.keys(scales2).filter((key) => scales2[key].axis === indexScaleId).shift();
    }
    _getAxis() {
      const axis = {};
      const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();
      for (const dataset of this.chart.data.datasets) {
        axis[valueOrDefault(this.chart.options.indexAxis === "x" ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;
      }
      return Object.keys(axis);
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
      return index2 === -1 ? stacks.length - 1 : index2;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i2, ilen;
      for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
      }
      const barThickness = opts.barThickness;
      const min = barThickness || computeMinSampleSize(meta);
      return {
        min,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index2) {
      const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start3 = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size2;
      if (length !== value) {
        start3 = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start3 = 0;
        }
        start3 += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start3;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index2)) {
        head = vScale.getPixelForValue(start3 + length);
      } else {
        head = base;
      }
      size2 = head - base;
      if (Math.abs(size2) < minBarLength) {
        size2 = barSign(size2, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size2 / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min = Math.min(startPixel, endPixel);
        const max = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max), min);
        head = base + size2;
        if (_stacked && !floating) {
          parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
        }
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size2) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size2 -= halfGrid;
      }
      return {
        size: size2,
        base,
        head,
        center: head + size2 / 2
      };
    }
    _calculateBarIndexPixels(index2, ruler) {
      const scale = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size2;
      const axisCount = this._getAxisCount();
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
        const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index2, ruler, options, stackCount * axisCount);
        const axisID = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID;
        const axisNumber = this._getAxis().indexOf(valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0) + axisNumber;
        center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
        size2 = Math.min(maxBarThickness, range2.chunk * range2.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
        size2 = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size2 / 2,
        head: center + size2 / 2,
        center,
        size: size2
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i2 = 0;
      for (; i2 < ilen; ++i2) {
        if (this.getParsed(i2)[vScale.axis] !== null && !rects[i2].hidden) {
          rects[i2].draw(this._ctx);
        }
      }
    }
  };
  var BubbleController = class extends DatasetController {
    static id = "bubble";
    static defaults = {
      datasetElementType: false,
      dataElementType: "point",
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "borderWidth",
            "radius"
          ]
        }
      }
    };
    static overrides = {
      scales: {
        x: {
          type: "linear"
        },
        y: {
          type: "linear"
        }
      }
    };
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data2, start3, count) {
      const parsed = super.parsePrimitiveData(meta, data2, start3, count);
      for (let i2 = 0; i2 < parsed.length; i2++) {
        parsed[i2]._custom = this.resolveDataElementOptions(i2 + start3).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data2, start3, count) {
      const parsed = super.parseArrayData(meta, data2, start3, count);
      for (let i2 = 0; i2 < parsed.length; i2++) {
        const item = data2[start3 + i2];
        parsed[i2]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i2 + start3).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data2, start3, count) {
      const parsed = super.parseObjectData(meta, data2, start3, count);
      for (let i2 = 0; i2 < parsed.length; i2++) {
        const item = data2[start3 + i2];
        parsed[i2]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i2 + start3).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data2 = this._cachedMeta.data;
      let max = 0;
      for (let i2 = data2.length - 1; i2 >= 0; --i2) {
        max = Math.max(max, data2[i2].size(this.resolveDataElementOptions(i2)) / 2);
      }
      return max > 0 && max;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x2 = xScale.getLabelForValue(parsed.x);
      const y3 = yScale.getLabelForValue(parsed.y);
      const r2 = parsed._custom;
      return {
        label: labels[index2] || "",
        value: "(" + x2 + ", " + y3 + (r2 ? ", " + r2 : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start3, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i2 = start3; i2 < start3 + count; i2++) {
        const point = points[i2];
        const parsed = !reset && this.getParsed(i2);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i2, properties, mode);
      }
    }
    resolveDataElementOptions(index2, mode) {
      const parsed = this.getParsed(index2);
      let values = super.resolveDataElementOptions(index2, mode);
      if (values.$shared) {
        values = Object.assign({}, values, {
          $shared: false
        });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a2, b3) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a2, a2 * cutout, b3, b3 * cutout);
      const calcMin = (angle, a2, b3) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a2, a2 * cutout, b3, b3 * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    };
  }
  var DoughnutController = class extends DatasetController {
    static id = "doughnut";
    static defaults = {
      datasetElementType: false,
      dataElementType: "arc",
      animation: {
        animateRotate: true,
        animateScale: false
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "circumference",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "startAngle",
            "x",
            "y",
            "offset",
            "borderWidth",
            "spacing"
          ]
        }
      },
      cutout: "50%",
      rotation: 0,
      circumference: 360,
      radius: "100%",
      spacing: 0,
      indexAxis: "r"
    };
    static descriptors = {
      _scriptable: (name) => name !== "spacing",
      _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
    };
    static overrides = {
      aspectRatio: 1,
      plugins: {
        legend: {
          labels: {
            generateLabels(chart) {
              const data2 = chart.data;
              const { labels: { pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
              if (data2.labels.length && data2.datasets.length) {
                return data2.labels.map((label, i2) => {
                  const meta = chart.getDatasetMeta(0);
                  const style = meta.controller.getStyle(i2);
                  return {
                    text: label,
                    fillStyle: style.backgroundColor,
                    fontColor: color2,
                    hidden: !chart.getDataVisibility(i2),
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: style.borderWidth,
                    strokeStyle: style.borderColor,
                    textAlign,
                    pointStyle,
                    borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                    index: i2
                  };
                });
              }
              return [];
            }
          },
          onClick(e2, legendItem, legend) {
            legend.chart.toggleDataVisibility(legendItem.index);
            legend.chart.update();
          }
        }
      }
    };
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start3, count) {
      const data2 = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data2;
      } else {
        let getter = (i3) => +data2[i3];
        if (isObject2(data2[start3])) {
          const { key = "value" } = this._parsing;
          getter = (i3) => +resolveObjectKey(data2[i3], key);
        }
        let i2, ilen;
        for (i2 = start3, ilen = start3 + count; i2 < ilen; ++i2) {
          meta._parsed[i2] = getter(i2);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min = TAU;
      let max = -TAU;
      for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
        if (this.chart.isDatasetVisible(i2) && this.chart.getDatasetMeta(i2).type === this._type) {
          const controller = this.chart.getDatasetMeta(i2).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min = Math.min(min, rotation);
          max = Math.max(max, rotation + circumference);
        }
      }
      return {
        rotation: min,
        circumference: max - min
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i2, reset) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i2) || meta._parsed[i2] === null || meta.data[i2].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i2] * circumference / TAU);
    }
    updateElements(arcs, start3, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      let startAngle = this._getRotation();
      let i2;
      for (i2 = 0; i2 < start3; ++i2) {
        startAngle += this._circumference(i2, reset);
      }
      for (i2 = start3; i2 < start3 + count; ++i2) {
        const circumference = this._circumference(i2, reset);
        const arc = arcs[i2];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i2, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i2;
      for (i2 = 0; i2 < metaData.length; i2++) {
        const value = meta._parsed[i2];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i2) && !metaData[i2].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2], chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max = 0;
      const chart = this.chart;
      let i2, ilen, meta, controller, options;
      if (!arcs) {
        for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
          if (chart.isDatasetVisible(i2)) {
            meta = chart.getDatasetMeta(i2);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
        options = controller.resolveDataElementOptions(i2);
        if (options.borderAlign !== "inner") {
          max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max;
    }
    getMaxOffset(arcs) {
      let max = 0;
      for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
        const options = this.resolveDataElementOptions(i2);
        max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
      }
      return max;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i2 = 0; i2 < datasetIndex; ++i2) {
        if (this.chart.isDatasetVisible(i2)) {
          ringWeightOffset += this._getRingWeight(i2);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  var LineController = class extends DatasetController {
    static id = "line";
    static defaults = {
      datasetElementType: "line",
      dataElementType: "point",
      showLine: true,
      spanGaps: false
    };
    static overrides = {
      scales: {
        _index_: {
          type: "category"
        },
        _value_: {
          type: "linear"
        }
      }
    };
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start3, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start3;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start3 = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start3, count, mode);
    }
    updateElements(points, start3, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      const end = start3 + count;
      const pointsCount = points.length;
      let prevParsed = start3 > 0 && this.getParsed(start3 - 1);
      for (let i2 = 0; i2 < pointsCount; ++i2) {
        const point = points[i2];
        const properties = directUpdate ? point : {};
        if (i2 < start3 || i2 >= end) {
          properties.skip = true;
          continue;
        }
        const parsed = this.getParsed(i2);
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i2];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i2, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data2 = meta.data || [];
      if (!data2.length) {
        return border;
      }
      const firstPoint = data2[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data2[data2.length - 1].size(this.resolveDataElementOptions(data2.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  var PolarAreaController = class extends DatasetController {
    static id = "polarArea";
    static defaults = {
      dataElementType: "arc",
      animation: {
        animateRotate: true,
        animateScale: true
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius"
          ]
        }
      },
      indexAxis: "r",
      startAngle: 0
    };
    static overrides = {
      aspectRatio: 1,
      plugins: {
        legend: {
          labels: {
            generateLabels(chart) {
              const data2 = chart.data;
              if (data2.labels.length && data2.datasets.length) {
                const { labels: { pointStyle, color: color2 } } = chart.legend.options;
                return data2.labels.map((label, i2) => {
                  const meta = chart.getDatasetMeta(0);
                  const style = meta.controller.getStyle(i2);
                  return {
                    text: label,
                    fillStyle: style.backgroundColor,
                    strokeStyle: style.borderColor,
                    fontColor: color2,
                    lineWidth: style.borderWidth,
                    pointStyle,
                    hidden: !chart.getDataVisibility(i2),
                    index: i2
                  };
                });
              }
              return [];
            }
          },
          onClick(e2, legendItem, legend) {
            legend.chart.toggleDataVisibility(legendItem.index);
            legend.chart.update();
          }
        }
      },
      scales: {
        r: {
          type: "radialLinear",
          angleLines: {
            display: false
          },
          beginAtZero: true,
          grid: {
            circular: true
          },
          pointLabels: {
            display: false
          },
          startAngle: 0
        }
      }
    };
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    parseObjectData(meta, data2, start3, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data2, start3, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range2 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      meta.data.forEach((element, index2) => {
        const parsed = this.getParsed(index2).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
          if (parsed < range2.min) {
            range2.min = parsed;
          }
          if (parsed > range2.max) {
            range2.max = parsed;
          }
        }
      });
      return range2;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start3, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale = this._cachedMeta.rScale;
      const centerX = scale.xCenter;
      const centerY = scale.yCenter;
      const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i2;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i2 = 0; i2 < start3; ++i2) {
        angle += this._computeAngle(i2, mode, defaultAngle);
      }
      for (i2 = start3; i2 < start3 + count; i2++) {
        const arc = arcs[i2];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i2, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i2) ? scale.getDistanceFromCenterForValue(this.getParsed(i2).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i2, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i2, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index2) => {
        if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index2, mode, defaultAngle) {
      return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
    }
  };
  var PieController = class extends DoughnutController {
    static id = "pie";
    static defaults = {
      cutout: 0,
      rotation: 0,
      circumference: 360,
      radius: "100%"
    };
  };
  var RadarController = class extends DatasetController {
    static id = "radar";
    static defaults = {
      datasetElementType: "line",
      dataElementType: "point",
      indexAxis: "r",
      showLine: true,
      elements: {
        line: {
          fill: "start"
        }
      }
    };
    static overrides = {
      aspectRatio: 1,
      scales: {
        r: {
          type: "radialLinear"
        }
      }
    };
    getLabelAndValue(index2) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: vScale.getLabels()[index2],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data2, start3, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data2, start3, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start3, count, mode) {
      const scale = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i2 = start3; i2 < start3 + count; i2++) {
        const point = points[i2];
        const options = this.resolveDataElementOptions(i2, point.active ? "active" : mode);
        const pointPosition = scale.getPointPositionForValue(i2, this.getParsed(i2).r);
        const x2 = reset ? scale.xCenter : pointPosition.x;
        const y3 = reset ? scale.yCenter : pointPosition.y;
        const properties = {
          x: x2,
          y: y3,
          angle: pointPosition.angle,
          skip: isNaN(x2) || isNaN(y3),
          options
        };
        this.updateElement(point, i2, properties, mode);
      }
    }
  };
  var ScatterController = class extends DatasetController {
    static id = "scatter";
    static defaults = {
      datasetElementType: false,
      dataElementType: "point",
      showLine: false,
      fill: false
    };
    static overrides = {
      interaction: {
        mode: "point"
      },
      scales: {
        x: {
          type: "linear"
        },
        y: {
          type: "linear"
        }
      }
    };
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x2 = xScale.getLabelForValue(parsed.x);
      const y3 = yScale.getLabelForValue(parsed.y);
      return {
        label: labels[index2] || "",
        value: "(" + x2 + ", " + y3 + ")"
      };
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start3, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start3;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start3 = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        if (!this.datasetElementType) {
          this.addElements();
        }
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      } else if (this.datasetElementType) {
        delete meta.dataset;
        this.datasetElementType = false;
      }
      this.updateElements(points, start3, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = this.chart.registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start3, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start3, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start3 > 0 && this.getParsed(start3 - 1);
      for (let i2 = start3; i2 < start3 + count; ++i2) {
        const point = points[i2];
        const parsed = this.getParsed(i2);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i2];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i2, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data2 = meta.data || [];
      if (!this.options.showLine) {
        let max = 0;
        for (let i2 = data2.length - 1; i2 >= 0; --i2) {
          max = Math.max(max, data2[i2].size(this.resolveDataElementOptions(i2)) / 2);
        }
        return max > 0 && max;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data2.length) {
        return border;
      }
      const firstPoint = data2[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data2[data2.length - 1].size(this.resolveDataElementOptions(data2.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PieController,
    PolarAreaController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapterBase = class _DateAdapterBase {
    /**
    * Override default date adapter methods.
    * Accepts type parameter to define options type.
    * @example
    * Chart._adapters._date.override<{myAdapterOption: string}>({
    *   init() {
    *     console.log(this.options.myAdapterOption);
    *   }
    * })
    */
    static override(members) {
      Object.assign(_DateAdapterBase.prototype, members);
    }
    options;
    constructor(options) {
      this.options = options || {};
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
    }
    formats() {
      return abstract();
    }
    parse() {
      return abstract();
    }
    format() {
      return abstract();
    }
    add() {
      return abstract();
    }
    diff() {
      return abstract();
    }
    startOf() {
      return abstract();
    }
    endOf() {
      return abstract();
    }
  };
  var adapters = {
    _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data: data2, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data2.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        const result = lookupMethod(data2, axis, value);
        if (spanGaps) {
          const { vScale } = controller._cachedMeta;
          const { _parsed } = metaset;
          const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          result.lo -= Math.max(0, distanceToDefinedLo);
          const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          result.hi += Math.max(0, distanceToDefinedHi);
        }
        return result;
      } else if (controller._sharedOptions) {
        const el = data2[0];
        const range2 = typeof el.getRange === "function" && el.getRange(axis);
        if (range2) {
          const start3 = lookupMethod(data2, axis, value - range2);
          const end = lookupMethod(data2, axis, value + range2);
          return {
            lo: start3.lo,
            hi: end.hi
          };
        }
      }
    }
    return {
      lo: 0,
      hi: data2.length - 1
    };
  }
  function evaluateInteractionItems(chart, axis, position, handler4, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const { index: index2, data: data2 } = metasets[i2];
      const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
      for (let j2 = lo; j2 <= hi; ++j2) {
        const element = data2[j2];
        if (!element.skip) {
          handler4(element, index2, j2);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index2) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index2) {
      const { startAngle, endAngle } = element.getProps([
        "startAngle",
        "endAngle"
      ], useFinalPosition);
      const { angle } = getAngleFromPoint(element, {
        x: position.x,
        y: position.y
      });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index2) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [
          {
            element,
            datasetIndex,
            index: index2
          }
        ];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
      if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index2 = items[0].index;
          const element = meta.data[index2];
          if (element && !element.skip) {
            elements2.push({
              element,
              datasetIndex: meta.index,
              index: index2
            });
          }
        });
        return elements2;
      },
      dataset(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data2 = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i2 = 0; i2 < data2.length; ++i2) {
            items.push({
              element: data2[i2],
              datasetIndex,
              index: i2
            });
          }
        }
        return items;
      },
      point(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function filterByPosition(array, position) {
    return array.filter((v3) => v3.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v3) => STATIC_POSITIONS.indexOf(v3.pos) === -1 && v3.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a2, b3) => {
      const v0 = reverse ? b3 : a2;
      const v1 = reverse ? a2 : b3;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i2, ilen, box, pos, stack, stackWeight;
    for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
      box = boxes[i2];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i2,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i2, ilen, layout;
    for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
      layout = layouts2[i2];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left.concat(top),
      rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left.concat(right).concat(centerVertical),
      horizontal: top.concat(bottom).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a2, b3) {
    return Math.max(maxPadding[a2], chartArea[a2]) + Math.max(maxPadding[b3], chartArea[b3]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject2(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || {
        size: 0,
        count: 1
      };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
      same: widthChanged,
      other: heightChanged
    } : {
      same: heightChanged,
      other: widthChanged
    };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions([
      "left",
      "right"
    ]) : marginForPositions([
      "top",
      "bottom"
    ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i2, ilen, layout, box, refit, changed;
    for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
      layout = boxes[i2];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x: x2, y: y3 } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y3 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y3, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y3, width, height);
        }
        stack.start = y3;
        stack.placed += width;
        y3 = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x2 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x2, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x2, chartArea.top + stack.placed, width, height);
        }
        stack.start = x2;
        stack.placed += height;
        x2 = box.right;
      }
    }
    chartArea.x = x2;
    chartArea.y = y3;
  }
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [
          {
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }
        ];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index2 !== -1) {
        chart.boxes.splice(index2, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener(node, type, listener) {
    if (node) {
      node.addEventListener(type, listener, eventListenerOptions);
    }
  }
  function removeListener(chart, type, listener) {
    if (chart && chart.canvas) {
      chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x: x2, y: y3 } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x2 !== void 0 ? x2 : null,
      y: y3 !== void 0 ? y3 : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer2 = new MutationObserver((entries2) => {
      let trigger2 = false;
      for (const entry of entries2) {
        trigger2 = trigger2 || nodeListContains(entry.addedNodes, canvas);
        trigger2 = trigger2 && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger2) {
        listener();
      }
    });
    observer2.observe(document, {
      childList: true,
      subtree: true
    });
    return observer2;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer2 = new MutationObserver((entries2) => {
      let trigger2 = false;
      for (const entry of entries2) {
        trigger2 = trigger2 || nodeListContains(entry.removedNodes, canvas);
        trigger2 = trigger2 && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger2) {
        listener();
      }
    });
    observer2.observe(document, {
      childList: true,
      subtree: true
    });
    return observer2;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w3 = container.clientWidth;
      listener(width, height);
      if (w3 < container.clientWidth) {
        listener();
      }
    }, window);
    const observer2 = new ResizeObserver((entries2) => {
      const entry = entries2[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer2.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer2;
  }
  function releaseObserver(chart, type, observer2) {
    if (observer2) {
      observer2.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      [
        "height",
        "width"
      ].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler4 = handlers[type] || createProxyAndListen;
      proxies[type] = handler4(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler4 = handlers[type] || removeListener;
      handler4(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = canvas && _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var Element2 = class {
    static defaults = {};
    static defaultRoutes = void 0;
    x;
    y;
    active = false;
    options;
    $animations;
    tooltipPosition(useFinalPosition) {
      const { x: x2, y: y3 } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x: x2,
        y: y3
      };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i2, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
        skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
      const factor = factors[i2];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      if (ticks[i2].major) {
        result.push(i2);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i2;
    spacing = Math.ceil(spacing);
    for (i2 = 0; i2 < ticks.length; i2++) {
      if (i2 === next) {
        newTicks.push(ticks[i2]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start3 = valueOrDefault(majorStart, 0);
    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i2, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start3;
    while (next < 0) {
      count++;
      next = Math.round(start3 + count * spacing);
    }
    for (i2 = Math.max(start3, 0); i2 < end; i2++) {
      if (i2 === next) {
        newTicks.push(ticks[i2]);
        count++;
        next = Math.round(start3 + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i2, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
      if (arr[i2] - arr[i2 - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
  var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i2 = 0;
    for (; i2 < len; i2 += increment) {
      result.push(arr[Math.floor(i2)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index2, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index2, length - 1);
    const start3 = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset;
    if (offsetGridLines) {
      if (length === 1) {
        offset = Math.max(lineValue - start3, end - lineValue);
      } else if (index2 === 0) {
        offset = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index2 ? offset : -offset;
      if (lineValue < start3 - epsilon || lineValue > end + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache) => {
      const gc = cache.gc;
      const gcLen = gc.length / 2;
      let i2;
      if (gcLen > length) {
        for (i2 = 0; i2 < gcLen; ++i2) {
          delete cache.data[gc[i2]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray2(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index2, tick) {
    return createContext(parent, {
      tick,
      index: index2,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset, position, align) {
    const { top, left, bottom, right, chart } = scale;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
      } else {
        titleY = offsetFromEdge(scale, position, offset);
      }
      maxWidth = right - left;
    } else {
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
      } else {
        titleX = offsetFromEdge(scale, position, offset);
      }
      titleY = _alignStartEnd(align, bottom, top);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  var Scale = class _Scale extends Element2 {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw2, index2) {
      return raw2;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      let range2;
      if (minDefined && maxDefined) {
        return {
          min,
          max
        };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
        range2 = metas[i2].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min = Math.min(min, range2.min);
        }
        if (!maxDefined) {
          max = Math.max(max, range2.max);
        }
      }
      min = maxDefined && min > max ? max : min;
      max = minDefined && min > max ? min : max;
      return {
        min: finiteOrDefault(min, finiteOrDefault(max, min)),
        max: finiteOrDefault(max, finiteOrDefault(min, max))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data2 = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data2.xLabels : data2.yLabels) || data2.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      return items;
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [
        this
      ]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(name) {
      this.chart.notifyPlugins(name, this.getContext());
      callback(this.options[name], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i2, ilen, tick;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
        tick = ticks[i2];
        tick.label = callback(tickOpts.callback, [
          tick.value,
          i2,
          ticks
        ], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i2, ilen;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
        if (isNullOrUndef(ticks[i2].label)) {
          ticks.splice(i2, 1);
          ilen--;
          i2--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i2, j2, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
      for (i2 = 0; i2 < length; i2 += increment) {
        label = ticks[i2].label;
        tickFont = this._resolveTickFontOptions(i2);
        ctx.font = fontString = tickFont.string;
        cache = caches[fontString] = caches[fontString] || {
          data: {},
          gc: []
        };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray2(label)) {
          width = _measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray2(label)) {
          for (j2 = 0, jlen = label.length; j2 < jlen; ++j2) {
            nestedLabel = label[j2];
            if (!isNullOrUndef(nestedLabel) && !isArray2(nestedLabel)) {
              width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({
        width: widths[idx] || 0,
        height: heights[idx] || 0
      });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index2) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min, max } = this;
      return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
    getContext(index2) {
      const ticks = this.ticks || [];
      if (index2 >= 0 && index2 < ticks.length) {
        const tick = ticks[index2];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w3 = labelSizes ? labelSizes.widest.width + padding : 0;
      const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h3 * cos > w3 * sin ? w3 / cos : h3 / sin : h3 * sin < w3 * cos ? h3 / cos : w3 / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position, border } = options;
      const offset = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = borderOpts.display ? borderOpts.width : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i2, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y22;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y22 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y22 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y22 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i2 = 0; i2 < ticksLength; i2 += step) {
        const context = this.getContext(i2);
        const optsAtIndex = grid.setContext(context);
        const optsAtIndexBorder = border.setContext(context);
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndexBorder.dash || [];
        const borderDashOffset = optsAtIndexBorder.dashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i2, offset);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y22 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2: y22,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i2, ilen, tick, label, x2, y3, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y3 = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y3 = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x2 = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x2 = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y3 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y3 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x2 = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
        tick = ticks[i2];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i2));
        pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i2);
        lineHeight = font.lineHeight;
        lineCount = isArray2(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x2 = pixel;
          if (textAlign === "inner") {
            if (i2 === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i2 === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
          if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
            x2 += lineHeight / 2 * Math.sin(rotation);
          }
        } else {
          y3 = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i2];
          const width = labelSizes.widths[i2];
          let top = textOffset - labelPadding.top;
          let left = 0 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top -= height / 2;
              break;
            case "bottom":
              top -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left -= width / 2;
              break;
            case "right":
              left -= width;
              break;
            case "inner":
              if (i2 === ilen - 1) {
                left -= width;
              } else if (i2 > 0) {
                left -= width / 2;
              }
              break;
          }
          backdrop = {
            left,
            top,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          label,
          font,
          textOffset,
          options: {
            rotation,
            color: color2,
            strokeColor,
            strokeWidth,
            textAlign: tickTextAlign,
            textBaseline,
            translation: [
              x2,
              y3
            ],
            backdrop
          }
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x2;
      if (position === "left") {
        if (mirror) {
          x2 = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 += widest / 2;
          } else {
            textAlign = "right";
            x2 += widest;
          }
        } else {
          x2 = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 -= widest / 2;
          } else {
            textAlign = "left";
            x2 = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x2 = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 -= widest / 2;
          } else {
            textAlign = "left";
            x2 -= widest;
          }
        } else {
          x2 = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 += widest / 2;
          } else {
            textAlign = "right";
            x2 = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return {
        textAlign,
        x: x2
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return {
          top: 0,
          left: this.left,
          bottom: chart.height,
          right: this.right
        };
      }
      if (position === "top" || position === "bottom") {
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: chart.width
        };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left, top, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left, top, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index2 = ticks.findIndex((t2) => t2.value === value);
      if (index2 >= 0) {
        const opts = grid.setContext(this.getContext(index2));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i2, ilen;
      const drawLine = (p1, p2, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
          const item = items[i2];
          if (grid.drawOnChartArea) {
            drawLine({
              x: item.x1,
              y: item.y1
            }, {
              x: item.x2,
              y: item.y2
            }, item);
          }
          if (grid.drawTicks) {
            drawLine({
              x: item.tx1,
              y: item.ty1
            }, {
              x: item.tx2,
              y: item.ty2
            }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { border, grid } } = this;
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = border.display ? borderOpts.width : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y22;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y22 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y22 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.width;
      ctx.strokeStyle = borderOpts.color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y22);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this.getLabelItems(chartArea);
      for (const item of items) {
        const renderTextOptions = item.options;
        const tickFont = item.font;
        const label = item.label;
        const y3 = item.textOffset;
        renderText(ctx, label, 0, y3, tickFont, renderTextOptions);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject2(position)) {
        offset += padding.bottom;
        if (isArray2(title.text)) {
          offset += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      const bz = valueOrDefault(opts.border && opts.border.z, 0);
      if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
        return [
          {
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }
        ];
      }
      return [
        {
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        },
        {
          z: bz,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }
      ];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i2, ilen;
      for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
        const meta = metas[i2];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index2) {
      const opts = this.options.ticks.setContext(this.getContext(index2));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope2, override) {
      this.type = type;
      this.scope = scope2;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id2 = item.id;
      const scope2 = this.scope + "." + id2;
      if (!id2) {
        throw new Error("class does not have id: " + item);
      }
      if (id2 in items) {
        return scope2;
      }
      items[id2] = item;
      registerDefaults(item, scope2, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope2;
    }
    get(id2) {
      return this.items[id2];
    }
    unregister(item) {
      const items = this.items;
      const id2 = item.id;
      const scope2 = this.scope;
      if (id2 in items) {
        delete items[id2];
      }
      if (scope2 && id2 in defaults[scope2]) {
        delete defaults[scope2][id2];
        if (this.override) {
          delete overrides[id2];
        }
      }
    }
  };
  function registerDefaults(item, scope2, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope2),
      item.defaults
    ]);
    defaults.set(scope2, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope2, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope2, item.descriptors);
    }
  }
  function routeDefaults(scope2, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [
        scope2
      ].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element2, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id2) {
      return this._get(id2, this.controllers, "controller");
    }
    getElement(id2) {
      return this._get(id2, this.elements, "element");
    }
    getPlugin(id2) {
      return this._get(id2, this.plugins, "plugin");
    }
    getScale(id2) {
      return this._get(id2, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [
        ...args
      ].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
        const reg = this._typedRegistries[i2];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id2, typedRegistry, type) {
      const item = typedRegistry.get(id2);
      if (item === void 0) {
        throw new Error('"' + id2 + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = /* @__PURE__ */ new Registry();
  var PluginService = class {
    constructor() {
      this._init = void 0;
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      if (this._init === void 0) {
        return;
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
        this._init = void 0;
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin2 = descriptor.plugin;
        const method = plugin2[hook];
        const params = [
          chart,
          args,
          descriptor.options
        ];
        if (callback(method, params, plugin2) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins2 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a2, b3) => a2.filter((x2) => !b3.some((y3) => x2.plugin.id === y3.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins2 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i2 = 0; i2 < keys.length; i2++) {
      plugins2.push(registry.getPlugin(keys[i2]));
    }
    const local = config.plugins || [];
    for (let i2 = 0; i2 < local.length; i2++) {
      const plugin2 = local[i2];
      if (plugins2.indexOf(plugin2) === -1) {
        plugins2.push(plugin2);
        localIds[plugin2.id] = true;
      }
    }
    return {
      plugins: plugins2,
      localIds
    };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin2 of plugins2) {
      const id2 = plugin2.id;
      const opts = getOpts(options[id2], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin: plugin2,
        options: pluginOpts(chart.config, {
          plugin: plugin2,
          local: localIds[id2]
        }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin: plugin2, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin2);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin2.defaults) {
      scopes.push(plugin2.defaults);
    }
    return config.createResolver(scopes, context, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id2, indexAxis) {
    let axis = id2;
    if (id2 === "_index_") {
      axis = indexAxis;
    } else if (id2 === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function idMatchesAxis(id2) {
    if (id2 === "x" || id2 === "y" || id2 === "r") {
      return id2;
    }
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id2, ...scaleOptions) {
    if (idMatchesAxis(id2)) {
      return id2;
    }
    for (const opts of scaleOptions) {
      const axis = opts.axis || axisFromPosition(opts.position) || id2.length > 1 && idMatchesAxis(id2[0].toLowerCase());
      if (axis) {
        return axis;
      }
    }
    throw new Error(`Cannot determine type of '${id2}' axis. Please provide 'axis' or 'position' option.`);
  }
  function getAxisFromDataset(id2, axis, dataset) {
    if (dataset[axis + "AxisID"] === id2) {
      return {
        axis
      };
    }
  }
  function retrieveAxisFromDatasets(id2, config) {
    if (config.data && config.data.datasets) {
      const boundDs = config.data.datasets.filter((d3) => d3.xAxisID === id2 || d3.yAxisID === id2);
      if (boundDs.length) {
        return getAxisFromDataset(id2, "x", boundDs[0]) || getAxisFromDataset(id2, "y", boundDs[0]);
      }
    }
    return {};
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || {
      scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales2 = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id2) => {
      const scaleConf = configScales[id2];
      if (!isObject2(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id2}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id2}`);
      }
      const axis = determineAxis(id2, scaleConf, retrieveAxisFromDatasets(id2, config), defaults.scales[scaleConf.type]);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      scales2[id2] = mergeIf(/* @__PURE__ */ Object.create(null), [
        {
          axis
        },
        scaleConf,
        defaultScaleOptions[axis],
        defaultScaleOptions[defaultId]
      ]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id2 = dataset[axis + "AxisID"] || axis;
        scales2[id2] = scales2[id2] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales2[id2], [
          {
            axis
          },
          configScales[id2],
          defaultScaleOptions[defaultID]
        ]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale = scales2[key];
      mergeIf(scale, [
        defaults.scales[scale.type],
        defaults.scale
      ]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data2) {
    data2 = data2 || {};
    data2.datasets = data2.datasets || [];
    data2.labels = data2.labels || [];
    return data2;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set4, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set4.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data2) {
      this._config.data = initData(data2);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(datasetType, transition2) {
      return cachedKeys(`${datasetType}.transition.${transition2}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition2}`,
          `transitions.${transition2}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
      return cachedKeys(`${datasetType}-${elementType}`, () => [
        [
          `datasets.${datasetType}.elements.${elementType}`,
          `datasets.${datasetType}`,
          `elements.${elementType}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(plugin2) {
      const id2 = plugin2.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id2}`, () => [
        [
          `plugins.${id2}`,
          ...plugin2.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache = _scopeCache.get(mainScope);
      if (!cache || resetCache) {
        cache = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache);
      }
      return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache = this._cachedScopes(mainScope, resetCache);
      const cached = cache.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides[type] || {},
        defaults.datasets[type] || {},
        {
          type
        },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [
      ""
    ]) {
      const result = {
        $shared: true
      };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [
      ""
    ], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p2) => !p2.toLowerCase().includes("hover"))
      };
      cache.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray2(value)) {
        return true;
      }
    }
    return false;
  }
  var version = "4.5.1";
  var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l22) {
    return function(a2, b3) {
      return a2[l1] === b3[l1] ? a2[l22] - b3[l22] : a2[l1] - b3[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [
      context
    ], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
      context
    ], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start3, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start3) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start3) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e2, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e2.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e2;
  }
  var Chart = class {
    static defaults = defaults;
    static instances = instances;
    static overrides = overrides;
    static registry = registry;
    static version = version;
    static getChart = getChart;
    static register(...items) {
      registry.add(...items);
      invalidatePlugins();
    }
    static unregister(...items) {
      registry.remove(...items);
      invalidatePlugins();
    }
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid2();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce2((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data2) {
      this.config.data = data2;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    get registry() {
      return registry;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = {
          width,
          height
        };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", {
        size: newSize
      });
      callback(options.onResize, [
        this,
        newSize
      ], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id2) => {
        obj[id2] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id2) => {
          const scaleOptions = scaleOpts[id2];
          const axis = determineAxis(id2, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id2 = scaleOptions.id;
        const axis = determineAxis(id2, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id2] = true;
        let scale = null;
        if (id2 in scales2 && scales2[id2].type === scaleType) {
          scale = scales2[id2];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id: id2,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale.id] = scale;
        }
        scale.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id2) => {
        if (!hasUpdated) {
          delete scales2[id2];
        }
      });
      each(scales2, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a2, b3) => a2.index - b3.index);
      if (numMeta > numData) {
        for (let i2 = numData; i2 < numMeta; ++i2) {
          this._destroyDatasetMeta(i2);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index2) => {
        if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index2);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i2, ilen;
      this._removeUnreferencedMetasets();
      for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
        const dataset = datasets[i2];
        let meta = this.getDatasetMeta(i2);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i2);
          meta = this.getDatasetMeta(i2);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i2;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i2);
        if (meta.controller) {
          meta.controller.updateIndex(i2);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i2);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
        const { controller } = this.getDatasetMeta(i2);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", {
        mode
      });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start: start3, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start3, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i2) => i2 + "," + c2.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i2 = 1; i2 < datasetCount; i2++) {
        if (!setsEqual(changeSet, makeSet(i2))) {
          return;
        }
      }
      return Array.from(changeSet).map((c2) => c2.split(",")).map((a2) => ({
        method: a2[1],
        start: +a2[2],
        count: +a2[3]
      }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index2) => {
        item._idx = index2;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
        this.getDatasetMeta(i2).controller.configure();
      }
      for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
        this._updateDataset(i2, isFunction(mode) ? mode({
          datasetIndex: i2
        }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", {
        mode
      });
    }
    _updateDataset(index2, mode) {
      const meta = this.getDatasetMeta(index2);
      const args = {
        meta,
        index: index2,
        mode,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", {
        cancelable: true
      }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({
          chart: this
        });
      }
    }
    draw() {
      let i2;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resizeBeforeDraw = null;
        this._resize(width, height);
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const layers = this._layers;
      for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
        layers[i2].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i2 < layers.length; ++i2) {
        layers[i2].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i2, ilen;
      for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
        const meta = metasets[i2];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
        this._drawDataset(metasets[i2]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      const clip = getDatasetClipArea(this, meta);
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (clip) {
        clipArea(ctx, clip);
      }
      meta.controller.draw();
      if (clip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e2, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e2, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index2) {
      this._hiddenIndices[index2] = !this._hiddenIndices[index2];
    }
    getDataVisibility(index2) {
      return !this._hiddenIndices[index2];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, {
          visible
        });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i2, ilen;
      this.stop();
      animator.remove(this);
      for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
        this._destroyDatasetMeta(i2);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e2, x2, y3) => {
        e2.offsetX = x2;
        e2.offsetY = y3;
        this._eventHandler(e2);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix2 = enabled ? "set" : "remove";
      let meta, item, i2, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix2 + "DatasetHoverStyle"]();
      }
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        item = items[i2];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix2 + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    isPluginEnabled(pluginId) {
      return this._plugins._cache.filter((p2) => p2.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a2, b3) => a2.filter((x2) => !b3.some((y3) => x2.datasetIndex === y3.datasetIndex && x2.index === y3.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e2, replay) {
      const args = {
        event: e2,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e2)
      };
      const eventFilter = (plugin2) => (plugin2.options.events || this.options.events).includes(e2.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e2, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e2, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e2, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e2);
      const lastEvent = determineLastEvent(e2, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [
          e2,
          active,
          this
        ], this);
        if (isClick) {
          callback(options.onClick, [
            e2,
            active,
            this
          ], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e2, lastActive, inChartArea, useFinalPosition) {
      if (e2.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e2, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  function invalidatePlugins() {
    return each(Chart.instances, (chart) => chart._plugins.invalidate());
  }
  function clipSelf(ctx, element, endAngle) {
    const { startAngle, x: x2, y: y3, outerRadius, innerRadius, options } = element;
    const { borderWidth, borderJoinStyle } = options;
    const outerAngleClip = Math.min(borderWidth / outerRadius, _normalizeAngle(startAngle - endAngle));
    ctx.beginPath();
    ctx.arc(x2, y3, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);
    if (innerRadius > 0) {
      const innerAngleClip = Math.min(borderWidth / innerRadius, _normalizeAngle(startAngle - endAngle));
      ctx.arc(x2, y3, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);
    } else {
      const clipWidth = Math.min(borderWidth / 2, outerRadius * _normalizeAngle(startAngle - endAngle));
      if (borderJoinStyle === "round") {
        ctx.arc(x2, y3, clipWidth, endAngle - PI / 2, startAngle + PI / 2, true);
      } else if (borderJoinStyle === "bevel") {
        const r2 = 2 * clipWidth * clipWidth;
        const endX = -r2 * Math.cos(endAngle + PI / 2) + x2;
        const endY = -r2 * Math.sin(endAngle + PI / 2) + y3;
        const startX = r2 * Math.cos(startAngle + PI / 2) + x2;
        const startY = r2 * Math.sin(startAngle + PI / 2) + y3;
        ctx.lineTo(endX, endY);
        ctx.lineTo(startX, startY);
      }
    }
    ctx.closePath();
    ctx.moveTo(0, 0);
    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.clip("evenodd");
  }
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x: x2, y: y3, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x2, y3, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x2, y3, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x2, y3, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o2 = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o2.outerStart),
      outerEnd: computeOuterLimit(o2.outerEnd),
      innerStart: _limitValue(o2.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o2.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r2, theta, x2, y3) {
    return {
      x: x2 + r2 * Math.cos(theta),
      y: y3 + r2 * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x: x2, y: y3, startAngle: start3, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end - start3;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start3 + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
      ctx.arc(x2, y3, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
      ctx.arc(x2, y3, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x2, y3);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x2, y3);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x2, y3);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
      ctx.arc(x2, y3, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
      ctx.arc(x2, y3, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x2, y3);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x2, y3);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x2, y3);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x2, y3);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x2;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y3;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x2;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y3;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i2 = 0; i2 < fullCircles; ++i2) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference, options } = element;
    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i2 = 0; i2 < fullCircles; ++i2) {
        ctx.stroke();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    if (options.selfJoin && endAngle - startAngle >= PI && borderRadius === 0 && borderJoinStyle !== "miter") {
      clipSelf(ctx, element, endAngle);
    }
    if (!fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      ctx.stroke();
    }
  }
  var ArcElement = class extends Element2 {
    static id = "arc";
    static defaults = {
      borderAlign: "center",
      borderColor: "#fff",
      borderDash: [],
      borderDashOffset: 0,
      borderJoinStyle: void 0,
      borderRadius: 0,
      borderWidth: 2,
      offset: 0,
      spacing: 0,
      angle: void 0,
      circular: true,
      selfJoin: false
    };
    static defaultRoutes = {
      backgroundColor: "backgroundColor"
    };
    static descriptors = {
      _scriptable: true,
      _indexable: (name) => name !== "borderDash"
    };
    circumference;
    endAngle;
    fullCircles;
    innerRadius;
    outerRadius;
    pixelMargin;
    startAngle;
    constructor(cfg) {
      super();
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, {
        x: chartX,
        y: chartY
      });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
      const betweenAngles = _circumference >= TAU || nonZeroBetween;
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x: x2, y: y3, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], useFinalPosition);
      const { offset, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
      return {
        x: x2 + Math.cos(halfAngle) * halfRadius,
        y: y3 + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset = (options.offset || 0) / 4;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
      const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
      const radiusOffset = offset * fix;
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, circular);
      ctx.restore();
    }
  };
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start3 = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start: start3,
      loop: segment.loop,
      ilen: end < start3 && !outside ? count + end - start3 : end - start3
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start: start3, loop: loop2, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i2, point, prev;
    for (i2 = 0; i2 <= ilen; ++i2) {
      point = points[(start3 + (reverse ? ilen - i2 : i2)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      prev = point;
    }
    if (loop2) {
      point = points[(start3 + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop2;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start: start3, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i2, point, prevX, minY, maxY, lastY;
    const pointIndex = (index2) => (start3 + (reverse ? ilen - index2 : index2)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i2 = 0; i2 <= ilen; ++i2) {
      point = points[pointIndex(i2)];
      if (point.skip) {
        continue;
      }
      const x2 = point.x;
      const y3 = point.y;
      const truncX = x2 | 0;
      if (truncX === prevX) {
        if (y3 < minY) {
          minY = y3;
        } else if (y3 > maxY) {
          maxY = y3;
        }
        avgX = (countX * avgX + x2) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x2, y3);
        prevX = truncX;
        countX = 0;
        minY = maxY = y3;
      }
      lastY = y3;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start3, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start3, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start3, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, {
        start: start3,
        end: start3 + count - 1
      })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start3, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start3, count);
    } else {
      strokePathDirect(ctx, line, start3, count);
    }
  }
  var LineElement = class extends Element2 {
    static id = "line";
    static defaults = {
      borderCapStyle: "butt",
      borderDash: [],
      borderDashOffset: 0,
      borderJoinStyle: "miter",
      borderWidth: 3,
      capBezierPoints: true,
      cubicInterpolationMode: "default",
      fill: false,
      spanGaps: false,
      stepped: false,
      tension: 0
    };
    static defaultRoutes = {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    };
    static descriptors = {
      _scriptable: true,
      _indexable: (name) => name !== "borderDash" && name !== "fill"
    };
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop2 = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop2, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, {
        property,
        start: value,
        end: value
      });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i2, ilen;
      for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
        const { start: start3, end } = segments[i2];
        const p1 = points[start3];
        const p2 = points[end];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t2, options.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start3, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop2 = this._loop;
      start3 = start3 || 0;
      count = count || this.points.length - start3;
      for (const segment of segments) {
        loop2 &= segmentMethod(ctx, this, segment, {
          start: start3,
          end: start3 + count - 1
        });
      }
      return !!loop2;
    }
    draw(ctx, chartArea, start3, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start3, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value } = el.getProps([
      axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element2 {
    static id = "point";
    parsed;
    skip;
    stop;
    /**
    * @type {any}
    */
    static defaults = {
      borderWidth: 1,
      hitRadius: 1,
      hoverBorderWidth: 1,
      hoverRadius: 4,
      pointStyle: "circle",
      radius: 3,
      rotation: 0
    };
    /**
    * @type {any}
    */
    static defaultRoutes = {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    };
    constructor(cfg) {
      super();
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x: x2, y: y3 } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return Math.pow(mouseX - x2, 2) + Math.pow(mouseY - y3, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x2, y: y3 } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x: x2,
        y: y3
      };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  function getBarBounds(bar, useFinalPosition) {
    const { x: x2, y: y3, base, width, height } = bar.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
      half = height / 2;
      left = Math.min(x2, base);
      right = Math.max(x2, base);
      top = y3 - half;
      bottom = y3 + half;
    } else {
      half = width / 2;
      left = x2 - half;
      right = x2 + half;
      top = Math.min(y3, base);
      bottom = Math.max(y3, base);
    }
    return {
      left,
      top,
      right,
      bottom
    };
  }
  function skipOrLimit(skip2, value, min, max) {
    return skip2 ? 0 : _limitValue(value, min, max);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o2 = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o2.top, 0, maxH),
      r: skipOrLimit(skip2.right, o2.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o2.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o2.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
      "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o2 = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject2(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o2.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o2.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o2.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o2.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x2, y3, useFinalPosition) {
    const skipX = x2 === null;
    const skipY = y3 === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x2, bounds.left, bounds.right)) && (skipY || _isBetween(y3, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x2 = rect.x !== refRect.x ? -amount : 0;
    const y3 = rect.y !== refRect.y ? -amount : 0;
    const w3 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x2;
    const h3 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y3;
    return {
      x: rect.x + x2,
      y: rect.y + y3,
      w: rect.w + w3,
      h: rect.h + h3,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element2 {
    static id = "bar";
    static defaults = {
      borderSkipped: "start",
      borderWidth: 0,
      borderRadius: 0,
      inflateAmount: "auto",
      pointStyle: void 0
    };
    static defaultRoutes = {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    };
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x2, y: y3, base, horizontal } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], useFinalPosition);
      return {
        x: horizontal ? (x2 + base) / 2 : x2,
        y: horizontal ? y3 : (y3 + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    BarElement,
    LineElement,
    PointElement
  });
  var BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
    // grey
  ];
  var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function getBorderColor(i2) {
    return BORDER_COLORS[i2 % BORDER_COLORS.length];
  }
  function getBackgroundColor(i2) {
    return BACKGROUND_COLORS[i2 % BACKGROUND_COLORS.length];
  }
  function colorizeDefaultDataset(dataset, i2) {
    dataset.borderColor = getBorderColor(i2);
    dataset.backgroundColor = getBackgroundColor(i2);
    return ++i2;
  }
  function colorizeDoughnutDataset(dataset, i2) {
    dataset.backgroundColor = dataset.data.map(() => getBorderColor(i2++));
    return i2;
  }
  function colorizePolarAreaDataset(dataset, i2) {
    dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i2++));
    return i2;
  }
  function getColorizer(chart) {
    let i2 = 0;
    return (dataset, datasetIndex) => {
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      if (controller instanceof DoughnutController) {
        i2 = colorizeDoughnutDataset(dataset, i2);
      } else if (controller instanceof PolarAreaController) {
        i2 = colorizePolarAreaDataset(dataset, i2);
      } else if (controller) {
        i2 = colorizeDefaultDataset(dataset, i2);
      }
    };
  }
  function containsColorsDefinitions(descriptors2) {
    let k2;
    for (k2 in descriptors2) {
      if (descriptors2[k2].borderColor || descriptors2[k2].backgroundColor) {
        return true;
      }
    }
    return false;
  }
  function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
  }
  function containsDefaultColorsDefenitions() {
    return defaults.borderColor !== "rgba(0,0,0,0.1)" || defaults.backgroundColor !== "rgba(0,0,0,0.1)";
  }
  var plugin_colors = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(chart, _args, options) {
      if (!options.enabled) {
        return;
      }
      const { data: { datasets }, options: chartOptions } = chart.config;
      const { elements: elements2 } = chartOptions;
      const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2) || containsDefaultColorsDefenitions();
      if (!options.forceOverride && containsColorDefenition) {
        return;
      }
      const colorizer = getColorizer(chart);
      datasets.forEach(colorizer);
    }
  };
  function lttbDecimation(data2, start3, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data2.slice(start3, start3 + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start3 + count - 1;
    let a2 = start3;
    let i2, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data2[a2];
    for (i2 = 0; i2 < samples - 2; i2++) {
      let avgX = 0;
      let avgY = 0;
      let j2;
      const avgRangeStart = Math.floor((i2 + 1) * bucketWidth) + 1 + start3;
      const avgRangeEnd = Math.min(Math.floor((i2 + 2) * bucketWidth) + 1, count) + start3;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j2 = avgRangeStart; j2 < avgRangeEnd; j2++) {
        avgX += data2[j2].x;
        avgY += data2[j2].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i2 * bucketWidth) + 1 + start3;
      const rangeTo = Math.min(Math.floor((i2 + 1) * bucketWidth) + 1, count) + start3;
      const { x: pointAx, y: pointAy } = data2[a2];
      maxArea = area = -1;
      for (j2 = rangeOffs; j2 < rangeTo; j2++) {
        area = 0.5 * Math.abs((pointAx - avgX) * (data2[j2].y - pointAy) - (pointAx - data2[j2].x) * (avgY - pointAy));
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data2[j2];
          nextA = j2;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a2 = nextA;
    }
    decimated[sampledIndex++] = data2[endIndex];
    return decimated;
  }
  function minMaxDecimation(data2, start3, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i2, point, x2, y3, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start3 + count - 1;
    const xMin = data2[start3].x;
    const xMax = data2[endIndex].x;
    const dx = xMax - xMin;
    for (i2 = start3; i2 < start3 + count; ++i2) {
      point = data2[i2];
      x2 = (point.x - xMin) / dx * availableWidth;
      y3 = point.y;
      const truncX = x2 | 0;
      if (truncX === prevX) {
        if (y3 < minY) {
          minY = y3;
          minIndex = i2;
        } else if (y3 > maxY) {
          maxY = y3;
          maxIndex = i2;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i2 - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push({
              ...data2[intermediateIndex1],
              x: avgX
            });
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push({
              ...data2[intermediateIndex2],
              x: avgX
            });
          }
        }
        if (i2 > 0 && lastIndex !== startIndex) {
          decimated.push(data2[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y3;
        minIndex = maxIndex = startIndex = i2;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data2 = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: data2
      });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start3 = 0;
    let count;
    const { iScale } = meta;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start3 = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start3, pointCount) - start3;
    } else {
      count = pointCount - start3;
    }
    return {
      start: start3,
      count
    };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data2 = _data || dataset.data;
        if (resolve([
          indexAxis,
          chart.options.indexAxis
        ]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start: start3, count } = getStartAndCountOfVisiblePointsSimplified(meta, data2);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data2;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d3) {
              this._data = d3;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data2, start3, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data2, start3, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start: start3, end } = segment;
      end = _findSegmentEnd(start3, end, points);
      const bounds = _getBounds(property, points[start3], points[end], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start3],
          end: points[end]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first, last, loop2) {
    if (loop2) {
      return;
    }
    let start3 = first[property];
    let end = last[property];
    if (property === "angle") {
      start3 = _normalizeAngle(start3);
      end = _normalizeAngle(end);
    }
    return {
      property,
      start: start3,
      end
    };
  }
  function _pointsFromSegments(boundary, line) {
    const { x: x2 = null, y: y3 = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start: start3, end }) => {
      end = _findSegmentEnd(start3, end, linePoints);
      const first = linePoints[start3];
      const last = linePoints[end];
      if (y3 !== null) {
        points.push({
          x: first.x,
          y: y3
        });
        points.push({
          x: last.x,
          y: y3
        });
      } else if (x2 !== null) {
        points.push({
          x: x2,
          y: first.y
        });
        points.push({
          x: x2,
          y: last.y
        });
      }
    });
    return points;
  }
  function _findSegmentEnd(start3, end, points) {
    for (; end > start3; end--) {
      const point = points[end];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end;
  }
  function _getEdge(a2, b3, prop, fn) {
    if (a2 && b3) {
      return fn(a2[prop], b3[prop]);
    }
    return a2 ? a2[prop] : b3 ? b3[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray2(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: {
        tension: 0
      },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index2, propagate) {
    const source = sources[index2];
    let fill2 = source.fill;
    const visited = [
      index2
    ];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index2, count) {
    const fill2 = parseFillOption(line);
    if (isObject2(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index2, target, count);
    }
    return [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index2, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index2 + target;
    }
    if (target === index2 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale.bottom;
    } else if (fill2 === "end") {
      pixel = scale.top;
    } else if (isObject2(fill2)) {
      pixel = scale.getPixelForValue(fill2.value);
    } else if (scale.getBasePixel) {
      pixel = scale.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject2(fill2)) {
      value = fill2.value;
    } else {
      value = scale.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale, index: index2, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index2);
    linesBelow.push(_createBoundaryLine({
      x: null,
      y: scale.bottom
    }, line));
    for (let i2 = 0; i2 < segments.length; i2++) {
      const segment = segments[i2];
      for (let j2 = segment.start; j2 <= segment.end; j2++) {
        addPointsBelow(points, sourcePoints[j2], linesBelow);
      }
    }
    return new LineElement({
      points,
      options: {}
    });
  }
  function getLinesBelow(scale, index2) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for (let i2 = 0; i2 < metas.length; i2++) {
      const meta = metas[i2];
      if (meta.index === index2) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j2 = 0; j2 < linesBelow.length; j2++) {
      const line = linesBelow[j2];
      const { first, last, point } = findPoint(line, sourcePoint, "x");
      if (!point || first && last) {
        continue;
      }
      if (first) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for (let i2 = 0; i2 < segments.length; i2++) {
      const segment = segments[i2];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return {
      first,
      last,
      point
    };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x: x2, y: y3, radius } = this;
      bounds = bounds || {
        start: 0,
        end: TAU
      };
      ctx.arc(x2, y3, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x: x2, y: y3, radius } = this;
      const angle = point.angle;
      return {
        x: x2 + Math.cos(angle) * radius,
        y: y3 + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index2) {
    const meta = chart.getDatasetMeta(index2);
    const visible = meta && chart.isDatasetVisible(index2);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale);
    if (isNumberFinite(pixel)) {
      const horizontal = scale.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale, fill: fill2 } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start3 = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill2, scale, start3);
    const target = [];
    if (options.grid.circular) {
      const center = scale.getPointPositionForValue(0, start3);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale.getDistanceFromCenterForValue(value)
      });
    }
    for (let i2 = 0; i2 < length; ++i2) {
      target.push(scale.getPointPositionForValue(i2, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { chart, index: index2, line, scale, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    const meta = chart.getDatasetMeta(index2);
    const clip = getDatasetClipArea(chart, meta);
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, {
        line,
        target,
        above,
        below,
        area,
        scale,
        axis,
        clip
      });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale, clip } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    let fillColor = below;
    if (below !== above) {
      if (property === "x") {
        clipVertical(ctx, target, area.top);
        fill(ctx, {
          line,
          target,
          color: above,
          scale,
          property,
          clip
        });
        ctx.restore();
        ctx.save();
        clipVertical(ctx, target, area.bottom);
      } else if (property === "y") {
        clipHorizontal(ctx, target, area.left);
        fill(ctx, {
          line,
          target,
          color: below,
          scale,
          property,
          clip
        });
        ctx.restore();
        ctx.save();
        clipHorizontal(ctx, target, area.right);
        fillColor = above;
      }
    }
    fill(ctx, {
      line,
      target,
      color: fillColor,
      scale,
      property,
      clip
    });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start: start3, end } = segment;
      const firstPoint = points[start3];
      const lastPoint = points[_findSegmentEnd(start3, end, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, {
        move: lineLoop
      });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function clipHorizontal(ctx, target, clipX) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start: start3, end } = segment;
      const firstPoint = points[start3];
      const lastPoint = points[_findSegmentEnd(start3, end, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(clipX, firstPoint.y);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, {
        move: lineLoop
      });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(clipX, lastPoint.y);
      }
    }
    ctx.lineTo(clipX, target.first().y);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale, clip } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start: start3, end } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale, clip, notShape && _getBounds(property, start3, end));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop2;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, {
          move: lineLoop,
          reverse: true
        });
        loop2 = lineLoop && targetLoop;
        if (!loop2) {
          interpolatedLineTo(ctx, target, start3, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop2 ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale, clip, bounds) {
    const chartArea = scale.chart.chartArea;
    const { property, start: start3, end } = bounds || {};
    if (property === "x" || property === "y") {
      let left, top, right, bottom;
      if (property === "x") {
        left = start3;
        top = chartArea.top;
        right = end;
        bottom = chartArea.bottom;
      } else {
        left = chartArea.left;
        top = start3;
        right = chartArea.right;
        bottom = end;
      }
      ctx.beginPath();
      if (clip) {
        left = Math.max(left, clip.left);
        right = Math.min(right, clip.right);
        top = Math.max(top, clip.top);
        bottom = Math.min(bottom, clip.bottom);
      }
      ctx.rect(left, top, right - left, bottom - top);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i2, line, source;
      for (i2 = 0; i2 < count; ++i2) {
        meta = chart.getDatasetMeta(i2);
        line = meta.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i2),
            index: i2,
            fill: _decodeFill(line, i2, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i2 = 0; i2 < count; ++i2) {
        source = sources[i2];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i2, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw2 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
        const source = metasets[i2].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw2 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
        const source = metasets[i2].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a2, b3) => a2 !== null && b3 !== null && a2.datasetIndex === b3.datasetIndex && a2.index === b3.index;
  var Legend = class extends Element2 {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [
        this.chart
      ], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a2, b3) => labelOpts.sort(a2, b3, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [
        0
      ];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top = -lineHeight;
      this.legendItems.forEach((legendItem, i2) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
          top += lineHeight;
          row++;
        }
        hitboxes[i2] = {
          left: 0,
          top,
          row,
          width: itemWidth,
          height: itemHeight
        };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i2) => {
        const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
        if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          left += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i2] = {
          left,
          top: currentColHeight,
          col,
          width: itemWidth,
          height: itemHeight
        };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({
        width: currentColWidth,
        height: currentColHeight
      });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
          left += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x2, y3, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
          const centerY = y3 + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y3 + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v3) => v3 !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x2, y3, legendItem) {
        renderText(ctx, legendItem.text, x2, y3 + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i2) => {
        ctx.strokeStyle = legendItem.fontColor;
        ctx.fillStyle = legendItem.fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x2 = cursor.x;
        let y3 = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i2 > 0 && x2 + width + padding > this.right) {
            y3 = cursor.y += lineHeight;
            cursor.line++;
            x2 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i2 > 0 && y3 + lineHeight > this.bottom) {
          x2 = cursor.x = x2 + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y3 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x2);
        drawLegendBox(realX, y3, legendItem);
        x2 = _textX(textAlign, x2 + boxWidth + halfFontSize, isHorizontal ? x2 + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x2), y3, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else if (typeof legendItem.text !== "string") {
          const fontLineHeight = labelFont.lineHeight;
          cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y3;
      let left = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y3 = this.top + topPaddingPlusHalfFontSize;
        left = _alignStartEnd(opts.align, left, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size2) => Math.max(acc, size2.height), 0);
        y3 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x2 = _alignStartEnd(position, left, left + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x2, y3, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x2, y3) {
      let i2, hitBox, lh;
      if (_isBetween(x2, this.left, this.right) && _isBetween(y3, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i2 = 0; i2 < lh.length; ++i2) {
          hitBox = lh[i2];
          if (_isBetween(x2, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y3, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i2];
          }
        }
      }
      return null;
    }
    handleEvent(e2) {
      const opts = this.options;
      if (!isListened(e2.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e2.x, e2.y);
      if (e2.type === "mousemove" || e2.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [
            e2,
            previous,
            this
          ], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [
            e2,
            hoveredItem,
            this
          ], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [
          e2,
          hoveredItem,
          this
        ], this);
      }
    }
  };
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
      itemWidth,
      itemHeight
    };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
      legendItemText = legendItemText.reduce((a2, b3) => a2.length > b3.length ? a2 : b3);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
      itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e2, legendItem, legend) {
        const index2 = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index2)) {
          ci.hide(index2);
          legendItem.hidden = true;
        } else {
          ci.show(index2);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name) => !name.startsWith("on"),
      labels: {
        _scriptable: (name) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(name)
      }
    }
  };
  var Title = class extends Element2 {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray2(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset) {
      const { top, left, bottom, right, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        titleY = top + offset;
        maxWidth = right - left;
      } else {
        if (options.position === "left") {
          titleX = left + offset;
          titleY = _alignStartEnd(align, bottom, top);
          rotation = PI * -0.5;
        } else {
          titleX = right - offset;
          titleY = _alignStartEnd(align, top, bottom);
          rotation = PI * 0.5;
        }
        maxWidth = bottom - top;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title, options);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i2, len;
      let xSet = /* @__PURE__ */ new Set();
      let y3 = 0;
      let count = 0;
      for (i2 = 0, len = items.length; i2 < len; ++i2) {
        const el = items[i2].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          xSet.add(pos.x);
          y3 += pos.y;
          ++count;
        }
      }
      if (count === 0 || xSet.size === 0) {
        return false;
      }
      const xAverage = [
        ...xSet
      ].reduce((a2, b3) => a2 + b3) / xSet.size;
      return {
        x: xAverage,
        y: y3 / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x2 = eventPosition.x;
      let y3 = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i2, len, nearestElement;
      for (i2 = 0, len = items.length; i2 < len; ++i2) {
        const el = items[i2].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d3 = distanceBetweenPoints(eventPosition, center);
          if (d3 < minDistance) {
            minDistance = d3;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x2 = tp.x;
        y3 = tp.y;
      }
      return {
        x: x2,
        y: y3
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray2(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index2 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index2);
    return {
      chart,
      label,
      parsed: controller.getParsed(index2),
      raw: chart.data.datasets[datasetIndex].data[index2],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index2,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
      width,
      height
    };
  }
  function determineYAlign(chart, size2) {
    const { y: y3, height } = size2;
    if (y3 < height / 2) {
      return "top";
    } else if (y3 > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size2) {
    const { x: x2, width } = size2;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x2 + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x2 - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size2, yAlign) {
    const { x: x2, width } = size2;
    const { width: chartWidth, chartArea: { left, right } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x2 <= (left + right) / 2 ? "left" : "right";
    } else if (x2 <= width / 2) {
      xAlign = "left";
    } else if (x2 >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size2)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size2) {
    const yAlign = size2.yAlign || options.yAlign || determineYAlign(chart, size2);
    return {
      xAlign: size2.xAlign || options.xAlign || determineXAlign(chart, options, size2, yAlign),
      yAlign
    };
  }
  function alignX(size2, xAlign) {
    let { x: x2, width } = size2;
    if (xAlign === "right") {
      x2 -= width;
    } else if (xAlign === "center") {
      x2 -= width / 2;
    }
    return x2;
  }
  function alignY(size2, yAlign, paddingAndSize) {
    let { y: y3, height } = size2;
    if (yAlign === "top") {
      y3 += paddingAndSize;
    } else if (yAlign === "bottom") {
      y3 -= height + paddingAndSize;
    } else {
      y3 -= height / 2;
    }
    return y3;
  }
  function getBackgroundPoint(options, size2, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x2 = alignX(size2, xAlign);
    const y3 = alignY(size2, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x2 += paddingAndSize;
      } else if (xAlign === "right") {
        x2 -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x2 -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x2 += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x2, 0, chart.width - size2.width),
      y: _limitValue(y3, 0, chart.height - size2.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var defaultCallbacks = {
    beforeTitle: noop,
    title(tooltipItems) {
      if (tooltipItems.length > 0) {
        const item = tooltipItems[0];
        const labels = item.chart.data.labels;
        const labelCount = labels ? labels.length : 0;
        if (this && this.options && this.options.mode === "dataset") {
          return item.dataset.label || "";
        } else if (item.label) {
          return item.label;
        } else if (labelCount > 0 && item.dataIndex < labelCount) {
          return labels[item.dataIndex];
        }
      }
      return "";
    },
    afterTitle: noop,
    beforeBody: noop,
    beforeLabel: noop,
    label(tooltipItem) {
      if (this && this.options && this.options.mode === "dataset") {
        return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
      }
      let label = tooltipItem.dataset.label || "";
      if (label) {
        label += ": ";
      }
      const value = tooltipItem.formattedValue;
      if (!isNullOrUndef(value)) {
        label += value;
      }
      return label;
    },
    labelColor(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        borderColor: options.borderColor,
        backgroundColor: options.backgroundColor,
        borderWidth: options.borderWidth,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        pointStyle: options.pointStyle,
        rotation: options.rotation
      };
    },
    afterLabel: noop,
    afterBody: noop,
    beforeFooter: noop,
    footer: noop,
    afterFooter: noop
  };
  function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") {
      return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
  }
  var Tooltip = class extends Element2 {
    static positioners = positioners;
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
      const { callbacks } = options;
      const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
      const title = invokeCallbackWithFallback(callbacks, "title", this, context);
      const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context);
        pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
        pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
        pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
      const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
      const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data2 = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i2, len;
      for (i2 = 0, len = active.length; i2 < len; ++i2) {
        tooltipItems.push(createTooltipItem(this.chart, active[i2]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data2));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a2, b3) => options.itemSort(a2, b3, data2));
      }
      each(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options.callbacks, context);
        labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
        labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
        labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size2 = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size2);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size2.width,
          height: size2.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, {
          chart: this.chart,
          tooltip: this,
          replay
        });
      }
    }
    drawCaret(tooltipPoint, ctx, size2, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size2, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size2, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size2;
      let x1, x2, x3, y1, y22, y3;
      if (yAlign === "center") {
        y22 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y22 + caretSize;
          y3 = y22 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y22 - caretSize;
          y3 = y22 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y22 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y22 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return {
        x1,
        x2,
        x3,
        y1,
        y2: y22,
        y3
      };
    }
    drawTitle(pt, ctx, options) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i2;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i2 = 0; i2 < length; ++i2) {
          ctx.fillText(title[i2], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
          pt.y += titleFont.lineHeight + titleSpacing;
          if (i2 + 1 === length) {
            pt.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt, i2, rtlHelper, options) {
      const labelColor = this.labelColors[i2];
      const labelPointStyle = this.labelPointStyles[i2];
      const { boxHeight, boxWidth } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColor.borderColor;
        ctx.fillStyle = labelColor.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject2(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
        ctx.strokeStyle = labelColor.borderColor;
        ctx.setLineDash(labelColor.borderDash || []);
        ctx.lineDashOffset = labelColor.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
        const borderRadius = toTRBLCorners(labelColor.borderRadius);
        if (Object.values(borderRadius).some((v3) => v3 !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i2];
    }
    drawBody(pt, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
        pt.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i2, j2, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
        bodyItem = body[i2];
        textColor = this.labelTextColors[i2];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt, i2, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j2 = 0, jlen = lines.length; j2 < jlen; ++j2) {
          fillLineOfText(lines[j2]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i2;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.footerAlign, options);
        pt.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i2 = 0; i2 < length; ++i2) {
          ctx.fillText(footer[i2], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
          pt.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x: x2, y: y3 } = pt;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x2 + topLeft, y3);
      if (yAlign === "top") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x2 + width - topRight, y3);
      ctx.quadraticCurveTo(x2 + width, y3, x2 + width, y3 + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x2 + width, y3 + height - bottomRight);
      ctx.quadraticCurveTo(x2 + width, y3 + height, x2 + width - bottomRight, y3 + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x2 + bottomLeft, y3 + height);
      ctx.quadraticCurveTo(x2, y3 + height, x2, y3 + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x2, y3 + topLeft);
      ctx.quadraticCurveTo(x2, y3, x2 + topLeft, y3);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size2 = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size2.width;
          this.height = size2.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt.y += padding.top;
        this.drawTitle(pt, ctx, options);
        this.drawBody(pt, ctx, options);
        this.drawFooter(pt, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e2, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e2, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e2);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e2.x,
            y: e2.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e2, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e2.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive.filter((i2) => this.chart.data.datasets[i2.datasetIndex] && this.chart.getDatasetMeta(i2.datasetIndex).controller.getParsed(i2.index) !== void 0);
      }
      const active = this.chart.getElementsAtEventForMode(e2, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e2) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e2);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip({
          chart,
          options
        });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", {
          ...args,
          cancelable: true
        }) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: defaultCallbacks
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw2, index2, addedLabels) => {
    if (typeof raw2 === "string") {
      index2 = labels.push(raw2) - 1;
      addedLabels.unshift({
        index: index2,
        label: raw2
      });
    } else if (isNaN(raw2)) {
      index2 = null;
    }
    return index2;
  };
  function findOrAddLabel(labels, raw2, index2, addedLabels) {
    const first = labels.indexOf(raw2);
    if (first === -1) {
      return addIfString(labels, raw2, index2, addedLabels);
    }
    const last = labels.lastIndexOf(raw2);
    return first !== last ? index2 : first;
  }
  var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
  function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  var CategoryScale = class extends Scale {
    static id = "category";
    static defaults = {
      ticks: {
        callback: _getLabelForValue
      }
    };
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index2, label } of added) {
          if (labels[index2] === label) {
            labels.splice(index2, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw2, index2) {
      if (isNullOrUndef(raw2)) {
        return null;
      }
      const labels = this.getLabels();
      index2 = isFinite(index2) && labels[index2] === raw2 ? index2 : findOrAddLabel(labels, raw2, valueOrDefault(index2, raw2), this._addedLabels);
      return validIndex(index2, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min = 0;
        }
        if (!maxDefined) {
          max = this.getLabels().length - 1;
        }
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const min = this.min;
      const max = this.max;
      const offset = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
      this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
      this._startValue = this.min - (offset ? 0.5 : 0);
      for (let value = min; value <= max; value++) {
        ticks.push({
          value
        });
      }
      return ticks;
    }
    getLabelForValue(value) {
      return _getLabelForValue.call(this, value);
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [
        {
          value: rmin
        },
        {
          value: rmax
        }
      ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
      spacing = (max - min) / numSpaces;
      niceMin = min;
      niceMax = max;
    } else if (countDefined) {
      niceMin = minDefined ? min : niceMin;
      niceMax = maxDefined ? max : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j2 = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min) {
        ticks.push({
          value: min
        });
        if (niceMin < min) {
          j2++;
        }
        if (almostEquals(Math.round((niceMin + j2 * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
          j2++;
        }
      } else if (niceMin < min) {
        j2++;
      }
    }
    for (; j2 < numSpaces; ++j2) {
      const tickValue = Math.round((niceMin + j2 * spacing) * factor) / factor;
      if (maxDefined && tickValue > max) {
        break;
      }
      ticks.push({
        value: tickValue
      });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max;
      } else {
        ticks.push({
          value: max
        });
      }
    } else if (!maxDefined || niceMax === max) {
      ticks.push({
        value: niceMax
      });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw2, index2) {
      if (isNullOrUndef(raw2)) {
        return null;
      }
      if ((typeof raw2 === "number" || raw2 instanceof Number) && !isFinite(+raw2)) {
        return null;
      }
      return +raw2;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this;
      const setMin = (v3) => min = minDefined ? min : v3;
      const setMax = (v3) => max = maxDefined ? max : v3;
      if (beginAtZero) {
        const minSign = sign(min);
        const maxSign = sign(max);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min === max) {
        let offset = max === 0 ? 1 : Math.abs(max * 0.05);
        setMax(max + offset);
        if (!beginAtZero) {
          setMin(min - offset);
        }
      }
      this.min = min;
      this.max = max;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start3 = this.min;
      let end = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset = (end - start3) / Math.max(ticks.length - 1, 1) / 2;
        start3 -= offset;
        end += offset;
      }
      this._startValue = start3;
      this._endValue = end;
      this._valueRange = end - start3;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    static id = "linear";
    static defaults = {
      ticks: {
        callback: Ticks.formatters.numeric
      }
    };
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? min : 0;
      this.max = isNumberFinite(max) ? max : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  var log10Floor = (v3) => Math.floor(log10(v3));
  var changeExponent = (v3, m2) => Math.pow(10, log10Floor(v3) + m2);
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
  }
  function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start3 = Math.floor(min / rangeStep);
    const end = Math.ceil(max / rangeStep);
    return end - start3;
  }
  function startExp(min, max) {
    const range2 = max - min;
    let rangeExp = log10Floor(range2);
    while (steps(min, max, rangeExp) > 10) {
      rangeExp++;
    }
    while (steps(min, max, rangeExp) < 10) {
      rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
  }
  function generateTicks(generationOptions, { min, max }) {
    min = finiteOrDefault(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start3 = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start3 - offset) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while (value < max) {
      ticks.push({
        value,
        major: isMajor(value),
        significand
      });
      if (significand >= 10) {
        significand = significand < 15 ? 15 : 20;
      } else {
        significand++;
      }
      if (significand >= 20) {
        exp++;
        significand = 2;
        precision = exp >= 0 ? 1 : precision;
      }
      value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
      value: lastTick,
      major: isMajor(lastTick),
      significand
    });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    static id = "logarithmic";
    static defaults = {
      ticks: {
        callback: Ticks.formatters.logarithmic,
        major: {
          enabled: true
        }
      }
    };
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw2, index2) {
      const value = LinearScaleBase.prototype.parse.apply(this, [
        raw2,
        index2
      ]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? Math.max(0, min) : null;
      this.max = isNumberFinite(max) ? Math.max(0, max) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
        this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min = this.min;
      let max = this.max;
      const setMin = (v3) => min = minDefined ? min : v3;
      const setMax = (v3) => max = maxDefined ? max : v3;
      if (min === max) {
        if (min <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(changeExponent(min, -1));
          setMax(changeExponent(max, 1));
        }
      }
      if (min <= 0) {
        setMin(changeExponent(max, -1));
      }
      if (max <= 0) {
        setMax(changeExponent(min, 1));
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start3 = this.min;
      super.configure();
      this._startValue = log10(start3);
      this._valueRange = log10(this.max) - log10(start3);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray2(label) ? label : [
      label
    ];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size2, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size2 / 2,
        end: pos + size2 / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size2,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size2
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i2 = 0; i2 < valueCount; i2++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i2));
      padding[i2] = opts.padding;
      const pointPosition = scale.getPointPosition(i2, scale.drawingArea + padding[i2], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i2]);
      labelSizes[i2] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i2) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x2 = 0;
    let y3 = 0;
    if (hLimits.start < orig.l) {
      x2 = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x2);
    } else if (hLimits.end > orig.r) {
      x2 = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x2);
    }
    if (vLimits.start < orig.t) {
      y3 = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y3);
    } else if (vLimits.end > orig.b) {
      y3 = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y3);
    }
  }
  function createPointLabelItem(scale, index2, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra, additionalAngle, padding, size: size2 } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y3 = yForAngle(pointLabelPosition.y, size2.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size2.w, textAlign);
    return {
      visible: true,
      x: pointLabelPosition.x,
      y: y3,
      textAlign,
      left,
      top: y3,
      right: left + size2.w,
      bottom: y3 + size2.h
    };
  }
  function isNotOverlapped(item, area) {
    if (!area) {
      return true;
    }
    const { left, top, right, bottom } = item;
    const apexesInArea = _isPointInArea({
      x: left,
      y: top
    }, area) || _isPointInArea({
      x: left,
      y: bottom
    }, area) || _isPointInArea({
      x: right,
      y: top
    }, area) || _isPointInArea({
      x: right,
      y: bottom
    }, area);
    return !apexesInArea;
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
      extra: getTickBackdropHeight(opts) / 2,
      additionalAngle: centerPointLabels ? PI / valueCount : 0
    };
    let area;
    for (let i2 = 0; i2 < valueCount; i2++) {
      itemOpts.padding = padding[i2];
      itemOpts.size = labelSizes[i2];
      const item = createPointLabelItem(scale, i2, itemOpts);
      items.push(item);
      if (display === "auto") {
        item.visible = isNotOverlapped(item, area);
        if (item.visible) {
          area = item;
        }
      }
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x2, w3, align) {
    if (align === "right") {
      x2 -= w3;
    } else if (align === "center") {
      x2 -= w3 / 2;
    }
    return x2;
  }
  function yForAngle(y3, h3, angle) {
    if (angle === 90 || angle === 270) {
      y3 -= h3 / 2;
    } else if (angle > 270 || angle < 90) {
      y3 -= h3;
    }
    return y3;
  }
  function drawPointLabelBox(ctx, opts, item) {
    const { left, top, right, bottom } = item;
    const { backdropColor } = opts;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(opts.borderRadius);
      const padding = toPadding(opts.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v3) => v3 !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i2 = labelCount - 1; i2 >= 0; i2--) {
      const item = scale._pointLabelItems[i2];
      if (!item.visible) {
        continue;
      }
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i2));
      drawPointLabelBox(ctx, optsAtIndex, item);
      const plFont = toFont(optsAtIndex.font);
      const { x: x2, y: y3, textAlign } = item;
      renderText(ctx, scale._pointLabels[i2], x2, y3 + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i2 = 1; i2 < labelCount; i2++) {
        pointPosition = scale.getPointPosition(i2, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash || []);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index2, label) {
    return createContext(parent, {
      label,
      index: index2,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    static id = "radialLinear";
    static defaults = {
      display: true,
      animate: true,
      position: "chartArea",
      angleLines: {
        display: true,
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0
      },
      grid: {
        circular: false
      },
      startAngle: 0,
      ticks: {
        showLabelBackdrop: true,
        callback: Ticks.formatters.numeric
      },
      pointLabels: {
        backdropColor: void 0,
        backdropPadding: 2,
        display: true,
        font: {
          size: 10
        },
        callback(label) {
          return label;
        },
        padding: 5,
        centerPointLabels: false
      }
    };
    static defaultRoutes = {
      "angleLines.color": "borderColor",
      "pointLabels.color": "color",
      "ticks.color": "color"
    };
    static descriptors = {
      angleLines: {
        _fallback: "grid"
      }
    };
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w3 = this.width = this.maxWidth - padding.width;
      const h3 = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w3 / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h3 / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w3, h3) / 2);
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(false);
      this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
      this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index2) => {
        const label = callback(this.options.pointLabels.callback, [
          value,
          index2
        ], this);
        return label || label === 0 ? label : "";
      }).filter((v3, i2) => this.chart.getDataVisibility(i2));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index2) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index2) {
      const pointLabels = this._pointLabels || [];
      if (index2 >= 0 && index2 < pointLabels.length) {
        const pointLabel = pointLabels[index2];
        return createPointLabelContext(this.getContext(), index2, pointLabel);
      }
    }
    getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index2, value) {
      return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index2) {
      return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index2) {
      const { left, top, right, bottom } = this._pointLabelItems[index2];
      return {
        left,
        top,
        right,
        bottom
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid, border } = opts;
      const labelCount = this._pointLabels.length;
      let i2, offset, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index2) => {
          if (index2 !== 0 || index2 === 0 && this.min < 0) {
            offset = this.getDistanceFromCenterForValue(tick.value);
            const context = this.getContext(index2);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i2 = labelCount - 1; i2 >= 0; i2--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
          position = this.getPointPosition(i2, offset);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index2) => {
        if (index2 === 0 && this.min >= 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index2));
        const tickFont = toFont(optsAtIndex.font);
        offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset, tickFont, {
          color: optsAtIndex.color,
          strokeColor: optsAtIndex.textStrokeColor,
          strokeWidth: optsAtIndex.textStrokeWidth
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  };
  var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
  function sorter(a2, b3) {
    return a2 - b3;
  }
  function parse(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round2, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round2) {
      value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
      const interval = INTERVALS[UNITS[i2]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
        return UNITS[i2];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
      const unit = UNITS[i2];
      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
      if (INTERVALS[UNITS[i2]].common) {
        return UNITS[i2];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index2;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index2 = map3[major];
      if (index2 >= 0) {
        ticks[index2].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i2, value;
    for (i2 = 0; i2 < ilen; ++i2) {
      value = values[i2];
      map3[value] = i2;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
  }
  var TimeScale = class extends Scale {
    static id = "time";
    static defaults = {
      bounds: "data",
      adapters: {},
      time: {
        parser: false,
        unit: false,
        round: false,
        isoWeekday: false,
        minUnit: "millisecond",
        displayFormats: {}
      },
      ticks: {
        source: "auto",
        callback: false,
        major: {
          enabled: false
        }
      }
    };
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw2, index2) {
      if (raw2 === void 0) {
        return null;
      }
      return parse(this, raw2);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min = Math.min(min, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max = Math.max(max, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
      max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min, max - 1);
      this.max = Math.max(min + 1, max);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min = Number.POSITIVE_INFINITY;
      let max = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min = arr[0];
        max = arr[arr.length - 1];
      }
      return {
        min,
        max
      };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min = this.min;
      const max = this.max;
      const ticks = _filterBetween(timestamps, min, max);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps = []) {
      let start3 = 0;
      let end = 0;
      let first, last;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start3 = 1 - first;
        } else {
          start3 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end = last;
        } else {
          end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start3 = _limitValue(start3, 0, limit);
      end = _limitValue(end, 0, limit);
      this._offsets = {
        start: start3,
        end,
        factor: 1 / (start3 + 1 + end)
      };
    }
    _generate() {
      const adapter = this._adapter;
      const min = this.min;
      const max = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
      const stepSize = valueOrDefault(options.ticks.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first = min;
      let time, count;
      if (hasWeekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, hasWeekday ? "day" : minor);
      if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
        throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort(sorter).map((x2) => +x2);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const fmt = format || formats[unit];
      return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index2, ticks, format) {
      const options = this.options;
      const formatter = options.ticks.callback;
      if (formatter) {
        return callback(formatter, [
          time,
          index2,
          ticks
        ], this);
      }
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index2];
      const major = majorUnit && majorFormat && tick && tick.major;
      return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
      let i2, ilen, tick;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
        tick = ticks[i2];
        tick.label = this._tickFormatFunction(tick.value, i2, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
        exampleTime
      ], this._majorUnit), format);
      const size2 = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size2.w : this.height / size2.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i2, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
        timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i2, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
        timestamps.push(parse(this, labels[i2]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  function interpolate2(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    static id = "timeseries";
    static defaults = TimeScale.defaults;
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate2(table, this.min);
      this._tableRange = interpolate2(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min, max } = this;
      const items = [];
      const table = [];
      let i2, ilen, prev, curr, next;
      for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
        curr = timestamps[i2];
        if (curr >= min && curr <= max) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          {
            time: min,
            pos: 0
          },
          {
            time: max,
            pos: 1
          }
        ];
      }
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        next = items[i2 + 1];
        prev = items[i2 - 1];
        curr = items[i2];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i2 / (ilen - 1)
          });
        }
      }
      return table;
    }
    _generate() {
      const min = this.min;
      const max = this.max;
      let timestamps = super.getDataTimestamps();
      if (!timestamps.includes(min) || !timestamps.length) {
        timestamps.splice(0, 0, min);
      }
      if (!timestamps.includes(max) || timestamps.length === 1) {
        timestamps.push(max);
      }
      return timestamps.sort((a2, b3) => a2 - b3);
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data2 = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data2.length && label.length) {
        timestamps = this.normalize(data2.concat(label));
      } else {
        timestamps = data2.length ? data2 : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // node_modules/chart.js/auto/auto.js
  Chart.register(...registerables);
  var auto_default = Chart;

  // lib/lesli_assets_js/application.js
  var import_lesli_chart = __toESM(require_lesli_chart());
  var import_browser = __toESM(require_browser2());

  // node_modules/@37signals/lexxy/dist/lexxy.esm.js
  var import_prismjs4 = __toESM(require_prism(), 1);

  // node_modules/prismjs/components/prism-clike.js
  Prism.languages.clike = {
    "comment": [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
  };

  // node_modules/prismjs/components/prism-markup.js
  Prism.languages.markup = {
    "comment": {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    "prolog": {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    "doctype": {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        "string": {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        "punctuation": /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        "name": /[^\s<>'"]+/
      }
    },
    "cdata": {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    "tag": {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        "tag": {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            "punctuation": /^<\/?/,
            "namespace": /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: true
              }
            ]
          }
        },
        "punctuation": /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            "namespace": /^[^\s>\/:]+:/
          }
        }
      }
    },
    "entity": [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };
  Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
  Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
  Prism.hooks.add("wrap", function(env) {
    if (env.type === "entity") {
      env.attributes["title"] = env.content.replace(/&amp;/, "&");
    }
  });
  Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function addInlined(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism.languages[lang]
      };
      includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[lang]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return tagName;
        }), "i"),
        lookbehind: true,
        greedy: true,
        inside
      };
      Prism.languages.insertBefore("markup", "cdata", def);
    }
  });
  Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(attrName, lang) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: true,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              "value": {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [lang, "language-" + lang],
                inside: Prism.languages[lang]
              },
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  });
  Prism.languages.html = Prism.languages.markup;
  Prism.languages.mathml = Prism.languages.markup;
  Prism.languages.svg = Prism.languages.markup;
  Prism.languages.xml = Prism.languages.extend("markup", {});
  Prism.languages.ssml = Prism.languages.xml;
  Prism.languages.atom = Prism.languages.xml;
  Prism.languages.rss = Prism.languages.xml;

  // node_modules/prismjs/components/prism-markup-templating.js
  (function(Prism3) {
    function getPlaceholder(language, index2) {
      return "___" + language.toUpperCase() + index2 + "___";
    }
    Object.defineProperties(Prism3.languages["markup-templating"] = {}, {
      buildPlaceholders: {
        /**
         * Tokenize all inline templating expressions matching `placeholderPattern`.
         *
         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
         * `true` will be replaced.
         *
         * @param {object} env The environment of the `before-tokenize` hook.
         * @param {string} language The language id.
         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
         * @param {(match: string) => boolean} [replaceFilter]
         */
        value: function(env, language, placeholderPattern, replaceFilter) {
          if (env.language !== language) {
            return;
          }
          var tokenStack = env.tokenStack = [];
          env.code = env.code.replace(placeholderPattern, function(match) {
            if (typeof replaceFilter === "function" && !replaceFilter(match)) {
              return match;
            }
            var i2 = tokenStack.length;
            var placeholder;
            while (env.code.indexOf(placeholder = getPlaceholder(language, i2)) !== -1) {
              ++i2;
            }
            tokenStack[i2] = match;
            return placeholder;
          });
          env.grammar = Prism3.languages.markup;
        }
      },
      tokenizePlaceholders: {
        /**
         * Replace placeholders with proper tokens after tokenizing.
         *
         * @param {object} env The environment of the `after-tokenize` hook.
         * @param {string} language The language id.
         */
        value: function(env, language) {
          if (env.language !== language || !env.tokenStack) {
            return;
          }
          env.grammar = Prism3.languages[language];
          var j2 = 0;
          var keys = Object.keys(env.tokenStack);
          function walkTokens(tokens) {
            for (var i2 = 0; i2 < tokens.length; i2++) {
              if (j2 >= keys.length) {
                break;
              }
              var token = tokens[i2];
              if (typeof token === "string" || token.content && typeof token.content === "string") {
                var k2 = keys[j2];
                var t2 = env.tokenStack[k2];
                var s2 = typeof token === "string" ? token : token.content;
                var placeholder = getPlaceholder(language, k2);
                var index2 = s2.indexOf(placeholder);
                if (index2 > -1) {
                  ++j2;
                  var before = s2.substring(0, index2);
                  var middle = new Prism3.Token(language, Prism3.tokenize(t2, env.grammar), "language-" + language, t2);
                  var after = s2.substring(index2 + placeholder.length);
                  var replacement = [];
                  if (before) {
                    replacement.push.apply(replacement, walkTokens([before]));
                  }
                  replacement.push(middle);
                  if (after) {
                    replacement.push.apply(replacement, walkTokens([after]));
                  }
                  if (typeof token === "string") {
                    tokens.splice.apply(tokens, [i2, 1].concat(replacement));
                  } else {
                    token.content = replacement;
                  }
                }
              } else if (token.content) {
                walkTokens(token.content);
              }
            }
            return tokens;
          }
          walkTokens(env.tokens);
        }
      }
    });
  })(Prism);

  // node_modules/prismjs/components/prism-ruby.js
  (function(Prism3) {
    Prism3.languages.ruby = Prism3.languages.extend("clike", {
      "comment": {
        pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
      "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
      "punctuation": /[(){}[\].,;]/
    });
    Prism3.languages.insertBefore("ruby", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    });
    var interpolation = {
      pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
      lookbehind: true,
      inside: {
        "content": {
          pattern: /^(#\{)[\s\S]+(?=\}$)/,
          lookbehind: true,
          inside: Prism3.languages.ruby
        },
        "delimiter": {
          pattern: /^#\{|\}$/,
          alias: "punctuation"
        }
      }
    };
    delete Prism3.languages.ruby.function;
    var percentExpression = "(?:" + [
      /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
      /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
      /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
      /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
      /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
    ].join("|") + ")";
    var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
    Prism3.languages.insertBefore("ruby", "keyword", {
      "regex-literal": [
        {
          pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "regex": /[\s\S]+/
          }
        },
        {
          pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
          lookbehind: true,
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "regex": /[\s\S]+/
          }
        }
      ],
      "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
      "symbol": [
        {
          pattern: RegExp(/(^|[^:]):/.source + symbolName),
          lookbehind: true,
          greedy: true
        },
        {
          pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
          lookbehind: true,
          greedy: true
        }
      ],
      "method-definition": {
        pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
        lookbehind: true,
        inside: {
          "function": /\b\w+$/,
          "keyword": /^self\b/,
          "class-name": /^\w+/,
          "punctuation": /\./
        }
      }
    });
    Prism3.languages.insertBefore("ruby", "string", {
      "string-literal": [
        {
          pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "string": /[\s\S]+/
          }
        },
        {
          pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "string": /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: true,
          inside: {
            "delimiter": {
              pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
              inside: {
                "symbol": /\b\w+/,
                "punctuation": /^<<[-~]?/
              }
            },
            "interpolation": interpolation,
            "string": /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: true,
          inside: {
            "delimiter": {
              pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
              inside: {
                "symbol": /\b\w+/,
                "punctuation": /^<<[-~]?'|'$/
              }
            },
            "string": /[\s\S]+/
          }
        }
      ],
      "command-literal": [
        {
          pattern: RegExp(/%x/.source + percentExpression),
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "command": {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        },
        {
          pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "command": {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        }
      ]
    });
    delete Prism3.languages.ruby.string;
    Prism3.languages.insertBefore("ruby", "number", {
      "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
      "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
    });
    Prism3.languages.rb = Prism3.languages.ruby;
  })(Prism);

  // node_modules/prismjs/components/prism-php.js
  (function(Prism3) {
    var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
    var constant = [
      {
        pattern: /\b(?:false|true)\b/i,
        alias: "boolean"
      },
      {
        pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
        greedy: true,
        lookbehind: true
      },
      /\b(?:null)\b/i,
      /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
    ];
    var number = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
    var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
    var punctuation = /[{}\[\](),:;]/;
    Prism3.languages.php = {
      "delimiter": {
        pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
        alias: "important"
      },
      "comment": comment,
      "variable": /\$+(?:\w+\b|(?=\{))/,
      "package": {
        pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      "class-name-definition": {
        pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
        lookbehind: true,
        alias: "class-name"
      },
      "function-definition": {
        pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
        lookbehind: true,
        alias: "function"
      },
      "keyword": [
        {
          pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
          alias: "type-casting",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
          alias: "type-hint",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
          alias: "return-type",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
          alias: "type-declaration",
          greedy: true
        },
        {
          pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
          alias: "type-declaration",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /\b(?:parent|self|static)(?=\s*::)/i,
          alias: "static-context",
          greedy: true
        },
        {
          // yield from
          pattern: /(\byield\s+)from\b/i,
          lookbehind: true
        },
        // `class` is always a keyword unlike other keywords
        /\bclass\b/i,
        {
          // https://www.php.net/manual/en/reserved.keywords.php
          //
          // keywords cannot be preceded by "->"
          // the complex lookbehind means `(?<!(?:->|::)\s*)`
          pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
          lookbehind: true
        }
      ],
      "argument-name": {
        pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
        lookbehind: true
      },
      "class-name": [
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
          greedy: true
        },
        {
          pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
          alias: "class-name-fully-qualified",
          greedy: true,
          lookbehind: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
          alias: "class-name-fully-qualified",
          greedy: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: "class-name-fully-qualified",
          greedy: true,
          lookbehind: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*\$)/i,
          alias: "type-declaration",
          greedy: true
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-declaration"],
          greedy: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*::)/i,
          alias: "static-context",
          greedy: true
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
          alias: ["class-name-fully-qualified", "static-context"],
          greedy: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
          alias: "type-hint",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-hint"],
          greedy: true,
          lookbehind: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
          alias: "return-type",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: ["class-name-fully-qualified", "return-type"],
          greedy: true,
          lookbehind: true,
          inside: {
            "punctuation": /\\/
          }
        }
      ],
      "constant": constant,
      "function": {
        pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      "property": {
        pattern: /(->\s*)\w+/,
        lookbehind: true
      },
      "number": number,
      "operator": operator,
      "punctuation": punctuation
    };
    var string_interpolation = {
      pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
      lookbehind: true,
      inside: Prism3.languages.php
    };
    var string = [
      {
        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
        alias: "nowdoc-string",
        greedy: true,
        inside: {
          "delimiter": {
            pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              "punctuation": /^<<<'?|[';]$/
            }
          }
        }
      },
      {
        pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
        alias: "heredoc-string",
        greedy: true,
        inside: {
          "delimiter": {
            pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              "punctuation": /^<<<"?|[";]$/
            }
          },
          "interpolation": string_interpolation
        }
      },
      {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        alias: "backtick-quoted-string",
        greedy: true
      },
      {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        alias: "single-quoted-string",
        greedy: true
      },
      {
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        alias: "double-quoted-string",
        greedy: true,
        inside: {
          "interpolation": string_interpolation
        }
      }
    ];
    Prism3.languages.insertBefore("php", "variable", {
      "string": string,
      "attribute": {
        pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
        greedy: true,
        inside: {
          "attribute-content": {
            pattern: /^(#\[)[\s\S]+(?=\]$)/,
            lookbehind: true,
            // inside can appear subset of php
            inside: {
              "comment": comment,
              "string": string,
              "attribute-class-name": [
                {
                  pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                  alias: "class-name",
                  greedy: true,
                  lookbehind: true
                },
                {
                  pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                  alias: [
                    "class-name",
                    "class-name-fully-qualified"
                  ],
                  greedy: true,
                  lookbehind: true,
                  inside: {
                    "punctuation": /\\/
                  }
                }
              ],
              "constant": constant,
              "number": number,
              "operator": operator,
              "punctuation": punctuation
            }
          },
          "delimiter": {
            pattern: /^#\[|\]$/,
            alias: "punctuation"
          }
        }
      }
    });
    Prism3.hooks.add("before-tokenize", function(env) {
      if (!/<\?/.test(env.code)) {
        return;
      }
      var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
      Prism3.languages["markup-templating"].buildPlaceholders(env, "php", phpPattern);
    });
    Prism3.hooks.add("after-tokenize", function(env) {
      Prism3.languages["markup-templating"].tokenizePlaceholders(env, "php");
    });
  })(Prism);

  // node_modules/prismjs/components/prism-go.js
  Prism.languages.go = Prism.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
      lookbehind: true,
      greedy: true
    },
    "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    "boolean": /\b(?:_|false|iota|nil|true)\b/,
    "number": [
      // binary and octal integers
      /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
      // hexadecimal integers and floats
      /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
      // decimal integers and floats
      /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
    ],
    "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
  });
  Prism.languages.insertBefore("go", "string", {
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
      greedy: true
    }
  });
  delete Prism.languages.go["class-name"];

  // node_modules/prismjs/components/prism-bash.js
  (function(Prism3) {
    var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
    var commandAfterHeredoc = {
      pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
      lookbehind: true,
      alias: "punctuation",
      // this looks reasonably well in all themes
      inside: null
      // see below
    };
    var insideString = {
      "bash": commandAfterHeredoc,
      "environment": {
        pattern: RegExp("\\$" + envVars),
        alias: "constant"
      },
      "variable": [
        // [0]: Arithmetic Environment
        {
          pattern: /\$?\(\([\s\S]+?\)\)/,
          greedy: true,
          inside: {
            // If there is a $ sign at the beginning highlight $(( and )) as variable
            "variable": [
              {
                pattern: /(^\$\(\([\s\S]+)\)\)/,
                lookbehind: true
              },
              /^\$\(\(/
            ],
            "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
            // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
            "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
            // If there is no $ sign at the beginning highlight (( and )) as punctuation
            "punctuation": /\(\(?|\)\)?|,|;/
          }
        },
        // [1]: Command Substitution
        {
          pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
          greedy: true,
          inside: {
            "variable": /^\$\(|^`|\)$|`$/
          }
        },
        // [2]: Brace expansion
        {
          pattern: /\$\{[^}]+\}/,
          greedy: true,
          inside: {
            "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
            "punctuation": /[\[\]]/,
            "environment": {
              pattern: RegExp("(\\{)" + envVars),
              lookbehind: true,
              alias: "constant"
            }
          }
        },
        /\$(?:\w+|[#?*!@$])/
      ],
      // Escape sequences from echo and printf's manuals, and escaped quotes.
      "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
    };
    Prism3.languages.bash = {
      "shebang": {
        pattern: /^#!\s*\/.*/,
        alias: "important"
      },
      "comment": {
        pattern: /(^|[^"{\\$])#.*/,
        lookbehind: true
      },
      "function-name": [
        // a) function foo {
        // b) foo() {
        // c) function foo() {
        // but not “foo {”
        {
          // a) and c)
          pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
          lookbehind: true,
          alias: "function"
        },
        {
          // b)
          pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
          alias: "function"
        }
      ],
      // Highlight variable names as variables in for and select beginnings.
      "for-or-select": {
        pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
        alias: "variable",
        lookbehind: true
      },
      // Highlight variable names as variables in the left-hand part
      // of assignments (“=” and “+=”).
      "assign-left": {
        pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
        inside: {
          "environment": {
            pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        },
        alias: "variable",
        lookbehind: true
      },
      // Highlight parameter names as variables
      "parameter": {
        pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
        alias: "variable",
        lookbehind: true
      },
      "string": [
        // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
        {
          pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
          lookbehind: true,
          greedy: true,
          inside: insideString
        },
        // Here-document with quotes around the tag
        // → No expansion (so no “inside”).
        {
          pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
          lookbehind: true,
          greedy: true,
          inside: {
            "bash": commandAfterHeredoc
          }
        },
        // “Normal” string
        {
          // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
          pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
          lookbehind: true,
          greedy: true,
          inside: insideString
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
          pattern: /(^|[^$\\])'[^']*'/,
          lookbehind: true,
          greedy: true
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
          pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
          greedy: true,
          inside: {
            "entity": insideString.entity
          }
        }
      ],
      "environment": {
        pattern: RegExp("\\$?" + envVars),
        alias: "constant"
      },
      "variable": insideString.variable,
      "function": {
        pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
        lookbehind: true
      },
      "keyword": {
        pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
        lookbehind: true
      },
      // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      "builtin": {
        pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
        lookbehind: true,
        // Alias added to make those easier to distinguish from strings.
        alias: "class-name"
      },
      "boolean": {
        pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
        lookbehind: true
      },
      "file-descriptor": {
        pattern: /\B&\d\b/,
        alias: "important"
      },
      "operator": {
        // Lots of redirections here, but not just that.
        pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
        inside: {
          "file-descriptor": {
            pattern: /^\d/,
            alias: "important"
          }
        }
      },
      "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
      "number": {
        pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
        lookbehind: true
      }
    };
    commandAfterHeredoc.inside = Prism3.languages.bash;
    var toBeCopied = [
      "comment",
      "function-name",
      "for-or-select",
      "assign-left",
      "parameter",
      "string",
      "environment",
      "function",
      "keyword",
      "builtin",
      "boolean",
      "file-descriptor",
      "operator",
      "punctuation",
      "number"
    ];
    var inside = insideString.variable[1].inside;
    for (var i2 = 0; i2 < toBeCopied.length; i2++) {
      inside[toBeCopied[i2]] = Prism3.languages.bash[toBeCopied[i2]];
    }
    Prism3.languages.sh = Prism3.languages.bash;
    Prism3.languages.shell = Prism3.languages.bash;
  })(Prism);

  // node_modules/prismjs/components/prism-json.js
  Prism.languages.json = {
    "property": {
      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
      lookbehind: true,
      greedy: true
    },
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
      lookbehind: true,
      greedy: true
    },
    "comment": {
      pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: true
    },
    "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    "punctuation": /[{}[\],]/,
    "operator": /:/,
    "boolean": /\b(?:false|true)\b/,
    "null": {
      pattern: /\bnull\b/,
      alias: "keyword"
    }
  };
  Prism.languages.webmanifest = Prism.languages.json;

  // node_modules/prismjs/components/prism-diff.js
  (function(Prism3) {
    Prism3.languages.diff = {
      "coord": [
        // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
        /^(?:\*{3}|-{3}|\+{3}).*$/m,
        // Match "@@ ... @@" coord lines in unified diff.
        /^@@.*@@$/m,
        // Match coord lines in normal diff (starts with a number).
        /^\d.*$/m
      ]
      // deleted, inserted, unchanged, diff
    };
    var PREFIXES = {
      "deleted-sign": "-",
      "deleted-arrow": "<",
      "inserted-sign": "+",
      "inserted-arrow": ">",
      "unchanged": " ",
      "diff": "!"
    };
    Object.keys(PREFIXES).forEach(function(name) {
      var prefix2 = PREFIXES[name];
      var alias = [];
      if (!/^\w+$/.test(name)) {
        alias.push(/\w+/.exec(name)[0]);
      }
      if (name === "diff") {
        alias.push("bold");
      }
      Prism3.languages.diff[name] = {
        pattern: RegExp("^(?:[" + prefix2 + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
        alias,
        inside: {
          "line": {
            pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
            lookbehind: true
          },
          "prefix": {
            pattern: /[\s\S]/,
            alias: /\w+/.exec(name)[0]
          }
        }
      };
    });
    Object.defineProperty(Prism3.languages.diff, "PREFIXES", {
      value: PREFIXES
    });
  })(Prism);

  // node_modules/dompurify/dist/purify.es.mjs
  var {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  var {
    freeze,
    seal,
    create
  } = Object;
  var {
    apply,
    construct
  } = typeof Reflect !== "undefined" && Reflect;
  if (!freeze) {
    freeze = function freeze2(x2) {
      return x2;
    };
  }
  if (!seal) {
    seal = function seal2(x2) {
      return x2;
    };
  }
  if (!apply) {
    apply = function apply2(func, thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return func.apply(thisArg, args);
    };
  }
  if (!construct) {
    construct = function construct2(Func) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return new Func(...args);
    };
  }
  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var arraySplice = unapply(Array.prototype.splice);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringToString = unapply(String.prototype.toString);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      if (thisArg instanceof RegExp) {
        thisArg.lastIndex = 0;
      }
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(Func) {
    return function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return construct(Func, args);
    };
  }
  function addToSet(set4, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set4, null);
    }
    let l4 = array.length;
    while (l4--) {
      let element = array[l4];
      if (typeof element === "string") {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array)) {
            array[l4] = lcElement;
          }
          element = lcElement;
        }
      }
      set4[element] = true;
    }
    return set4;
  }
  function cleanArray(array) {
    for (let index2 = 0; index2 < array.length; index2++) {
      const isPropertyExist = objectHasOwnProperty(array, index2);
      if (!isPropertyExist) {
        array[index2] = null;
      }
    }
    return array;
  }
  function clone4(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object)) {
      const isPropertyExist = objectHasOwnProperty(object, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (value && typeof value === "object" && value.constructor === Object) {
          newObject[property] = clone4(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }
  var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  var text = freeze(["#text"]);
  var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  var IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);
  var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT,
    DATA_ATTR,
    DOCTYPE_NAME,
    ERB_EXPR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR,
    TMPLIT_EXPR
  });
  var NODE_TYPE = {
    element: 1,
    attribute: 2,
    text: 3,
    cdataSection: 4,
    entityReference: 5,
    // Deprecated
    entityNode: 6,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9,
    documentType: 10,
    documentFragment: 11,
    notation: 12
    // Deprecated
  };
  var getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html2) {
          return html2;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_3) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  var _createHooksMap = function _createHooksMap2() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify = (root) => createDOMPurify(root);
    DOMPurify.version = "3.3.1";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let {
      document: document2
    } = window2;
    const originalDocument = document2;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node: Node2,
      Element: Element3,
      NodeFilter,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser: DOMParser2,
      trustedTypes
    } = window2;
    const ElementPrototype = Element3.prototype;
    const cloneNode2 = lookupGetter(ElementPrototype, "cloneNode");
    const remove = lookupGetter(ElementPrototype, "remove");
    const getNextSibling2 = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      const template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2;
    const {
      importNode
    } = originalDocument;
    let hooks = _createHooksMap();
    DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    let FORBID_TAGS = null;
    let FORBID_ATTR = null;
    const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {
      tagCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      }
    }));
    let ALLOW_ARIA_ATTR = true;
    let ALLOW_DATA_ATTR = true;
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    let SAFE_FOR_TEMPLATES = false;
    let SAFE_FOR_XML = true;
    let WHOLE_DOCUMENT = false;
    let SET_CONFIG = false;
    let FORCE_BODY = false;
    let RETURN_DOM = false;
    let RETURN_DOM_FRAGMENT = false;
    let RETURN_TRUSTED_TYPE = false;
    let SANITIZE_DOM = true;
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = true;
    let IN_PLACE = false;
    let USE_PROFILES = {};
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    let CONFIG = null;
    const formElement = document2.createElement("form");
    const isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    const _parseConfig = function _parseConfig2() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      cfg = clone4(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone4(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone4(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone4({});
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone4({});
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (typeof cfg.ADD_TAGS === "function") {
          EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;
        } else {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone4(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
        }
      }
      if (cfg.ADD_ATTR) {
        if (typeof cfg.ADD_ATTR === "function") {
          EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;
        } else {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone4(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
        }
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone4(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (cfg.ADD_FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone4(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        if (trustedTypesPolicy === void 0) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    const _checkValidNamespace = function _checkValidNamespace2(element) {
      let parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: "template"
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      }
      return false;
    };
    const _forceRemove = function _forceRemove2(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });
      try {
        getParentNode(node).removeChild(node);
      } catch (_3) {
        remove(node);
      }
    };
    const _removeAttribute = function _removeAttribute2(name, element) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element.getAttributeNode(name),
          from: element
        });
      } catch (_3) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element
        });
      }
      element.removeAttribute(name);
      if (name === "is") {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element);
          } catch (_3) {
          }
        } else {
          try {
            element.setAttribute(name, "");
          } catch (_3) {
          }
        }
      }
    };
    const _initDocument = function _initDocument2(dirty) {
      let doc = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        const matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_3) {
        }
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_3) {
        }
      }
      const body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    const _createNodeIterator = function _createNodeIterator2(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    };
    const _isClobbered = function _isClobbered2(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
    };
    const _isNode = function _isNode2(value) {
      return typeof Node2 === "function" && value instanceof Node2;
    };
    function _executeHooks(hooks2, currentNode, data2) {
      arrayForEach(hooks2, (hook) => {
        hook.call(DOMPurify, currentNode, data2, CONFIG);
      });
    }
    const _sanitizeElements = function _sanitizeElements2(currentNode) {
      let content = null;
      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      const tagName = transformCaseFunc(currentNode.nodeName);
      _executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i2 = childCount - 1; i2 >= 0; --i2) {
              const childClone = cloneNode2(childNodes[i2], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode.insertBefore(childClone, getNextSibling2(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element3 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        content = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          content = stringReplace(content, expr, " ");
        });
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHooks(hooks.afterSanitizeElements, currentNode, null);
      return false;
    };
    const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
      else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
        ) ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if (value) {
        return false;
      } else ;
      return true;
    };
    const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    };
    const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes || _isClobbered(currentNode)) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      };
      let l4 = attributes.length;
      while (l4--) {
        const attr = attributes[l4];
        const {
          name,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name);
        const initValue = attrValue;
        let value = name === "value" ? initValue : stringTrim(initValue);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (lcName === "attributename" && stringMatch(value, "href")) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        if (!hookEvent.keepAttr) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            value = stringReplace(value, expr, " ");
          });
        }
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI) ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
              case "TrustedScriptURL": {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
            }
          }
        }
        if (value !== initValue) {
          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              currentNode.setAttribute(name, value);
            }
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
            } else {
              arrayPop(DOMPurify.removed);
            }
          } catch (_3) {
            _removeAttribute(name, currentNode);
          }
        }
      }
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
        _sanitizeElements(shadowNode);
        _sanitizeAttributes(shadowNode);
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
      }
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    DOMPurify.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node2) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        _sanitizeElements(currentNode);
        _sanitizeAttributes(currentNode);
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
      }
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint, hookFunction) {
      if (hookFunction !== void 0) {
        const index2 = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index2 === -1 ? void 0 : arraySplice(hooks[entryPoint], index2, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    };
    DOMPurify.removeHooks = function(entryPoint) {
      hooks[entryPoint] = [];
    };
    DOMPurify.removeAllHooks = function() {
      hooks = _createHooksMap();
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();

  // node_modules/@lexical/selection/LexicalSelection.dev.mjs
  var LexicalSelection_dev_exports = {};
  __export(LexicalSelection_dev_exports, {
    $addNodeStyle: () => $addNodeStyle,
    $cloneWithProperties: () => $cloneWithProperties2,
    $copyBlockFormatIndent: () => $copyBlockFormatIndent,
    $ensureForwardRangeSelection: () => $ensureForwardRangeSelection,
    $forEachSelectedTextNode: () => $forEachSelectedTextNode,
    $getComputedStyleForElement: () => $getComputedStyleForElement,
    $getComputedStyleForParent: () => $getComputedStyleForParent,
    $getSelectionStyleValueForProperty: () => $getSelectionStyleValueForProperty,
    $isAtNodeEnd: () => $isAtNodeEnd,
    $isParentElementRTL: () => $isParentElementRTL,
    $isParentRTL: () => $isParentRTL,
    $moveCaretSelection: () => $moveCaretSelection,
    $moveCharacter: () => $moveCharacter,
    $patchStyleText: () => $patchStyleText,
    $selectAll: () => $selectAll2,
    $setBlocksType: () => $setBlocksType,
    $shouldOverrideDefaultCharacterSelection: () => $shouldOverrideDefaultCharacterSelection,
    $sliceSelectedTextNodeContent: () => $sliceSelectedTextNodeContent,
    $trimTextContentFromAnchor: () => $trimTextContentFromAnchor,
    $wrapNodes: () => $wrapNodes,
    createDOMRange: () => createDOMRange,
    createRectsFromDOMRange: () => createRectsFromDOMRange,
    getCSSFromStyleObject: () => getCSSFromStyleObject,
    getStyleObjectFromCSS: () => getStyleObjectFromCSS,
    trimTextContentFromAnchor: () => trimTextContentFromAnchor
  });

  // node_modules/lexical/Lexical.dev.mjs
  var Lexical_dev_exports = {};
  __export(Lexical_dev_exports, {
    $addUpdateTag: () => $addUpdateTag,
    $applyNodeReplacement: () => $applyNodeReplacement,
    $caretFromPoint: () => $caretFromPoint,
    $caretRangeFromSelection: () => $caretRangeFromSelection,
    $cloneWithProperties: () => $cloneWithProperties,
    $cloneWithPropertiesEphemeral: () => $cloneWithPropertiesEphemeral,
    $comparePointCaretNext: () => $comparePointCaretNext,
    $copyNode: () => $copyNode,
    $create: () => $create,
    $createLineBreakNode: () => $createLineBreakNode,
    $createNodeSelection: () => $createNodeSelection,
    $createParagraphNode: () => $createParagraphNode,
    $createPoint: () => $createPoint,
    $createRangeSelection: () => $createRangeSelection,
    $createRangeSelectionFromDom: () => $createRangeSelectionFromDom,
    $createTabNode: () => $createTabNode,
    $createTextNode: () => $createTextNode,
    $extendCaretToRange: () => $extendCaretToRange,
    $findMatchingParent: () => $findMatchingParent,
    $getAdjacentChildCaret: () => $getAdjacentChildCaret,
    $getAdjacentNode: () => $getAdjacentNode,
    $getAdjacentSiblingOrParentSiblingCaret: () => $getAdjacentSiblingOrParentSiblingCaret,
    $getCaretInDirection: () => $getCaretInDirection,
    $getCaretRange: () => $getCaretRange,
    $getCaretRangeInDirection: () => $getCaretRangeInDirection,
    $getCharacterOffsets: () => $getCharacterOffsets,
    $getChildCaret: () => $getChildCaret,
    $getChildCaretAtIndex: () => $getChildCaretAtIndex,
    $getChildCaretOrSelf: () => $getChildCaretOrSelf,
    $getCollapsedCaretRange: () => $getCollapsedCaretRange,
    $getCommonAncestor: () => $getCommonAncestor,
    $getCommonAncestorResultBranchOrder: () => $getCommonAncestorResultBranchOrder,
    $getEditor: () => $getEditor,
    $getNearestNodeFromDOMNode: () => $getNearestNodeFromDOMNode,
    $getNearestRootOrShadowRoot: () => $getNearestRootOrShadowRoot,
    $getNodeByKey: () => $getNodeByKey,
    $getNodeByKeyOrThrow: () => $getNodeByKeyOrThrow,
    $getNodeFromDOMNode: () => $getNodeFromDOMNode,
    $getPreviousSelection: () => $getPreviousSelection,
    $getRoot: () => $getRoot,
    $getSelection: () => $getSelection,
    $getSiblingCaret: () => $getSiblingCaret,
    $getState: () => $getState,
    $getStateChange: () => $getStateChange,
    $getTextContent: () => $getTextContent,
    $getTextNodeOffset: () => $getTextNodeOffset,
    $getTextPointCaret: () => $getTextPointCaret,
    $getTextPointCaretSlice: () => $getTextPointCaretSlice,
    $getWritableNodeState: () => $getWritableNodeState,
    $hasAncestor: () => $hasAncestor,
    $hasUpdateTag: () => $hasUpdateTag,
    $insertNodes: () => $insertNodes,
    $isBlockElementNode: () => $isBlockElementNode,
    $isChildCaret: () => $isChildCaret,
    $isDecoratorNode: () => $isDecoratorNode,
    $isEditorState: () => $isEditorState,
    $isElementNode: () => $isElementNode,
    $isExtendableTextPointCaret: () => $isExtendableTextPointCaret,
    $isInlineElementOrDecoratorNode: () => $isInlineElementOrDecoratorNode,
    $isLeafNode: () => $isLeafNode,
    $isLineBreakNode: () => $isLineBreakNode,
    $isNodeCaret: () => $isNodeCaret,
    $isNodeSelection: () => $isNodeSelection,
    $isParagraphNode: () => $isParagraphNode,
    $isRangeSelection: () => $isRangeSelection,
    $isRootNode: () => $isRootNode,
    $isRootOrShadowRoot: () => $isRootOrShadowRoot,
    $isSiblingCaret: () => $isSiblingCaret,
    $isTabNode: () => $isTabNode,
    $isTextNode: () => $isTextNode,
    $isTextPointCaret: () => $isTextPointCaret,
    $isTextPointCaretSlice: () => $isTextPointCaretSlice,
    $isTokenOrSegmented: () => $isTokenOrSegmented,
    $isTokenOrTab: () => $isTokenOrTab,
    $nodesOfType: () => $nodesOfType,
    $normalizeCaret: () => $normalizeCaret,
    $normalizeSelection__EXPERIMENTAL: () => $normalizeSelection,
    $onUpdate: () => $onUpdate,
    $parseSerializedNode: () => $parseSerializedNode,
    $removeTextFromCaretRange: () => $removeTextFromCaretRange,
    $rewindSiblingCaret: () => $rewindSiblingCaret,
    $selectAll: () => $selectAll,
    $setCompositionKey: () => $setCompositionKey,
    $setPointFromCaret: () => $setPointFromCaret,
    $setSelection: () => $setSelection,
    $setSelectionFromCaretRange: () => $setSelectionFromCaretRange,
    $setState: () => $setState,
    $splitAtPointCaretNext: () => $splitAtPointCaretNext,
    $splitNode: () => $splitNode,
    $updateRangeSelectionFromCaretRange: () => $updateRangeSelectionFromCaretRange,
    ArtificialNode__DO_NOT_USE: () => ArtificialNode__DO_NOT_USE,
    BLUR_COMMAND: () => BLUR_COMMAND,
    CAN_REDO_COMMAND: () => CAN_REDO_COMMAND,
    CAN_UNDO_COMMAND: () => CAN_UNDO_COMMAND,
    CLEAR_EDITOR_COMMAND: () => CLEAR_EDITOR_COMMAND,
    CLEAR_HISTORY_COMMAND: () => CLEAR_HISTORY_COMMAND,
    CLICK_COMMAND: () => CLICK_COMMAND,
    COLLABORATION_TAG: () => COLLABORATION_TAG,
    COMMAND_PRIORITY_CRITICAL: () => COMMAND_PRIORITY_CRITICAL,
    COMMAND_PRIORITY_EDITOR: () => COMMAND_PRIORITY_EDITOR,
    COMMAND_PRIORITY_HIGH: () => COMMAND_PRIORITY_HIGH,
    COMMAND_PRIORITY_LOW: () => COMMAND_PRIORITY_LOW,
    COMMAND_PRIORITY_NORMAL: () => COMMAND_PRIORITY_NORMAL,
    CONTROLLED_TEXT_INSERTION_COMMAND: () => CONTROLLED_TEXT_INSERTION_COMMAND,
    COPY_COMMAND: () => COPY_COMMAND,
    CUT_COMMAND: () => CUT_COMMAND,
    DELETE_CHARACTER_COMMAND: () => DELETE_CHARACTER_COMMAND,
    DELETE_LINE_COMMAND: () => DELETE_LINE_COMMAND,
    DELETE_WORD_COMMAND: () => DELETE_WORD_COMMAND,
    DRAGEND_COMMAND: () => DRAGEND_COMMAND,
    DRAGOVER_COMMAND: () => DRAGOVER_COMMAND,
    DRAGSTART_COMMAND: () => DRAGSTART_COMMAND,
    DROP_COMMAND: () => DROP_COMMAND,
    DecoratorNode: () => DecoratorNode,
    ElementNode: () => ElementNode,
    FOCUS_COMMAND: () => FOCUS_COMMAND,
    FORMAT_ELEMENT_COMMAND: () => FORMAT_ELEMENT_COMMAND,
    FORMAT_TEXT_COMMAND: () => FORMAT_TEXT_COMMAND,
    HISTORIC_TAG: () => HISTORIC_TAG,
    HISTORY_MERGE_TAG: () => HISTORY_MERGE_TAG,
    HISTORY_PUSH_TAG: () => HISTORY_PUSH_TAG,
    INDENT_CONTENT_COMMAND: () => INDENT_CONTENT_COMMAND,
    INSERT_LINE_BREAK_COMMAND: () => INSERT_LINE_BREAK_COMMAND,
    INSERT_PARAGRAPH_COMMAND: () => INSERT_PARAGRAPH_COMMAND,
    INSERT_TAB_COMMAND: () => INSERT_TAB_COMMAND,
    INTERNAL_$isBlock: () => INTERNAL_$isBlock,
    IS_ALL_FORMATTING: () => IS_ALL_FORMATTING,
    IS_BOLD: () => IS_BOLD,
    IS_CODE: () => IS_CODE,
    IS_HIGHLIGHT: () => IS_HIGHLIGHT,
    IS_ITALIC: () => IS_ITALIC,
    IS_STRIKETHROUGH: () => IS_STRIKETHROUGH,
    IS_SUBSCRIPT: () => IS_SUBSCRIPT,
    IS_SUPERSCRIPT: () => IS_SUPERSCRIPT,
    IS_UNDERLINE: () => IS_UNDERLINE,
    KEY_ARROW_DOWN_COMMAND: () => KEY_ARROW_DOWN_COMMAND,
    KEY_ARROW_LEFT_COMMAND: () => KEY_ARROW_LEFT_COMMAND,
    KEY_ARROW_RIGHT_COMMAND: () => KEY_ARROW_RIGHT_COMMAND,
    KEY_ARROW_UP_COMMAND: () => KEY_ARROW_UP_COMMAND,
    KEY_BACKSPACE_COMMAND: () => KEY_BACKSPACE_COMMAND,
    KEY_DELETE_COMMAND: () => KEY_DELETE_COMMAND,
    KEY_DOWN_COMMAND: () => KEY_DOWN_COMMAND,
    KEY_ENTER_COMMAND: () => KEY_ENTER_COMMAND,
    KEY_ESCAPE_COMMAND: () => KEY_ESCAPE_COMMAND,
    KEY_MODIFIER_COMMAND: () => KEY_MODIFIER_COMMAND,
    KEY_SPACE_COMMAND: () => KEY_SPACE_COMMAND,
    KEY_TAB_COMMAND: () => KEY_TAB_COMMAND,
    LineBreakNode: () => LineBreakNode,
    MOVE_TO_END: () => MOVE_TO_END,
    MOVE_TO_START: () => MOVE_TO_START,
    NODE_STATE_KEY: () => NODE_STATE_KEY,
    OUTDENT_CONTENT_COMMAND: () => OUTDENT_CONTENT_COMMAND,
    PASTE_COMMAND: () => PASTE_COMMAND,
    PASTE_TAG: () => PASTE_TAG,
    ParagraphNode: () => ParagraphNode,
    REDO_COMMAND: () => REDO_COMMAND,
    REMOVE_TEXT_COMMAND: () => REMOVE_TEXT_COMMAND,
    RootNode: () => RootNode,
    SELECTION_CHANGE_COMMAND: () => SELECTION_CHANGE_COMMAND,
    SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,
    SELECT_ALL_COMMAND: () => SELECT_ALL_COMMAND,
    SKIP_COLLAB_TAG: () => SKIP_COLLAB_TAG,
    SKIP_DOM_SELECTION_TAG: () => SKIP_DOM_SELECTION_TAG,
    SKIP_SCROLL_INTO_VIEW_TAG: () => SKIP_SCROLL_INTO_VIEW_TAG,
    SKIP_SELECTION_FOCUS_TAG: () => SKIP_SELECTION_FOCUS_TAG,
    TEXT_TYPE_TO_FORMAT: () => TEXT_TYPE_TO_FORMAT,
    TabNode: () => TabNode,
    TextNode: () => TextNode,
    UNDO_COMMAND: () => UNDO_COMMAND,
    buildImportMap: () => buildImportMap,
    configExtension: () => configExtension,
    createCommand: () => createCommand,
    createEditor: () => createEditor,
    createSharedNodeState: () => createSharedNodeState,
    createState: () => createState,
    declarePeerDependency: () => declarePeerDependency,
    defineExtension: () => defineExtension,
    flipDirection: () => flipDirection,
    getDOMOwnerDocument: () => getDOMOwnerDocument,
    getDOMSelection: () => getDOMSelection,
    getDOMSelectionFromTarget: () => getDOMSelectionFromTarget,
    getDOMTextNode: () => getDOMTextNode,
    getEditorPropertyFromDOMNode: () => getEditorPropertyFromDOMNode,
    getNearestEditorFromDOMNode: () => getNearestEditorFromDOMNode,
    getRegisteredNode: () => getRegisteredNode,
    getRegisteredNodeOrThrow: () => getRegisteredNodeOrThrow,
    getStaticNodeConfig: () => getStaticNodeConfig,
    getTextDirection: () => getTextDirection,
    getTransformSetFromKlass: () => getTransformSetFromKlass,
    isBlockDomNode: () => isBlockDomNode,
    isCurrentlyReadOnlyMode: () => isCurrentlyReadOnlyMode,
    isDOMDocumentNode: () => isDOMDocumentNode,
    isDOMNode: () => isDOMNode,
    isDOMTextNode: () => isDOMTextNode,
    isDOMUnmanaged: () => isDOMUnmanaged,
    isDocumentFragment: () => isDocumentFragment,
    isExactShortcutMatch: () => isExactShortcutMatch,
    isHTMLAnchorElement: () => isHTMLAnchorElement,
    isHTMLElement: () => isHTMLElement,
    isInlineDomNode: () => isInlineDomNode,
    isLexicalEditor: () => isLexicalEditor,
    isModifierMatch: () => isModifierMatch,
    isSelectionCapturedInDecoratorInput: () => isSelectionCapturedInDecoratorInput,
    isSelectionWithinEditor: () => isSelectionWithinEditor,
    makeStepwiseIterator: () => makeStepwiseIterator,
    removeFromParent: () => removeFromParent,
    resetRandomKey: () => resetRandomKey,
    safeCast: () => safeCast,
    setDOMUnmanaged: () => setDOMUnmanaged,
    setNodeIndentFromDOM: () => setNodeIndentFromDOM,
    shallowMergeConfig: () => shallowMergeConfig
  });
  function formatDevErrorMessage(message) {
    throw new Error(message);
  }
  var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  var documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
  var IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
  var IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
  var CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
  var IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
  var IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  var IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);
  var IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
  var IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;
  var IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && IS_APPLE && !IS_CHROME;
  function normalizeClassNames(...classNames) {
    const rval = [];
    for (const className of classNames) {
      if (className && typeof className === "string") {
        for (const [s2] of className.matchAll(/\S+/g)) {
          rval.push(s2);
        }
      }
    }
    return rval;
  }
  var DOM_ELEMENT_TYPE = 1;
  var DOM_TEXT_TYPE = 3;
  var DOM_DOCUMENT_TYPE = 9;
  var DOM_DOCUMENT_FRAGMENT_TYPE = 11;
  var NO_DIRTY_NODES = 0;
  var HAS_DIRTY_NODES = 1;
  var FULL_RECONCILE = 2;
  var IS_NORMAL = 0;
  var IS_TOKEN = 1;
  var IS_SEGMENTED = 2;
  var IS_BOLD = 1;
  var IS_ITALIC = 1 << 1;
  var IS_STRIKETHROUGH = 1 << 2;
  var IS_UNDERLINE = 1 << 3;
  var IS_CODE = 1 << 4;
  var IS_SUBSCRIPT = 1 << 5;
  var IS_SUPERSCRIPT = 1 << 6;
  var IS_HIGHLIGHT = 1 << 7;
  var IS_LOWERCASE = 1 << 8;
  var IS_UPPERCASE = 1 << 9;
  var IS_CAPITALIZE = 1 << 10;
  var IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;
  var IS_DIRECTIONLESS = 1;
  var IS_UNMERGEABLE = 1 << 1;
  var IS_ALIGN_LEFT = 1;
  var IS_ALIGN_CENTER = 2;
  var IS_ALIGN_RIGHT = 3;
  var IS_ALIGN_JUSTIFY = 4;
  var IS_ALIGN_START = 5;
  var IS_ALIGN_END = 6;
  var NON_BREAKING_SPACE = "\xA0";
  var ZERO_WIDTH_SPACE = "\u200B";
  var COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;
  var DOUBLE_LINE_BREAK = "\n\n";
  var COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;
  var RTL = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
  var LTR = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
  var RTL_REGEX = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
  var LTR_REGEX = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
  var TEXT_TYPE_TO_FORMAT = {
    bold: IS_BOLD,
    capitalize: IS_CAPITALIZE,
    code: IS_CODE,
    highlight: IS_HIGHLIGHT,
    italic: IS_ITALIC,
    lowercase: IS_LOWERCASE,
    strikethrough: IS_STRIKETHROUGH,
    subscript: IS_SUBSCRIPT,
    superscript: IS_SUPERSCRIPT,
    underline: IS_UNDERLINE,
    uppercase: IS_UPPERCASE
  };
  var DETAIL_TYPE_TO_DETAIL = {
    directionless: IS_DIRECTIONLESS,
    unmergeable: IS_UNMERGEABLE
  };
  var ELEMENT_TYPE_TO_FORMAT = {
    center: IS_ALIGN_CENTER,
    end: IS_ALIGN_END,
    justify: IS_ALIGN_JUSTIFY,
    left: IS_ALIGN_LEFT,
    right: IS_ALIGN_RIGHT,
    start: IS_ALIGN_START
  };
  var ELEMENT_FORMAT_TO_TYPE = {
    [IS_ALIGN_CENTER]: "center",
    [IS_ALIGN_END]: "end",
    [IS_ALIGN_JUSTIFY]: "justify",
    [IS_ALIGN_LEFT]: "left",
    [IS_ALIGN_RIGHT]: "right",
    [IS_ALIGN_START]: "start"
  };
  var TEXT_MODE_TO_TYPE = {
    normal: IS_NORMAL,
    segmented: IS_SEGMENTED,
    token: IS_TOKEN
  };
  var TEXT_TYPE_TO_MODE = {
    [IS_NORMAL]: "normal",
    [IS_SEGMENTED]: "segmented",
    [IS_TOKEN]: "token"
  };
  var NODE_STATE_KEY = "$";
  var PROTOTYPE_CONFIG_METHOD = "$config";
  function $garbageCollectDetachedDecorators(editor, pendingEditorState) {
    const currentDecorators = editor._decorators;
    const pendingDecorators = editor._pendingDecorators;
    let decorators = pendingDecorators || currentDecorators;
    const nodeMap = pendingEditorState._nodeMap;
    let key;
    for (key in decorators) {
      if (!nodeMap.has(key)) {
        if (decorators === currentDecorators) {
          decorators = cloneDecorators(editor);
        }
        delete decorators[key];
      }
    }
  }
  function $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {
    let child = node.getFirstChild();
    while (child !== null) {
      const childKey = child.__key;
      if (child.__parent === parentKey) {
        if ($isElementNode(child)) {
          $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);
        }
        if (!prevNodeMap.has(childKey)) {
          dirtyNodes.delete(childKey);
        }
        nodeMapDelete.push(childKey);
      }
      child = child.getNextSibling();
    }
  }
  function $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {
    const prevNodeMap = prevEditorState._nodeMap;
    const nodeMap = editorState._nodeMap;
    const nodeMapDelete = [];
    for (const [nodeKey] of dirtyElements) {
      const node = nodeMap.get(nodeKey);
      if (node !== void 0) {
        if (!node.isAttached()) {
          if ($isElementNode(node)) {
            $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);
          }
          if (!prevNodeMap.has(nodeKey)) {
            dirtyElements.delete(nodeKey);
          }
          nodeMapDelete.push(nodeKey);
        }
      }
    }
    for (const nodeKey of nodeMapDelete) {
      nodeMap.delete(nodeKey);
    }
    for (const nodeKey of dirtyLeaves) {
      const node = nodeMap.get(nodeKey);
      if (node !== void 0 && !node.isAttached()) {
        if (!prevNodeMap.has(nodeKey)) {
          dirtyLeaves.delete(nodeKey);
        }
        nodeMap.delete(nodeKey);
      }
    }
  }
  var TEXT_MUTATION_VARIANCE = 100;
  var isProcessingMutations = false;
  var lastTextEntryTimeStamp = 0;
  function getIsProcessingMutations() {
    return isProcessingMutations;
  }
  function updateTimeStamp(event) {
    lastTextEntryTimeStamp = event.timeStamp;
  }
  function initTextEntryListener(editor) {
    if (lastTextEntryTimeStamp === 0) {
      getWindow(editor).addEventListener("textInput", updateTimeStamp, true);
    }
  }
  function isManagedLineBreak(dom, target, editor) {
    const isBR = dom.nodeName === "BR";
    const lexicalLineBreak = target.__lexicalLineBreak;
    return lexicalLineBreak && (dom === lexicalLineBreak || isBR && dom.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom, editor) !== void 0;
  }
  function getLastSelection(editor) {
    return editor.getEditorState().read(() => {
      const selection = $getSelection();
      return selection !== null ? selection.clone() : null;
    });
  }
  function $handleTextMutation(target, node, editor) {
    const domSelection = getDOMSelection(getWindow(editor));
    let anchorOffset = null;
    let focusOffset = null;
    if (domSelection !== null && domSelection.anchorNode === target) {
      anchorOffset = domSelection.anchorOffset;
      focusOffset = domSelection.focusOffset;
    }
    const text2 = target.nodeValue;
    if (text2 !== null) {
      $updateTextNodeFromDOMContent(node, text2, anchorOffset, focusOffset, false);
    }
  }
  function shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {
    if ($isRangeSelection(selection)) {
      const anchorNode = selection.anchor.getNode();
      if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {
        return false;
      }
    }
    return isDOMTextNode(targetDOM) && targetNode.isAttached();
  }
  function $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {
    for (let dom = startingDOM; dom && !isDOMUnmanaged(dom); dom = getParentElement(dom)) {
      const key = getNodeKeyFromDOMNode(dom, editor);
      if (key !== void 0) {
        const node = $getNodeByKey(key, editorState);
        if (node) {
          return $isDecoratorNode(node) || !isHTMLElement(dom) ? void 0 : [dom, node];
        }
      } else if (dom === rootElement) {
        return [rootElement, internalGetRoot(editorState)];
      }
    }
  }
  function flushMutations(editor, mutations, observer2) {
    isProcessingMutations = true;
    const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;
    try {
      updateEditorSync(editor, () => {
        const selection = $getSelection() || getLastSelection(editor);
        const badDOMTargets = /* @__PURE__ */ new Map();
        const rootElement = editor.getRootElement();
        const currentEditorState = editor._editorState;
        const blockCursorElement = editor._blockCursorElement;
        let shouldRevertSelection = false;
        let possibleTextForFirefoxPaste = "";
        for (let i2 = 0; i2 < mutations.length; i2++) {
          const mutation = mutations[i2];
          const type = mutation.type;
          const targetDOM = mutation.target;
          const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);
          if (!pair) {
            continue;
          }
          const [nodeDOM, targetNode] = pair;
          if (type === "characterData") {
            if (
              // TODO there is an edge case here if a mutation happens too quickly
              //      after text input, it may never be handled since we do not
              //      track the ignored mutations in any way
              shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)
            ) {
              $handleTextMutation(targetDOM, targetNode, editor);
            }
          } else if (type === "childList") {
            shouldRevertSelection = true;
            const addedDOMs = mutation.addedNodes;
            for (let s2 = 0; s2 < addedDOMs.length; s2++) {
              const addedDOM = addedDOMs[s2];
              const node = $getNodeFromDOMNode(addedDOM);
              const parentDOM = addedDOM.parentNode;
              if (parentDOM != null && addedDOM !== blockCursorElement && node === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {
                if (IS_FIREFOX) {
                  const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;
                  if (possibleText) {
                    possibleTextForFirefoxPaste += possibleText;
                  }
                }
                parentDOM.removeChild(addedDOM);
              }
            }
            const removedDOMs = mutation.removedNodes;
            const removedDOMsLength = removedDOMs.length;
            if (removedDOMsLength > 0) {
              let unremovedBRs = 0;
              for (let s2 = 0; s2 < removedDOMsLength; s2++) {
                const removedDOM = removedDOMs[s2];
                if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {
                  targetDOM.appendChild(removedDOM);
                  unremovedBRs++;
                }
              }
              if (removedDOMsLength !== unremovedBRs) {
                badDOMTargets.set(nodeDOM, targetNode);
              }
            }
          }
        }
        if (badDOMTargets.size > 0) {
          for (const [nodeDOM, targetNode] of badDOMTargets) {
            targetNode.reconcileObservedMutation(nodeDOM, editor);
          }
        }
        const records = observer2.takeRecords();
        if (records.length > 0) {
          for (let i2 = 0; i2 < records.length; i2++) {
            const record = records[i2];
            const addedNodes = record.addedNodes;
            const target = record.target;
            for (let s2 = 0; s2 < addedNodes.length; s2++) {
              const addedDOM = addedNodes[s2];
              const parentDOM = addedDOM.parentNode;
              if (parentDOM != null && addedDOM.nodeName === "BR" && !isManagedLineBreak(addedDOM, target, editor)) {
                parentDOM.removeChild(addedDOM);
              }
            }
          }
          observer2.takeRecords();
        }
        if (selection !== null) {
          if (shouldRevertSelection) {
            $setSelection(selection);
          }
          if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
            selection.insertRawText(possibleTextForFirefoxPaste);
          }
        }
      });
    } finally {
      isProcessingMutations = false;
    }
  }
  function flushRootMutations(editor) {
    const observer2 = editor._observer;
    if (observer2 !== null) {
      const mutations = observer2.takeRecords();
      flushMutations(editor, mutations, observer2);
    }
  }
  function initMutationObserver(editor) {
    initTextEntryListener(editor);
    editor._observer = new MutationObserver((mutations, observer2) => {
      flushMutations(editor, mutations, observer2);
    });
  }
  var StateConfig = class {
    /** The string key used when serializing this state to JSON */
    key;
    /** The parse function from the StateValueConfig passed to createState */
    parse;
    /**
     * The unparse function from the StateValueConfig passed to createState,
     * with a default that is simply a pass-through that assumes the value is
     * JSON serializable.
     */
    unparse;
    /**
     * An equality function from the StateValueConfig, with a default of
     * Object.is.
     */
    isEqual;
    /**
     * The result of `stateValueConfig.parse(undefined)`, which is computed only
     * once and used as the default value. When the current value `isEqual` to
     * the `defaultValue`, it will not be serialized to JSON.
     */
    defaultValue;
    constructor(key, stateValueConfig) {
      this.key = key;
      this.parse = stateValueConfig.parse.bind(stateValueConfig);
      this.unparse = (stateValueConfig.unparse || coerceToJSON).bind(stateValueConfig);
      this.isEqual = (stateValueConfig.isEqual || Object.is).bind(stateValueConfig);
      this.defaultValue = this.parse(void 0);
    }
  };
  // @__NO_SIDE_EFFECTS__
  function createState(key, valueConfig) {
    return new StateConfig(key, valueConfig);
  }
  function $getState(node, stateConfig, version2 = "latest") {
    const latestOrDirectNode = version2 === "latest" ? node.getLatest() : node;
    const state = latestOrDirectNode.__state;
    if (state) {
      $checkCollision(node, stateConfig, state);
      return state.getValue(stateConfig);
    }
    return stateConfig.defaultValue;
  }
  function $getStateChange(node, prevNode, stateConfig) {
    const value = $getState(node, stateConfig, "direct");
    const prevValue = $getState(prevNode, stateConfig, "direct");
    return stateConfig.isEqual(value, prevValue) ? null : [value, prevValue];
  }
  function $setState(node, stateConfig, valueOrUpdater) {
    errorOnReadOnly();
    let value;
    if (typeof valueOrUpdater === "function") {
      const latest = node.getLatest();
      const prevValue = $getState(latest, stateConfig);
      value = valueOrUpdater(prevValue);
      if (stateConfig.isEqual(prevValue, value)) {
        return latest;
      }
    } else {
      value = valueOrUpdater;
    }
    const writable = node.getWritable();
    const state = $getWritableNodeState(writable);
    $checkCollision(node, stateConfig, state);
    state.updateFromKnown(stateConfig, value);
    return writable;
  }
  function $checkCollision(node, stateConfig, state) {
    {
      const collision = state.sharedNodeState.sharedConfigMap.get(stateConfig.key);
      if (collision !== void 0 && collision !== stateConfig) {
        {
          formatDevErrorMessage(`$setState: State key collision ${JSON.stringify(stateConfig.key)} detected in ${node.constructor.name} node with type ${node.getType()} and key ${node.getKey()}. Only one StateConfig with a given key should be used on a node.`);
        }
      }
    }
  }
  function createSharedNodeState(nodeConfig) {
    const sharedConfigMap = /* @__PURE__ */ new Map();
    const flatKeys = /* @__PURE__ */ new Set();
    for (let klass = typeof nodeConfig === "function" ? nodeConfig : nodeConfig.replace; klass.prototype && klass.prototype.getType !== void 0; klass = Object.getPrototypeOf(klass)) {
      const {
        ownNodeConfig
      } = getStaticNodeConfig(klass);
      if (ownNodeConfig && ownNodeConfig.stateConfigs) {
        for (const requiredStateConfig of ownNodeConfig.stateConfigs) {
          let stateConfig;
          if ("stateConfig" in requiredStateConfig) {
            stateConfig = requiredStateConfig.stateConfig;
            if (requiredStateConfig.flat) {
              flatKeys.add(stateConfig.key);
            }
          } else {
            stateConfig = requiredStateConfig;
          }
          sharedConfigMap.set(stateConfig.key, stateConfig);
        }
      }
    }
    return {
      flatKeys,
      sharedConfigMap
    };
  }
  var NodeState = class _NodeState {
    /**
     * @internal
     *
     * Track the (versioned) node that this NodeState was created for, to
     * facilitate copy-on-write for NodeState. When a LexicalNode is cloned,
     * it will *reference* the NodeState from its prevNode. From the nextNode
     * you can continue to read state without copying, but the first $setState
     * will trigger a copy of the prevNode's NodeState with the node property
     * updated.
     */
    node;
    /**
     * @internal
     *
     * State that has already been parsed in a get state, so it is safe. (can be returned with
     * just a cast since the proof was given before).
     *
     * Note that it uses StateConfig, so in addition to (1) the CURRENT VALUE, it has access to
     * (2) the State key (3) the DEFAULT VALUE and (4) the PARSE FUNCTION
     */
    knownState;
    /**
     * @internal
     *
     * A copy of serializedNode[NODE_STATE_KEY] that is made when JSON is
     * imported but has not been parsed yet.
     *
     * It stays here until a get state requires us to parse it, and since we
     * then know the value is safe we move it to knownState.
     *
     * Note that since only string keys are used here, we can only allow this
     * state to pass-through on export or on the next version since there is
     * no known value configuration. This pass-through is to support scenarios
     * where multiple versions of the editor code are working in parallel so
     * an old version of your code doesnt erase metadata that was
     * set by a newer version of your code.
     */
    unknownState;
    /**
     * @internal
     *
     * This sharedNodeState is preserved across all instances of a given
     * node type in an editor and remains writable. It is how keys are resolved
     * to configuration.
     */
    sharedNodeState;
    /**
     * @internal
     *
     * The count of known or unknown keys in this state, ignoring the
     * intersection between the two sets.
     */
    size;
    /**
     * @internal
     */
    constructor(node, sharedNodeState, unknownState = void 0, knownState = /* @__PURE__ */ new Map(), size2 = void 0) {
      this.node = node;
      this.sharedNodeState = sharedNodeState;
      this.unknownState = unknownState;
      this.knownState = knownState;
      const {
        sharedConfigMap
      } = this.sharedNodeState;
      const computedSize = size2 !== void 0 ? size2 : computeSize(sharedConfigMap, unknownState, knownState);
      {
        if (!(size2 === void 0 || computedSize === size2)) {
          formatDevErrorMessage(`NodeState: size != computedSize (${String(size2)} != ${String(computedSize)})`);
        }
        for (const stateConfig of knownState.keys()) {
          if (!sharedConfigMap.has(stateConfig.key)) {
            formatDevErrorMessage(`NodeState: sharedConfigMap missing knownState key ${stateConfig.key}`);
          }
        }
      }
      this.size = computedSize;
    }
    /**
     * @internal
     *
     * Get the value from knownState, or parse it from unknownState
     * if it contains the given key.
     *
     * Updates the sharedConfigMap when no known state is found.
     * Updates unknownState and knownState when an unknownState is parsed.
     */
    getValue(stateConfig) {
      const known = this.knownState.get(stateConfig);
      if (known !== void 0) {
        return known;
      }
      this.sharedNodeState.sharedConfigMap.set(stateConfig.key, stateConfig);
      let parsed = stateConfig.defaultValue;
      if (this.unknownState && stateConfig.key in this.unknownState) {
        const jsonValue = this.unknownState[stateConfig.key];
        if (jsonValue !== void 0) {
          parsed = stateConfig.parse(jsonValue);
        }
        this.updateFromKnown(stateConfig, parsed);
      }
      return parsed;
    }
    /**
     * @internal
     *
     * Used only for advanced use cases, such as collab. The intent here is to
     * allow you to diff states with a more stable interface than the properties
     * of this class.
     */
    getInternalState() {
      return [this.unknownState, this.knownState];
    }
    /**
     * Encode this NodeState to JSON in the format that its node expects.
     * This returns `{[NODE_STATE_KEY]?: UnknownStateRecord}` rather than
     * `UnknownStateRecord | undefined` so that we can support flattening
     * specific entries in the future when nodes can declare what
     * their required StateConfigs are.
     */
    toJSON() {
      const state = {
        ...this.unknownState
      };
      const flatState = {};
      for (const [stateConfig, v3] of this.knownState) {
        if (stateConfig.isEqual(v3, stateConfig.defaultValue)) {
          delete state[stateConfig.key];
        } else {
          state[stateConfig.key] = stateConfig.unparse(v3);
        }
      }
      for (const key of this.sharedNodeState.flatKeys) {
        if (key in state) {
          flatState[key] = state[key];
          delete state[key];
        }
      }
      if (undefinedIfEmpty(state)) {
        flatState[NODE_STATE_KEY] = state;
      }
      return flatState;
    }
    /**
     * @internal
     *
     * A NodeState is writable when the node to update matches
     * the node associated with the NodeState. This basically
     * mirrors how the EditorState NodeMap works, but in a
     * bottom-up organization rather than a top-down organization.
     *
     * This allows us to implement the same "copy on write"
     * pattern for state, without having the state version
     * update every time the node version changes (e.g. when
     * its parent or siblings change).
     *
     * @param node The node to associate with the state
     * @returns The next writable state
     */
    getWritable(node) {
      if (this.node === node) {
        return this;
      }
      const {
        sharedNodeState,
        unknownState
      } = this;
      const nextKnownState = new Map(this.knownState);
      return new _NodeState(node, sharedNodeState, parseAndPruneNextUnknownState(sharedNodeState.sharedConfigMap, nextKnownState, unknownState), nextKnownState, this.size);
    }
    /** @internal */
    updateFromKnown(stateConfig, value) {
      const key = stateConfig.key;
      this.sharedNodeState.sharedConfigMap.set(key, stateConfig);
      const {
        knownState,
        unknownState
      } = this;
      if (!(knownState.has(stateConfig) || unknownState && key in unknownState)) {
        if (unknownState) {
          delete unknownState[key];
          this.unknownState = undefinedIfEmpty(unknownState);
        }
        this.size++;
      }
      knownState.set(stateConfig, value);
    }
    /**
     * @internal
     *
     * This is intended for advanced use cases only, such
     * as collab or dev tools.
     *
     * Update a single key value pair from unknown state,
     * parsing it if the key is known to this node. This is
     * basically like updateFromJSON, but the effect is
     * isolated to a single entry.
     *
     * @param k The string key from an UnknownStateRecord
     * @param v The unknown value from an UnknownStateRecord
     */
    updateFromUnknown(k2, v3) {
      const stateConfig = this.sharedNodeState.sharedConfigMap.get(k2);
      if (stateConfig) {
        this.updateFromKnown(stateConfig, stateConfig.parse(v3));
      } else {
        this.unknownState = this.unknownState || {};
        if (!(k2 in this.unknownState)) {
          this.size++;
        }
        this.unknownState[k2] = v3;
      }
    }
    /**
     * @internal
     *
     * Reset all existing state to default or empty values,
     * and perform any updates from the given unknownState.
     *
     * This is used when initializing a node's state from JSON,
     * or when resetting a node's state from JSON.
     *
     * @param unknownState The new state in serialized form
     */
    updateFromJSON(unknownState) {
      const {
        knownState
      } = this;
      for (const stateConfig of knownState.keys()) {
        knownState.set(stateConfig, stateConfig.defaultValue);
      }
      this.size = knownState.size;
      this.unknownState = void 0;
      if (unknownState) {
        for (const [k2, v3] of Object.entries(unknownState)) {
          this.updateFromUnknown(k2, v3);
        }
      }
    }
  };
  function $getWritableNodeState(node) {
    const writable = node.getWritable();
    const state = writable.__state ? writable.__state.getWritable(writable) : new NodeState(writable, $getSharedNodeState(writable));
    writable.__state = state;
    return state;
  }
  function $getSharedNodeState(node) {
    return node.__state ? node.__state.sharedNodeState : getRegisteredNodeOrThrow($getEditor(), node.getType()).sharedNodeState;
  }
  function $updateStateFromJSON(node, serialized) {
    const writable = node.getWritable();
    const unknownState = serialized[NODE_STATE_KEY];
    let parseState = unknownState;
    for (const k2 of $getSharedNodeState(writable).flatKeys) {
      if (k2 in serialized) {
        if (parseState === void 0 || parseState === unknownState) {
          parseState = {
            ...unknownState
          };
        }
        parseState[k2] = serialized[k2];
      }
    }
    if (writable.__state || parseState) {
      $getWritableNodeState(node).updateFromJSON(parseState);
    }
    return writable;
  }
  function nodeStatesAreEquivalent(a2, b3) {
    if (a2 === b3) {
      return true;
    }
    if (a2 && b3 && a2.size !== b3.size) {
      return false;
    }
    const keys = /* @__PURE__ */ new Set();
    return !(a2 && hasUnequalMapEntry(keys, a2, b3) || b3 && hasUnequalMapEntry(keys, b3, a2) || a2 && hasUnequalRecordEntry(keys, a2, b3) || b3 && hasUnequalRecordEntry(keys, b3, a2));
  }
  function computeSize(sharedConfigMap, unknownState, knownState) {
    let size2 = knownState.size;
    if (unknownState) {
      for (const k2 in unknownState) {
        const sharedConfig = sharedConfigMap.get(k2);
        if (!sharedConfig || !knownState.has(sharedConfig)) {
          size2++;
        }
      }
    }
    return size2;
  }
  function undefinedIfEmpty(obj) {
    if (obj) {
      for (const key in obj) {
        return obj;
      }
    }
    return void 0;
  }
  function coerceToJSON(v3) {
    return v3;
  }
  function parseAndPruneNextUnknownState(sharedConfigMap, nextKnownState, unknownState) {
    let nextUnknownState = void 0;
    if (unknownState) {
      for (const [k2, v3] of Object.entries(unknownState)) {
        const stateConfig = sharedConfigMap.get(k2);
        if (stateConfig) {
          if (!nextKnownState.has(stateConfig)) {
            nextKnownState.set(stateConfig, stateConfig.parse(v3));
          }
        } else {
          nextUnknownState = nextUnknownState || {};
          nextUnknownState[k2] = v3;
        }
      }
    }
    return nextUnknownState;
  }
  function hasUnequalMapEntry(keys, sourceState, otherState) {
    for (const [stateConfig, value] of sourceState.knownState) {
      if (keys.has(stateConfig.key)) {
        continue;
      }
      keys.add(stateConfig.key);
      const otherValue = otherState ? otherState.getValue(stateConfig) : stateConfig.defaultValue;
      if (otherValue !== value && !stateConfig.isEqual(otherValue, value)) {
        return true;
      }
    }
    return false;
  }
  function hasUnequalRecordEntry(keys, sourceState, otherState) {
    const {
      unknownState
    } = sourceState;
    const otherUnknownState = otherState ? otherState.unknownState : void 0;
    if (unknownState) {
      for (const [key, value] of Object.entries(unknownState)) {
        if (keys.has(key)) {
          continue;
        }
        keys.add(key);
        const otherValue = otherUnknownState ? otherUnknownState[key] : void 0;
        if (value !== otherValue) {
          return true;
        }
      }
    }
    return false;
  }
  function $cloneNodeState(from2, to2) {
    const state = from2.__state;
    return state && state.node === from2 ? state.getWritable(to2) : state;
  }
  function $canSimpleTextNodesBeMerged(node1, node2) {
    const node1Mode = node1.__mode;
    const node1Format = node1.__format;
    const node1Style = node1.__style;
    const node2Mode = node2.__mode;
    const node2Format = node2.__format;
    const node2Style = node2.__style;
    const node1State = node1.__state;
    const node2State = node2.__state;
    return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style) && (node1.__state === null || node1State === node2State || nodeStatesAreEquivalent(node1State, node2State));
  }
  function $mergeTextNodes(node1, node2) {
    const writableNode1 = node1.mergeWithSibling(node2);
    const normalizedNodes = getActiveEditor()._normalizedNodes;
    normalizedNodes.add(node1.__key);
    normalizedNodes.add(node2.__key);
    return writableNode1;
  }
  function $normalizeTextNode(textNode) {
    let node = textNode;
    if (node.__text === "" && node.isSimpleText() && !node.isUnmergeable()) {
      node.remove();
      return;
    }
    let previousNode;
    while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {
      if (previousNode.__text === "") {
        previousNode.remove();
      } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {
        node = $mergeTextNodes(previousNode, node);
        break;
      } else {
        break;
      }
    }
    let nextNode;
    while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {
      if (nextNode.__text === "") {
        nextNode.remove();
      } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {
        node = $mergeTextNodes(node, nextNode);
        break;
      } else {
        break;
      }
    }
  }
  function $normalizeSelection(selection) {
    $normalizePoint(selection.anchor);
    $normalizePoint(selection.focus);
    return selection;
  }
  function $normalizePoint(point) {
    while (point.type === "element") {
      const node = point.getNode();
      const offset = point.offset;
      let nextNode;
      let nextOffsetAtEnd;
      if (offset === node.getChildrenSize()) {
        nextNode = node.getChildAtIndex(offset - 1);
        nextOffsetAtEnd = true;
      } else {
        nextNode = node.getChildAtIndex(offset);
        nextOffsetAtEnd = false;
      }
      if ($isTextNode(nextNode)) {
        point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, "text", true);
        break;
      } else if (!$isElementNode(nextNode)) {
        break;
      }
      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, "element", true);
    }
  }
  var subTreeTextContent = "";
  var subTreeTextFormat = null;
  var subTreeTextStyle = "";
  var editorTextContent = "";
  var activeEditorConfig;
  var activeEditor$1;
  var activeEditorNodes;
  var treatAllNodesAsDirty = false;
  var activeEditorStateReadOnly = false;
  var activeMutationListeners;
  var activeDirtyElements;
  var activeDirtyLeaves;
  var activePrevNodeMap;
  var activeNextNodeMap;
  var activePrevKeyToDOMMap;
  var mutatedNodes;
  function destroyNode(key, parentDOM) {
    const node = activePrevNodeMap.get(key);
    if (parentDOM !== null) {
      const dom = getPrevElementByKeyOrThrow(key);
      if (dom.parentNode === parentDOM) {
        parentDOM.removeChild(dom);
      }
    }
    if (!activeNextNodeMap.has(key)) {
      activeEditor$1._keyToDOMMap.delete(key);
    }
    if ($isElementNode(node)) {
      const children = createChildrenArray(node, activePrevNodeMap);
      destroyChildren(children, 0, children.length - 1, null);
    }
    if (node !== void 0) {
      setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "destroyed");
    }
  }
  function destroyChildren(children, _startIndex, endIndex, dom) {
    let startIndex = _startIndex;
    for (; startIndex <= endIndex; ++startIndex) {
      const child = children[startIndex];
      if (child !== void 0) {
        destroyNode(child, dom);
      }
    }
  }
  function setTextAlign(domStyle, value) {
    domStyle.setProperty("text-align", value);
  }
  var DEFAULT_INDENT_VALUE = "40px";
  function setElementIndent(dom, indent) {
    const indentClassName = activeEditorConfig.theme.indent;
    if (typeof indentClassName === "string") {
      const elementHasClassName = dom.classList.contains(indentClassName);
      if (indent > 0 && !elementHasClassName) {
        dom.classList.add(indentClassName);
      } else if (indent < 1 && elementHasClassName) {
        dom.classList.remove(indentClassName);
      }
    }
    const indentationBaseValue = getComputedStyle(dom).getPropertyValue("--lexical-indent-base-value") || DEFAULT_INDENT_VALUE;
    dom.style.setProperty("padding-inline-start", indent === 0 ? "" : `calc(${indent} * ${indentationBaseValue})`);
  }
  function setElementFormat(dom, format) {
    const domStyle = dom.style;
    if (format === 0) {
      setTextAlign(domStyle, "");
    } else if (format === IS_ALIGN_LEFT) {
      setTextAlign(domStyle, "left");
    } else if (format === IS_ALIGN_CENTER) {
      setTextAlign(domStyle, "center");
    } else if (format === IS_ALIGN_RIGHT) {
      setTextAlign(domStyle, "right");
    } else if (format === IS_ALIGN_JUSTIFY) {
      setTextAlign(domStyle, "justify");
    } else if (format === IS_ALIGN_START) {
      setTextAlign(domStyle, "start");
    } else if (format === IS_ALIGN_END) {
      setTextAlign(domStyle, "end");
    }
  }
  function $getReconciledDirection(node) {
    const direction = node.__dir;
    if (direction !== null) {
      return direction;
    }
    if ($isRootNode(node)) {
      return null;
    }
    const parent = node.getParentOrThrow();
    if (!$isRootNode(parent) || parent.__dir !== null) {
      return null;
    }
    return "auto";
  }
  function $setElementDirection(dom, node) {
    const direction = $getReconciledDirection(node);
    if (direction !== null) {
      dom.dir = direction;
    } else {
      dom.removeAttribute("dir");
    }
  }
  function $createNode(key, slot) {
    const node = activeNextNodeMap.get(key);
    if (node === void 0) {
      {
        formatDevErrorMessage(`createNode: node does not exist in nodeMap`);
      }
    }
    const dom = node.createDOM(activeEditorConfig, activeEditor$1);
    storeDOMWithKey(key, dom, activeEditor$1);
    if ($isTextNode(node)) {
      dom.setAttribute("data-lexical-text", "true");
    } else if ($isDecoratorNode(node)) {
      dom.setAttribute("data-lexical-decorator", "true");
    }
    if ($isElementNode(node)) {
      const indent = node.__indent;
      const childrenSize = node.__size;
      $setElementDirection(dom, node);
      if (indent !== 0) {
        setElementIndent(dom, indent);
      }
      if (childrenSize !== 0) {
        const endIndex = childrenSize - 1;
        const children = createChildrenArray(node, activeNextNodeMap);
        $createChildren(children, node, 0, endIndex, node.getDOMSlot(dom));
      }
      const format = node.__format;
      if (format !== 0) {
        setElementFormat(dom, format);
      }
      if (!node.isInline()) {
        reconcileElementTerminatingLineBreak(null, node, dom);
      }
      if ($textContentRequiresDoubleLinebreakAtEnd(node)) {
        subTreeTextContent += DOUBLE_LINE_BREAK;
        editorTextContent += DOUBLE_LINE_BREAK;
      }
    } else {
      const text2 = node.getTextContent();
      if ($isDecoratorNode(node)) {
        const decorator = node.decorate(activeEditor$1, activeEditorConfig);
        if (decorator !== null) {
          reconcileDecorator(key, decorator);
        }
        dom.contentEditable = "false";
      }
      subTreeTextContent += text2;
      editorTextContent += text2;
    }
    if (slot !== null) {
      slot.insertChild(dom);
    }
    {
      Object.freeze(node);
    }
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "created");
    return dom;
  }
  function $createChildren(children, element, _startIndex, endIndex, slot) {
    const previousSubTreeTextContent = subTreeTextContent;
    subTreeTextContent = "";
    let startIndex = _startIndex;
    for (; startIndex <= endIndex; ++startIndex) {
      $createNode(children[startIndex], slot);
      const node = activeNextNodeMap.get(children[startIndex]);
      if (node !== null && $isTextNode(node)) {
        if (subTreeTextFormat === null) {
          subTreeTextFormat = node.getFormat();
        }
        if (subTreeTextStyle === "") {
          subTreeTextStyle = node.getStyle();
        }
      }
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(element)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
    }
    const dom = slot.element;
    dom.__lexicalTextContent = subTreeTextContent;
    subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
  }
  function isLastChildLineBreakOrDecorator(element, nodeMap) {
    if (element) {
      const lastKey = element.__last;
      if (lastKey) {
        const node = nodeMap.get(lastKey);
        if (node) {
          return $isLineBreakNode(node) ? "line-break" : $isDecoratorNode(node) && node.isInline() ? "decorator" : null;
        }
      }
      return "empty";
    }
    return null;
  }
  function reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {
    const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);
    const nextLineBreak = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);
    if (prevLineBreak !== nextLineBreak) {
      nextElement.getDOMSlot(dom).setManagedLineBreak(nextLineBreak);
    }
  }
  function reconcileTextFormat(element) {
    if (subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {
      element.setTextFormat(subTreeTextFormat);
    }
  }
  function reconcileTextStyle(element) {
    if (subTreeTextStyle !== "" && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {
      element.setTextStyle(subTreeTextStyle);
    }
  }
  function $reconcileChildrenWithDirection(prevElement, nextElement, dom) {
    subTreeTextFormat = null;
    subTreeTextStyle = "";
    $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom));
    reconcileTextFormat(nextElement);
    reconcileTextStyle(nextElement);
  }
  function createChildrenArray(element, nodeMap) {
    const children = [];
    let nodeKey = element.__first;
    while (nodeKey !== null) {
      const node = nodeMap.get(nodeKey);
      if (node === void 0) {
        {
          formatDevErrorMessage(`createChildrenArray: node does not exist in nodeMap`);
        }
      }
      children.push(nodeKey);
      nodeKey = node.__next;
    }
    return children;
  }
  function $reconcileChildren(prevElement, nextElement, slot) {
    const previousSubTreeTextContent = subTreeTextContent;
    const prevChildrenSize = prevElement.__size;
    const nextChildrenSize = nextElement.__size;
    subTreeTextContent = "";
    const dom = slot.element;
    if (prevChildrenSize === 1 && nextChildrenSize === 1) {
      const prevFirstChildKey = prevElement.__first;
      const nextFirstChildKey = nextElement.__first;
      if (prevFirstChildKey === nextFirstChildKey) {
        $reconcileNode(prevFirstChildKey, dom);
      } else {
        const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);
        const replacementDOM = $createNode(nextFirstChildKey, null);
        try {
          dom.replaceChild(replacementDOM, lastDOM);
        } catch (error2) {
          if (typeof error2 === "object" && error2 != null) {
            const msg = `${error2.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;
            throw new Error(msg);
          } else {
            throw error2;
          }
        }
        destroyNode(prevFirstChildKey, null);
      }
      const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);
      if ($isTextNode(nextChildNode)) {
        if (subTreeTextFormat === null) {
          subTreeTextFormat = nextChildNode.getFormat();
        }
        if (subTreeTextStyle === "") {
          subTreeTextStyle = nextChildNode.getStyle();
        }
      }
    } else {
      const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);
      const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);
      if (!(prevChildren.length === prevChildrenSize)) {
        formatDevErrorMessage(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);
      }
      if (!(nextChildren.length === nextChildrenSize)) {
        formatDevErrorMessage(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);
      }
      if (prevChildrenSize === 0) {
        if (nextChildrenSize !== 0) {
          $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);
        }
      } else if (nextChildrenSize === 0) {
        if (prevChildrenSize !== 0) {
          const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;
          destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);
          if (canUseFastPath) {
            dom.textContent = "";
          }
        }
      } else {
        $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);
      }
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
    }
    dom.__lexicalTextContent = subTreeTextContent;
    subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
  }
  function $reconcileNode(key, parentDOM) {
    const prevNode = activePrevNodeMap.get(key);
    let nextNode = activeNextNodeMap.get(key);
    if (prevNode === void 0 || nextNode === void 0) {
      {
        formatDevErrorMessage(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);
      }
    }
    const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);
    const dom = getElementByKeyOrThrow(activeEditor$1, key);
    if (prevNode === nextNode && !isDirty) {
      if ($isElementNode(prevNode)) {
        const previousSubTreeTextContent = dom.__lexicalTextContent;
        if (previousSubTreeTextContent !== void 0) {
          subTreeTextContent += previousSubTreeTextContent;
          editorTextContent += previousSubTreeTextContent;
        }
      } else {
        const text2 = prevNode.getTextContent();
        editorTextContent += text2;
        subTreeTextContent += text2;
      }
      return dom;
    }
    if (prevNode !== nextNode && isDirty) {
      setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, "updated");
    }
    if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {
      const replacementDOM = $createNode(key, null);
      if (parentDOM === null) {
        {
          formatDevErrorMessage(`reconcileNode: parentDOM is null`);
        }
      }
      parentDOM.replaceChild(replacementDOM, dom);
      destroyNode(key, null);
      return replacementDOM;
    }
    if ($isElementNode(prevNode) && $isElementNode(nextNode)) {
      const nextIndent = nextNode.__indent;
      if (treatAllNodesAsDirty || nextIndent !== prevNode.__indent) {
        setElementIndent(dom, nextIndent);
      }
      const nextFormat = nextNode.__format;
      if (treatAllNodesAsDirty || nextFormat !== prevNode.__format) {
        setElementFormat(dom, nextFormat);
      }
      if (isDirty) {
        $reconcileChildrenWithDirection(prevNode, nextNode, dom);
        if (!$isRootNode(nextNode) && !nextNode.isInline()) {
          reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);
        }
      }
      if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {
        subTreeTextContent += DOUBLE_LINE_BREAK;
        editorTextContent += DOUBLE_LINE_BREAK;
      }
      if (treatAllNodesAsDirty || nextNode.__dir !== prevNode.__dir) {
        $setElementDirection(dom, nextNode);
        if (
          // Root node direction changing from set to unset (or vice versa)
          // changes how children's direction is calculated.
          $isRootNode(nextNode) && // Can skip if all children already reconciled.
          !treatAllNodesAsDirty
        ) {
          for (const child of nextNode.getChildren()) {
            if ($isElementNode(child)) {
              const childDom = getElementByKeyOrThrow(activeEditor$1, child.getKey());
              $setElementDirection(childDom, child);
            }
          }
        }
      }
    } else {
      const text2 = nextNode.getTextContent();
      if ($isDecoratorNode(nextNode)) {
        const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);
        if (decorator !== null) {
          reconcileDecorator(key, decorator);
        }
      }
      subTreeTextContent += text2;
      editorTextContent += text2;
    }
    if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {
      const nextRootNode = nextNode.getWritable();
      nextRootNode.__cachedText = editorTextContent;
      nextNode = nextRootNode;
    }
    {
      Object.freeze(nextNode);
    }
    return dom;
  }
  function reconcileDecorator(key, decorator) {
    let pendingDecorators = activeEditor$1._pendingDecorators;
    const currentDecorators = activeEditor$1._decorators;
    if (pendingDecorators === null) {
      if (currentDecorators[key] === decorator) {
        return;
      }
      pendingDecorators = cloneDecorators(activeEditor$1);
    }
    pendingDecorators[key] = decorator;
  }
  function getNextSibling(element) {
    let nextSibling = element.nextSibling;
    if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {
      nextSibling = nextSibling.nextSibling;
    }
    return nextSibling;
  }
  function $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {
    const prevEndIndex = prevChildrenLength - 1;
    const nextEndIndex = nextChildrenLength - 1;
    let prevChildrenSet;
    let nextChildrenSet;
    let siblingDOM = slot.getFirstChild();
    let prevIndex = 0;
    let nextIndex = 0;
    while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {
      const prevKey = prevChildren[prevIndex];
      const nextKey = nextChildren[nextIndex];
      if (prevKey === nextKey) {
        siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));
        prevIndex++;
        nextIndex++;
      } else {
        if (prevChildrenSet === void 0) {
          prevChildrenSet = new Set(prevChildren);
        }
        if (nextChildrenSet === void 0) {
          nextChildrenSet = new Set(nextChildren);
        }
        const nextHasPrevKey = nextChildrenSet.has(prevKey);
        const prevHasNextKey = prevChildrenSet.has(nextKey);
        if (!nextHasPrevKey) {
          siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));
          destroyNode(prevKey, slot.element);
          prevIndex++;
        } else if (!prevHasNextKey) {
          $createNode(nextKey, slot.withBefore(siblingDOM));
          nextIndex++;
        } else {
          const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);
          if (childDOM === siblingDOM) {
            siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));
          } else {
            slot.withBefore(siblingDOM).insertChild(childDOM);
            $reconcileNode(nextKey, slot.element);
          }
          prevIndex++;
          nextIndex++;
        }
      }
      const node = activeNextNodeMap.get(nextKey);
      if (node !== null && $isTextNode(node)) {
        if (subTreeTextFormat === null) {
          subTreeTextFormat = node.getFormat();
        }
        if (subTreeTextStyle === "") {
          subTreeTextStyle = node.getStyle();
        }
      }
    }
    const appendNewChildren = prevIndex > prevEndIndex;
    const removeOldChildren = nextIndex > nextEndIndex;
    if (appendNewChildren && !removeOldChildren) {
      const previousNode = nextChildren[nextEndIndex + 1];
      const insertDOM = previousNode === void 0 ? null : activeEditor$1.getElementByKey(previousNode);
      $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, slot.withBefore(insertDOM));
    } else if (removeOldChildren && !appendNewChildren) {
      destroyChildren(prevChildren, prevIndex, prevEndIndex, slot.element);
    }
  }
  function $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {
    subTreeTextContent = "";
    editorTextContent = "";
    treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;
    activeEditor$1 = editor;
    activeEditorConfig = editor._config;
    activeEditorNodes = editor._nodes;
    activeMutationListeners = activeEditor$1._listeners.mutation;
    activeDirtyElements = dirtyElements;
    activeDirtyLeaves = dirtyLeaves;
    activePrevNodeMap = prevEditorState._nodeMap;
    activeNextNodeMap = nextEditorState._nodeMap;
    activeEditorStateReadOnly = nextEditorState._readOnly;
    activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);
    const currentMutatedNodes = /* @__PURE__ */ new Map();
    mutatedNodes = currentMutatedNodes;
    $reconcileNode("root", null);
    activeEditor$1 = void 0;
    activeEditorNodes = void 0;
    activeDirtyElements = void 0;
    activeDirtyLeaves = void 0;
    activePrevNodeMap = void 0;
    activeNextNodeMap = void 0;
    activeEditorConfig = void 0;
    activePrevKeyToDOMMap = void 0;
    mutatedNodes = void 0;
    return currentMutatedNodes;
  }
  function storeDOMWithKey(key, dom, editor) {
    const keyToDOMMap = editor._keyToDOMMap;
    setNodeKeyOnDOMNode(dom, editor, key);
    keyToDOMMap.set(key, dom);
  }
  function getPrevElementByKeyOrThrow(key) {
    const element = activePrevKeyToDOMMap.get(key);
    if (element === void 0) {
      {
        formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key}`);
      }
    }
    return element;
  }
  function warnOnlyOnce(message) {
    {
      let run = false;
      return () => {
        if (!run) {
          console.warn(message);
        }
        run = true;
      };
    }
  }
  // @__NO_SIDE_EFFECTS__
  function createCommand(type) {
    return {
      type
    };
  }
  var SELECTION_CHANGE_COMMAND = /* @__PURE__ */ createCommand("SELECTION_CHANGE_COMMAND");
  var SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = /* @__PURE__ */ createCommand("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND");
  var CLICK_COMMAND = /* @__PURE__ */ createCommand("CLICK_COMMAND");
  var DELETE_CHARACTER_COMMAND = /* @__PURE__ */ createCommand("DELETE_CHARACTER_COMMAND");
  var INSERT_LINE_BREAK_COMMAND = /* @__PURE__ */ createCommand("INSERT_LINE_BREAK_COMMAND");
  var INSERT_PARAGRAPH_COMMAND = /* @__PURE__ */ createCommand("INSERT_PARAGRAPH_COMMAND");
  var CONTROLLED_TEXT_INSERTION_COMMAND = /* @__PURE__ */ createCommand("CONTROLLED_TEXT_INSERTION_COMMAND");
  var PASTE_COMMAND = /* @__PURE__ */ createCommand("PASTE_COMMAND");
  var REMOVE_TEXT_COMMAND = /* @__PURE__ */ createCommand("REMOVE_TEXT_COMMAND");
  var DELETE_WORD_COMMAND = /* @__PURE__ */ createCommand("DELETE_WORD_COMMAND");
  var DELETE_LINE_COMMAND = /* @__PURE__ */ createCommand("DELETE_LINE_COMMAND");
  var FORMAT_TEXT_COMMAND = /* @__PURE__ */ createCommand("FORMAT_TEXT_COMMAND");
  var UNDO_COMMAND = /* @__PURE__ */ createCommand("UNDO_COMMAND");
  var REDO_COMMAND = /* @__PURE__ */ createCommand("REDO_COMMAND");
  var KEY_DOWN_COMMAND = /* @__PURE__ */ createCommand("KEYDOWN_COMMAND");
  var KEY_ARROW_RIGHT_COMMAND = /* @__PURE__ */ createCommand("KEY_ARROW_RIGHT_COMMAND");
  var MOVE_TO_END = /* @__PURE__ */ createCommand("MOVE_TO_END");
  var KEY_ARROW_LEFT_COMMAND = /* @__PURE__ */ createCommand("KEY_ARROW_LEFT_COMMAND");
  var MOVE_TO_START = /* @__PURE__ */ createCommand("MOVE_TO_START");
  var KEY_ARROW_UP_COMMAND = /* @__PURE__ */ createCommand("KEY_ARROW_UP_COMMAND");
  var KEY_ARROW_DOWN_COMMAND = /* @__PURE__ */ createCommand("KEY_ARROW_DOWN_COMMAND");
  var KEY_ENTER_COMMAND = /* @__PURE__ */ createCommand("KEY_ENTER_COMMAND");
  var KEY_SPACE_COMMAND = /* @__PURE__ */ createCommand("KEY_SPACE_COMMAND");
  var KEY_BACKSPACE_COMMAND = /* @__PURE__ */ createCommand("KEY_BACKSPACE_COMMAND");
  var KEY_ESCAPE_COMMAND = /* @__PURE__ */ createCommand("KEY_ESCAPE_COMMAND");
  var KEY_DELETE_COMMAND = /* @__PURE__ */ createCommand("KEY_DELETE_COMMAND");
  var KEY_TAB_COMMAND = /* @__PURE__ */ createCommand("KEY_TAB_COMMAND");
  var INSERT_TAB_COMMAND = /* @__PURE__ */ createCommand("INSERT_TAB_COMMAND");
  var INDENT_CONTENT_COMMAND = /* @__PURE__ */ createCommand("INDENT_CONTENT_COMMAND");
  var OUTDENT_CONTENT_COMMAND = /* @__PURE__ */ createCommand("OUTDENT_CONTENT_COMMAND");
  var DROP_COMMAND = /* @__PURE__ */ createCommand("DROP_COMMAND");
  var FORMAT_ELEMENT_COMMAND = /* @__PURE__ */ createCommand("FORMAT_ELEMENT_COMMAND");
  var DRAGSTART_COMMAND = /* @__PURE__ */ createCommand("DRAGSTART_COMMAND");
  var DRAGOVER_COMMAND = /* @__PURE__ */ createCommand("DRAGOVER_COMMAND");
  var DRAGEND_COMMAND = /* @__PURE__ */ createCommand("DRAGEND_COMMAND");
  var COPY_COMMAND = /* @__PURE__ */ createCommand("COPY_COMMAND");
  var CUT_COMMAND = /* @__PURE__ */ createCommand("CUT_COMMAND");
  var SELECT_ALL_COMMAND = /* @__PURE__ */ createCommand("SELECT_ALL_COMMAND");
  var CLEAR_EDITOR_COMMAND = /* @__PURE__ */ createCommand("CLEAR_EDITOR_COMMAND");
  var CLEAR_HISTORY_COMMAND = /* @__PURE__ */ createCommand("CLEAR_HISTORY_COMMAND");
  var CAN_REDO_COMMAND = /* @__PURE__ */ createCommand("CAN_REDO_COMMAND");
  var CAN_UNDO_COMMAND = /* @__PURE__ */ createCommand("CAN_UNDO_COMMAND");
  var FOCUS_COMMAND = /* @__PURE__ */ createCommand("FOCUS_COMMAND");
  var BLUR_COMMAND = /* @__PURE__ */ createCommand("BLUR_COMMAND");
  var KEY_MODIFIER_COMMAND = /* @__PURE__ */ createCommand("KEY_MODIFIER_COMMAND");
  var PASS_THROUGH_COMMAND = Object.freeze({});
  var ANDROID_COMPOSITION_LATENCY = 30;
  var rootElementEvents = [["keydown", onKeyDown], ["pointerdown", onPointerDown], ["compositionstart", onCompositionStart], ["compositionend", onCompositionEnd], ["input", onInput], ["click", onClick], ["cut", PASS_THROUGH_COMMAND], ["copy", PASS_THROUGH_COMMAND], ["dragstart", PASS_THROUGH_COMMAND], ["dragover", PASS_THROUGH_COMMAND], ["dragend", PASS_THROUGH_COMMAND], ["paste", PASS_THROUGH_COMMAND], ["focus", PASS_THROUGH_COMMAND], ["blur", PASS_THROUGH_COMMAND], ["drop", PASS_THROUGH_COMMAND]];
  if (CAN_USE_BEFORE_INPUT) {
    rootElementEvents.push(["beforeinput", (event, editor) => onBeforeInput(event, editor)]);
  }
  var lastKeyDownTimeStamp = 0;
  var lastKeyCode = null;
  var lastBeforeInputInsertTextTimeStamp = 0;
  var unprocessedBeforeInputData = null;
  var rootElementToDocument = /* @__PURE__ */ new WeakMap();
  var rootElementsRegistered = /* @__PURE__ */ new WeakMap();
  var isSelectionChangeFromDOMUpdate = false;
  var isSelectionChangeFromMouseDown = false;
  var isInsertLineBreak = false;
  var isFirefoxEndingComposition = false;
  var isSafariEndingComposition = false;
  var safariEndCompositionEventData = "";
  var postDeleteSelectionToRestore = null;
  var collapsedSelectionFormat = [0, "", 0, "root", 0];
  function $shouldPreventDefaultAndInsertText(selection, domTargetRange, text2, timeStamp, isBeforeInput) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const editor = getActiveEditor();
    const domSelection = getDOMSelection(getWindow(editor));
    const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;
    const anchorKey = anchor.key;
    const backingAnchorElement = editor.getElementByKey(anchorKey);
    const textLength = text2.length;
    return anchorKey !== focus.key || // If we're working with a non-text node.
    !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.
    (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been
    // a recent beforeinput event for "textInput". If there has been one in the last
    // 50ms then we proceed as normal. However, if there is not, then this is likely
    // a dangling `input` event caused by execCommand('insertText').
    lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || // TODO consider if there are other scenarios when multiple code units
    //      should be addressed here
    doesContainSurrogatePair(text2)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.
    $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either
    // dealing with this in "beforeinput" or where the node has already recently
    // been changed (thus is dirty).
    anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
    (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
    // of the editor.
    domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
    anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.
    $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);
  }
  function shouldSkipSelectionChange(domNode, offset) {
    return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset !== 0 && offset !== domNode.nodeValue.length;
  }
  function onSelectionChange(domSelection, editor, isActive) {
    const {
      anchorNode: anchorDOM,
      anchorOffset,
      focusNode: focusDOM,
      focusOffset
    } = domSelection;
    if (isSelectionChangeFromDOMUpdate) {
      isSelectionChangeFromDOMUpdate = false;
      if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset) && !postDeleteSelectionToRestore) {
        return;
      }
    }
    updateEditorSync(editor, () => {
      if (!isActive) {
        $setSelection(null);
        return;
      }
      if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
        return;
      }
      let selection = $getSelection();
      if (postDeleteSelectionToRestore && $isRangeSelection(selection) && selection.isCollapsed()) {
        const curAnchor = selection.anchor;
        const prevAnchor = postDeleteSelectionToRestore.anchor;
        if (
          // Rightward shift in same node
          curAnchor.key === prevAnchor.key && curAnchor.offset === prevAnchor.offset + 1 || // Or rightward shift into sibling node
          curAnchor.offset === 1 && prevAnchor.getNode().is(curAnchor.getNode().getPreviousSibling())
        ) {
          selection = postDeleteSelectionToRestore.clone();
          $setSelection(selection);
        }
      }
      postDeleteSelectionToRestore = null;
      if ($isRangeSelection(selection)) {
        const anchor = selection.anchor;
        const anchorNode = anchor.getNode();
        if (selection.isCollapsed()) {
          if (domSelection.type === "Range" && domSelection.anchorNode === domSelection.focusNode) {
            selection.dirty = true;
          }
          const windowEvent = getWindow(editor).event;
          const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();
          const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;
          const root = $getRoot();
          const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === "";
          if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {
            $updateSelectionFormatStyle(selection, lastFormat, lastStyle);
          } else {
            if (anchor.type === "text") {
              if (!$isTextNode(anchorNode)) {
                formatDevErrorMessage(`Point.getNode() must return TextNode when type is text`);
              }
              $updateSelectionFormatStyleFromTextNode(selection, anchorNode);
            } else if (anchor.type === "element" && !isRootTextContentEmpty) {
              if (!$isElementNode(anchorNode)) {
                formatDevErrorMessage(`Point.getNode() must return ElementNode when type is element`);
              }
              const lastNode = anchor.getNode();
              if (
                // This previously applied to all ParagraphNode
                lastNode.isEmpty()
              ) {
                $updateSelectionFormatStyleFromElementNode(selection, lastNode);
              } else {
                $updateSelectionFormatStyle(selection, 0, "");
              }
            }
          }
        } else {
          const anchorKey = anchor.key;
          const focus = selection.focus;
          const focusKey = focus.key;
          const nodes = selection.getNodes();
          const nodesLength = nodes.length;
          const isBackward = selection.isBackward();
          const startOffset = isBackward ? focusOffset : anchorOffset;
          const endOffset = isBackward ? anchorOffset : focusOffset;
          const startKey = isBackward ? focusKey : anchorKey;
          const endKey = isBackward ? anchorKey : focusKey;
          let combinedFormat = IS_ALL_FORMATTING;
          let hasTextNodes = false;
          for (let i2 = 0; i2 < nodesLength; i2++) {
            const node = nodes[i2];
            const textContentSize = node.getTextContentSize();
            if ($isTextNode(node) && textContentSize !== 0 && // Exclude empty text nodes at boundaries resulting from user's selection
            !(i2 === 0 && node.__key === startKey && startOffset === textContentSize || i2 === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {
              hasTextNodes = true;
              combinedFormat &= node.getFormat();
              if (combinedFormat === 0) {
                break;
              }
            }
          }
          selection.format = hasTextNodes ? combinedFormat : 0;
        }
      }
      dispatchCommand(editor, SELECTION_CHANGE_COMMAND, void 0);
    });
  }
  function $updateSelectionFormatStyle(selection, format, style) {
    if (selection.format !== format || selection.style !== style) {
      selection.format = format;
      selection.style = style;
      selection.dirty = true;
    }
  }
  function $updateSelectionFormatStyleFromTextNode(selection, node) {
    const format = node.getFormat();
    const style = node.getStyle();
    $updateSelectionFormatStyle(selection, format, style);
  }
  function $updateSelectionFormatStyleFromElementNode(selection, node) {
    const format = node.getTextFormat();
    const style = node.getTextStyle();
    $updateSelectionFormatStyle(selection, format, style);
  }
  function onClick(event, editor) {
    updateEditorSync(editor, () => {
      const selection = $getSelection();
      const domSelection = getDOMSelection(getWindow(editor));
      const lastSelection = $getPreviousSelection();
      if (domSelection) {
        if ($isRangeSelection(selection)) {
          const anchor = selection.anchor;
          const anchorNode = anchor.getNode();
          if (anchor.type === "element" && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {
            domSelection.removeAllRanges();
            selection.dirty = true;
          } else if (event.detail === 3 && !selection.isCollapsed()) {
            const focus = selection.focus;
            const focusNode = focus.getNode();
            if (anchorNode !== focusNode) {
              const parentNode = $findMatchingParent(anchorNode, (node) => $isElementNode(node) && !node.isInline());
              if ($isElementNode(parentNode)) {
                parentNode.select(0);
              }
            }
          }
        } else if (event.pointerType === "touch" || event.pointerType === "pen") {
          const domAnchorNode = domSelection.anchorNode;
          if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {
            const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);
            $setSelection(newSelection);
          }
        }
      }
      dispatchCommand(editor, CLICK_COMMAND, event);
    });
  }
  function onPointerDown(event, editor) {
    const target = event.target;
    const pointerType = event.pointerType;
    if (isDOMNode(target) && pointerType !== "touch" && pointerType !== "pen" && event.button === 0) {
      updateEditorSync(editor, () => {
        if (!$isSelectionCapturedInDecorator(target)) {
          isSelectionChangeFromMouseDown = true;
        }
      });
    }
  }
  function getTargetRange(event) {
    if (!event.getTargetRanges) {
      return null;
    }
    const targetRanges = event.getTargetRanges();
    if (targetRanges.length === 0) {
      return null;
    }
    return targetRanges[0];
  }
  function $canRemoveText(anchorNode, focusNode) {
    return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !$isTokenOrTab(anchorNode) || !$isTokenOrTab(focusNode);
  }
  function isPossiblyAndroidKeyPress(timeStamp) {
    return lastKeyCode === "MediaLast" && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;
  }
  function onBeforeInput(event, editor) {
    const inputType = event.inputType;
    const targetRange = getTargetRange(event);
    if (inputType === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
    // as the `paste` event should have triggered, unless the
    // user has dom.event.clipboardevents.enabled disabled in
    // about:config. In that case, we need to process the
    // pasted content in the DOM mutation phase.
    IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
      return;
    } else if (inputType === "insertCompositionText") {
      return;
    }
    updateEditorSync(editor, () => {
      const selection = $getSelection();
      if (inputType === "deleteContentBackward") {
        if (selection === null) {
          const prevSelection = $getPreviousSelection();
          if (!$isRangeSelection(prevSelection)) {
            return;
          }
          $setSelection(prevSelection.clone());
        }
        if ($isRangeSelection(selection)) {
          const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;
          if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {
            $setCompositionKey(null);
            lastKeyDownTimeStamp = 0;
            setTimeout(() => {
              updateEditorSync(editor, () => {
                $setCompositionKey(null);
              });
            }, ANDROID_COMPOSITION_LATENCY);
            if ($isRangeSelection(selection)) {
              const anchorNode2 = selection.anchor.getNode();
              anchorNode2.markDirty();
              if (!$isTextNode(anchorNode2)) {
                formatDevErrorMessage(`Anchor node must be a TextNode`);
              }
              $updateSelectionFormatStyleFromTextNode(selection, anchorNode2);
            }
          } else {
            $setCompositionKey(null);
            event.preventDefault();
            const selectedNode = selection.anchor.getNode();
            const selectedNodeText = selectedNode.getTextContent();
            const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();
            const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;
            let shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;
            if (shouldLetBrowserHandleDelete && selection.isCollapsed()) {
              shouldLetBrowserHandleDelete = !$isDecoratorNode($getAdjacentNode(selection.anchor, true));
            }
            if (!shouldLetBrowserHandleDelete) {
              dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
              const selectionAfterDelete = $getSelection();
              if (IS_ANDROID_CHROME && $isRangeSelection(selectionAfterDelete) && selectionAfterDelete.isCollapsed()) {
                postDeleteSelectionToRestore = selectionAfterDelete;
                setTimeout(() => postDeleteSelectionToRestore = null);
              }
            }
          }
          return;
        }
      }
      if (!$isRangeSelection(selection)) {
        return;
      }
      const data2 = event.data;
      if (unprocessedBeforeInputData !== null) {
        $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);
      }
      if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {
        selection.applyDOMRange(targetRange);
      }
      unprocessedBeforeInputData = null;
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      if (inputType === "insertText" || inputType === "insertTranspose") {
        if (data2 === "\n") {
          event.preventDefault();
          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
        } else if (data2 === DOUBLE_LINE_BREAK) {
          event.preventDefault();
          dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
        } else if (data2 == null && event.dataTransfer) {
          const text2 = event.dataTransfer.getData("text/plain");
          event.preventDefault();
          selection.insertRawText(text2);
        } else if (data2 != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data2, event.timeStamp, true)) {
          event.preventDefault();
          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data2);
        } else {
          unprocessedBeforeInputData = data2;
        }
        lastBeforeInputInsertTextTimeStamp = event.timeStamp;
        return;
      }
      event.preventDefault();
      switch (inputType) {
        case "insertFromYank":
        case "insertFromDrop":
        case "insertReplacementText": {
          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
          break;
        }
        case "insertFromComposition": {
          $setCompositionKey(null);
          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
          break;
        }
        case "insertLineBreak": {
          $setCompositionKey(null);
          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
          break;
        }
        case "insertParagraph": {
          $setCompositionKey(null);
          if (isInsertLineBreak && !IS_IOS) {
            isInsertLineBreak = false;
            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
          } else {
            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
          }
          break;
        }
        case "insertFromPaste":
        case "insertFromPasteAsQuotation": {
          dispatchCommand(editor, PASTE_COMMAND, event);
          break;
        }
        case "deleteByComposition": {
          if ($canRemoveText(anchorNode, focusNode)) {
            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
          }
          break;
        }
        case "deleteByDrag":
        case "deleteByCut": {
          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
          break;
        }
        case "deleteContent": {
          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
          break;
        }
        case "deleteWordBackward": {
          dispatchCommand(editor, DELETE_WORD_COMMAND, true);
          break;
        }
        case "deleteWordForward": {
          dispatchCommand(editor, DELETE_WORD_COMMAND, false);
          break;
        }
        case "deleteHardLineBackward":
        case "deleteSoftLineBackward": {
          dispatchCommand(editor, DELETE_LINE_COMMAND, true);
          break;
        }
        case "deleteContentForward":
        case "deleteHardLineForward":
        case "deleteSoftLineForward": {
          dispatchCommand(editor, DELETE_LINE_COMMAND, false);
          break;
        }
        case "formatStrikeThrough": {
          dispatchCommand(editor, FORMAT_TEXT_COMMAND, "strikethrough");
          break;
        }
        case "formatBold": {
          dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
          break;
        }
        case "formatItalic": {
          dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
          break;
        }
        case "formatUnderline": {
          dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
          break;
        }
        case "historyUndo": {
          dispatchCommand(editor, UNDO_COMMAND, void 0);
          break;
        }
        case "historyRedo": {
          dispatchCommand(editor, REDO_COMMAND, void 0);
          break;
        }
      }
    });
  }
  function onInput(event, editor) {
    event.stopPropagation();
    updateEditorSync(editor, () => {
      if (isHTMLElement(event.target) && $isSelectionCapturedInDecorator(event.target)) {
        return;
      }
      const selection = $getSelection();
      const data2 = event.data;
      const targetRange = getTargetRange(event);
      if (data2 != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data2, event.timeStamp, false)) {
        if (isFirefoxEndingComposition) {
          $onCompositionEndImpl(editor, data2);
          isFirefoxEndingComposition = false;
        }
        const anchor = selection.anchor;
        const anchorNode = anchor.getNode();
        const domSelection = getDOMSelection(getWindow(editor));
        if (domSelection === null) {
          return;
        }
        const isBackward = selection.isBackward();
        const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;
        const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;
        if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data2 + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {
          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data2);
        }
        const textLength = data2.length;
        if (IS_FIREFOX && textLength > 1 && event.inputType === "insertCompositionText" && !editor.isComposing()) {
          selection.anchor.offset -= textLength;
        }
        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {
          lastKeyDownTimeStamp = 0;
          $setCompositionKey(null);
        }
      } else {
        const characterData = data2 !== null ? data2 : void 0;
        $updateSelectedTextFromDOM(false, editor, characterData);
        if (isFirefoxEndingComposition) {
          $onCompositionEndImpl(editor, data2 || void 0);
          isFirefoxEndingComposition = false;
        }
      }
      $flushMutations();
    }, {
      event
    });
    unprocessedBeforeInputData = null;
  }
  function onCompositionStart(event, editor) {
    updateEditorSync(editor, () => {
      const selection = $getSelection();
      if ($isRangeSelection(selection) && !editor.isComposing()) {
        const anchor = selection.anchor;
        const node = selection.anchor.getNode();
        $setCompositionKey(anchor.key);
        if (
          // If it has been 30ms since the last keydown, then we should
          // apply the empty space heuristic. We can't do this for Safari,
          // as the keydown fires after composition start.
          event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also
          // need to invoke the empty space heuristic below.
          anchor.type === "element" || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style
        ) {
          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);
        }
      }
    });
  }
  function $onCompositionEndImpl(editor, data2) {
    const compositionKey = editor._compositionKey;
    $setCompositionKey(null);
    if (compositionKey !== null && data2 != null) {
      if (data2 === "") {
        const node = $getNodeByKey(compositionKey);
        const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));
        if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {
          $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);
        }
        return;
      }
      if (data2[data2.length - 1] === "\n") {
        const selection = $getSelection();
        if ($isRangeSelection(selection)) {
          const focus = selection.focus;
          selection.anchor.set(focus.key, focus.offset, focus.type);
          dispatchCommand(editor, KEY_ENTER_COMMAND, null);
          return;
        }
      }
    }
    $updateSelectedTextFromDOM(true, editor, data2);
  }
  function onCompositionEnd(event, editor) {
    if (IS_FIREFOX) {
      isFirefoxEndingComposition = true;
    } else if (!IS_IOS && (IS_SAFARI || IS_APPLE_WEBKIT)) {
      isSafariEndingComposition = true;
      safariEndCompositionEventData = event.data;
    } else {
      updateEditorSync(editor, () => {
        $onCompositionEndImpl(editor, event.data);
      });
    }
  }
  function onKeyDown(event, editor) {
    lastKeyDownTimeStamp = event.timeStamp;
    lastKeyCode = event.key;
    if (editor.isComposing()) {
      return;
    }
    if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {
      return;
    }
    if (event.key == null) {
      return;
    }
    if (isSafariEndingComposition && isBackspace(event)) {
      updateEditorSync(editor, () => {
        $onCompositionEndImpl(editor, safariEndCompositionEventData);
      });
      isSafariEndingComposition = false;
      safariEndCompositionEventData = "";
      return;
    }
    if (isMoveForward(event)) {
      dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);
    } else if (isMoveToEnd(event)) {
      dispatchCommand(editor, MOVE_TO_END, event);
    } else if (isMoveBackward(event)) {
      dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);
    } else if (isMoveToStart(event)) {
      dispatchCommand(editor, MOVE_TO_START, event);
    } else if (isMoveUp(event)) {
      dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);
    } else if (isMoveDown(event)) {
      dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);
    } else if (isLineBreak(event)) {
      isInsertLineBreak = true;
      dispatchCommand(editor, KEY_ENTER_COMMAND, event);
    } else if (isSpace(event)) {
      dispatchCommand(editor, KEY_SPACE_COMMAND, event);
    } else if (isOpenLineBreak(event)) {
      event.preventDefault();
      isInsertLineBreak = true;
      dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);
    } else if (isParagraph(event)) {
      isInsertLineBreak = false;
      dispatchCommand(editor, KEY_ENTER_COMMAND, event);
    } else if (isDeleteBackward(event)) {
      if (isBackspace(event)) {
        dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);
      } else {
        event.preventDefault();
        dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
      }
    } else if (isEscape(event)) {
      dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);
    } else if (isDeleteForward(event)) {
      if (isDelete(event)) {
        dispatchCommand(editor, KEY_DELETE_COMMAND, event);
      } else {
        event.preventDefault();
        dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
      }
    } else if (isDeleteWordBackward(event)) {
      event.preventDefault();
      dispatchCommand(editor, DELETE_WORD_COMMAND, true);
    } else if (isDeleteWordForward(event)) {
      event.preventDefault();
      dispatchCommand(editor, DELETE_WORD_COMMAND, false);
    } else if (isDeleteLineBackward(event)) {
      event.preventDefault();
      dispatchCommand(editor, DELETE_LINE_COMMAND, true);
    } else if (isDeleteLineForward(event)) {
      event.preventDefault();
      dispatchCommand(editor, DELETE_LINE_COMMAND, false);
    } else if (isBold(event)) {
      event.preventDefault();
      dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
    } else if (isUnderline(event)) {
      event.preventDefault();
      dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
    } else if (isItalic(event)) {
      event.preventDefault();
      dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
    } else if (isTab(event)) {
      dispatchCommand(editor, KEY_TAB_COMMAND, event);
    } else if (isUndo(event)) {
      event.preventDefault();
      dispatchCommand(editor, UNDO_COMMAND, void 0);
    } else if (isRedo(event)) {
      event.preventDefault();
      dispatchCommand(editor, REDO_COMMAND, void 0);
    } else {
      const prevSelection = editor._editorState._selection;
      if (prevSelection !== null && !$isRangeSelection(prevSelection)) {
        if (isCopy(event)) {
          event.preventDefault();
          dispatchCommand(editor, COPY_COMMAND, event);
        } else if (isCut(event)) {
          event.preventDefault();
          dispatchCommand(editor, CUT_COMMAND, event);
        } else if (isSelectAll(event)) {
          event.preventDefault();
          dispatchCommand(editor, SELECT_ALL_COMMAND, event);
        }
      } else if (isSelectAll(event)) {
        event.preventDefault();
        dispatchCommand(editor, SELECT_ALL_COMMAND, event);
      }
    }
    if (isModifier(event)) {
      dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);
    }
  }
  function getRootElementRemoveHandles(rootElement) {
    let eventHandles = rootElement.__lexicalEventHandles;
    if (eventHandles === void 0) {
      eventHandles = [];
      rootElement.__lexicalEventHandles = eventHandles;
    }
    return eventHandles;
  }
  var activeNestedEditorsMap = /* @__PURE__ */ new Map();
  function onDocumentSelectionChange(event) {
    const domSelection = getDOMSelectionFromTarget(event.target);
    if (domSelection === null) {
      return;
    }
    const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);
    if (nextActiveEditor === null) {
      return;
    }
    if (isSelectionChangeFromMouseDown) {
      isSelectionChangeFromMouseDown = false;
      updateEditorSync(nextActiveEditor, () => {
        const lastSelection = $getPreviousSelection();
        const domAnchorNode = domSelection.anchorNode;
        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {
          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);
          $setSelection(newSelection);
        }
      });
    }
    const editors = getEditorsToPropagate(nextActiveEditor);
    const rootEditor = editors[editors.length - 1];
    const rootEditorKey = rootEditor._key;
    const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);
    const prevActiveEditor = activeNestedEditor || rootEditor;
    if (prevActiveEditor !== nextActiveEditor) {
      onSelectionChange(domSelection, prevActiveEditor, false);
    }
    onSelectionChange(domSelection, nextActiveEditor, true);
    if (nextActiveEditor !== rootEditor) {
      activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);
    } else if (activeNestedEditor) {
      activeNestedEditorsMap.delete(rootEditorKey);
    }
  }
  function stopLexicalPropagation(event) {
    event._lexicalHandled = true;
  }
  function hasStoppedLexicalPropagation(event) {
    const stopped = event._lexicalHandled === true;
    return stopped;
  }
  function addRootElementEvents(rootElement, editor) {
    const doc = rootElement.ownerDocument;
    rootElementToDocument.set(rootElement, doc);
    const documentRootElementsCount = rootElementsRegistered.get(doc) ?? 0;
    if (documentRootElementsCount < 1) {
      doc.addEventListener("selectionchange", onDocumentSelectionChange);
    }
    rootElementsRegistered.set(doc, documentRootElementsCount + 1);
    rootElement.__lexicalEditor = editor;
    const removeHandles = getRootElementRemoveHandles(rootElement);
    for (let i2 = 0; i2 < rootElementEvents.length; i2++) {
      const [eventName, onEvent] = rootElementEvents[i2];
      const eventHandler = typeof onEvent === "function" ? (event) => {
        if (hasStoppedLexicalPropagation(event)) {
          return;
        }
        stopLexicalPropagation(event);
        if (editor.isEditable() || eventName === "click") {
          onEvent(event, editor);
        }
      } : (event) => {
        if (hasStoppedLexicalPropagation(event)) {
          return;
        }
        stopLexicalPropagation(event);
        const isEditable = editor.isEditable();
        switch (eventName) {
          case "cut":
            return isEditable && dispatchCommand(editor, CUT_COMMAND, event);
          case "copy":
            return dispatchCommand(editor, COPY_COMMAND, event);
          case "paste":
            return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);
          case "dragstart":
            return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);
          case "dragover":
            return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);
          case "dragend":
            return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);
          case "focus":
            return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);
          case "blur": {
            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);
          }
          case "drop":
            return isEditable && dispatchCommand(editor, DROP_COMMAND, event);
        }
      };
      rootElement.addEventListener(eventName, eventHandler);
      removeHandles.push(() => {
        rootElement.removeEventListener(eventName, eventHandler);
      });
    }
  }
  var rootElementNotRegisteredWarning = warnOnlyOnce("Root element not registered");
  function removeRootElementEvents(rootElement) {
    const doc = rootElementToDocument.get(rootElement);
    if (doc === void 0) {
      rootElementNotRegisteredWarning();
      return;
    }
    const documentRootElementsCount = rootElementsRegistered.get(doc);
    if (documentRootElementsCount === void 0) {
      rootElementNotRegisteredWarning();
      return;
    }
    const newCount = documentRootElementsCount - 1;
    if (!(newCount >= 0)) {
      formatDevErrorMessage(`Root element count less than 0`);
    }
    rootElementToDocument.delete(rootElement);
    rootElementsRegistered.set(doc, newCount);
    if (newCount === 0) {
      doc.removeEventListener("selectionchange", onDocumentSelectionChange);
    }
    const editor = getEditorPropertyFromDOMNode(rootElement);
    if (isLexicalEditor(editor)) {
      cleanActiveNestedEditorsMap(editor);
      rootElement.__lexicalEditor = null;
    } else if (editor) {
      {
        formatDevErrorMessage(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);
      }
    }
    const removeHandles = getRootElementRemoveHandles(rootElement);
    for (let i2 = 0; i2 < removeHandles.length; i2++) {
      removeHandles[i2]();
    }
    rootElement.__lexicalEventHandles = [];
  }
  function cleanActiveNestedEditorsMap(editor) {
    if (editor._parentEditor !== null) {
      const editors = getEditorsToPropagate(editor);
      const rootEditor = editors[editors.length - 1];
      const rootEditorKey = rootEditor._key;
      if (activeNestedEditorsMap.get(rootEditorKey) === editor) {
        activeNestedEditorsMap.delete(rootEditorKey);
      }
    } else {
      activeNestedEditorsMap.delete(editor._key);
    }
  }
  function markSelectionChangeFromDOMUpdate() {
    isSelectionChangeFromDOMUpdate = true;
  }
  function markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {
    collapsedSelectionFormat = [format, style, offset, key, timeStamp];
  }
  function $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {
    errorOnReadOnly();
    const key = nodeToRemove.__key;
    const parent = nodeToRemove.getParent();
    if (parent === null) {
      return;
    }
    const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);
    let selectionMoved = false;
    if ($isRangeSelection(selection) && restoreSelection) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      if (anchor.key === key) {
        moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
        selectionMoved = true;
      }
      if (focus.key === key) {
        moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
        selectionMoved = true;
      }
    } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {
      nodeToRemove.selectPrevious();
    }
    if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {
      const index2 = nodeToRemove.getIndexWithinParent();
      removeFromParent(nodeToRemove);
      $updateElementSelectionOnCreateDeleteNode(selection, parent, index2, -1);
    } else {
      removeFromParent(nodeToRemove);
    }
    if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {
      $removeNode(parent, restoreSelection);
    }
    if (restoreSelection && selection && $isRootNode(parent) && parent.isEmpty()) {
      parent.selectEnd();
    }
  }
  function buildImportMap(importMap) {
    return importMap;
  }
  var EPHEMERAL = Symbol.for("ephemeral");
  function $isEphemeral(node) {
    return node[EPHEMERAL] || false;
  }
  function $markEphemeral(node) {
    node[EPHEMERAL] = true;
    return node;
  }
  var LexicalNode = class {
    /** @internal Allow us to look up the type including static props */
    /** @internal */
    __type;
    /** @internal */
    //@ts-ignore We set the key in the constructor.
    __key;
    /** @internal */
    __parent;
    /** @internal */
    __prev;
    /** @internal */
    __next;
    /** @internal */
    __state;
    // Flow doesn't support abstract classes unfortunately, so we can't _force_
    // subclasses of Node to implement statics. All subclasses of Node should have
    // a static getType and clone method though. We define getType and clone here so we can call it
    // on any  Node, and we throw this error by default since the subclass should provide
    // their own implementation.
    /**
     * Returns the string type of this node. Every node must
     * implement this and it MUST BE UNIQUE amongst nodes registered
     * on the editor.
     *
     */
    static getType() {
      const {
        ownNodeType
      } = getStaticNodeConfig(this);
      if (!(ownNodeType !== void 0)) {
        formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .getType().`);
      }
      return ownNodeType;
    }
    /**
     * Clones this node, creating a new node with a different key
     * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
     * implement this method.
     *
     */
    static clone(_data) {
      {
        formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .clone().`);
      }
    }
    /**
     * Override this to implement the new static node configuration protocol,
     * this method is called directly on the prototype and must not depend
     * on anything initialized in the constructor. Generally it should be
     * a trivial implementation.
     *
     * @example
     * ```ts
     * class MyNode extends TextNode {
     *   $config() {
     *     return this.config('my-node', {extends: TextNode});
     *   }
     * }
     * ```
     */
    $config() {
      return {};
    }
    /**
     * This is a convenience method for $config that
     * aids in type inference. See {@link LexicalNode.$config}
     * for example usage.
     */
    config(type, config) {
      const parentKlass = config.extends || Object.getPrototypeOf(this.constructor);
      Object.assign(config, {
        extends: parentKlass,
        type
      });
      return {
        [type]: config
      };
    }
    /**
     * Perform any state updates on the clone of prevNode that are not already
     * handled by the constructor call in the static clone method. If you have
     * state to update in your clone that is not handled directly by the
     * constructor, it is advisable to override this method but it is required
     * to include a call to `super.afterCloneFrom(prevNode)` in your
     * implementation. This is only intended to be called by
     * {@link $cloneWithProperties} function or via a super call.
     *
     * @example
     * ```ts
     * class ClassesTextNode extends TextNode {
     *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM
     *   __classes = new Set<string>();
     *   static clone(node: ClassesTextNode): ClassesTextNode {
     *     // The inherited TextNode constructor is used here, so
     *     // classes is not set by this method.
     *     return new ClassesTextNode(node.__text, node.__key);
     *   }
     *   afterCloneFrom(node: this): void {
     *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom
     *     // for necessary state updates
     *     super.afterCloneFrom(node);
     *     this.__addClasses(node.__classes);
     *   }
     *   // This method is a private implementation detail, it is not
     *   // suitable for the public API because it does not call getWritable
     *   __addClasses(classNames: Iterable<string>): this {
     *     for (const className of classNames) {
     *       this.__classes.add(className);
     *     }
     *     return this;
     *   }
     *   addClass(...classNames: string[]): this {
     *     return this.getWritable().__addClasses(classNames);
     *   }
     *   removeClass(...classNames: string[]): this {
     *     const node = this.getWritable();
     *     for (const className of classNames) {
     *       this.__classes.delete(className);
     *     }
     *     return this;
     *   }
     *   getClasses(): Set<string> {
     *     return this.getLatest().__classes;
     *   }
     * }
     * ```
     *
     */
    afterCloneFrom(prevNode) {
      if (this.__key === prevNode.__key) {
        this.__parent = prevNode.__parent;
        this.__next = prevNode.__next;
        this.__prev = prevNode.__prev;
        this.__state = prevNode.__state;
      } else if (prevNode.__state) {
        this.__state = prevNode.__state.getWritable(this);
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static importDOM;
    constructor(key) {
      this.__type = this.constructor.getType();
      this.__parent = null;
      this.__prev = null;
      this.__next = null;
      Object.defineProperty(this, "__state", {
        configurable: true,
        enumerable: false,
        value: void 0,
        writable: true
      });
      $setNodeKey(this, key);
      {
        if (this.__type !== "root") {
          errorOnTypeKlassMismatch(this.__type, this.constructor);
        }
      }
    }
    // Getters and Traversers
    /**
     * Returns the string type of this node.
     */
    getType() {
      return this.__type;
    }
    isInline() {
      {
        formatDevErrorMessage(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);
      }
    }
    /**
     * Returns true if there is a path between this node and the RootNode, false otherwise.
     * This is a way of determining if the node is "attached" EditorState. Unattached nodes
     * won't be reconciled and will ultimately be cleaned up by the Lexical GC.
     */
    isAttached() {
      let nodeKey = this.__key;
      while (nodeKey !== null) {
        if (nodeKey === "root") {
          return true;
        }
        const node = $getNodeByKey(nodeKey);
        if (node === null) {
          break;
        }
        nodeKey = node.__parent;
      }
      return false;
    }
    /**
     * Returns true if this node is contained within the provided Selection., false otherwise.
     * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
     * what's included.
     *
     * @param selection - The selection that we want to determine if the node is in.
     */
    isSelected(selection) {
      const targetSelection = selection || $getSelection();
      if (targetSelection == null) {
        return false;
      }
      const isSelected = targetSelection.getNodes().some((n2) => n2.__key === this.__key);
      if ($isTextNode(this)) {
        return isSelected;
      }
      const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === "element" && targetSelection.focus.type === "element";
      if (isElementRangeSelection) {
        if (targetSelection.isCollapsed()) {
          return false;
        }
        const parentNode = this.getParent();
        if ($isDecoratorNode(this) && this.isInline() && parentNode) {
          const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;
          if (parentNode.is(firstPoint.getNode()) && firstPoint.offset === parentNode.getChildrenSize() && this.is(parentNode.getLastChild())) {
            return false;
          }
        }
      }
      return isSelected;
    }
    /**
     * Returns this nodes key.
     */
    getKey() {
      return this.__key;
    }
    /**
     * Returns the zero-based index of this node within the parent.
     */
    getIndexWithinParent() {
      const parent = this.getParent();
      if (parent === null) {
        return -1;
      }
      let node = parent.getFirstChild();
      let index2 = 0;
      while (node !== null) {
        if (this.is(node)) {
          return index2;
        }
        index2++;
        node = node.getNextSibling();
      }
      return -1;
    }
    /**
     * Returns the parent of this node, or null if none is found.
     */
    getParent() {
      const parent = this.getLatest().__parent;
      if (parent === null) {
        return null;
      }
      return $getNodeByKey(parent);
    }
    /**
     * Returns the parent of this node, or throws if none is found.
     */
    getParentOrThrow() {
      const parent = this.getParent();
      if (parent === null) {
        {
          formatDevErrorMessage(`Expected node ${this.__key} to have a parent.`);
        }
      }
      return parent;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElement() {
      let node = this;
      while (node !== null) {
        const parent = node.getParent();
        if ($isRootOrShadowRoot(parent)) {
          if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {
            formatDevErrorMessage(`Children of root nodes must be elements or decorators`);
          }
          return node;
        }
        node = parent;
      }
      return null;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElementOrThrow() {
      const parent = this.getTopLevelElement();
      if (parent === null) {
        {
          formatDevErrorMessage(`Expected node ${this.__key} to have a top parent element.`);
        }
      }
      return parent;
    }
    /**
     * Returns a list of the every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParents() {
      const parents = [];
      let node = this.getParent();
      while (node !== null) {
        parents.push(node);
        node = node.getParent();
      }
      return parents;
    }
    /**
     * Returns a list of the keys of every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParentKeys() {
      const parents = [];
      let node = this.getParent();
      while (node !== null) {
        parents.push(node.__key);
        node = node.getParent();
      }
      return parents;
    }
    /**
     * Returns the "previous" siblings - that is, the node that comes
     * before this one in the same parent.
     *
     */
    getPreviousSibling() {
      const self2 = this.getLatest();
      const prevKey = self2.__prev;
      return prevKey === null ? null : $getNodeByKey(prevKey);
    }
    /**
     * Returns the "previous" siblings - that is, the nodes that come between
     * this one and the first child of it's parent, inclusive.
     *
     */
    getPreviousSiblings() {
      const siblings = [];
      const parent = this.getParent();
      if (parent === null) {
        return siblings;
      }
      let node = parent.getFirstChild();
      while (node !== null) {
        if (node.is(this)) {
          break;
        }
        siblings.push(node);
        node = node.getNextSibling();
      }
      return siblings;
    }
    /**
     * Returns the "next" siblings - that is, the node that comes
     * after this one in the same parent
     *
     */
    getNextSibling() {
      const self2 = this.getLatest();
      const nextKey = self2.__next;
      return nextKey === null ? null : $getNodeByKey(nextKey);
    }
    /**
     * Returns all "next" siblings - that is, the nodes that come between this
     * one and the last child of it's parent, inclusive.
     *
     */
    getNextSiblings() {
      const siblings = [];
      let node = this.getNextSibling();
      while (node !== null) {
        siblings.push(node);
        node = node.getNextSibling();
      }
      return siblings;
    }
    /**
     * @deprecated use {@link $getCommonAncestor}
     *
     * Returns the closest common ancestor of this node and the provided one or null
     * if one cannot be found.
     *
     * @param node - the other node to find the common ancestor of.
     */
    getCommonAncestor(node) {
      const a2 = $isElementNode(this) ? this : this.getParent();
      const b3 = $isElementNode(node) ? node : node.getParent();
      const result = a2 && b3 ? $getCommonAncestor(a2, b3) : null;
      return result ? result.commonAncestor : null;
    }
    /**
     * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
     * Always use this instead of referential equality.
     *
     * @param object - the node to perform the equality comparison on.
     */
    is(object) {
      if (object == null) {
        return false;
      }
      return this.__key === object.__key;
    }
    /**
     * Returns true if this node logically precedes the target node in the
     * editor state, false otherwise (including if there is no common ancestor).
     *
     * Note that this notion of isBefore is based on post-order; a descendant
     * node is always before its ancestors. See also
     * {@link $getCommonAncestor} and {@link $comparePointCaretNext} for
     * more flexible ways to determine the relative positions of nodes.
     *
     * @param targetNode - the node we're testing to see if it's after this one.
     */
    isBefore(targetNode) {
      const compare = $getCommonAncestor(this, targetNode);
      if (compare === null) {
        return false;
      }
      if (compare.type === "descendant") {
        return true;
      }
      if (compare.type === "branch") {
        return $getCommonAncestorResultBranchOrder(compare) === -1;
      }
      if (!(compare.type === "same" || compare.type === "ancestor")) {
        formatDevErrorMessage(`LexicalNode.isBefore: exhaustiveness check`);
      }
      return false;
    }
    /**
     * Returns true if this node is an ancestor of and distinct from the target node, false otherwise.
     *
     * @param targetNode - the would-be child node.
     */
    isParentOf(targetNode) {
      const result = $getCommonAncestor(this, targetNode);
      return result !== null && result.type === "ancestor";
    }
    // TO-DO: this function can be simplified a lot
    /**
     * Returns a list of nodes that are between this node and
     * the target node in the EditorState.
     *
     * @param targetNode - the node that marks the other end of the range of nodes to be returned.
     */
    getNodesBetween(targetNode) {
      const isBefore = this.isBefore(targetNode);
      const nodes = [];
      const visited = /* @__PURE__ */ new Set();
      let node = this;
      while (true) {
        if (node === null) {
          break;
        }
        const key = node.__key;
        if (!visited.has(key)) {
          visited.add(key);
          nodes.push(node);
        }
        if (node === targetNode) {
          break;
        }
        const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;
        if (child !== null) {
          node = child;
          continue;
        }
        const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();
        if (nextSibling !== null) {
          node = nextSibling;
          continue;
        }
        const parent = node.getParentOrThrow();
        if (!visited.has(parent.__key)) {
          nodes.push(parent);
        }
        if (parent === targetNode) {
          break;
        }
        let parentSibling = null;
        let ancestor = parent;
        do {
          if (ancestor === null) {
            {
              formatDevErrorMessage(`getNodesBetween: ancestor is null`);
            }
          }
          parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();
          ancestor = ancestor.getParent();
          if (ancestor !== null) {
            if (parentSibling === null && !visited.has(ancestor.__key)) {
              nodes.push(ancestor);
            }
          } else {
            break;
          }
        } while (parentSibling === null);
        node = parentSibling;
      }
      if (!isBefore) {
        nodes.reverse();
      }
      return nodes;
    }
    /**
     * Returns true if this node has been marked dirty during this update cycle.
     *
     */
    isDirty() {
      const editor = getActiveEditor();
      const dirtyLeaves = editor._dirtyLeaves;
      return dirtyLeaves !== null && dirtyLeaves.has(this.__key);
    }
    /**
     * Returns the latest version of the node from the active EditorState.
     * This is used to avoid getting values from stale node references.
     *
     */
    getLatest() {
      if ($isEphemeral(this)) {
        return this;
      }
      const latest = $getNodeByKey(this.__key);
      if (latest === null) {
        {
          formatDevErrorMessage(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);
        }
      }
      return latest;
    }
    /**
     * Returns a mutable version of the node using {@link $cloneWithProperties}
     * if necessary. Will throw an error if called outside of a Lexical Editor
     * {@link LexicalEditor.update} callback.
     *
     */
    getWritable() {
      if ($isEphemeral(this)) {
        return this;
      }
      errorOnReadOnly();
      const editorState = getActiveEditorState();
      const editor = getActiveEditor();
      const nodeMap = editorState._nodeMap;
      const key = this.__key;
      const latestNode = this.getLatest();
      const cloneNotNeeded = editor._cloneNotNeeded;
      const selection = $getSelection();
      if (selection !== null) {
        selection.setCachedNodes(null);
      }
      if (cloneNotNeeded.has(key)) {
        internalMarkNodeAsDirty(latestNode);
        return latestNode;
      }
      const mutableNode = $cloneWithProperties(latestNode);
      cloneNotNeeded.add(key);
      internalMarkNodeAsDirty(mutableNode);
      nodeMap.set(key, mutableNode);
      return mutableNode;
    }
    /**
     * Returns the text content of the node. Override this for
     * custom nodes that should have a representation in plain text
     * format (for copy + paste, for example)
     *
     */
    getTextContent() {
      return "";
    }
    /**
     * Returns the length of the string produced by calling getTextContent on this node.
     *
     */
    getTextContentSize() {
      return this.getTextContent().length;
    }
    // View
    /**
     * Called during the reconciliation process to determine which nodes
     * to insert into the DOM for this Lexical Node.
     *
     * This method must return exactly one HTMLElement. Nested elements are not supported.
     *
     * Do not attempt to update the Lexical EditorState during this phase of the update lifecycle.
     *
     * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
     * @param _editor - allows access to the editor for context during reconciliation.
     *
     * */
    createDOM(_config, _editor) {
      {
        formatDevErrorMessage(`createDOM: base method not extended`);
      }
    }
    /**
     * Called when a node changes and should update the DOM
     * in whatever way is necessary to make it align with any changes that might
     * have happened during the update.
     *
     * Returning "true" here will cause lexical to unmount and recreate the DOM node
     * (by calling createDOM). You would need to do this if the element tag changes,
     * for instance.
     *
     * */
    updateDOM(_prevNode, _dom, _config) {
      {
        formatDevErrorMessage(`updateDOM: base method not extended`);
      }
    }
    /**
     * Controls how the this node is serialized to HTML. This is important for
     * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
     * in which case the primary transfer format is HTML. It's also important if you're serializing
     * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
     * also use this method to build your own HTML renderer.
     *
     * */
    exportDOM(editor) {
      const element = this.createDOM(editor._config, editor);
      return {
        element
      };
    }
    /**
     * Controls how the this node is serialized to JSON. This is important for
     * copy and paste between Lexical editors sharing the same namespace. It's also important
     * if you're serializing to JSON for persistent storage somewhere.
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    exportJSON() {
      const state = this.__state ? this.__state.toJSON() : void 0;
      return {
        type: this.__type,
        version: 1,
        ...state
      };
    }
    /**
     * Controls how the this node is deserialized from JSON. This is usually boilerplate,
     * but provides an abstraction between the node implementation and serialized interface that can
     * be important if you ever make breaking changes to a node schema (by adding or removing properties).
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    static importJSON(_serializedNode) {
      {
        formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
      }
    }
    /**
     * Update this LexicalNode instance from serialized JSON. It's recommended
     * to implement as much logic as possible in this method instead of the
     * static importJSON method, so that the functionality can be inherited in subclasses.
     *
     * The LexicalUpdateJSON utility type should be used to ignore any type, version,
     * or children properties in the JSON so that the extended JSON from subclasses
     * are acceptable parameters for the super call.
     *
     * If overridden, this method must call super.
     *
     * @example
     * ```ts
     * class MyTextNode extends TextNode {
     *   // ...
     *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {
     *     return $createMyTextNode()
     *       .updateFromJSON(serializedNode);
     *   }
     *   updateFromJSON(
     *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,
     *   ): this {
     *     return super.updateFromJSON(serializedNode)
     *       .setMyProperty(serializedNode.myProperty);
     *   }
     * }
     * ```
     **/
    updateFromJSON(serializedNode) {
      return $updateStateFromJSON(this, serializedNode);
    }
    /**
     * @experimental
     *
     * Registers the returned function as a transform on the node during
     * Editor initialization. Most such use cases should be addressed via
     * the {@link LexicalEditor.registerNodeTransform} API.
     *
     * Experimental - use at your own risk.
     */
    static transform() {
      return null;
    }
    // Setters and mutators
    /**
     * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
     * somewhere, the Lexical garbage collector will eventually clean it up.
     *
     * @param preserveEmptyParent - If falsy, the node's parent will be removed if
     * it's empty after the removal operation. This is the default behavior, subject to
     * other node heuristics such as {@link ElementNode#canBeEmpty}
     * */
    remove(preserveEmptyParent) {
      $removeNode(this, true, preserveEmptyParent);
    }
    /**
     * Replaces this LexicalNode with the provided node, optionally transferring the children
     * of the replaced node to the replacing node.
     *
     * @param replaceWith - The node to replace this one with.
     * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
     * */
    replace(replaceWith, includeChildren) {
      errorOnReadOnly();
      let selection = $getSelection();
      if (selection !== null) {
        selection = selection.clone();
      }
      errorOnInsertTextNodeOnRoot(this, replaceWith);
      const self2 = this.getLatest();
      const toReplaceKey = this.__key;
      const key = replaceWith.__key;
      const writableReplaceWith = replaceWith.getWritable();
      const writableParent = this.getParentOrThrow().getWritable();
      const size2 = writableParent.__size;
      removeFromParent(writableReplaceWith);
      const prevSibling = self2.getPreviousSibling();
      const nextSibling = self2.getNextSibling();
      const prevKey = self2.__prev;
      const nextKey = self2.__next;
      const parentKey = self2.__parent;
      $removeNode(self2, false, true);
      if (prevSibling === null) {
        writableParent.__first = key;
      } else {
        const writablePrevSibling = prevSibling.getWritable();
        writablePrevSibling.__next = key;
      }
      writableReplaceWith.__prev = prevKey;
      if (nextSibling === null) {
        writableParent.__last = key;
      } else {
        const writableNextSibling = nextSibling.getWritable();
        writableNextSibling.__prev = key;
      }
      writableReplaceWith.__next = nextKey;
      writableReplaceWith.__parent = parentKey;
      writableParent.__size = size2;
      if (includeChildren) {
        if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {
          formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);
        }
        this.getChildren().forEach((child) => {
          writableReplaceWith.append(child);
        });
      }
      if ($isRangeSelection(selection)) {
        $setSelection(selection);
        const anchor = selection.anchor;
        const focus = selection.focus;
        if (anchor.key === toReplaceKey) {
          $moveSelectionPointToEnd(anchor, writableReplaceWith);
        }
        if (focus.key === toReplaceKey) {
          $moveSelectionPointToEnd(focus, writableReplaceWith);
        }
      }
      if ($getCompositionKey() === toReplaceKey) {
        $setCompositionKey(key);
      }
      return writableReplaceWith;
    }
    /**
     * Inserts a node after this LexicalNode (as the next sibling).
     *
     * @param nodeToInsert - The node to insert after this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertAfter(nodeToInsert, restoreSelection = true) {
      errorOnReadOnly();
      errorOnInsertTextNodeOnRoot(this, nodeToInsert);
      const writableSelf = this.getWritable();
      const writableNodeToInsert = nodeToInsert.getWritable();
      const oldParent = writableNodeToInsert.getParent();
      const selection = $getSelection();
      let elementAnchorSelectionOnNode = false;
      let elementFocusSelectionOnNode = false;
      if (oldParent !== null) {
        const oldIndex = nodeToInsert.getIndexWithinParent();
        removeFromParent(writableNodeToInsert);
        if ($isRangeSelection(selection)) {
          const oldParentKey = oldParent.__key;
          const anchor = selection.anchor;
          const focus = selection.focus;
          elementAnchorSelectionOnNode = anchor.type === "element" && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;
          elementFocusSelectionOnNode = focus.type === "element" && focus.key === oldParentKey && focus.offset === oldIndex + 1;
        }
      }
      const nextSibling = this.getNextSibling();
      const writableParent = this.getParentOrThrow().getWritable();
      const insertKey = writableNodeToInsert.__key;
      const nextKey = writableSelf.__next;
      if (nextSibling === null) {
        writableParent.__last = insertKey;
      } else {
        const writableNextSibling = nextSibling.getWritable();
        writableNextSibling.__prev = insertKey;
      }
      writableParent.__size++;
      writableSelf.__next = insertKey;
      writableNodeToInsert.__next = nextKey;
      writableNodeToInsert.__prev = writableSelf.__key;
      writableNodeToInsert.__parent = writableSelf.__parent;
      if (restoreSelection && $isRangeSelection(selection)) {
        const index2 = this.getIndexWithinParent();
        $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index2 + 1);
        const writableParentKey = writableParent.__key;
        if (elementAnchorSelectionOnNode) {
          selection.anchor.set(writableParentKey, index2 + 2, "element");
        }
        if (elementFocusSelectionOnNode) {
          selection.focus.set(writableParentKey, index2 + 2, "element");
        }
      }
      return nodeToInsert;
    }
    /**
     * Inserts a node before this LexicalNode (as the previous sibling).
     *
     * @param nodeToInsert - The node to insert before this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertBefore(nodeToInsert, restoreSelection = true) {
      errorOnReadOnly();
      errorOnInsertTextNodeOnRoot(this, nodeToInsert);
      const writableSelf = this.getWritable();
      const writableNodeToInsert = nodeToInsert.getWritable();
      const insertKey = writableNodeToInsert.__key;
      removeFromParent(writableNodeToInsert);
      const prevSibling = this.getPreviousSibling();
      const writableParent = this.getParentOrThrow().getWritable();
      const prevKey = writableSelf.__prev;
      const index2 = this.getIndexWithinParent();
      if (prevSibling === null) {
        writableParent.__first = insertKey;
      } else {
        const writablePrevSibling = prevSibling.getWritable();
        writablePrevSibling.__next = insertKey;
      }
      writableParent.__size++;
      writableSelf.__prev = insertKey;
      writableNodeToInsert.__prev = prevKey;
      writableNodeToInsert.__next = writableSelf.__key;
      writableNodeToInsert.__parent = writableSelf.__parent;
      const selection = $getSelection();
      if (restoreSelection && $isRangeSelection(selection)) {
        const parent = this.getParentOrThrow();
        $updateElementSelectionOnCreateDeleteNode(selection, parent, index2);
      }
      return nodeToInsert;
    }
    /**
     * Whether or not this node has a required parent. Used during copy + paste operations
     * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
     * a ListNode parent or TextNodes with a ParagraphNode parent.
     *
     * */
    isParentRequired() {
      return false;
    }
    /**
     * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
     *
     * */
    createParentElementNode() {
      return $createParagraphNode();
    }
    selectStart() {
      return this.selectPrevious();
    }
    selectEnd() {
      return this.selectNext(0, 0);
    }
    /**
     * Moves selection to the previous sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectPrevious(anchorOffset, focusOffset) {
      errorOnReadOnly();
      const prevSibling = this.getPreviousSibling();
      const parent = this.getParentOrThrow();
      if (prevSibling === null) {
        return parent.select(0, 0);
      }
      if ($isElementNode(prevSibling)) {
        return prevSibling.select();
      } else if (!$isTextNode(prevSibling)) {
        const index2 = prevSibling.getIndexWithinParent() + 1;
        return parent.select(index2, index2);
      }
      return prevSibling.select(anchorOffset, focusOffset);
    }
    /**
     * Moves selection to the next sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectNext(anchorOffset, focusOffset) {
      errorOnReadOnly();
      const nextSibling = this.getNextSibling();
      const parent = this.getParentOrThrow();
      if (nextSibling === null) {
        return parent.select();
      }
      if ($isElementNode(nextSibling)) {
        return nextSibling.select(0, 0);
      } else if (!$isTextNode(nextSibling)) {
        const index2 = nextSibling.getIndexWithinParent();
        return parent.select(index2, index2);
      }
      return nextSibling.select(anchorOffset, focusOffset);
    }
    /**
     * Marks a node dirty, triggering transforms and
     * forcing it to be reconciled during the update cycle.
     *
     * */
    markDirty() {
      this.getWritable();
    }
    /**
     * @internal
     *
     * When the reconciler detects that a node was mutated, this method
     * may be called to restore the node to a known good state.
     */
    reconcileObservedMutation(dom, editor) {
      this.markDirty();
    }
  };
  function errorOnTypeKlassMismatch(type, klass) {
    const registeredNode = getRegisteredNode(getActiveEditor(), type);
    if (registeredNode === void 0) {
      {
        formatDevErrorMessage(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);
      }
    }
    const editorKlass = registeredNode.klass;
    if (editorKlass !== klass) {
      {
        formatDevErrorMessage(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);
      }
    }
  }
  function insertRangeAfter(node, firstToInsert, lastToInsert) {
    const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();
    let current = firstToInsert;
    const nodesToInsert = [firstToInsert];
    while (current !== lastToInsert2) {
      if (!current.getNextSibling()) {
        {
          formatDevErrorMessage(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);
        }
      }
      current = current.getNextSibling();
      nodesToInsert.push(current);
    }
    let currentNode = node;
    for (const nodeToInsert of nodesToInsert) {
      currentNode = currentNode.insertAfter(nodeToInsert);
    }
  }
  var HISTORIC_TAG = "historic";
  var HISTORY_PUSH_TAG = "history-push";
  var HISTORY_MERGE_TAG = "history-merge";
  var PASTE_TAG = "paste";
  var COLLABORATION_TAG = "collaboration";
  var SKIP_COLLAB_TAG = "skip-collab";
  var SKIP_SCROLL_INTO_VIEW_TAG = "skip-scroll-into-view";
  var SKIP_DOM_SELECTION_TAG = "skip-dom-selection";
  var SKIP_SELECTION_FOCUS_TAG = "skip-selection-focus";
  var FOCUS_TAG = "focus";
  var LineBreakNode = class _LineBreakNode extends LexicalNode {
    /** @internal */
    static getType() {
      return "linebreak";
    }
    static clone(node) {
      return new _LineBreakNode(node.__key);
    }
    constructor(key) {
      super(key);
    }
    getTextContent() {
      return "\n";
    }
    createDOM() {
      return document.createElement("br");
    }
    updateDOM() {
      return false;
    }
    isInline() {
      return true;
    }
    static importDOM() {
      return {
        br: (node) => {
          if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {
            return null;
          }
          return {
            conversion: $convertLineBreakElement,
            priority: 0
          };
        }
      };
    }
    static importJSON(serializedLineBreakNode) {
      return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);
    }
  };
  function $convertLineBreakElement(node) {
    return {
      node: $createLineBreakNode()
    };
  }
  function $createLineBreakNode() {
    return $applyNodeReplacement(new LineBreakNode());
  }
  function $isLineBreakNode(node) {
    return node instanceof LineBreakNode;
  }
  function isOnlyChildInBlockNode(node) {
    const parentElement = node.parentElement;
    if (parentElement !== null && isBlockDomNode(parentElement)) {
      const firstChild = parentElement.firstChild;
      if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {
        const lastChild = parentElement.lastChild;
        if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {
          return true;
        }
      }
    }
    return false;
  }
  function isLastChildInBlockNode(node) {
    const parentElement = node.parentElement;
    if (parentElement !== null && isBlockDomNode(parentElement)) {
      const firstChild = parentElement.firstChild;
      if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {
        return false;
      }
      const lastChild = parentElement.lastChild;
      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespaceDomTextNode(node) {
    return isDOMTextNode(node) && /^( |\t|\r?\n)+$/.test(node.textContent || "");
  }
  function getElementOuterTag(node, format) {
    if (format & IS_CODE) {
      return "code";
    }
    if (format & IS_HIGHLIGHT) {
      return "mark";
    }
    if (format & IS_SUBSCRIPT) {
      return "sub";
    }
    if (format & IS_SUPERSCRIPT) {
      return "sup";
    }
    return null;
  }
  function getElementInnerTag(node, format) {
    if (format & IS_BOLD) {
      return "strong";
    }
    if (format & IS_ITALIC) {
      return "em";
    }
    return "span";
  }
  function setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {
    const domClassList = dom.classList;
    let classNames = getCachedClassNameArray(textClassNames, "base");
    if (classNames !== void 0) {
      domClassList.add(...classNames);
    }
    classNames = getCachedClassNameArray(textClassNames, "underlineStrikethrough");
    let hasUnderlineStrikethrough = false;
    const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;
    const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;
    if (classNames !== void 0) {
      if (nextUnderlineStrikethrough) {
        hasUnderlineStrikethrough = true;
        if (!prevUnderlineStrikethrough) {
          domClassList.add(...classNames);
        }
      } else if (prevUnderlineStrikethrough) {
        domClassList.remove(...classNames);
      }
    }
    for (const key in TEXT_TYPE_TO_FORMAT) {
      const format = key;
      const flag = TEXT_TYPE_TO_FORMAT[format];
      classNames = getCachedClassNameArray(textClassNames, key);
      if (classNames !== void 0) {
        if (nextFormat & flag) {
          if (hasUnderlineStrikethrough && (key === "underline" || key === "strikethrough")) {
            if (prevFormat & flag) {
              domClassList.remove(...classNames);
            }
            continue;
          }
          if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === "underline" || key === "strikethrough") {
            domClassList.add(...classNames);
          }
        } else if (prevFormat & flag) {
          domClassList.remove(...classNames);
        }
      }
    }
  }
  function diffComposedText(a2, b3) {
    const aLength = a2.length;
    const bLength = b3.length;
    let left = 0;
    let right = 0;
    while (left < aLength && left < bLength && a2[left] === b3[left]) {
      left++;
    }
    while (right + left < aLength && right + left < bLength && a2[aLength - right - 1] === b3[bLength - right - 1]) {
      right++;
    }
    return [left, aLength - left - right, b3.slice(left, bLength - right)];
  }
  function setTextContent(nextText, dom, node) {
    const firstChild = dom.firstChild;
    const isComposing = node.isComposing();
    const suffix = isComposing ? COMPOSITION_SUFFIX : "";
    const text2 = nextText + suffix;
    if (firstChild == null) {
      dom.textContent = text2;
    } else {
      const nodeValue = firstChild.nodeValue;
      if (nodeValue !== text2) {
        if (isComposing || IS_FIREFOX) {
          const [index2, remove, insert] = diffComposedText(nodeValue, text2);
          if (remove !== 0) {
            firstChild.deleteData(index2, remove);
          }
          firstChild.insertData(index2, insert);
        } else {
          firstChild.nodeValue = text2;
        }
      }
    }
  }
  function createTextInnerDOM(innerDOM, node, innerTag, format, text2, config) {
    setTextContent(text2, innerDOM, node);
    const theme2 = config.theme;
    const textClassNames = theme2.text;
    if (textClassNames !== void 0) {
      setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);
    }
  }
  function wrapElementWith(element, tag) {
    const el = document.createElement(tag);
    el.appendChild(element);
    return el;
  }
  var TextNode = class _TextNode extends LexicalNode {
    /** @internal */
    __text;
    /** @internal */
    __format;
    /** @internal */
    __style;
    /** @internal */
    __mode;
    /** @internal */
    __detail;
    static getType() {
      return "text";
    }
    static clone(node) {
      return new _TextNode(node.__text, node.__key);
    }
    afterCloneFrom(prevNode) {
      super.afterCloneFrom(prevNode);
      this.__text = prevNode.__text;
      this.__format = prevNode.__format;
      this.__style = prevNode.__style;
      this.__mode = prevNode.__mode;
      this.__detail = prevNode.__detail;
    }
    constructor(text2 = "", key) {
      super(key);
      this.__text = text2;
      this.__format = 0;
      this.__style = "";
      this.__mode = 0;
      this.__detail = 0;
    }
    /**
     * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
     *
     * @returns a number representing the format of the text node.
     */
    getFormat() {
      const self2 = this.getLatest();
      return self2.__format;
    }
    /**
     * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
     * or TextNode.isUnmergeable instead.
     *
     * @returns a number representing the detail of the text node.
     */
    getDetail() {
      const self2 = this.getLatest();
      return self2.__detail;
    }
    /**
     * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
     *
     * @returns TextModeType.
     */
    getMode() {
      const self2 = this.getLatest();
      return TEXT_TYPE_TO_MODE[self2.__mode];
    }
    /**
     * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
     *
     * @returns CSSText-like string of styles applied to the underlying DOM node.
     */
    getStyle() {
      const self2 = this.getLatest();
      return self2.__style;
    }
    /**
     * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted as a single entity (not individually by character).
     *
     * @returns true if the node is in token mode, false otherwise.
     */
    isToken() {
      const self2 = this.getLatest();
      return self2.__mode === IS_TOKEN;
    }
    /**
     *
     * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
     * mutate the TextNode, false otherwise.
     */
    isComposing() {
      return this.__key === $getCompositionKey();
    }
    /**
     * Returns whether or not the node is in "segmented" mode. TextNodes in segmented mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted in space-delimited "segments".
     *
     * @returns true if the node is in segmented mode, false otherwise.
     */
    isSegmented() {
      const self2 = this.getLatest();
      return self2.__mode === IS_SEGMENTED;
    }
    /**
     * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
     *
     * @returns true if the node is directionless, false otherwise.
     */
    isDirectionless() {
      const self2 = this.getLatest();
      return (self2.__detail & IS_DIRECTIONLESS) !== 0;
    }
    /**
     * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
     * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
     *
     * @returns true if the node is unmergeable, false otherwise.
     */
    isUnmergeable() {
      const self2 = this.getLatest();
      return (self2.__detail & IS_UNMERGEABLE) !== 0;
    }
    /**
     * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
     * string values to get the format of a TextNode.
     *
     * @param type - the TextFormatType to check for.
     *
     * @returns true if the node has the provided format, false otherwise.
     */
    hasFormat(type) {
      const formatFlag = TEXT_TYPE_TO_FORMAT[type];
      return (this.getFormat() & formatFlag) !== 0;
    }
    /**
     * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
     * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
     *
     * @returns true if the node is simple text, false otherwise.
     */
    isSimpleText() {
      return this.__type === "text" && this.__mode === 0;
    }
    /**
     * Returns the text content of the node as a string.
     *
     * @returns a string representing the text content of the node.
     */
    getTextContent() {
      const self2 = this.getLatest();
      return self2.__text;
    }
    /**
     * Returns the format flags applied to the node as a 32-bit integer.
     *
     * @returns a number representing the TextFormatTypes applied to the node.
     */
    getFormatFlags(type, alignWithFormat) {
      const self2 = this.getLatest();
      const format = self2.__format;
      return toggleTextFormatType(format, type, alignWithFormat);
    }
    /**
     *
     * @returns true if the text node supports font styling, false otherwise.
     */
    canHaveFormat() {
      return true;
    }
    /**
     * @returns true if the text node is inline, false otherwise.
     */
    isInline() {
      return true;
    }
    // View
    createDOM(config, editor) {
      const format = this.__format;
      const outerTag = getElementOuterTag(this, format);
      const innerTag = getElementInnerTag(this, format);
      const tag = outerTag === null ? innerTag : outerTag;
      const dom = document.createElement(tag);
      let innerDOM = dom;
      if (this.hasFormat("code")) {
        dom.setAttribute("spellcheck", "false");
      }
      if (outerTag !== null) {
        innerDOM = document.createElement(innerTag);
        dom.appendChild(innerDOM);
      }
      const text2 = this.__text;
      createTextInnerDOM(innerDOM, this, innerTag, format, text2, config);
      const style = this.__style;
      if (style !== "") {
        dom.style.cssText = style;
      }
      return dom;
    }
    updateDOM(prevNode, dom, config) {
      const nextText = this.__text;
      const prevFormat = prevNode.__format;
      const nextFormat = this.__format;
      const prevOuterTag = getElementOuterTag(this, prevFormat);
      const nextOuterTag = getElementOuterTag(this, nextFormat);
      const prevInnerTag = getElementInnerTag(this, prevFormat);
      const nextInnerTag = getElementInnerTag(this, nextFormat);
      const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;
      const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;
      if (prevTag !== nextTag) {
        return true;
      }
      if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {
        const prevInnerDOM = dom.firstChild;
        if (prevInnerDOM == null) {
          {
            formatDevErrorMessage(`updateDOM: prevInnerDOM is null or undefined`);
          }
        }
        const nextInnerDOM = document.createElement(nextInnerTag);
        createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);
        dom.replaceChild(nextInnerDOM, prevInnerDOM);
        return false;
      }
      let innerDOM = dom;
      if (nextOuterTag !== null) {
        if (prevOuterTag !== null) {
          innerDOM = dom.firstChild;
          if (innerDOM == null) {
            {
              formatDevErrorMessage(`updateDOM: innerDOM is null or undefined`);
            }
          }
        }
      }
      setTextContent(nextText, innerDOM, this);
      const theme2 = config.theme;
      const textClassNames = theme2.text;
      if (textClassNames !== void 0 && prevFormat !== nextFormat) {
        setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);
      }
      const prevStyle = prevNode.__style;
      const nextStyle = this.__style;
      if (prevStyle !== nextStyle) {
        dom.style.cssText = nextStyle;
      }
      return false;
    }
    static importDOM() {
      return {
        "#text": () => ({
          conversion: $convertTextDOMNode,
          priority: 0
        }),
        b: () => ({
          conversion: convertBringAttentionToElement,
          priority: 0
        }),
        code: () => ({
          conversion: convertTextFormatElement,
          priority: 0
        }),
        em: () => ({
          conversion: convertTextFormatElement,
          priority: 0
        }),
        i: () => ({
          conversion: convertTextFormatElement,
          priority: 0
        }),
        mark: () => ({
          conversion: convertTextFormatElement,
          priority: 0
        }),
        s: () => ({
          conversion: convertTextFormatElement,
          priority: 0
        }),
        span: () => ({
          conversion: convertSpanElement,
          priority: 0
        }),
        strong: () => ({
          conversion: convertTextFormatElement,
          priority: 0
        }),
        sub: () => ({
          conversion: convertTextFormatElement,
          priority: 0
        }),
        sup: () => ({
          conversion: convertTextFormatElement,
          priority: 0
        }),
        u: () => ({
          conversion: convertTextFormatElement,
          priority: 0
        })
      };
    }
    static importJSON(serializedNode) {
      return $createTextNode().updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);
    }
    // This improves Lexical's basic text output in copy+paste plus
    // for headless mode where people might use Lexical to generate
    // HTML content and not have the ability to use CSS classes.
    exportDOM(editor) {
      let {
        element
      } = super.exportDOM(editor);
      if (!isHTMLElement(element)) {
        formatDevErrorMessage(`Expected TextNode createDOM to always return a HTMLElement`);
      }
      element.style.whiteSpace = "pre-wrap";
      if (this.hasFormat("lowercase")) {
        element.style.textTransform = "lowercase";
      } else if (this.hasFormat("uppercase")) {
        element.style.textTransform = "uppercase";
      } else if (this.hasFormat("capitalize")) {
        element.style.textTransform = "capitalize";
      }
      if (this.hasFormat("bold")) {
        element = wrapElementWith(element, "b");
      }
      if (this.hasFormat("italic")) {
        element = wrapElementWith(element, "i");
      }
      if (this.hasFormat("strikethrough")) {
        element = wrapElementWith(element, "s");
      }
      if (this.hasFormat("underline")) {
        element = wrapElementWith(element, "u");
      }
      return {
        element
      };
    }
    exportJSON() {
      return {
        detail: this.getDetail(),
        format: this.getFormat(),
        mode: this.getMode(),
        style: this.getStyle(),
        text: this.getTextContent(),
        // As an exception here we invoke super at the end for historical reasons.
        // Namely, to preserve the order of the properties and not to break the tests
        // that use the serialized string representation.
        ...super.exportJSON()
      };
    }
    // Mutators
    selectionTransform(prevSelection, nextSelection) {
      return;
    }
    /**
     * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
     * version of the argument can only specify one format and doing so will remove all other formats that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
     *
     * @param format - TextFormatType or 32-bit integer representing the node format.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setFormat(format) {
      const self2 = this.getWritable();
      self2.__format = typeof format === "string" ? TEXT_TYPE_TO_FORMAT[format] : format;
      return self2;
    }
    /**
     * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
     * version of the argument can only specify one detail value and doing so will remove all other detail values that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
     * or {@link TextNode.toggleUnmergeable}
     *
     * @param detail - TextDetailType or 32-bit integer representing the node detail.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setDetail(detail) {
      const self2 = this.getWritable();
      self2.__detail = typeof detail === "string" ? DETAIL_TYPE_TO_DETAIL[detail] : detail;
      return self2;
    }
    /**
     * Sets the node style to the provided CSSText-like string. Set this property as you
     * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
     *
     * @param style - CSSText to be applied to the underlying HTMLElement.
     *
     * @returns this TextNode.
     */
    setStyle(style) {
      const self2 = this.getWritable();
      self2.__style = style;
      return self2;
    }
    /**
     * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
     * The subscript and superscript formats are mutually exclusive.
     * Prefer using this method to turn specific formats on and off.
     *
     * @param type - TextFormatType to toggle.
     *
     * @returns this TextNode.
     */
    toggleFormat(type) {
      const format = this.getFormat();
      const newFormat = toggleTextFormatType(format, type, null);
      return this.setFormat(newFormat);
    }
    /**
     * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleDirectionless() {
      const self2 = this.getWritable();
      self2.__detail ^= IS_DIRECTIONLESS;
      return self2;
    }
    /**
     * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleUnmergeable() {
      const self2 = this.getWritable();
      self2.__detail ^= IS_UNMERGEABLE;
      return self2;
    }
    /**
     * Sets the mode of the node.
     *
     * @returns this TextNode.
     */
    setMode(type) {
      const mode = TEXT_MODE_TO_TYPE[type];
      if (this.__mode === mode) {
        return this;
      }
      const self2 = this.getWritable();
      self2.__mode = mode;
      return self2;
    }
    /**
     * Sets the text content of the node.
     *
     * @param text - the string to set as the text value of the node.
     *
     * @returns this TextNode.
     */
    setTextContent(text2) {
      if (this.__text === text2) {
        return this;
      }
      const self2 = this.getWritable();
      self2.__text = text2;
      return self2;
    }
    /**
     * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
     *
     * @param _anchorOffset - the offset at which the Selection anchor will be placed.
     * @param _focusOffset - the offset at which the Selection focus will be placed.
     *
     * @returns the new RangeSelection.
     */
    select(_anchorOffset, _focusOffset) {
      errorOnReadOnly();
      let anchorOffset = _anchorOffset;
      let focusOffset = _focusOffset;
      const selection = $getSelection();
      const text2 = this.getTextContent();
      const key = this.__key;
      if (typeof text2 === "string") {
        const lastOffset = text2.length;
        if (anchorOffset === void 0) {
          anchorOffset = lastOffset;
        }
        if (focusOffset === void 0) {
          focusOffset = lastOffset;
        }
      } else {
        anchorOffset = 0;
        focusOffset = 0;
      }
      if (!$isRangeSelection(selection)) {
        return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "text", "text");
      } else {
        const compositionKey = $getCompositionKey();
        if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {
          $setCompositionKey(key);
        }
        selection.setTextNodeRange(this, anchorOffset, this, focusOffset);
      }
      return selection;
    }
    selectStart() {
      return this.select(0, 0);
    }
    selectEnd() {
      const size2 = this.getTextContentSize();
      return this.select(size2, size2);
    }
    /**
     * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
     * specified. Can optionally calculate a new selection after the operation is complete.
     *
     * @param offset - the offset at which the splice operation should begin.
     * @param delCount - the number of characters to delete, starting from the offset.
     * @param newText - the text to insert into the TextNode at the offset.
     * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
     *
     * @returns this TextNode.
     */
    spliceText(offset, delCount, newText, moveSelection) {
      const writableSelf = this.getWritable();
      const text2 = writableSelf.__text;
      const handledTextLength = newText.length;
      let index2 = offset;
      if (index2 < 0) {
        index2 = handledTextLength + index2;
        if (index2 < 0) {
          index2 = 0;
        }
      }
      const selection = $getSelection();
      if (moveSelection && $isRangeSelection(selection)) {
        const newOffset = offset + handledTextLength;
        selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);
      }
      const updatedText = text2.slice(0, index2) + newText + text2.slice(index2 + delCount);
      writableSelf.__text = updatedText;
      return writableSelf;
    }
    /**
     * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted before the node, false otherwise.
     */
    canInsertTextBefore() {
      return true;
    }
    /**
     * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted after the node, false otherwise.
     */
    canInsertTextAfter() {
      return true;
    }
    /**
     * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
     * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
     *
     * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
     *
     * @returns an Array containing the newly-created TextNodes.
     */
    splitText(...splitOffsets) {
      errorOnReadOnly();
      const self2 = this.getLatest();
      const textContent = self2.getTextContent();
      if (textContent === "") {
        return [];
      }
      const key = self2.__key;
      const compositionKey = $getCompositionKey();
      const textLength = textContent.length;
      splitOffsets.sort((a2, b3) => a2 - b3);
      splitOffsets.push(textLength);
      const parts = [];
      const splitOffsetsLength = splitOffsets.length;
      for (let start3 = 0, offsetIndex = 0; start3 < textLength && offsetIndex <= splitOffsetsLength; offsetIndex++) {
        const end = splitOffsets[offsetIndex];
        if (end > start3) {
          parts.push(textContent.slice(start3, end));
          start3 = end;
        }
      }
      const partsLength = parts.length;
      if (partsLength === 1) {
        return [self2];
      }
      const firstPart = parts[0];
      const parent = self2.getParent();
      let writableNode;
      const format = self2.getFormat();
      const style = self2.getStyle();
      const detail = self2.__detail;
      let hasReplacedSelf = false;
      let startTextPoint = null;
      let endTextPoint = null;
      const selection = $getSelection();
      if ($isRangeSelection(selection)) {
        const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];
        if (startPoint.type === "text" && startPoint.key === key) {
          startTextPoint = startPoint;
        }
        if (endPoint.type === "text" && endPoint.key === key) {
          endTextPoint = endPoint;
        }
      }
      if (self2.isSegmented()) {
        writableNode = $createTextNode(firstPart);
        writableNode.__format = format;
        writableNode.__style = style;
        writableNode.__detail = detail;
        writableNode.__state = $cloneNodeState(self2, writableNode);
        hasReplacedSelf = true;
      } else {
        writableNode = self2.setTextContent(firstPart);
      }
      const splitNodes = [writableNode];
      for (let i2 = 1; i2 < partsLength; i2++) {
        const part = parts[i2];
        const sibling = $createTextNode(part);
        sibling.__format = format;
        sibling.__style = style;
        sibling.__detail = detail;
        sibling.__state = $cloneNodeState(self2, sibling);
        const siblingKey = sibling.__key;
        if (compositionKey === key) {
          $setCompositionKey(siblingKey);
        }
        splitNodes.push(sibling);
      }
      const originalStartOffset = startTextPoint ? startTextPoint.offset : null;
      const originalEndOffset = endTextPoint ? endTextPoint.offset : null;
      let startOffset = 0;
      for (const node of splitNodes) {
        if (!(startTextPoint || endTextPoint)) {
          break;
        }
        const endOffset = startOffset + node.getTextContentSize();
        if (startTextPoint !== null && originalStartOffset !== null && originalStartOffset <= endOffset && originalStartOffset >= startOffset) {
          startTextPoint.set(node.getKey(), originalStartOffset - startOffset, "text");
          if (originalStartOffset < endOffset) {
            startTextPoint = null;
          }
        }
        if (endTextPoint !== null && originalEndOffset !== null && originalEndOffset <= endOffset && originalEndOffset >= startOffset) {
          endTextPoint.set(node.getKey(), originalEndOffset - startOffset, "text");
          break;
        }
        startOffset = endOffset;
      }
      if (parent !== null) {
        internalMarkSiblingsAsDirty(this);
        const writableParent = parent.getWritable();
        const insertionIndex = this.getIndexWithinParent();
        if (hasReplacedSelf) {
          writableParent.splice(insertionIndex, 0, splitNodes);
          this.remove();
        } else {
          writableParent.splice(insertionIndex, 1, splitNodes);
        }
        if ($isRangeSelection(selection)) {
          $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);
        }
      }
      return splitNodes;
    }
    /**
     * Merges the target TextNode into this TextNode, removing the target node.
     *
     * @param target - the TextNode to merge into this one.
     *
     * @returns this TextNode.
     */
    mergeWithSibling(target) {
      const isBefore = target === this.getPreviousSibling();
      if (!isBefore && target !== this.getNextSibling()) {
        {
          formatDevErrorMessage(`mergeWithSibling: sibling must be a previous or next sibling`);
        }
      }
      const key = this.__key;
      const targetKey = target.__key;
      const text2 = this.__text;
      const textLength = text2.length;
      const compositionKey = $getCompositionKey();
      if (compositionKey === targetKey) {
        $setCompositionKey(key);
      }
      const selection = $getSelection();
      if ($isRangeSelection(selection)) {
        const anchor = selection.anchor;
        const focus = selection.focus;
        if (anchor !== null && anchor.key === targetKey) {
          adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);
        }
        if (focus !== null && focus.key === targetKey) {
          adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);
        }
      }
      const targetText = target.__text;
      const newText = isBefore ? targetText + text2 : text2 + targetText;
      this.setTextContent(newText);
      const writableSelf = this.getWritable();
      target.remove();
      return writableSelf;
    }
    /**
     * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes
     * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
     * node class that you create and replace matched text with should return true from this method.
     *
     * @returns true if the node is to be treated as a "text entity", false otherwise.
     */
    isTextEntity() {
      return false;
    }
  };
  function convertSpanElement(domNode) {
    const span = domNode;
    const style = span.style;
    return {
      forChild: applyTextFormatFromStyle(style),
      node: null
    };
  }
  function convertBringAttentionToElement(domNode) {
    const b3 = domNode;
    const hasNormalFontWeight = b3.style.fontWeight === "normal";
    return {
      forChild: applyTextFormatFromStyle(b3.style, hasNormalFontWeight ? void 0 : "bold"),
      node: null
    };
  }
  var preParentCache = /* @__PURE__ */ new WeakMap();
  function isNodePre(node) {
    if (!isHTMLElement(node)) {
      return false;
    } else if (node.nodeName === "PRE") {
      return true;
    }
    const whiteSpace = node.style.whiteSpace;
    return typeof whiteSpace === "string" && whiteSpace.startsWith("pre");
  }
  function findParentPreDOMNode(node) {
    let cached;
    let parent = node.parentNode;
    const visited = [node];
    while (parent !== null && (cached = preParentCache.get(parent)) === void 0 && !isNodePre(parent)) {
      visited.push(parent);
      parent = parent.parentNode;
    }
    const resultNode = cached === void 0 ? parent : cached;
    for (let i2 = 0; i2 < visited.length; i2++) {
      preParentCache.set(visited[i2], resultNode);
    }
    return resultNode;
  }
  function $convertTextDOMNode(domNode) {
    const domNode_ = domNode;
    const parentDom = domNode.parentElement;
    if (!(parentDom !== null)) {
      formatDevErrorMessage(`Expected parentElement of Text not to be null`);
    }
    let textContent = domNode_.textContent || "";
    if (findParentPreDOMNode(domNode_) !== null) {
      const parts = textContent.split(/(\r?\n|\t)/);
      const nodes = [];
      const length = parts.length;
      for (let i2 = 0; i2 < length; i2++) {
        const part = parts[i2];
        if (part === "\n" || part === "\r\n") {
          nodes.push($createLineBreakNode());
        } else if (part === "	") {
          nodes.push($createTabNode());
        } else if (part !== "") {
          nodes.push($createTextNode(part));
        }
      }
      return {
        node: nodes
      };
    }
    textContent = textContent.replace(/\r/g, "").replace(/[ \t\n]+/g, " ");
    if (textContent === "") {
      return {
        node: null
      };
    }
    if (textContent[0] === " ") {
      let previousText = domNode_;
      let isStartOfLine = true;
      while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {
        const previousTextContent = previousText.textContent || "";
        if (previousTextContent.length > 0) {
          if (/[ \t\n]$/.test(previousTextContent)) {
            textContent = textContent.slice(1);
          }
          isStartOfLine = false;
          break;
        }
      }
      if (isStartOfLine) {
        textContent = textContent.slice(1);
      }
    }
    if (textContent[textContent.length - 1] === " ") {
      let nextText = domNode_;
      let isEndOfLine = true;
      while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {
        const nextTextContent = (nextText.textContent || "").replace(/^( |\t|\r?\n)+/, "");
        if (nextTextContent.length > 0) {
          isEndOfLine = false;
          break;
        }
      }
      if (isEndOfLine) {
        textContent = textContent.slice(0, textContent.length - 1);
      }
    }
    if (textContent === "") {
      return {
        node: null
      };
    }
    return {
      node: $createTextNode(textContent)
    };
  }
  function findTextInLine(text2, forward) {
    let node = text2;
    while (true) {
      let sibling;
      while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {
        const parentElement = node.parentElement;
        if (parentElement === null) {
          return null;
        }
        node = parentElement;
      }
      node = sibling;
      if (isHTMLElement(node)) {
        const display = node.style.display;
        if (display === "" && !isInlineDomNode(node) || display !== "" && !display.startsWith("inline")) {
          return null;
        }
      }
      let descendant = node;
      while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {
        node = descendant;
      }
      if (isDOMTextNode(node)) {
        return node;
      } else if (node.nodeName === "BR") {
        return null;
      }
    }
  }
  var nodeNameToTextFormat = {
    code: "code",
    em: "italic",
    i: "italic",
    mark: "highlight",
    s: "strikethrough",
    strong: "bold",
    sub: "subscript",
    sup: "superscript",
    u: "underline"
  };
  function convertTextFormatElement(domNode) {
    const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];
    if (format === void 0) {
      return {
        node: null
      };
    }
    return {
      forChild: applyTextFormatFromStyle(domNode.style, format),
      node: null
    };
  }
  function $createTextNode(text2 = "") {
    return $applyNodeReplacement(new TextNode(text2));
  }
  function $isTextNode(node) {
    return node instanceof TextNode;
  }
  function applyTextFormatFromStyle(style, shouldApply) {
    const fontWeight = style.fontWeight;
    const textDecoration = style.textDecoration.split(" ");
    const hasBoldFontWeight = fontWeight === "700" || fontWeight === "bold";
    const hasLinethroughTextDecoration = textDecoration.includes("line-through");
    const hasItalicFontStyle = style.fontStyle === "italic";
    const hasUnderlineTextDecoration = textDecoration.includes("underline");
    const verticalAlign = style.verticalAlign;
    return (lexicalNode) => {
      if (!$isTextNode(lexicalNode)) {
        return lexicalNode;
      }
      if (hasBoldFontWeight && !lexicalNode.hasFormat("bold")) {
        lexicalNode.toggleFormat("bold");
      }
      if (hasLinethroughTextDecoration && !lexicalNode.hasFormat("strikethrough")) {
        lexicalNode.toggleFormat("strikethrough");
      }
      if (hasItalicFontStyle && !lexicalNode.hasFormat("italic")) {
        lexicalNode.toggleFormat("italic");
      }
      if (hasUnderlineTextDecoration && !lexicalNode.hasFormat("underline")) {
        lexicalNode.toggleFormat("underline");
      }
      if (verticalAlign === "sub" && !lexicalNode.hasFormat("subscript")) {
        lexicalNode.toggleFormat("subscript");
      }
      if (verticalAlign === "super" && !lexicalNode.hasFormat("superscript")) {
        lexicalNode.toggleFormat("superscript");
      }
      if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {
        lexicalNode.toggleFormat(shouldApply);
      }
      return lexicalNode;
    };
  }
  var TabNode = class _TabNode extends TextNode {
    static getType() {
      return "tab";
    }
    static clone(node) {
      return new _TabNode(node.__key);
    }
    constructor(key) {
      super("	", key);
      this.__detail = IS_UNMERGEABLE;
    }
    static importDOM() {
      return null;
    }
    createDOM(config) {
      const dom = super.createDOM(config);
      const classNames = getCachedClassNameArray(config.theme, "tab");
      if (classNames !== void 0) {
        const domClassList = dom.classList;
        domClassList.add(...classNames);
      }
      return dom;
    }
    static importJSON(serializedTabNode) {
      return $createTabNode().updateFromJSON(serializedTabNode);
    }
    setTextContent(text2) {
      if (!(text2 === "	" || text2 === "")) {
        formatDevErrorMessage(`TabNode does not support setTextContent`);
      }
      return super.setTextContent("	");
    }
    spliceText(offset, delCount, newText, moveSelection) {
      if (!(newText === "" && delCount === 0 || newText === "	" && delCount === 1)) {
        formatDevErrorMessage(`TabNode does not support spliceText`);
      }
      return this;
    }
    setDetail(detail) {
      if (!(detail === IS_UNMERGEABLE)) {
        formatDevErrorMessage(`TabNode does not support setDetail`);
      }
      return this;
    }
    setMode(type) {
      if (!(type === "normal")) {
        formatDevErrorMessage(`TabNode does not support setMode`);
      }
      return this;
    }
    canInsertTextBefore() {
      return false;
    }
    canInsertTextAfter() {
      return false;
    }
  };
  function $createTabNode() {
    return $applyNodeReplacement(new TabNode());
  }
  function $isTabNode(node) {
    return node instanceof TabNode;
  }
  var Point = class {
    key;
    offset;
    type;
    _selection;
    constructor(key, offset, type) {
      {
        Object.defineProperty(this, "_selection", {
          enumerable: false,
          writable: true
        });
      }
      this._selection = null;
      this.key = key;
      this.offset = offset;
      this.type = type;
    }
    is(point) {
      return this.key === point.key && this.offset === point.offset && this.type === point.type;
    }
    isBefore(b3) {
      if (this.key === b3.key) {
        return this.offset < b3.offset;
      }
      const aCaret = $normalizeCaret($caretFromPoint(this, "next"));
      const bCaret = $normalizeCaret($caretFromPoint(b3, "next"));
      return $comparePointCaretNext(aCaret, bCaret) < 0;
    }
    getNode() {
      const key = this.key;
      const node = $getNodeByKey(key);
      if (node === null) {
        {
          formatDevErrorMessage(`Point.getNode: node not found`);
        }
      }
      return node;
    }
    set(key, offset, type, onlyIfChanged) {
      const selection = this._selection;
      const oldKey = this.key;
      if (onlyIfChanged && this.key === key && this.offset === offset && this.type === type) {
        return;
      }
      this.key = key;
      this.offset = offset;
      this.type = type;
      {
        const node = $getNodeByKey(key);
        if (!(type === "text" ? $isTextNode(node) : $isElementNode(node))) {
          formatDevErrorMessage(`PointType.set: node with key ${key} is ${node ? node.__type : "[not found]"} and can not be used for a ${type} point`);
        }
      }
      if (!isCurrentlyReadOnlyMode()) {
        if ($getCompositionKey() === oldKey) {
          $setCompositionKey(key);
        }
        if (selection !== null) {
          selection.setCachedNodes(null);
          selection.dirty = true;
        }
      }
    }
  };
  function $createPoint(key, offset, type) {
    return new Point(key, offset, type);
  }
  function selectPointOnNode(point, node) {
    let key = node.__key;
    let offset = point.offset;
    let type = "element";
    if ($isTextNode(node)) {
      type = "text";
      const textContentLength = node.getTextContentSize();
      if (offset > textContentLength) {
        offset = textContentLength;
      }
    } else if (!$isElementNode(node)) {
      const nextSibling = node.getNextSibling();
      if ($isTextNode(nextSibling)) {
        key = nextSibling.__key;
        offset = 0;
        type = "text";
      } else {
        const parentNode = node.getParent();
        if (parentNode) {
          key = parentNode.__key;
          offset = node.getIndexWithinParent() + 1;
        }
      }
    }
    point.set(key, offset, type);
  }
  function $moveSelectionPointToEnd(point, node) {
    if ($isElementNode(node)) {
      const lastNode = node.getLastDescendant();
      if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
        selectPointOnNode(point, lastNode);
      } else {
        selectPointOnNode(point, node);
      }
    } else {
      selectPointOnNode(point, node);
    }
  }
  function $transferStartingElementPointToTextPoint(start3, end, format, style) {
    const element = start3.getNode();
    const placementNode = element.getChildAtIndex(start3.offset);
    const textNode = $createTextNode();
    textNode.setFormat(format);
    textNode.setStyle(style);
    if ($isParagraphNode(placementNode)) {
      placementNode.splice(0, 0, [textNode]);
    } else {
      const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;
      if (placementNode === null) {
        element.append(target);
      } else {
        placementNode.insertBefore(target);
      }
    }
    if (start3.is(end)) {
      end.set(textNode.__key, 0, "text");
    }
    start3.set(textNode.__key, 0, "text");
  }
  var NodeSelection = class _NodeSelection {
    _nodes;
    _cachedNodes;
    dirty;
    constructor(objects) {
      this._cachedNodes = null;
      this._nodes = objects;
      this.dirty = false;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(nodes) {
      this._cachedNodes = nodes;
    }
    is(selection) {
      if (!$isNodeSelection(selection)) {
        return false;
      }
      const a2 = this._nodes;
      const b3 = selection._nodes;
      return a2.size === b3.size && Array.from(a2).every((key) => b3.has(key));
    }
    isCollapsed() {
      return false;
    }
    isBackward() {
      return false;
    }
    getStartEndPoints() {
      return null;
    }
    add(key) {
      this.dirty = true;
      this._nodes.add(key);
      this._cachedNodes = null;
    }
    delete(key) {
      this.dirty = true;
      this._nodes.delete(key);
      this._cachedNodes = null;
    }
    clear() {
      this.dirty = true;
      this._nodes.clear();
      this._cachedNodes = null;
    }
    has(key) {
      return this._nodes.has(key);
    }
    clone() {
      return new _NodeSelection(new Set(this._nodes));
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(text2) {
    }
    insertText() {
    }
    insertNodes(nodes) {
      const selectedNodes = this.getNodes();
      const selectedNodesLength = selectedNodes.length;
      const lastSelectedNode = selectedNodes[selectedNodesLength - 1];
      let selectionAtEnd;
      if ($isTextNode(lastSelectedNode)) {
        selectionAtEnd = lastSelectedNode.select();
      } else {
        const index2 = lastSelectedNode.getIndexWithinParent() + 1;
        selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index2, index2);
      }
      selectionAtEnd.insertNodes(nodes);
      for (let i2 = 0; i2 < selectedNodesLength; i2++) {
        selectedNodes[i2].remove();
      }
    }
    getNodes() {
      const cachedNodes = this._cachedNodes;
      if (cachedNodes !== null) {
        return cachedNodes;
      }
      const objects = this._nodes;
      const nodes = [];
      for (const object of objects) {
        const node = $getNodeByKey(object);
        if (node !== null) {
          nodes.push(node);
        }
      }
      if (!isCurrentlyReadOnlyMode()) {
        this._cachedNodes = nodes;
      }
      return nodes;
    }
    getTextContent() {
      const nodes = this.getNodes();
      let textContent = "";
      for (let i2 = 0; i2 < nodes.length; i2++) {
        textContent += nodes[i2].getTextContent();
      }
      return textContent;
    }
    /**
     * Remove all nodes in the NodeSelection. If there were any nodes,
     * replace the selection with a new RangeSelection at the previous
     * location of the first node.
     */
    deleteNodes() {
      const nodes = this.getNodes();
      if (($getSelection() || $getPreviousSelection()) === this && nodes[0]) {
        const firstCaret = $getSiblingCaret(nodes[0], "next");
        $setSelectionFromCaretRange($getCaretRange(firstCaret, firstCaret));
      }
      for (const node of nodes) {
        node.remove();
      }
    }
  };
  function $isRangeSelection(x2) {
    return x2 instanceof RangeSelection;
  }
  var RangeSelection = class _RangeSelection {
    format;
    style;
    anchor;
    focus;
    _cachedNodes;
    dirty;
    constructor(anchor, focus, format, style) {
      this.anchor = anchor;
      this.focus = focus;
      anchor._selection = this;
      focus._selection = this;
      this._cachedNodes = null;
      this.format = format;
      this.style = style;
      this.dirty = false;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(nodes) {
      this._cachedNodes = nodes;
    }
    /**
     * Used to check if the provided selections is equal to this one by value,
     * including anchor, focus, format, and style properties.
     * @param selection - the Selection to compare this one to.
     * @returns true if the Selections are equal, false otherwise.
     */
    is(selection) {
      if (!$isRangeSelection(selection)) {
        return false;
      }
      return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;
    }
    /**
     * Returns whether the Selection is "collapsed", meaning the anchor and focus are
     * the same node and have the same offset.
     *
     * @returns true if the Selection is collapsed, false otherwise.
     */
    isCollapsed() {
      return this.anchor.is(this.focus);
    }
    /**
     * Gets all the nodes in the Selection. Uses caching to make it generally suitable
     * for use in hot paths.
     *
     * See also the {@link CaretRange} APIs (starting with
     * {@link $caretRangeFromSelection}), which are likely to provide a better
     * foundation for any operation where partial selection is relevant
     * (e.g. the anchor or focus are inside an ElementNode and TextNode)
     *
     * @returns an Array containing all the nodes in the Selection
     */
    getNodes() {
      const cachedNodes = this._cachedNodes;
      if (cachedNodes !== null) {
        return cachedNodes;
      }
      const range2 = $getCaretRangeInDirection($caretRangeFromSelection(this), "next");
      const nodes = $getNodesFromCaretRangeCompat(range2);
      {
        if (this.isCollapsed() && nodes.length > 1) {
          {
            formatDevErrorMessage(`RangeSelection.getNodes() returned ${String(nodes.length)} > 1 nodes in a collapsed selection`);
          }
        }
      }
      if (!isCurrentlyReadOnlyMode()) {
        this._cachedNodes = nodes;
      }
      return nodes;
    }
    /**
     * Sets this Selection to be of type "text" at the provided anchor and focus values.
     *
     * @param anchorNode - the anchor node to set on the Selection
     * @param anchorOffset - the offset to set on the Selection
     * @param focusNode - the focus node to set on the Selection
     * @param focusOffset - the focus offset to set on the Selection
     */
    setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchor.set(anchorNode.__key, anchorOffset, "text");
      this.focus.set(focusNode.__key, focusOffset, "text");
    }
    /**
     * Gets the (plain) text content of all the nodes in the selection.
     *
     * @returns a string representing the text content of all the nodes in the Selection
     */
    getTextContent() {
      const nodes = this.getNodes();
      if (nodes.length === 0) {
        return "";
      }
      const firstNode = nodes[0];
      const lastNode = nodes[nodes.length - 1];
      const anchor = this.anchor;
      const focus = this.focus;
      const isBefore = anchor.isBefore(focus);
      const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
      let textContent = "";
      let prevWasElement = true;
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node = nodes[i2];
        if ($isElementNode(node) && !node.isInline()) {
          if (!prevWasElement) {
            textContent += "\n";
          }
          if (node.isEmpty()) {
            prevWasElement = false;
          } else {
            prevWasElement = true;
          }
        } else {
          prevWasElement = false;
          if ($isTextNode(node)) {
            let text2 = node.getTextContent();
            if (node === firstNode) {
              if (node === lastNode) {
                if (anchor.type !== "element" || focus.type !== "element" || focus.offset === anchor.offset) {
                  text2 = anchorOffset < focusOffset ? text2.slice(anchorOffset, focusOffset) : text2.slice(focusOffset, anchorOffset);
                }
              } else {
                text2 = isBefore ? text2.slice(anchorOffset) : text2.slice(focusOffset);
              }
            } else if (node === lastNode) {
              text2 = isBefore ? text2.slice(0, focusOffset) : text2.slice(0, anchorOffset);
            }
            textContent += text2;
          } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {
            textContent += node.getTextContent();
          }
        }
      }
      return textContent;
    }
    /**
     * Attempts to map a DOM selection range onto this Lexical Selection,
     * setting the anchor, focus, and type accordingly
     *
     * @param range a DOM Selection range conforming to the StaticRange interface.
     */
    applyDOMRange(range2) {
      const editor = getActiveEditor();
      const currentEditorState = editor.getEditorState();
      const lastSelection = currentEditorState._selection;
      const resolvedSelectionPoints = $internalResolveSelectionPoints(range2.startContainer, range2.startOffset, range2.endContainer, range2.endOffset, editor, lastSelection);
      if (resolvedSelectionPoints === null) {
        return;
      }
      const [anchorPoint, focusPoint] = resolvedSelectionPoints;
      this.anchor.set(anchorPoint.key, anchorPoint.offset, anchorPoint.type, true);
      this.focus.set(focusPoint.key, focusPoint.offset, focusPoint.type, true);
      $normalizeSelection(this);
    }
    /**
     * Creates a new RangeSelection, copying over all the property values from this one.
     *
     * @returns a new RangeSelection with the same property values as this one.
     */
    clone() {
      const anchor = this.anchor;
      const focus = this.focus;
      const selection = new _RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);
      return selection;
    }
    /**
     * Toggles the provided format on all the TextNodes in the Selection.
     *
     * @param format a string TextFormatType to toggle on the TextNodes in the selection
     */
    toggleFormat(format) {
      this.format = toggleTextFormatType(this.format, format, null);
      this.dirty = true;
    }
    /**
     * Sets the value of the format property on the Selection
     *
     * @param format - the format to set at the value of the format property.
     */
    setFormat(format) {
      this.format = format;
      this.dirty = true;
    }
    /**
     * Sets the value of the style property on the Selection
     *
     * @param style - the style to set at the value of the style property.
     */
    setStyle(style) {
      this.style = style;
      this.dirty = true;
    }
    /**
     * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
     * has the specified format.
     *
     * @param type the TextFormatType to check for.
     * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
     */
    hasFormat(type) {
      const formatFlag = TEXT_TYPE_TO_FORMAT[type];
      return (this.format & formatFlag) !== 0;
    }
    /**
     * Attempts to insert the provided text into the EditorState at the current Selection.
     * converts tabs, newlines, and carriage returns into LexicalNodes.
     *
     * @param text the text to insert into the Selection
     */
    insertRawText(text2) {
      const parts = text2.split(/(\r?\n|\t)/);
      const nodes = [];
      const length = parts.length;
      for (let i2 = 0; i2 < length; i2++) {
        const part = parts[i2];
        if (part === "\n" || part === "\r\n") {
          nodes.push($createLineBreakNode());
        } else if (part === "	") {
          nodes.push($createTabNode());
        } else {
          nodes.push($createTextNode(part));
        }
      }
      this.insertNodes(nodes);
    }
    /**
     * Insert the provided text into the EditorState at the current Selection.
     *
     * @param text the text to insert into the Selection
     */
    insertText(text2) {
      const anchor = this.anchor;
      const focus = this.focus;
      const format = this.format;
      const style = this.style;
      let firstPoint = anchor;
      let endPoint = focus;
      if (!this.isCollapsed() && focus.isBefore(anchor)) {
        firstPoint = focus;
        endPoint = anchor;
      }
      if (firstPoint.type === "element") {
        $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);
      }
      if (endPoint.type === "element") {
        $setPointFromCaret(endPoint, $normalizeCaret($caretFromPoint(endPoint, "next")));
      }
      const startOffset = firstPoint.offset;
      let endOffset = endPoint.offset;
      const selectedNodes = this.getNodes();
      const selectedNodesLength = selectedNodes.length;
      let firstNode = selectedNodes[0];
      if (!$isTextNode(firstNode)) {
        {
          formatDevErrorMessage(`insertText: first node is not a text node`);
        }
      }
      const firstNodeText = firstNode.getTextContent();
      const firstNodeTextLength = firstNodeText.length;
      const firstNodeParent = firstNode.getParentOrThrow();
      const lastIndex = selectedNodesLength - 1;
      let lastNode = selectedNodes[lastIndex];
      if (selectedNodesLength === 1 && endPoint.type === "element") {
        endOffset = firstNodeTextLength;
        endPoint.set(firstPoint.key, endOffset, "text");
      }
      if (this.isCollapsed() && startOffset === firstNodeTextLength && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {
        let nextSibling = firstNode.getNextSibling();
        if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {
          nextSibling = $createTextNode();
          nextSibling.setFormat(format);
          nextSibling.setStyle(style);
          if (!firstNodeParent.canInsertTextAfter()) {
            firstNodeParent.insertAfter(nextSibling);
          } else {
            firstNode.insertAfter(nextSibling);
          }
        }
        nextSibling.select(0, 0);
        firstNode = nextSibling;
        if (text2 !== "") {
          this.insertText(text2);
          return;
        }
      } else if (this.isCollapsed() && startOffset === 0 && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {
        let prevSibling = firstNode.getPreviousSibling();
        if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {
          prevSibling = $createTextNode();
          prevSibling.setFormat(format);
          if (!firstNodeParent.canInsertTextBefore()) {
            firstNodeParent.insertBefore(prevSibling);
          } else {
            firstNode.insertBefore(prevSibling);
          }
        }
        prevSibling.select();
        firstNode = prevSibling;
        if (text2 !== "") {
          this.insertText(text2);
          return;
        }
      } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {
        const textNode = $createTextNode(firstNode.getTextContent());
        textNode.setFormat(format);
        firstNode.replace(textNode);
        firstNode = textNode;
      } else if (!this.isCollapsed() && text2 !== "") {
        const lastNodeParent = lastNode.getParent();
        if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {
          this.insertText("");
          $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);
          this.insertText(text2);
          return;
        }
      }
      if (selectedNodesLength === 1) {
        if ($isTokenOrTab(firstNode)) {
          const textNode = $createTextNode(text2);
          textNode.select();
          firstNode.replace(textNode);
          return;
        }
        const firstNodeFormat = firstNode.getFormat();
        const firstNodeStyle = firstNode.getStyle();
        if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {
          if (firstNode.getTextContent() === "") {
            firstNode.setFormat(format);
            firstNode.setStyle(style);
          } else {
            const textNode = $createTextNode(text2);
            textNode.setFormat(format);
            textNode.setStyle(style);
            textNode.select();
            if (startOffset === 0) {
              firstNode.insertBefore(textNode, false);
            } else {
              const [targetNode] = firstNode.splitText(startOffset);
              targetNode.insertAfter(textNode, false);
            }
            if (textNode.isComposing() && this.anchor.type === "text") {
              this.anchor.offset -= text2.length;
            }
            return;
          }
        } else if ($isTabNode(firstNode)) {
          const textNode = $createTextNode(text2);
          textNode.setFormat(format);
          textNode.setStyle(style);
          textNode.select();
          firstNode.replace(textNode);
          return;
        }
        const delCount = endOffset - startOffset;
        firstNode = firstNode.spliceText(startOffset, delCount, text2, true);
        if (firstNode.getTextContent() === "") {
          firstNode.remove();
        } else if (this.anchor.type === "text") {
          if (firstNode.isComposing()) {
            this.anchor.offset -= text2.length;
          } else {
            this.format = firstNodeFormat;
            this.style = firstNodeStyle;
          }
        }
      } else {
        const markedNodeKeysForKeep = /* @__PURE__ */ new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);
        const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
        let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();
        let lastElementChild = lastNode;
        if (!firstElement.is(lastElement) && lastElement.isInline()) {
          do {
            lastElementChild = lastElement;
            lastElement = lastElement.getParentOrThrow();
          } while (lastElement.isInline());
        }
        if (endPoint.type === "text" && (endOffset !== 0 || lastNode.getTextContent() === "") || endPoint.type === "element" && lastNode.getIndexWithinParent() < endOffset) {
          if ($isTextNode(lastNode) && !$isTokenOrTab(lastNode) && endOffset !== lastNode.getTextContentSize()) {
            if (lastNode.isSegmented()) {
              const textNode = $createTextNode(lastNode.getTextContent());
              lastNode.replace(textNode);
              lastNode = textNode;
            }
            if (!$isRootNode(endPoint.getNode()) && endPoint.type === "text") {
              lastNode = lastNode.spliceText(0, endOffset, "");
            }
            markedNodeKeysForKeep.add(lastNode.__key);
          } else {
            const lastNodeParent = lastNode.getParentOrThrow();
            if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {
              lastNodeParent.remove();
            } else {
              lastNode.remove();
            }
          }
        } else {
          markedNodeKeysForKeep.add(lastNode.__key);
        }
        const lastNodeChildren = lastElement.getChildren();
        const selectedNodesSet = new Set(selectedNodes);
        const firstAndLastElementsAreEqual = firstElement.is(lastElement);
        const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;
        for (let i2 = lastNodeChildren.length - 1; i2 >= 0; i2--) {
          const lastNodeChild = lastNodeChildren[i2];
          if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {
            break;
          }
          if (lastNodeChild.isAttached()) {
            if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {
              if (!firstAndLastElementsAreEqual) {
                insertionTarget.insertAfter(lastNodeChild, false);
              }
            } else {
              lastNodeChild.remove();
            }
          }
        }
        if (!firstAndLastElementsAreEqual) {
          let parent = lastElement;
          let lastRemovedParent = null;
          while (parent !== null) {
            const children = parent.getChildren();
            const childrenLength = children.length;
            if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {
              markedNodeKeysForKeep.delete(parent.__key);
              lastRemovedParent = parent;
            }
            parent = parent.getParent();
          }
        }
        if (!$isTokenOrTab(firstNode)) {
          firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text2, true);
          if (firstNode.getTextContent() === "") {
            firstNode.remove();
          } else if (firstNode.isComposing() && this.anchor.type === "text") {
            this.anchor.offset -= text2.length;
          }
        } else if (startOffset === firstNodeTextLength) {
          firstNode.select();
        } else {
          const textNode = $createTextNode(text2);
          textNode.select();
          firstNode.replace(textNode);
        }
        for (let i2 = 1; i2 < selectedNodesLength; i2++) {
          const selectedNode = selectedNodes[i2];
          const key = selectedNode.__key;
          if (!markedNodeKeysForKeep.has(key)) {
            selectedNode.remove();
          }
        }
      }
    }
    /**
     * Removes the text in the Selection, adjusting the EditorState accordingly.
     */
    removeText() {
      const isCurrentSelection = $getSelection() === this;
      const newRange = $removeTextFromCaretRange($caretRangeFromSelection(this));
      $updateRangeSelectionFromCaretRange(this, newRange);
      if (isCurrentSelection && $getSelection() !== this) {
        $setSelection(this);
      }
    }
    // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)
    /**
     * Applies the provided format to the TextNodes in the Selection, splitting or
     * merging nodes as necessary.
     *
     * @param formatType the format type to apply to the nodes in the Selection.
     * @param alignWithFormat a 32-bit integer representing formatting flags to align with.
     */
    formatText(formatType, alignWithFormat = null) {
      if (this.isCollapsed()) {
        this.toggleFormat(formatType);
        $setCompositionKey(null);
        return;
      }
      const selectedNodes = this.getNodes();
      const selectedTextNodes = [];
      for (const selectedNode of selectedNodes) {
        if ($isTextNode(selectedNode)) {
          selectedTextNodes.push(selectedNode);
        }
      }
      const applyFormatToElements = (alignWith) => {
        selectedNodes.forEach((node) => {
          if ($isElementNode(node)) {
            const newFormat = node.getFormatFlags(formatType, alignWith);
            node.setTextFormat(newFormat);
          }
        });
      };
      const selectedTextNodesLength = selectedTextNodes.length;
      if (selectedTextNodesLength === 0) {
        this.toggleFormat(formatType);
        $setCompositionKey(null);
        applyFormatToElements(alignWithFormat);
        return;
      }
      const anchor = this.anchor;
      const focus = this.focus;
      const isBackward = this.isBackward();
      const startPoint = isBackward ? focus : anchor;
      const endPoint = isBackward ? anchor : focus;
      let firstIndex = 0;
      let firstNode = selectedTextNodes[0];
      let startOffset = startPoint.type === "element" ? 0 : startPoint.offset;
      if (startPoint.type === "text" && startOffset === firstNode.getTextContentSize()) {
        firstIndex = 1;
        firstNode = selectedTextNodes[1];
        startOffset = 0;
      }
      if (firstNode == null) {
        return;
      }
      const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);
      applyFormatToElements(firstNextFormat);
      const lastIndex = selectedTextNodesLength - 1;
      let lastNode = selectedTextNodes[lastIndex];
      const endOffset = endPoint.type === "text" ? endPoint.offset : lastNode.getTextContentSize();
      if (firstNode.is(lastNode)) {
        if (startOffset === endOffset) {
          return;
        }
        if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {
          firstNode.setFormat(firstNextFormat);
        } else {
          const splitNodes = firstNode.splitText(startOffset, endOffset);
          const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
          replacement.setFormat(firstNextFormat);
          if (startPoint.type === "text") {
            startPoint.set(replacement.__key, 0, "text");
          }
          if (endPoint.type === "text") {
            endPoint.set(replacement.__key, endOffset - startOffset, "text");
          }
        }
        this.format = firstNextFormat;
        return;
      }
      if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {
        [, firstNode] = firstNode.splitText(startOffset);
        startOffset = 0;
      }
      firstNode.setFormat(firstNextFormat);
      const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);
      if (endOffset > 0) {
        if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {
          [lastNode] = lastNode.splitText(endOffset);
        }
        lastNode.setFormat(lastNextFormat);
      }
      for (let i2 = firstIndex + 1; i2 < lastIndex; i2++) {
        const textNode = selectedTextNodes[i2];
        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);
        textNode.setFormat(nextFormat);
      }
      if (startPoint.type === "text") {
        startPoint.set(firstNode.__key, startOffset, "text");
      }
      if (endPoint.type === "text") {
        endPoint.set(lastNode.__key, endOffset, "text");
      }
      this.format = firstNextFormat | lastNextFormat;
    }
    /**
     * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
     * current Selection according to a set of heuristics that determine how surrounding nodes
     * should be changed, replaced, or moved to accommodate the incoming ones.
     *
     * @param nodes - the nodes to insert
     */
    insertNodes(nodes) {
      if (nodes.length === 0) {
        return;
      }
      if (!this.isCollapsed()) {
        this.removeText();
      }
      if (this.anchor.key === "root") {
        this.insertParagraph();
        const selection = $getSelection();
        if (!$isRangeSelection(selection)) {
          formatDevErrorMessage(`Expected RangeSelection after insertParagraph`);
        }
        return selection.insertNodes(nodes);
      }
      const firstPoint = this.isBackward() ? this.focus : this.anchor;
      const firstNode = firstPoint.getNode();
      const firstBlock = $findMatchingParent(firstNode, INTERNAL_$isBlock);
      const last = nodes[nodes.length - 1];
      if ($isElementNode(firstBlock) && "__language" in firstBlock) {
        if ("__language" in nodes[0]) {
          this.insertText(nodes[0].getTextContent());
        } else {
          const index2 = $removeTextAndSplitBlock(this);
          firstBlock.splice(index2, 0, nodes);
          last.selectEnd();
        }
        return;
      }
      const notInline = (node) => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();
      if (!nodes.some(notInline)) {
        if (!$isElementNode(firstBlock)) {
          formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);
        }
        const index2 = $removeTextAndSplitBlock(this);
        firstBlock.splice(index2, 0, nodes);
        last.selectEnd();
        return;
      }
      const blocksParent = $wrapInlineNodes(nodes);
      const nodeToSelect = blocksParent.getLastDescendant();
      const blocks = blocksParent.getChildren();
      const isMergeable = (node) => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());
      const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();
      const insertedParagraph = shouldInsert ? this.insertParagraph() : null;
      const lastToInsert = blocks[blocks.length - 1];
      let firstToInsert = blocks[0];
      if (isMergeable(firstToInsert)) {
        if (!$isElementNode(firstBlock)) {
          formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);
        }
        firstBlock.append(...firstToInsert.getChildren());
        firstToInsert = blocks[1];
      }
      if (firstToInsert) {
        if (!(firstBlock !== null)) {
          formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);
        }
        insertRangeAfter(firstBlock, firstToInsert);
      }
      const lastInsertedBlock = $findMatchingParent(nodeToSelect, INTERNAL_$isBlock);
      if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {
        lastInsertedBlock.append(...insertedParagraph.getChildren());
        insertedParagraph.remove();
      }
      if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {
        firstBlock.remove();
      }
      nodeToSelect.selectEnd();
      const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;
      if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {
        lastChild.remove();
      }
    }
    /**
     * Inserts a new ParagraphNode into the EditorState at the current Selection
     *
     * @returns the newly inserted node.
     */
    insertParagraph() {
      if (this.anchor.key === "root") {
        const paragraph = $createParagraphNode();
        $getRoot().splice(this.anchor.offset, 0, [paragraph]);
        paragraph.select();
        return paragraph;
      }
      const index2 = $removeTextAndSplitBlock(this);
      const block = $findMatchingParent(this.anchor.getNode(), INTERNAL_$isBlock);
      if (!$isElementNode(block)) {
        formatDevErrorMessage(`Expected ancestor to be a block ElementNode`);
      }
      const firstToAppend = block.getChildAtIndex(index2);
      const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];
      const newBlock = block.insertNewAfter(this, false);
      if (newBlock) {
        newBlock.append(...nodesToInsert);
        newBlock.selectStart();
        return newBlock;
      }
      return null;
    }
    /**
     * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
     * current Selection.
     */
    insertLineBreak(selectStart) {
      const lineBreak = $createLineBreakNode();
      this.insertNodes([lineBreak]);
      if (selectStart) {
        const parent = lineBreak.getParentOrThrow();
        const index2 = lineBreak.getIndexWithinParent();
        parent.select(index2, index2);
      }
    }
    /**
     * Extracts the nodes in the Selection, splitting nodes where necessary
     * to get offset-level precision.
     *
     * @returns The nodes in the Selection
     */
    extract() {
      const selectedNodes = [...this.getNodes()];
      const selectedNodesLength = selectedNodes.length;
      let firstNode = selectedNodes[0];
      let lastNode = selectedNodes[selectedNodesLength - 1];
      const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
      const isBackward = this.isBackward();
      const [startPoint, endPoint] = isBackward ? [this.focus, this.anchor] : [this.anchor, this.focus];
      const [startOffset, endOffset] = isBackward ? [focusOffset, anchorOffset] : [anchorOffset, focusOffset];
      if (selectedNodesLength === 0) {
        return [];
      } else if (selectedNodesLength === 1) {
        if ($isTextNode(firstNode) && !this.isCollapsed()) {
          const splitNodes = firstNode.splitText(startOffset, endOffset);
          const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];
          if (node) {
            startPoint.set(node.getKey(), 0, "text");
            endPoint.set(node.getKey(), node.getTextContentSize(), "text");
            return [node];
          }
          return [];
        }
        return [firstNode];
      }
      if ($isTextNode(firstNode)) {
        if (startOffset === firstNode.getTextContentSize()) {
          selectedNodes.shift();
        } else if (startOffset !== 0) {
          [, firstNode] = firstNode.splitText(startOffset);
          selectedNodes[0] = firstNode;
          startPoint.set(firstNode.getKey(), 0, "text");
        }
      }
      if ($isTextNode(lastNode)) {
        const lastNodeText = lastNode.getTextContent();
        const lastNodeTextLength = lastNodeText.length;
        if (endOffset === 0) {
          selectedNodes.pop();
        } else if (endOffset !== lastNodeTextLength) {
          [lastNode] = lastNode.splitText(endOffset);
          selectedNodes[selectedNodes.length - 1] = lastNode;
          endPoint.set(lastNode.getKey(), lastNode.getTextContentSize(), "text");
        }
      }
      return selectedNodes;
    }
    /**
     * Modifies the Selection according to the parameters and a set of heuristics that account for
     * various node types. Can be used to safely move or extend selection by one logical "unit" without
     * dealing explicitly with all the possible node types.
     *
     * @param alter the type of modification to perform
     * @param isBackward whether or not selection is backwards
     * @param granularity the granularity at which to apply the modification
     */
    modify(alter, isBackward, granularity) {
      if ($modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity)) {
        return;
      }
      const collapse = alter === "move";
      const editor = getActiveEditor();
      const domSelection = getDOMSelection(getWindow(editor));
      if (!domSelection) {
        return;
      }
      const blockCursorElement = editor._blockCursorElement;
      const rootElement = editor._rootElement;
      const focusNode = this.focus.getNode();
      if (rootElement !== null && blockCursorElement !== null && $isElementNode(focusNode) && !focusNode.isInline() && !focusNode.canBeEmpty()) {
        removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
      }
      if (this.dirty) {
        let nextAnchorDOM = getElementByKeyOrThrow(editor, this.anchor.key);
        let nextFocusDOM = getElementByKeyOrThrow(editor, this.focus.key);
        if (this.anchor.type === "text") {
          nextAnchorDOM = getDOMTextNode(nextAnchorDOM);
        }
        if (this.focus.type === "text") {
          nextFocusDOM = getDOMTextNode(nextFocusDOM);
        }
        if (nextAnchorDOM && nextFocusDOM) {
          setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, this.anchor.offset, nextFocusDOM, this.focus.offset);
        }
      }
      moveNativeSelection(domSelection, alter, isBackward ? "backward" : "forward", granularity);
      if (domSelection.rangeCount > 0) {
        const range2 = domSelection.getRangeAt(0);
        const anchorNode = this.anchor.getNode();
        const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);
        this.applyDOMRange(range2);
        this.dirty = true;
        if (!collapse) {
          const nodes = this.getNodes();
          const validNodes = [];
          let shrinkSelection = false;
          for (let i2 = 0; i2 < nodes.length; i2++) {
            const nextNode = nodes[i2];
            if ($hasAncestor(nextNode, root)) {
              validNodes.push(nextNode);
            } else {
              shrinkSelection = true;
            }
          }
          if (shrinkSelection && validNodes.length > 0) {
            if (isBackward) {
              const firstValidNode = validNodes[0];
              if ($isElementNode(firstValidNode)) {
                firstValidNode.selectStart();
              } else {
                firstValidNode.getParentOrThrow().selectStart();
              }
            } else {
              const lastValidNode = validNodes[validNodes.length - 1];
              if ($isElementNode(lastValidNode)) {
                lastValidNode.selectEnd();
              } else {
                lastValidNode.getParentOrThrow().selectEnd();
              }
            }
          }
          if (domSelection.anchorNode !== range2.startContainer || domSelection.anchorOffset !== range2.startOffset) {
            $swapPoints(this);
          }
        }
      }
      if (granularity === "lineboundary") {
        $modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity, "decorators");
      }
    }
    /**
     * Helper for handling forward character and word deletion that prevents element nodes
     * like a table, columns layout being destroyed
     *
     * @param anchor the anchor
     * @param anchorNode the anchor node in the selection
     * @param isBackward whether or not selection is backwards
     */
    forwardDeletion(anchor, anchorNode, isBackward) {
      if (!isBackward && // Delete forward handle case
      (anchor.type === "element" && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === "text" && anchor.offset === anchorNode.getTextContentSize())) {
        const parent = anchorNode.getParent();
        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());
        if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {
          return true;
        }
      }
      return false;
    }
    /**
     * Performs one logical character deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteCharacter(isBackward) {
      const wasCollapsed = this.isCollapsed();
      if (this.isCollapsed()) {
        const anchor = this.anchor;
        let anchorNode = anchor.getNode();
        if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
          return;
        }
        const direction = isBackward ? "previous" : "next";
        const initialCaret = $caretFromPoint(anchor, direction);
        const initialRange = $extendCaretToRange(initialCaret);
        if (initialRange.getTextSlices().every((slice) => slice === null || slice.distance === 0)) {
          let state = {
            type: "initial"
          };
          for (const caret of initialRange.iterNodeCarets("shadowRoot")) {
            if ($isChildCaret(caret)) {
              if (caret.origin.isInline()) ;
              else if (caret.origin.isShadowRoot()) {
                if (state.type === "merge-block") {
                  break;
                }
                if ($isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {
                  const normCaret = $normalizeCaret(caret);
                  $updateRangeSelectionFromCaretRange(this, $getCaretRange(normCaret, normCaret));
                  initialRange.anchor.origin.remove();
                }
                return;
              } else if (state.type === "merge-next-block" || state.type === "merge-block") {
                state = {
                  block: state.block,
                  caret,
                  type: "merge-block"
                };
              }
            } else if (state.type === "merge-block") {
              break;
            } else if ($isSiblingCaret(caret)) {
              if ($isElementNode(caret.origin)) {
                if (!caret.origin.isInline()) {
                  state = {
                    block: caret.origin,
                    type: "merge-next-block"
                  };
                } else if (!caret.origin.isParentOf(initialRange.anchor.origin)) {
                  break;
                }
                continue;
              } else if ($isDecoratorNode(caret.origin)) {
                if (caret.origin.isIsolated()) ;
                else if (state.type === "merge-next-block" && (caret.origin.isKeyboardSelectable() || !caret.origin.isInline()) && $isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {
                  initialRange.anchor.origin.remove();
                  const nodeSelection = $createNodeSelection();
                  nodeSelection.add(caret.origin.getKey());
                  $setSelection(nodeSelection);
                } else {
                  caret.origin.remove();
                }
                return;
              }
              break;
            }
          }
          if (state.type === "merge-block") {
            const {
              caret,
              block
            } = state;
            $updateRangeSelectionFromCaretRange(this, $getCaretRange(!caret.origin.isEmpty() && block.isEmpty() ? $rewindSiblingCaret($getSiblingCaret(block, caret.direction)) : initialRange.anchor, caret));
            return this.removeText();
          }
        }
        const focus = this.focus;
        this.modify("extend", isBackward, "character");
        if (!this.isCollapsed()) {
          const focusNode = focus.type === "text" ? focus.getNode() : null;
          anchorNode = anchor.type === "text" ? anchor.getNode() : null;
          if (focusNode !== null && focusNode.isSegmented()) {
            const offset = focus.offset;
            const textContentSize = focusNode.getTextContentSize();
            if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {
              $removeSegment(focusNode, isBackward, offset);
              return;
            }
          } else if (anchorNode !== null && anchorNode.isSegmented()) {
            const offset = anchor.offset;
            const textContentSize = anchorNode.getTextContentSize();
            if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {
              $removeSegment(anchorNode, isBackward, offset);
              return;
            }
          }
          $updateCaretSelectionForUnicodeCharacter(this, isBackward);
        } else if (isBackward && anchor.offset === 0) {
          if ($collapseAtStart(this, anchor.getNode())) {
            return;
          }
        }
      }
      this.removeText();
      if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
        const anchorNode = this.anchor.getNode();
        if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getPreviousSibling() === null) {
          $collapseAtStart(this, anchorNode);
        }
      }
    }
    /**
     * Performs one logical line deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteLine(isBackward) {
      if (this.isCollapsed()) {
        this.modify("extend", isBackward, "lineboundary");
      }
      if (this.isCollapsed()) {
        this.deleteCharacter(isBackward);
      } else {
        this.removeText();
      }
    }
    /**
     * Performs one logical word deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteWord(isBackward) {
      if (this.isCollapsed()) {
        const anchor = this.anchor;
        const anchorNode = anchor.getNode();
        if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
          return;
        }
        this.modify("extend", isBackward, "word");
      }
      this.removeText();
    }
    /**
     * Returns whether the Selection is "backwards", meaning the focus
     * logically precedes the anchor in the EditorState.
     * @returns true if the Selection is backwards, false otherwise.
     */
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getStartEndPoints() {
      return [this.anchor, this.focus];
    }
  };
  function $isNodeSelection(x2) {
    return x2 instanceof NodeSelection;
  }
  function getCharacterOffset(point) {
    const offset = point.offset;
    if (point.type === "text") {
      return offset;
    }
    const parent = point.getNode();
    return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;
  }
  function $getCharacterOffsets(selection) {
    const anchorAndFocus = selection.getStartEndPoints();
    if (anchorAndFocus === null) {
      return [0, 0];
    }
    const [anchor, focus] = anchorAndFocus;
    if (anchor.type === "element" && focus.type === "element" && anchor.key === focus.key && anchor.offset === focus.offset) {
      return [0, 0];
    }
    return [getCharacterOffset(anchor), getCharacterOffset(focus)];
  }
  function $collapseAtStart(selection, startNode) {
    for (let node = startNode; node; node = node.getParent()) {
      if ($isElementNode(node)) {
        if (node.collapseAtStart(selection)) {
          return true;
        }
        if ($isRootOrShadowRoot(node)) {
          break;
        }
      }
      if (node.getPreviousSibling()) {
        break;
      }
    }
    return false;
  }
  function $swapPoints(selection) {
    const focus = selection.focus;
    const anchor = selection.anchor;
    const anchorKey = anchor.key;
    const anchorOffset = anchor.offset;
    const anchorType = anchor.type;
    anchor.set(focus.key, focus.offset, focus.type, true);
    focus.set(anchorKey, anchorOffset, anchorType, true);
  }
  function moveNativeSelection(domSelection, alter, direction, granularity) {
    domSelection.modify(alter, direction, granularity);
  }
  function $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    if (anchorNode === focusNode && anchor.type === "text" && focus.type === "text") {
      const anchorOffset = anchor.offset;
      const focusOffset = focus.offset;
      const isBefore = anchorOffset < focusOffset;
      const startOffset = isBefore ? anchorOffset : focusOffset;
      const endOffset = isBefore ? focusOffset : anchorOffset;
      const characterOffset = endOffset - 1;
      if (startOffset !== characterOffset) {
        const text2 = anchorNode.getTextContent().slice(startOffset, endOffset);
        if (shouldDeleteExactlyOneCodeUnit(text2)) {
          if (isBackward) {
            focus.set(focus.key, characterOffset, focus.type);
          } else {
            anchor.set(anchor.key, characterOffset, anchor.type);
          }
        }
      }
    }
  }
  function shouldDeleteExactlyOneCodeUnit(text2) {
    {
      if (!(text2.length > 1)) {
        formatDevErrorMessage(`shouldDeleteExactlyOneCodeUnit: expecting to be called only with sequences of two or more code units`);
      }
    }
    return !(doesContainSurrogatePair(text2) || doesContainEmoji(text2));
  }
  var doesContainEmoji = (() => {
    try {
      const re2 = new RegExp("\\p{Emoji}", "u");
      const test = re2.test.bind(re2);
      if (
        // Emoji in the BMP (heart) with variation selector
        test("\u2764\uFE0F") && // Emoji in the BMP (#) with variation selector
        test("#\uFE0F\u20E3") && // Emoji outside the BMP (thumbs up) that is encoded with a surrogate pair
        test("\u{1F44D}")
      ) {
        return test;
      }
    } catch (_e2) {
    }
    return () => false;
  })();
  function $removeSegment(node, isBackward, offset) {
    const textNode = node;
    const textContent = textNode.getTextContent();
    const split = textContent.split(/(?=\s)/g);
    const splitLength = split.length;
    let segmentOffset = 0;
    let restoreOffset = 0;
    for (let i2 = 0; i2 < splitLength; i2++) {
      const text2 = split[i2];
      const isLast = i2 === splitLength - 1;
      restoreOffset = segmentOffset;
      segmentOffset += text2.length;
      if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {
        split.splice(i2, 1);
        if (isLast) {
          restoreOffset = void 0;
        }
        break;
      }
    }
    const nextTextContent = split.join("").trim();
    if (nextTextContent === "") {
      textNode.remove();
    } else {
      textNode.setTextContent(nextTextContent);
      textNode.select(restoreOffset, restoreOffset);
    }
  }
  function shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {
    const parent = resolvedElement.getParent();
    return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();
  }
  function $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {
    let resolvedOffset = offset;
    let resolvedNode;
    if (isHTMLElement(dom)) {
      let moveSelectionToEnd = false;
      const childNodes = dom.childNodes;
      const childNodesLength = childNodes.length;
      const blockCursorElement = editor._blockCursorElement;
      if (resolvedOffset === childNodesLength) {
        moveSelectionToEnd = true;
        resolvedOffset = childNodesLength - 1;
      }
      let childDOM = childNodes[resolvedOffset];
      let hasBlockCursor = false;
      if (childDOM === blockCursorElement) {
        childDOM = childNodes[resolvedOffset + 1];
        hasBlockCursor = true;
      } else if (blockCursorElement !== null) {
        const blockCursorElementParent = blockCursorElement.parentNode;
        if (dom === blockCursorElementParent) {
          const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);
          if (offset > blockCursorOffset) {
            resolvedOffset--;
          }
        }
      }
      resolvedNode = $getNodeFromDOM(childDOM);
      if ($isTextNode(resolvedNode)) {
        resolvedOffset = $getTextNodeOffset(resolvedNode, moveSelectionToEnd ? "next" : "previous");
      } else {
        let resolvedElement = $getNodeFromDOM(dom);
        if (resolvedElement === null) {
          return null;
        }
        if ($isElementNode(resolvedElement)) {
          const elementDOM = editor.getElementByKey(resolvedElement.getKey());
          if (!(elementDOM !== null)) {
            formatDevErrorMessage(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);
          }
          const slot = resolvedElement.getDOMSlot(elementDOM);
          [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom, offset);
          if (!$isElementNode(resolvedElement)) {
            formatDevErrorMessage(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);
          }
          if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {
            resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);
          }
          let child = resolvedElement.getChildAtIndex(resolvedOffset);
          if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {
            const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();
            if (descendant === null) {
              resolvedElement = child;
            } else {
              child = descendant;
              resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();
            }
            resolvedOffset = 0;
          }
          if ($isTextNode(child)) {
            resolvedNode = child;
            resolvedElement = null;
            resolvedOffset = $getTextNodeOffset(child, moveSelectionToEnd ? "next" : "previous");
          } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {
            if (!$isElementNode(resolvedElement)) {
              formatDevErrorMessage(`invariant`);
            }
            resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);
          }
        } else {
          const index2 = resolvedElement.getIndexWithinParent();
          if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {
            resolvedOffset = index2;
          } else {
            resolvedOffset = index2 + 1;
          }
          resolvedElement = resolvedElement.getParentOrThrow();
        }
        if ($isElementNode(resolvedElement)) {
          return $createPoint(resolvedElement.__key, resolvedOffset, "element");
        }
      }
    } else {
      resolvedNode = $getNodeFromDOM(dom);
    }
    if (!$isTextNode(resolvedNode)) {
      return null;
    }
    return $createPoint(resolvedNode.__key, $getTextNodeOffset(resolvedNode, resolvedOffset, "clamp"), "text");
  }
  function resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {
    const offset = point.offset;
    const node = point.getNode();
    if (offset === 0) {
      const prevSibling = node.getPreviousSibling();
      const parent = node.getParent();
      if (!isBackward) {
        if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {
          point.set(prevSibling.__key, prevSibling.getChildrenSize(), "element");
        } else if ($isTextNode(prevSibling)) {
          point.set(prevSibling.__key, prevSibling.getTextContent().length, "text");
        }
      } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {
        const parentSibling = parent.getPreviousSibling();
        if ($isTextNode(parentSibling)) {
          point.set(parentSibling.__key, parentSibling.getTextContent().length, "text");
        }
      }
    } else if (offset === node.getTextContent().length) {
      const nextSibling = node.getNextSibling();
      const parent = node.getParent();
      if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {
        point.set(nextSibling.__key, 0, "element");
      } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {
        const parentSibling = parent.getNextSibling();
        if ($isTextNode(parentSibling)) {
          point.set(parentSibling.__key, 0, "text");
        }
      }
    }
  }
  function $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {
    if (anchor.type === "text" && focus.type === "text") {
      const isBackward = anchor.isBefore(focus);
      const isCollapsed = anchor.is(focus);
      resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);
      resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);
      if (isCollapsed) {
        focus.set(anchor.key, anchor.offset, anchor.type);
      }
      const editor = getActiveEditor();
      if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {
        const lastAnchor = lastSelection.anchor;
        const lastFocus = lastSelection.focus;
        anchor.set(lastAnchor.key, lastAnchor.offset, lastAnchor.type, true);
        focus.set(lastFocus.key, lastFocus.offset, lastFocus.type, true);
      }
    }
  }
  function $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {
    if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return null;
    }
    const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);
    if (resolvedAnchorPoint === null) {
      return null;
    }
    const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);
    if (resolvedFocusPoint === null) {
      return null;
    }
    {
      $validatePoint("anchor", resolvedAnchorPoint);
      $validatePoint("focus", resolvedFocusPoint);
    }
    if (resolvedAnchorPoint.type === "element" && resolvedFocusPoint.type === "element") {
      const anchorNode = $getNodeFromDOM(anchorDOM);
      const focusNode = $getNodeFromDOM(focusDOM);
      if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {
        return null;
      }
    }
    $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);
    return [resolvedAnchorPoint, resolvedFocusPoint];
  }
  function $isBlockElementNode(node) {
    return $isElementNode(node) && !node.isInline();
  }
  function $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {
    const editorState = getActiveEditorState();
    const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, "");
    selection.dirty = true;
    editorState._selection = selection;
    return selection;
  }
  function $createRangeSelection() {
    const anchor = $createPoint("root", 0, "element");
    const focus = $createPoint("root", 0, "element");
    return new RangeSelection(anchor, focus, 0, "");
  }
  function $createNodeSelection() {
    return new NodeSelection(/* @__PURE__ */ new Set());
  }
  function $internalCreateSelection(editor, event) {
    const currentEditorState = editor.getEditorState();
    const lastSelection = currentEditorState._selection;
    const domSelection = getDOMSelection(getWindow(editor));
    if ($isRangeSelection(lastSelection) || lastSelection == null) {
      return $internalCreateRangeSelection(lastSelection, domSelection, editor, event);
    }
    return lastSelection.clone();
  }
  function $createRangeSelectionFromDom(domSelection, editor) {
    return $internalCreateRangeSelection(null, domSelection, editor, null);
  }
  function $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {
    const windowObj = editor._window;
    if (windowObj === null) {
      return null;
    }
    const windowEvent = event || windowObj.event;
    const eventType = windowEvent ? windowEvent.type : void 0;
    const isSelectionChange = eventType === "selectionchange";
    const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === "beforeinput" || eventType === "compositionstart" || eventType === "compositionend" || eventType === "click" && windowEvent && windowEvent.detail === 3 || eventType === "drop" || eventType === void 0);
    let anchorDOM, focusDOM, anchorOffset, focusOffset;
    if (!$isRangeSelection(lastSelection) || useDOMSelection) {
      if (domSelection === null) {
        return null;
      }
      anchorDOM = domSelection.anchorNode;
      focusDOM = domSelection.focusNode;
      anchorOffset = domSelection.anchorOffset;
      focusOffset = domSelection.focusOffset;
      if ((isSelectionChange || eventType === void 0) && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
        return lastSelection.clone();
      }
    } else {
      return lastSelection.clone();
    }
    const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);
    if (resolvedSelectionPoints === null) {
      return null;
    }
    const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;
    return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? "" : lastSelection.style);
  }
  function $validatePoint(name, point) {
    const node = $getNodeByKey(point.key);
    if (!(node !== void 0)) {
      formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} not found in current editorState`);
    }
    if (point.type === "text") {
      if (!$isTextNode(node)) {
        formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not a TextNode`);
      }
      const size2 = node.getTextContentSize();
      if (!(point.offset <= size2)) {
        formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getTextContentSize() (${String(point.offset)} > ${String(size2)})`);
      }
    } else {
      if (!$isElementNode(node)) {
        formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not an ElementNode`);
      }
      const size2 = node.getChildrenSize();
      if (!(point.offset <= size2)) {
        formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getChildrenSize() (${String(point.offset)} > ${String(size2)})`);
      }
    }
  }
  function $getSelection() {
    const editorState = getActiveEditorState();
    return editorState._selection;
  }
  function $getPreviousSelection() {
    const editor = getActiveEditor();
    return editor._editorState._selection;
  }
  function $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {
      return;
    }
    const parentKey = parentNode.__key;
    if (selection.isCollapsed()) {
      const selectionOffset = anchor.offset;
      if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {
        const newSelectionOffset = Math.max(0, selectionOffset + times);
        anchor.set(parentKey, newSelectionOffset, "element");
        focus.set(parentKey, newSelectionOffset, "element");
        $updateSelectionResolveTextNodes(selection);
      }
    } else {
      const isBackward = selection.isBackward();
      const firstPoint = isBackward ? focus : anchor;
      const firstPointNode = firstPoint.getNode();
      const lastPoint = isBackward ? anchor : focus;
      const lastPointNode = lastPoint.getNode();
      if (parentNode.is(firstPointNode)) {
        const firstPointOffset = firstPoint.offset;
        if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {
          firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), "element");
        }
      }
      if (parentNode.is(lastPointNode)) {
        const lastPointOffset = lastPoint.offset;
        if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {
          lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), "element");
        }
      }
    }
    $updateSelectionResolveTextNodes(selection);
  }
  function $updateSelectionResolveTextNodes(selection) {
    const anchor = selection.anchor;
    const anchorOffset = anchor.offset;
    const focus = selection.focus;
    const focusOffset = focus.offset;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    if (selection.isCollapsed()) {
      if (!$isElementNode(anchorNode)) {
        return;
      }
      const childSize = anchorNode.getChildrenSize();
      const anchorOffsetAtEnd = anchorOffset >= childSize;
      const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
      if ($isTextNode(child)) {
        let newOffset = 0;
        if (anchorOffsetAtEnd) {
          newOffset = child.getTextContentSize();
        }
        anchor.set(child.__key, newOffset, "text");
        focus.set(child.__key, newOffset, "text");
      }
      return;
    }
    if ($isElementNode(anchorNode)) {
      const childSize = anchorNode.getChildrenSize();
      const anchorOffsetAtEnd = anchorOffset >= childSize;
      const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
      if ($isTextNode(child)) {
        let newOffset = 0;
        if (anchorOffsetAtEnd) {
          newOffset = child.getTextContentSize();
        }
        anchor.set(child.__key, newOffset, "text");
      }
    }
    if ($isElementNode(focusNode)) {
      const childSize = focusNode.getChildrenSize();
      const focusOffsetAtEnd = focusOffset >= childSize;
      const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);
      if ($isTextNode(child)) {
        let newOffset = 0;
        if (focusOffsetAtEnd) {
          newOffset = child.getTextContentSize();
        }
        focus.set(child.__key, newOffset, "text");
      }
    }
  }
  function applySelectionTransforms(nextEditorState, editor) {
    const prevEditorState = editor.getEditorState();
    const prevSelection = prevEditorState._selection;
    const nextSelection = nextEditorState._selection;
    if ($isRangeSelection(nextSelection)) {
      const anchor = nextSelection.anchor;
      const focus = nextSelection.focus;
      let anchorNode;
      if (anchor.type === "text") {
        anchorNode = anchor.getNode();
        anchorNode.selectionTransform(prevSelection, nextSelection);
      }
      if (focus.type === "text") {
        const focusNode = focus.getNode();
        if (anchorNode !== focusNode) {
          focusNode.selectionTransform(prevSelection, nextSelection);
        }
      }
    }
  }
  function moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {
    let siblingKey = null;
    let offset = 0;
    let type = null;
    if (prevSibling !== null) {
      siblingKey = prevSibling.__key;
      if ($isTextNode(prevSibling)) {
        offset = prevSibling.getTextContentSize();
        type = "text";
      } else if ($isElementNode(prevSibling)) {
        offset = prevSibling.getChildrenSize();
        type = "element";
      }
    } else {
      if (nextSibling !== null) {
        siblingKey = nextSibling.__key;
        if ($isTextNode(nextSibling)) {
          type = "text";
        } else if ($isElementNode(nextSibling)) {
          type = "element";
        }
      }
    }
    if (siblingKey !== null && type !== null) {
      point.set(siblingKey, offset, type);
    } else {
      offset = node.getIndexWithinParent();
      if (offset === -1) {
        offset = parent.getChildrenSize();
      }
      point.set(parent.__key, offset, "element");
    }
  }
  function adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {
    if (point.type === "text") {
      point.set(key, point.offset + (isBefore ? 0 : textLength), "text");
    } else if (point.offset > target.getIndexWithinParent()) {
      point.set(point.key, point.offset - 1, "element");
    }
  }
  function setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset) {
    try {
      domSelection.setBaseAndExtent(nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset);
    } catch (error2) {
      {
        console.warn(error2);
      }
    }
  }
  function updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {
    const anchorDOMNode = domSelection.anchorNode;
    const focusDOMNode = domSelection.focusNode;
    const anchorOffset = domSelection.anchorOffset;
    const focusOffset = domSelection.focusOffset;
    const activeElement = document.activeElement;
    if (tags.has(COLLABORATION_TAG) && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {
      return;
    }
    if (!$isRangeSelection(nextSelection)) {
      if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {
        domSelection.removeAllRanges();
      }
      return;
    }
    const anchor = nextSelection.anchor;
    const focus = nextSelection.focus;
    const anchorKey = anchor.key;
    const focusKey = focus.key;
    const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);
    const focusDOM = getElementByKeyOrThrow(editor, focusKey);
    const nextAnchorOffset = anchor.offset;
    const nextFocusOffset = focus.offset;
    const nextFormat = nextSelection.format;
    const nextStyle = nextSelection.style;
    const isCollapsed = nextSelection.isCollapsed();
    let nextAnchorNode = anchorDOM;
    let nextFocusNode = focusDOM;
    let anchorFormatOrStyleChanged = false;
    if (anchor.type === "text") {
      nextAnchorNode = getDOMTextNode(anchorDOM);
      const anchorNode = anchor.getNode();
      anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;
    } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === "text") {
      anchorFormatOrStyleChanged = true;
    }
    if (focus.type === "text") {
      nextFocusNode = getDOMTextNode(focusDOM);
    }
    if (nextAnchorNode === null || nextFocusNode === null) {
      return;
    }
    if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {
      markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());
    }
    if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482
    !(domSelection.type === "Range" && isCollapsed)) {
      if (activeElement === null || !rootElement.contains(activeElement)) {
        if (!tags.has(SKIP_SELECTION_FOCUS_TAG)) {
          rootElement.focus({
            preventScroll: true
          });
        }
      }
      if (anchor.type !== "element") {
        return;
      }
    }
    setDOMSelectionBaseAndExtent(domSelection, nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);
    if (!tags.has(SKIP_SCROLL_INTO_VIEW_TAG) && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {
      const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === "element" ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;
      if (selectionTarget !== null) {
        let selectionRect;
        if (selectionTarget instanceof Text) {
          const range2 = document.createRange();
          range2.selectNode(selectionTarget);
          selectionRect = range2.getBoundingClientRect();
        } else {
          selectionRect = selectionTarget.getBoundingClientRect();
        }
        scrollIntoViewIfNeeded(editor, selectionRect, rootElement);
      }
    }
    markSelectionChangeFromDOMUpdate();
  }
  function $insertNodes(nodes) {
    let selection = $getSelection() || $getPreviousSelection();
    if (selection === null) {
      selection = $getRoot().selectEnd();
    }
    selection.insertNodes(nodes);
  }
  function $getTextContent() {
    const selection = $getSelection();
    if (selection === null) {
      return "";
    }
    return selection.getTextContent();
  }
  function $removeTextAndSplitBlock(selection) {
    let selection_ = selection;
    if (!selection.isCollapsed()) {
      selection_.removeText();
    }
    const newSelection = $getSelection();
    if ($isRangeSelection(newSelection)) {
      selection_ = newSelection;
    }
    if (!$isRangeSelection(selection_)) {
      formatDevErrorMessage(`Unexpected dirty selection to be null`);
    }
    const anchor = selection_.anchor;
    let node = anchor.getNode();
    let offset = anchor.offset;
    while (!INTERNAL_$isBlock(node)) {
      const prevNode = node;
      [node, offset] = $splitNodeAtPoint(node, offset);
      if (prevNode.is(node)) {
        break;
      }
    }
    return offset;
  }
  function $splitNodeAtPoint(node, offset) {
    const parent = node.getParent();
    if (!parent) {
      const paragraph = $createParagraphNode();
      $getRoot().append(paragraph);
      paragraph.select();
      return [$getRoot(), 0];
    }
    if ($isTextNode(node)) {
      const split = node.splitText(offset);
      if (split.length === 0) {
        return [parent, node.getIndexWithinParent()];
      }
      const x2 = offset === 0 ? 0 : 1;
      const index2 = split[0].getIndexWithinParent() + x2;
      return [parent, index2];
    }
    if (!$isElementNode(node) || offset === 0) {
      return [parent, node.getIndexWithinParent()];
    }
    const firstToAppend = node.getChildAtIndex(offset);
    if (firstToAppend) {
      const insertPoint = new RangeSelection($createPoint(node.__key, offset, "element"), $createPoint(node.__key, offset, "element"), 0, "");
      const newElement = node.insertNewAfter(insertPoint);
      if (newElement) {
        newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());
      }
    }
    return [parent, node.getIndexWithinParent() + 1];
  }
  function $wrapInlineNodes(nodes) {
    const virtualRoot = $createParagraphNode();
    let currentBlock = null;
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      const isLineBreakNode = $isLineBreakNode(node);
      if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {
        if (currentBlock === null) {
          currentBlock = node.createParentElementNode();
          virtualRoot.append(currentBlock);
          if (isLineBreakNode) {
            continue;
          }
        }
        if (currentBlock !== null) {
          currentBlock.append(node);
        }
      } else {
        virtualRoot.append(node);
        currentBlock = null;
      }
    }
    return virtualRoot;
  }
  function $getNodesFromCaretRangeCompat(range2) {
    const nodes = [];
    const [beforeSlice, afterSlice] = range2.getTextSlices();
    if (beforeSlice) {
      nodes.push(beforeSlice.caret.origin);
    }
    const seenAncestors = /* @__PURE__ */ new Set();
    const seenElements = /* @__PURE__ */ new Set();
    for (const caret of range2) {
      if ($isChildCaret(caret)) {
        const {
          origin
        } = caret;
        if (nodes.length === 0) {
          seenAncestors.add(origin);
        } else {
          seenElements.add(origin);
          nodes.push(origin);
        }
      } else {
        const {
          origin
        } = caret;
        if (!$isElementNode(origin) || !seenElements.has(origin)) {
          nodes.push(origin);
        }
      }
    }
    if (afterSlice) {
      nodes.push(afterSlice.caret.origin);
    }
    if ($isSiblingCaret(range2.focus) && $isElementNode(range2.focus.origin) && range2.focus.getNodeAtCaret() === null) {
      for (let reverseCaret = $getChildCaret(range2.focus.origin, "previous"); $isChildCaret(reverseCaret) && seenAncestors.has(reverseCaret.origin) && !reverseCaret.origin.isEmpty() && reverseCaret.origin.is(nodes[nodes.length - 1]); reverseCaret = $getAdjacentChildCaret(reverseCaret)) {
        seenAncestors.delete(reverseCaret.origin);
        nodes.pop();
      }
    }
    while (nodes.length > 1) {
      const lastIncludedNode = nodes[nodes.length - 1];
      if ($isElementNode(lastIncludedNode)) {
        if (seenElements.has(lastIncludedNode) || lastIncludedNode.isEmpty() || seenAncestors.has(lastIncludedNode)) ;
        else {
          nodes.pop();
          continue;
        }
      }
      break;
    }
    if (nodes.length === 0 && range2.isCollapsed()) {
      const normCaret = $normalizeCaret(range2.anchor);
      const flippedNormCaret = $normalizeCaret(range2.anchor.getFlipped());
      const $getCandidate = (caret) => $isTextPointCaret(caret) ? caret.origin : caret.getNodeAtCaret();
      const node = $getCandidate(normCaret) || $getCandidate(flippedNormCaret) || (range2.anchor.getNodeAtCaret() ? normCaret.origin : flippedNormCaret.origin);
      nodes.push(node);
    }
    return nodes;
  }
  function $modifySelectionAroundDecoratorsAndBlocks(selection, alter, isBackward, granularity, mode = "decorators-and-blocks") {
    if (alter === "move" && granularity === "character" && !selection.isCollapsed()) {
      const [src, dst] = isBackward === selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];
      dst.set(src.key, src.offset, src.type);
      return true;
    }
    const initialFocus = $caretFromPoint(selection.focus, isBackward ? "previous" : "next");
    const isLineBoundary = granularity === "lineboundary";
    const collapse = alter === "move";
    let focus = initialFocus;
    let checkForBlock = mode === "decorators-and-blocks";
    if (!$isExtendableTextPointCaret(focus)) {
      for (const siblingCaret of focus) {
        checkForBlock = false;
        const {
          origin
        } = siblingCaret;
        if ($isDecoratorNode(origin) && !origin.isIsolated()) {
          focus = siblingCaret;
          if (isLineBoundary && origin.isInline()) {
            continue;
          }
        }
        break;
      }
      if (checkForBlock) {
        for (const nextCaret of $extendCaretToRange(initialFocus).iterNodeCarets(alter === "extend" ? "shadowRoot" : "root")) {
          if ($isChildCaret(nextCaret)) {
            if (!nextCaret.origin.isInline()) {
              focus = nextCaret;
            }
          } else if ($isElementNode(nextCaret.origin)) {
            continue;
          } else if ($isDecoratorNode(nextCaret.origin) && !nextCaret.origin.isInline()) {
            focus = nextCaret;
          }
          break;
        }
      }
    }
    if (focus === initialFocus) {
      return false;
    }
    if (collapse && !isLineBoundary && $isDecoratorNode(focus.origin) && focus.origin.isKeyboardSelectable()) {
      const nodeSelection = $createNodeSelection();
      nodeSelection.add(focus.origin.getKey());
      $setSelection(nodeSelection);
      return true;
    }
    focus = $normalizeCaret(focus);
    if (collapse) {
      $setPointFromCaret(selection.anchor, focus);
    }
    $setPointFromCaret(selection.focus, focus);
    return checkForBlock || !isLineBoundary;
  }
  var activeEditorState = null;
  var activeEditor = null;
  var isReadOnlyMode = false;
  var isAttemptingToRecoverFromReconcilerError = false;
  var infiniteTransformCount = 0;
  var observerOptions = {
    characterData: true,
    childList: true,
    subtree: true
  };
  function isCurrentlyReadOnlyMode() {
    return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;
  }
  function errorOnReadOnly() {
    if (isReadOnlyMode) {
      {
        formatDevErrorMessage(`Cannot use method in read-only mode.`);
      }
    }
  }
  function errorOnInfiniteTransforms() {
    if (infiniteTransformCount > 99) {
      {
        formatDevErrorMessage(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);
      }
    }
  }
  function getActiveEditorState() {
    if (activeEditorState === null) {
      {
        formatDevErrorMessage(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);
      }
    }
    return activeEditorState;
  }
  function getActiveEditor() {
    if (activeEditor === null) {
      {
        formatDevErrorMessage(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);
      }
    }
    return activeEditor;
  }
  function collectBuildInformation() {
    let compatibleEditors = 0;
    const incompatibleEditors = /* @__PURE__ */ new Set();
    const thisVersion = LexicalEditor.version;
    if (typeof window !== "undefined") {
      for (const node of document.querySelectorAll("[contenteditable]")) {
        const editor = getEditorPropertyFromDOMNode(node);
        if (isLexicalEditor(editor)) {
          compatibleEditors++;
        } else if (editor) {
          let version2 = String(editor.constructor.version || "<0.17.1");
          if (version2 === thisVersion) {
            version2 += " (separately built, likely a bundler configuration issue)";
          }
          incompatibleEditors.add(version2);
        }
      }
    }
    let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;
    if (incompatibleEditors.size) {
      output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(", ")}`;
    }
    return output;
  }
  function internalGetActiveEditor() {
    return activeEditor;
  }
  function internalGetActiveEditorState() {
    return activeEditorState;
  }
  function $applyTransforms(editor, node, transformsCache) {
    const type = node.__type;
    const registeredNode = getRegisteredNodeOrThrow(editor, type);
    let transformsArr = transformsCache.get(type);
    if (transformsArr === void 0) {
      transformsArr = Array.from(registeredNode.transforms);
      transformsCache.set(type, transformsArr);
    }
    const transformsArrLength = transformsArr.length;
    for (let i2 = 0; i2 < transformsArrLength; i2++) {
      transformsArr[i2](node);
      if (!node.isAttached()) {
        break;
      }
    }
  }
  function $isNodeValidForTransform(node, compositionKey) {
    return node !== void 0 && // We don't want to transform nodes being composed
    node.__key !== compositionKey && node.isAttached();
  }
  function $normalizeAllDirtyTextNodes(editorState, editor) {
    const dirtyLeaves = editor._dirtyLeaves;
    const nodeMap = editorState._nodeMap;
    for (const nodeKey of dirtyLeaves) {
      const node = nodeMap.get(nodeKey);
      if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
        $normalizeTextNode(node);
      }
    }
  }
  function addTags(editor, tags) {
    if (!tags) {
      return;
    }
    const updateTags = editor._updateTags;
    let tags_ = tags;
    if (!Array.isArray(tags)) {
      tags_ = [tags];
    }
    for (const tag of tags_) {
      updateTags.add(tag);
    }
  }
  function $applyAllTransforms(editorState, editor) {
    const dirtyLeaves = editor._dirtyLeaves;
    const dirtyElements = editor._dirtyElements;
    const nodeMap = editorState._nodeMap;
    const compositionKey = $getCompositionKey();
    const transformsCache = /* @__PURE__ */ new Map();
    let untransformedDirtyLeaves = dirtyLeaves;
    let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
    let untransformedDirtyElements = dirtyElements;
    let untransformedDirtyElementsLength = untransformedDirtyElements.size;
    while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {
      if (untransformedDirtyLeavesLength > 0) {
        editor._dirtyLeaves = /* @__PURE__ */ new Set();
        for (const nodeKey of untransformedDirtyLeaves) {
          const node = nodeMap.get(nodeKey);
          if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
            $normalizeTextNode(node);
          }
          if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
            $applyTransforms(editor, node, transformsCache);
          }
          dirtyLeaves.add(nodeKey);
        }
        untransformedDirtyLeaves = editor._dirtyLeaves;
        untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
        if (untransformedDirtyLeavesLength > 0) {
          infiniteTransformCount++;
          continue;
        }
      }
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      editor._dirtyElements = /* @__PURE__ */ new Map();
      const rootDirty = untransformedDirtyElements.delete("root");
      if (rootDirty) {
        untransformedDirtyElements.set("root", true);
      }
      for (const currentUntransformedDirtyElement of untransformedDirtyElements) {
        const nodeKey = currentUntransformedDirtyElement[0];
        const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];
        dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);
        if (!intentionallyMarkedAsDirty) {
          continue;
        }
        const node = nodeMap.get(nodeKey);
        if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
          $applyTransforms(editor, node, transformsCache);
        }
      }
      untransformedDirtyLeaves = editor._dirtyLeaves;
      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
      untransformedDirtyElements = editor._dirtyElements;
      untransformedDirtyElementsLength = untransformedDirtyElements.size;
      infiniteTransformCount++;
    }
    editor._dirtyLeaves = dirtyLeaves;
    editor._dirtyElements = dirtyElements;
  }
  function $parseSerializedNode(serializedNode) {
    const internalSerializedNode = serializedNode;
    return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);
  }
  function $parseSerializedNodeImpl(serializedNode, registeredNodes) {
    const type = serializedNode.type;
    const registeredNode = registeredNodes.get(type);
    if (registeredNode === void 0) {
      {
        formatDevErrorMessage(`parseEditorState: type "${type}" + not found`);
      }
    }
    const nodeClass = registeredNode.klass;
    if (serializedNode.type !== nodeClass.getType()) {
      {
        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);
      }
    }
    const node = nodeClass.importJSON(serializedNode);
    const children = serializedNode.children;
    if ($isElementNode(node) && Array.isArray(children)) {
      for (let i2 = 0; i2 < children.length; i2++) {
        const serializedJSONChildNode = children[i2];
        const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);
        node.append(childNode);
      }
    }
    return node;
  }
  function parseEditorState(serializedEditorState, editor, updateFn) {
    const editorState = createEmptyEditorState();
    const previousActiveEditorState = activeEditorState;
    const previousReadOnlyMode = isReadOnlyMode;
    const previousActiveEditor = activeEditor;
    const previousDirtyElements = editor._dirtyElements;
    const previousDirtyLeaves = editor._dirtyLeaves;
    const previousCloneNotNeeded = editor._cloneNotNeeded;
    const previousDirtyType = editor._dirtyType;
    editor._dirtyElements = /* @__PURE__ */ new Map();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._cloneNotNeeded = /* @__PURE__ */ new Set();
    editor._dirtyType = 0;
    activeEditorState = editorState;
    isReadOnlyMode = false;
    activeEditor = editor;
    setPendingNodeToClone(null);
    try {
      const registeredNodes = editor._nodes;
      const serializedNode = serializedEditorState.root;
      $parseSerializedNodeImpl(serializedNode, registeredNodes);
      if (updateFn) {
        updateFn();
      }
      editorState._readOnly = true;
      {
        handleDEVOnlyPendingUpdateGuarantees(editorState);
      }
    } catch (error2) {
      if (error2 instanceof Error) {
        editor._onError(error2);
      }
    } finally {
      editor._dirtyElements = previousDirtyElements;
      editor._dirtyLeaves = previousDirtyLeaves;
      editor._cloneNotNeeded = previousCloneNotNeeded;
      editor._dirtyType = previousDirtyType;
      activeEditorState = previousActiveEditorState;
      isReadOnlyMode = previousReadOnlyMode;
      activeEditor = previousActiveEditor;
    }
    return editorState;
  }
  function readEditorState(editor, editorState, callbackFn) {
    const previousActiveEditorState = activeEditorState;
    const previousReadOnlyMode = isReadOnlyMode;
    const previousActiveEditor = activeEditor;
    activeEditorState = editorState;
    isReadOnlyMode = true;
    activeEditor = editor;
    try {
      return callbackFn();
    } finally {
      activeEditorState = previousActiveEditorState;
      isReadOnlyMode = previousReadOnlyMode;
      activeEditor = previousActiveEditor;
    }
  }
  function handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {
    const nodeMap = pendingEditorState._nodeMap;
    nodeMap.set = () => {
      throw new Error("Cannot call set() on a frozen Lexical node map");
    };
    nodeMap.clear = () => {
      throw new Error("Cannot call clear() on a frozen Lexical node map");
    };
    nodeMap.delete = () => {
      throw new Error("Cannot call delete() on a frozen Lexical node map");
    };
  }
  function $commitPendingUpdates(editor, recoveryEditorState) {
    const pendingEditorState = editor._pendingEditorState;
    const rootElement = editor._rootElement;
    const shouldSkipDOM = editor._headless || rootElement === null;
    if (pendingEditorState === null) {
      return;
    }
    const currentEditorState = editor._editorState;
    const currentSelection = currentEditorState._selection;
    const pendingSelection = pendingEditorState._selection;
    const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;
    const previousActiveEditorState = activeEditorState;
    const previousReadOnlyMode = isReadOnlyMode;
    const previousActiveEditor = activeEditor;
    const previouslyUpdating = editor._updating;
    const observer2 = editor._observer;
    let mutatedNodes2 = null;
    editor._pendingEditorState = null;
    editor._editorState = pendingEditorState;
    if (!shouldSkipDOM && needsUpdate && observer2 !== null) {
      activeEditor = editor;
      activeEditorState = pendingEditorState;
      isReadOnlyMode = false;
      editor._updating = true;
      try {
        const dirtyType = editor._dirtyType;
        const dirtyElements2 = editor._dirtyElements;
        const dirtyLeaves2 = editor._dirtyLeaves;
        observer2.disconnect();
        mutatedNodes2 = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements2, dirtyLeaves2);
      } catch (error2) {
        if (error2 instanceof Error) {
          editor._onError(error2);
        }
        if (!isAttemptingToRecoverFromReconcilerError) {
          resetEditor(editor, null, rootElement, pendingEditorState);
          initMutationObserver(editor);
          editor._dirtyType = FULL_RECONCILE;
          isAttemptingToRecoverFromReconcilerError = true;
          $commitPendingUpdates(editor, currentEditorState);
          isAttemptingToRecoverFromReconcilerError = false;
        } else {
          throw error2;
        }
        return;
      } finally {
        observer2.observe(rootElement, observerOptions);
        editor._updating = previouslyUpdating;
        activeEditorState = previousActiveEditorState;
        isReadOnlyMode = previousReadOnlyMode;
        activeEditor = previousActiveEditor;
      }
    }
    if (!pendingEditorState._readOnly) {
      pendingEditorState._readOnly = true;
      {
        handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);
        if ($isRangeSelection(pendingSelection)) {
          Object.freeze(pendingSelection.anchor);
          Object.freeze(pendingSelection.focus);
        }
        Object.freeze(pendingSelection);
      }
    }
    const dirtyLeaves = editor._dirtyLeaves;
    const dirtyElements = editor._dirtyElements;
    const normalizedNodes = editor._normalizedNodes;
    const tags = editor._updateTags;
    const deferred = editor._deferred;
    if (needsUpdate) {
      editor._dirtyType = NO_DIRTY_NODES;
      editor._cloneNotNeeded.clear();
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      editor._dirtyElements = /* @__PURE__ */ new Map();
      editor._normalizedNodes = /* @__PURE__ */ new Set();
      editor._updateTags = /* @__PURE__ */ new Set();
    }
    $garbageCollectDetachedDecorators(editor, pendingEditorState);
    const domSelection = shouldSkipDOM ? null : getDOMSelection(getWindow(editor));
    if (editor._editable && // domSelection will be null in headless
    domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty || !pendingSelection.is(currentSelection)) && rootElement !== null && !tags.has(SKIP_DOM_SELECTION_TAG)) {
      activeEditor = editor;
      activeEditorState = pendingEditorState;
      try {
        if (observer2 !== null) {
          observer2.disconnect();
        }
        if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {
          const blockCursorElement = editor._blockCursorElement;
          if (blockCursorElement !== null) {
            removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
          }
          updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);
        }
        updateDOMBlockCursorElement(editor, rootElement, pendingSelection);
      } finally {
        if (observer2 !== null) {
          observer2.observe(rootElement, observerOptions);
        }
        activeEditor = previousActiveEditor;
        activeEditorState = previousActiveEditorState;
      }
    }
    if (mutatedNodes2 !== null) {
      triggerMutationListeners(editor, mutatedNodes2, tags, dirtyLeaves, currentEditorState);
    }
    if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {
      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, void 0);
    }
    const pendingDecorators = editor._pendingDecorators;
    if (pendingDecorators !== null) {
      editor._decorators = pendingDecorators;
      editor._pendingDecorators = null;
      triggerListeners("decorator", editor, true, pendingDecorators);
    }
    triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);
    triggerListeners("update", editor, true, {
      dirtyElements,
      dirtyLeaves,
      editorState: pendingEditorState,
      mutatedNodes: mutatedNodes2,
      normalizedNodes,
      prevEditorState: recoveryEditorState || currentEditorState,
      tags
    });
    triggerDeferredUpdateCallbacks(editor, deferred);
    $triggerEnqueuedUpdates(editor);
  }
  function triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {
    const currentTextContent = getEditorStateTextContent(currentEditorState);
    const latestTextContent = getEditorStateTextContent(pendingEditorState);
    if (currentTextContent !== latestTextContent) {
      triggerListeners("textcontent", editor, true, latestTextContent);
    }
  }
  function triggerMutationListeners(editor, mutatedNodes2, updateTags, dirtyLeaves, prevEditorState) {
    const listeners = Array.from(editor._listeners.mutation);
    const listenersLength = listeners.length;
    for (let i2 = 0; i2 < listenersLength; i2++) {
      const [listener, klassSet] = listeners[i2];
      for (const klass of klassSet) {
        const mutatedNodesByType = mutatedNodes2.get(klass);
        if (mutatedNodesByType !== void 0) {
          listener(mutatedNodesByType, {
            dirtyLeaves,
            prevEditorState,
            updateTags
          });
        }
      }
    }
  }
  function triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {
    const previouslyUpdating = editor._updating;
    editor._updating = isCurrentlyEnqueuingUpdates;
    try {
      const listeners = Array.from(editor._listeners[type]);
      for (let i2 = 0; i2 < listeners.length; i2++) {
        listeners[i2].apply(null, payload);
      }
    } finally {
      editor._updating = previouslyUpdating;
    }
  }
  function triggerCommandListeners(editor, type, payload) {
    const editors = getEditorsToPropagate(editor);
    for (let i2 = 4; i2 >= 0; i2--) {
      for (let e2 = 0; e2 < editors.length; e2++) {
        const currentEditor = editors[e2];
        const commandListeners = currentEditor._commands;
        const listenerInPriorityOrder = commandListeners.get(type);
        if (listenerInPriorityOrder !== void 0) {
          const listenersSet = listenerInPriorityOrder[i2];
          if (listenersSet !== void 0) {
            const listeners = Array.from(listenersSet);
            const listenersLength = listeners.length;
            let returnVal = false;
            updateEditorSync(currentEditor, () => {
              for (let j2 = 0; j2 < listenersLength; j2++) {
                if (listeners[j2](payload, editor)) {
                  returnVal = true;
                  return;
                }
              }
            });
            if (returnVal) {
              return returnVal;
            }
          }
        }
      }
    }
    return false;
  }
  function $triggerEnqueuedUpdates(editor) {
    const queuedUpdates = editor._updates;
    if (queuedUpdates.length !== 0) {
      const queuedUpdate = queuedUpdates.shift();
      if (queuedUpdate) {
        const [updateFn, options] = queuedUpdate;
        $beginUpdate(editor, updateFn, options);
      }
    }
  }
  function triggerDeferredUpdateCallbacks(editor, deferred) {
    editor._deferred = [];
    if (deferred.length !== 0) {
      const previouslyUpdating = editor._updating;
      editor._updating = true;
      try {
        for (let i2 = 0; i2 < deferred.length; i2++) {
          deferred[i2]();
        }
      } finally {
        editor._updating = previouslyUpdating;
      }
    }
  }
  function $processNestedUpdates(editor, initialSkipTransforms) {
    const queuedUpdates = editor._updates;
    let skipTransforms = initialSkipTransforms || false;
    while (queuedUpdates.length !== 0) {
      const queuedUpdate = queuedUpdates.shift();
      if (queuedUpdate) {
        const [nextUpdateFn, options] = queuedUpdate;
        const pendingEditorState = editor._pendingEditorState;
        let onUpdate;
        if (options !== void 0) {
          onUpdate = options.onUpdate;
          if (options.skipTransforms) {
            skipTransforms = true;
          }
          if (options.discrete) {
            if (!(pendingEditorState !== null)) {
              formatDevErrorMessage(`Unexpected empty pending editor state on discrete nested update`);
            }
            pendingEditorState._flushSync = true;
          }
          if (onUpdate) {
            editor._deferred.push(onUpdate);
          }
          addTags(editor, options.tag);
        }
        if (pendingEditorState == null) {
          $beginUpdate(editor, nextUpdateFn, options);
        } else {
          nextUpdateFn();
        }
      }
    }
    return skipTransforms;
  }
  function $beginUpdate(editor, updateFn, options) {
    const updateTags = editor._updateTags;
    let onUpdate;
    let skipTransforms = false;
    let discrete = false;
    if (options !== void 0) {
      onUpdate = options.onUpdate;
      addTags(editor, options.tag);
      skipTransforms = options.skipTransforms || false;
      discrete = options.discrete || false;
    }
    if (onUpdate) {
      editor._deferred.push(onUpdate);
    }
    const currentEditorState = editor._editorState;
    let pendingEditorState = editor._pendingEditorState;
    let editorStateWasCloned = false;
    if (pendingEditorState === null || pendingEditorState._readOnly) {
      pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);
      editorStateWasCloned = true;
    }
    pendingEditorState._flushSync = discrete;
    const previousActiveEditorState = activeEditorState;
    const previousReadOnlyMode = isReadOnlyMode;
    const previousActiveEditor = activeEditor;
    const previouslyUpdating = editor._updating;
    activeEditorState = pendingEditorState;
    isReadOnlyMode = false;
    editor._updating = true;
    activeEditor = editor;
    const headless = editor._headless || editor.getRootElement() === null;
    setPendingNodeToClone(null);
    try {
      if (editorStateWasCloned) {
        if (headless) {
          if (currentEditorState._selection !== null) {
            pendingEditorState._selection = currentEditorState._selection.clone();
          }
        } else {
          pendingEditorState._selection = $internalCreateSelection(editor, options && options.event || null);
        }
      }
      const startingCompositionKey = editor._compositionKey;
      updateFn();
      skipTransforms = $processNestedUpdates(editor, skipTransforms);
      applySelectionTransforms(pendingEditorState, editor);
      if (editor._dirtyType !== NO_DIRTY_NODES) {
        if (skipTransforms) {
          $normalizeAllDirtyTextNodes(pendingEditorState, editor);
        } else {
          $applyAllTransforms(pendingEditorState, editor);
        }
        $processNestedUpdates(editor);
        $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);
      }
      const endingCompositionKey = editor._compositionKey;
      if (startingCompositionKey !== endingCompositionKey) {
        pendingEditorState._flushSync = true;
      }
      const pendingSelection = pendingEditorState._selection;
      if ($isRangeSelection(pendingSelection)) {
        const pendingNodeMap = pendingEditorState._nodeMap;
        const anchorKey = pendingSelection.anchor.key;
        const focusKey = pendingSelection.focus.key;
        if (pendingNodeMap.get(anchorKey) === void 0 || pendingNodeMap.get(focusKey) === void 0) {
          {
            formatDevErrorMessage(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);
          }
        }
      } else if ($isNodeSelection(pendingSelection)) {
        if (pendingSelection._nodes.size === 0) {
          pendingEditorState._selection = null;
        }
      }
    } catch (error2) {
      if (error2 instanceof Error) {
        editor._onError(error2);
      }
      editor._pendingEditorState = currentEditorState;
      editor._dirtyType = FULL_RECONCILE;
      editor._cloneNotNeeded.clear();
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      editor._dirtyElements.clear();
      $commitPendingUpdates(editor);
      return;
    } finally {
      activeEditorState = previousActiveEditorState;
      isReadOnlyMode = previousReadOnlyMode;
      activeEditor = previousActiveEditor;
      editor._updating = previouslyUpdating;
      infiniteTransformCount = 0;
    }
    const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);
    if (shouldUpdate) {
      if (pendingEditorState._flushSync) {
        pendingEditorState._flushSync = false;
        $commitPendingUpdates(editor);
      } else if (editorStateWasCloned) {
        scheduleMicroTask(() => {
          $commitPendingUpdates(editor);
        });
      }
    } else {
      pendingEditorState._flushSync = false;
      if (editorStateWasCloned) {
        updateTags.clear();
        editor._deferred = [];
        editor._pendingEditorState = null;
      }
    }
  }
  function updateEditorSync(editor, updateFn, options) {
    if (activeEditor === editor && options === void 0) {
      updateFn();
    } else {
      $beginUpdate(editor, updateFn, options);
    }
  }
  function updateEditor(editor, updateFn, options) {
    if (editor._updating) {
      editor._updates.push([updateFn, options]);
    } else {
      $beginUpdate(editor, updateFn, options);
    }
  }
  var ElementDOMSlot = class _ElementDOMSlot {
    element;
    before;
    after;
    constructor(element, before, after) {
      this.element = element;
      this.before = before || null;
      this.after = after || null;
    }
    /**
     * Return a new ElementDOMSlot where all managed children will be inserted before this node
     */
    withBefore(before) {
      return new _ElementDOMSlot(this.element, before, this.after);
    }
    /**
     * Return a new ElementDOMSlot where all managed children will be inserted after this node
     */
    withAfter(after) {
      return new _ElementDOMSlot(this.element, this.before, after);
    }
    /**
     * Return a new ElementDOMSlot with an updated root element
     */
    withElement(element) {
      if (this.element === element) {
        return this;
      }
      return new _ElementDOMSlot(element, this.before, this.after);
    }
    /**
     * Insert the given child before this.before and any reconciler managed line break node,
     * or append it if this.before is not defined
     */
    insertChild(dom) {
      const before = this.before || this.getManagedLineBreak();
      if (!(before === null || before.parentElement === this.element)) {
        formatDevErrorMessage(`ElementDOMSlot.insertChild: before is not in element`);
      }
      this.element.insertBefore(dom, before);
      return this;
    }
    /**
     * Remove the managed child from this container, will throw if it was not already there
     */
    removeChild(dom) {
      if (!(dom.parentElement === this.element)) {
        formatDevErrorMessage(`ElementDOMSlot.removeChild: dom is not in element`);
      }
      this.element.removeChild(dom);
      return this;
    }
    /**
     * Replace managed child prevDom with dom. Will throw if prevDom is not a child
     *
     * @param dom The new node to replace prevDom
     * @param prevDom the node that will be replaced
     */
    replaceChild(dom, prevDom) {
      if (!(prevDom.parentElement === this.element)) {
        formatDevErrorMessage(`ElementDOMSlot.replaceChild: prevDom is not in element`);
      }
      this.element.replaceChild(dom, prevDom);
      return this;
    }
    /**
     * Returns the first managed child of this node,
     * which will either be this.after.nextSibling or this.element.firstChild,
     * and will never be this.before if it is defined.
     */
    getFirstChild() {
      const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;
      return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;
    }
    /**
     * @internal
     */
    getManagedLineBreak() {
      const element = this.element;
      return element.__lexicalLineBreak || null;
    }
    /** @internal */
    setManagedLineBreak(lineBreakType) {
      if (lineBreakType === null) {
        this.removeManagedLineBreak();
      } else {
        const webkitHack = lineBreakType === "decorator" && (IS_APPLE_WEBKIT || IS_IOS || IS_SAFARI);
        this.insertManagedLineBreak(webkitHack);
      }
    }
    /** @internal */
    removeManagedLineBreak() {
      const br = this.getManagedLineBreak();
      if (br) {
        const element = this.element;
        const sibling = br.nodeName === "IMG" ? br.nextSibling : null;
        if (sibling) {
          element.removeChild(sibling);
        }
        element.removeChild(br);
        element.__lexicalLineBreak = void 0;
      }
    }
    /** @internal */
    insertManagedLineBreak(webkitHack) {
      const prevBreak = this.getManagedLineBreak();
      if (prevBreak) {
        if (webkitHack === (prevBreak.nodeName === "IMG")) {
          return;
        }
        this.removeManagedLineBreak();
      }
      const element = this.element;
      const before = this.before;
      const br = document.createElement("br");
      element.insertBefore(br, before);
      if (webkitHack) {
        const img = document.createElement("img");
        img.setAttribute("data-lexical-linebreak", "true");
        img.style.cssText = "display: inline !important; border: 0px !important; margin: 0px !important;";
        img.alt = "";
        element.insertBefore(img, br);
        element.__lexicalLineBreak = img;
      } else {
        element.__lexicalLineBreak = br;
      }
    }
    /**
     * @internal
     *
     * Returns the offset of the first child
     */
    getFirstChildOffset() {
      let i2 = 0;
      for (let node = this.after; node !== null; node = node.previousSibling) {
        i2++;
      }
      return i2;
    }
    /**
     * @internal
     */
    resolveChildIndex(element, elementDOM, initialDOM, initialOffset) {
      if (initialDOM === this.element) {
        const firstChildOffset = this.getFirstChildOffset();
        return [element, Math.min(firstChildOffset + element.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];
      }
      const initialPath = indexPath(elementDOM, initialDOM);
      initialPath.push(initialOffset);
      const elementPath = indexPath(elementDOM, this.element);
      let offset = element.getIndexWithinParent();
      for (let i2 = 0; i2 < elementPath.length; i2++) {
        const target = initialPath[i2];
        const source = elementPath[i2];
        if (target === void 0 || target < source) {
          break;
        } else if (target > source) {
          offset += 1;
          break;
        }
      }
      return [element.getParentOrThrow(), offset];
    }
  };
  function indexPath(root, child) {
    const path = [];
    let node = child;
    for (; node !== root && node !== null; node = node.parentNode) {
      let i2 = 0;
      for (let sibling = node.previousSibling; sibling !== null; sibling = sibling.previousSibling) {
        i2++;
      }
      path.push(i2);
    }
    if (!(node === root)) {
      formatDevErrorMessage(`indexPath: root is not a parent of child`);
    }
    return path.reverse();
  }
  var ElementNode = class extends LexicalNode {
    /** @internal */
    /** @internal */
    __first;
    /** @internal */
    __last;
    /** @internal */
    __size;
    /** @internal */
    __format;
    /** @internal */
    __style;
    /** @internal */
    __indent;
    /** @internal */
    __dir;
    /** @internal */
    __textFormat;
    /** @internal */
    __textStyle;
    constructor(key) {
      super(key);
      this.__first = null;
      this.__last = null;
      this.__size = 0;
      this.__format = 0;
      this.__style = "";
      this.__indent = 0;
      this.__dir = null;
      this.__textFormat = 0;
      this.__textStyle = "";
    }
    afterCloneFrom(prevNode) {
      super.afterCloneFrom(prevNode);
      if (this.__key === prevNode.__key) {
        this.__first = prevNode.__first;
        this.__last = prevNode.__last;
        this.__size = prevNode.__size;
      }
      this.__indent = prevNode.__indent;
      this.__format = prevNode.__format;
      this.__style = prevNode.__style;
      this.__dir = prevNode.__dir;
      this.__textFormat = prevNode.__textFormat;
      this.__textStyle = prevNode.__textStyle;
    }
    getFormat() {
      const self2 = this.getLatest();
      return self2.__format;
    }
    getFormatType() {
      const format = this.getFormat();
      return ELEMENT_FORMAT_TO_TYPE[format] || "";
    }
    getStyle() {
      const self2 = this.getLatest();
      return self2.__style;
    }
    getIndent() {
      const self2 = this.getLatest();
      return self2.__indent;
    }
    getChildren() {
      const children = [];
      let child = this.getFirstChild();
      while (child !== null) {
        children.push(child);
        child = child.getNextSibling();
      }
      return children;
    }
    getChildrenKeys() {
      const children = [];
      let child = this.getFirstChild();
      while (child !== null) {
        children.push(child.__key);
        child = child.getNextSibling();
      }
      return children;
    }
    getChildrenSize() {
      const self2 = this.getLatest();
      return self2.__size;
    }
    isEmpty() {
      return this.getChildrenSize() === 0;
    }
    isDirty() {
      const editor = getActiveEditor();
      const dirtyElements = editor._dirtyElements;
      return dirtyElements !== null && dirtyElements.has(this.__key);
    }
    isLastChild() {
      const self2 = this.getLatest();
      const parentLastChild = this.getParentOrThrow().getLastChild();
      return parentLastChild !== null && parentLastChild.is(self2);
    }
    getAllTextNodes() {
      const textNodes = [];
      let child = this.getFirstChild();
      while (child !== null) {
        if ($isTextNode(child)) {
          textNodes.push(child);
        }
        if ($isElementNode(child)) {
          const subChildrenNodes = child.getAllTextNodes();
          textNodes.push(...subChildrenNodes);
        }
        child = child.getNextSibling();
      }
      return textNodes;
    }
    getFirstDescendant() {
      let node = this.getFirstChild();
      while ($isElementNode(node)) {
        const child = node.getFirstChild();
        if (child === null) {
          break;
        }
        node = child;
      }
      return node;
    }
    getLastDescendant() {
      let node = this.getLastChild();
      while ($isElementNode(node)) {
        const child = node.getLastChild();
        if (child === null) {
          break;
        }
        node = child;
      }
      return node;
    }
    getDescendantByIndex(index2) {
      const children = this.getChildren();
      const childrenLength = children.length;
      if (index2 >= childrenLength) {
        const resolvedNode2 = children[childrenLength - 1];
        return $isElementNode(resolvedNode2) && resolvedNode2.getLastDescendant() || resolvedNode2 || null;
      }
      const resolvedNode = children[index2];
      return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;
    }
    getFirstChild() {
      const self2 = this.getLatest();
      const firstKey = self2.__first;
      return firstKey === null ? null : $getNodeByKey(firstKey);
    }
    getFirstChildOrThrow() {
      const firstChild = this.getFirstChild();
      if (firstChild === null) {
        {
          formatDevErrorMessage(`Expected node ${this.__key} to have a first child.`);
        }
      }
      return firstChild;
    }
    getLastChild() {
      const self2 = this.getLatest();
      const lastKey = self2.__last;
      return lastKey === null ? null : $getNodeByKey(lastKey);
    }
    getLastChildOrThrow() {
      const lastChild = this.getLastChild();
      if (lastChild === null) {
        {
          formatDevErrorMessage(`Expected node ${this.__key} to have a last child.`);
        }
      }
      return lastChild;
    }
    getChildAtIndex(index2) {
      const size2 = this.getChildrenSize();
      let node;
      let i2;
      if (index2 < size2 / 2) {
        node = this.getFirstChild();
        i2 = 0;
        while (node !== null && i2 <= index2) {
          if (i2 === index2) {
            return node;
          }
          node = node.getNextSibling();
          i2++;
        }
        return null;
      }
      node = this.getLastChild();
      i2 = size2 - 1;
      while (node !== null && i2 >= index2) {
        if (i2 === index2) {
          return node;
        }
        node = node.getPreviousSibling();
        i2--;
      }
      return null;
    }
    getTextContent() {
      let textContent = "";
      const children = this.getChildren();
      const childrenLength = children.length;
      for (let i2 = 0; i2 < childrenLength; i2++) {
        const child = children[i2];
        textContent += child.getTextContent();
        if ($isElementNode(child) && i2 !== childrenLength - 1 && !child.isInline()) {
          textContent += DOUBLE_LINE_BREAK;
        }
      }
      return textContent;
    }
    getTextContentSize() {
      let textContentSize = 0;
      const children = this.getChildren();
      const childrenLength = children.length;
      for (let i2 = 0; i2 < childrenLength; i2++) {
        const child = children[i2];
        textContentSize += child.getTextContentSize();
        if ($isElementNode(child) && i2 !== childrenLength - 1 && !child.isInline()) {
          textContentSize += DOUBLE_LINE_BREAK.length;
        }
      }
      return textContentSize;
    }
    getDirection() {
      const self2 = this.getLatest();
      return self2.__dir;
    }
    getTextFormat() {
      const self2 = this.getLatest();
      return self2.__textFormat;
    }
    hasFormat(type) {
      if (type !== "") {
        const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];
        return (this.getFormat() & formatFlag) !== 0;
      }
      return false;
    }
    hasTextFormat(type) {
      const formatFlag = TEXT_TYPE_TO_FORMAT[type];
      return (this.getTextFormat() & formatFlag) !== 0;
    }
    /**
     * Returns the format flags applied to the node as a 32-bit integer.
     *
     * @returns a number representing the TextFormatTypes applied to the node.
     */
    getFormatFlags(type, alignWithFormat) {
      const self2 = this.getLatest();
      const format = self2.__textFormat;
      return toggleTextFormatType(format, type, alignWithFormat);
    }
    getTextStyle() {
      const self2 = this.getLatest();
      return self2.__textStyle;
    }
    // Mutators
    select(_anchorOffset, _focusOffset) {
      errorOnReadOnly();
      const selection = $getSelection();
      let anchorOffset = _anchorOffset;
      let focusOffset = _focusOffset;
      const childrenCount = this.getChildrenSize();
      if (!this.canBeEmpty()) {
        if (_anchorOffset === 0 && _focusOffset === 0) {
          const firstChild = this.getFirstChild();
          if ($isTextNode(firstChild) || $isElementNode(firstChild)) {
            return firstChild.select(0, 0);
          }
        } else if ((_anchorOffset === void 0 || _anchorOffset === childrenCount) && (_focusOffset === void 0 || _focusOffset === childrenCount)) {
          const lastChild = this.getLastChild();
          if ($isTextNode(lastChild) || $isElementNode(lastChild)) {
            return lastChild.select();
          }
        }
      }
      if (anchorOffset === void 0) {
        anchorOffset = childrenCount;
      }
      if (focusOffset === void 0) {
        focusOffset = childrenCount;
      }
      const key = this.__key;
      if (!$isRangeSelection(selection)) {
        return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "element", "element");
      } else {
        selection.anchor.set(key, anchorOffset, "element");
        selection.focus.set(key, focusOffset, "element");
        selection.dirty = true;
      }
      return selection;
    }
    selectStart() {
      const firstNode = this.getFirstDescendant();
      return firstNode ? firstNode.selectStart() : this.select();
    }
    selectEnd() {
      const lastNode = this.getLastDescendant();
      return lastNode ? lastNode.selectEnd() : this.select();
    }
    clear() {
      const writableSelf = this.getWritable();
      const children = this.getChildren();
      children.forEach((child) => child.remove());
      return writableSelf;
    }
    append(...nodesToAppend) {
      return this.splice(this.getChildrenSize(), 0, nodesToAppend);
    }
    setDirection(direction) {
      const self2 = this.getWritable();
      self2.__dir = direction;
      return self2;
    }
    setFormat(type) {
      const self2 = this.getWritable();
      self2.__format = type !== "" ? ELEMENT_TYPE_TO_FORMAT[type] : 0;
      return this;
    }
    setStyle(style) {
      const self2 = this.getWritable();
      self2.__style = style || "";
      return this;
    }
    setTextFormat(type) {
      const self2 = this.getWritable();
      self2.__textFormat = type;
      return self2;
    }
    setTextStyle(style) {
      const self2 = this.getWritable();
      self2.__textStyle = style;
      return self2;
    }
    setIndent(indentLevel) {
      const self2 = this.getWritable();
      self2.__indent = indentLevel;
      return this;
    }
    splice(start3, deleteCount, nodesToInsert) {
      if (!!$isEphemeral(this)) {
        formatDevErrorMessage(`ElementNode.splice: Ephemeral nodes can not mutate their children (key ${this.__key} type ${this.__type})`);
      }
      const oldSize = this.getChildrenSize();
      const writableSelf = this.getWritable();
      if (!(start3 + deleteCount <= oldSize)) {
        formatDevErrorMessage(`ElementNode.splice: start + deleteCount > oldSize (${String(start3)} + ${String(deleteCount)} > ${String(oldSize)})`);
      }
      const writableSelfKey = writableSelf.__key;
      const nodesToInsertKeys = [];
      const nodesToRemoveKeys = [];
      const nodeAfterRange = this.getChildAtIndex(start3 + deleteCount);
      let nodeBeforeRange = null;
      let newSize = oldSize - deleteCount + nodesToInsert.length;
      if (start3 !== 0) {
        if (start3 === oldSize) {
          nodeBeforeRange = this.getLastChild();
        } else {
          const node = this.getChildAtIndex(start3);
          if (node !== null) {
            nodeBeforeRange = node.getPreviousSibling();
          }
        }
      }
      if (deleteCount > 0) {
        let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();
        for (let i2 = 0; i2 < deleteCount; i2++) {
          if (nodeToDelete === null) {
            {
              formatDevErrorMessage(`splice: sibling not found`);
            }
          }
          const nextSibling = nodeToDelete.getNextSibling();
          const nodeKeyToDelete = nodeToDelete.__key;
          const writableNodeToDelete = nodeToDelete.getWritable();
          removeFromParent(writableNodeToDelete);
          nodesToRemoveKeys.push(nodeKeyToDelete);
          nodeToDelete = nextSibling;
        }
      }
      let prevNode = nodeBeforeRange;
      for (const nodeToInsert of nodesToInsert) {
        if (prevNode !== null && nodeToInsert.is(prevNode)) {
          nodeBeforeRange = prevNode = prevNode.getPreviousSibling();
        }
        const writableNodeToInsert = nodeToInsert.getWritable();
        if (writableNodeToInsert.__parent === writableSelfKey) {
          newSize--;
        }
        removeFromParent(writableNodeToInsert);
        const nodeKeyToInsert = nodeToInsert.__key;
        if (prevNode === null) {
          writableSelf.__first = nodeKeyToInsert;
          writableNodeToInsert.__prev = null;
        } else {
          const writablePrevNode = prevNode.getWritable();
          writablePrevNode.__next = nodeKeyToInsert;
          writableNodeToInsert.__prev = writablePrevNode.__key;
        }
        if (nodeToInsert.__key === writableSelfKey) {
          {
            formatDevErrorMessage(`append: attempting to append self`);
          }
        }
        writableNodeToInsert.__parent = writableSelfKey;
        nodesToInsertKeys.push(nodeKeyToInsert);
        prevNode = nodeToInsert;
      }
      if (start3 + deleteCount === oldSize) {
        if (prevNode !== null) {
          const writablePrevNode = prevNode.getWritable();
          writablePrevNode.__next = null;
          writableSelf.__last = prevNode.__key;
        }
      } else if (nodeAfterRange !== null) {
        const writableNodeAfterRange = nodeAfterRange.getWritable();
        if (prevNode !== null) {
          const writablePrevNode = prevNode.getWritable();
          writableNodeAfterRange.__prev = prevNode.__key;
          writablePrevNode.__next = nodeAfterRange.__key;
        } else {
          writableNodeAfterRange.__prev = null;
        }
      }
      writableSelf.__size = newSize;
      if (nodesToRemoveKeys.length) {
        const selection = $getSelection();
        if ($isRangeSelection(selection)) {
          const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);
          const nodesToInsertKeySet = new Set(nodesToInsertKeys);
          const {
            anchor,
            focus
          } = selection;
          if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {
            moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);
          }
          if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {
            moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);
          }
          if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {
            this.remove();
          }
        }
      }
      return writableSelf;
    }
    /**
     * @internal
     *
     * An experimental API that an ElementNode can override to control where its
     * children are inserted into the DOM, this is useful to add a wrapping node
     * or accessory nodes before or after the children. The root of the node returned
     * by createDOM must still be exactly one HTMLElement.
     */
    getDOMSlot(element) {
      return new ElementDOMSlot(element);
    }
    exportDOM(editor) {
      const {
        element
      } = super.exportDOM(editor);
      if (isHTMLElement(element)) {
        const indent = this.getIndent();
        if (indent > 0) {
          element.style.paddingInlineStart = `${indent * 40}px`;
        }
        const direction = this.getDirection();
        if (direction) {
          element.dir = direction;
        }
      }
      return {
        element
      };
    }
    // JSON serialization
    exportJSON() {
      const json = {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        // As an exception here we invoke super at the end for historical reasons.
        // Namely, to preserve the order of the properties and not to break the tests
        // that use the serialized string representation.
        ...super.exportJSON()
      };
      const textFormat = this.getTextFormat();
      const textStyle = this.getTextStyle();
      if (textFormat !== 0) {
        json.textFormat = textFormat;
      }
      if (textStyle !== "") {
        json.textStyle = textStyle;
      }
      return json;
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || "");
    }
    // These are intended to be extends for specific element heuristics.
    insertNewAfter(selection, restoreSelection) {
      return null;
    }
    canIndent() {
      return true;
    }
    /*
     * This method controls the behavior of the node during backwards
     * deletion (i.e., backspace) when selection is at the beginning of
     * the node (offset 0). You may use this to have the node replace
     * itself, change its state, or do nothing. When you do make such
     * a change, you should return true.
     *
     * When true is returned, the collapse phase will stop.
     * When false is returned, and isInline() is true, and getPreviousSibling() is null,
     * then this function will be called on its parent.
     */
    collapseAtStart(selection) {
      return false;
    }
    excludeFromCopy(destination) {
      return false;
    }
    /** @deprecated @internal */
    canReplaceWith(replacement) {
      return true;
    }
    /** @deprecated @internal */
    canInsertAfter(node) {
      return true;
    }
    canBeEmpty() {
      return true;
    }
    canInsertTextBefore() {
      return true;
    }
    canInsertTextAfter() {
      return true;
    }
    isInline() {
      return false;
    }
    // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
    // end of the hierarchy, most implementations should treat it as there's nothing (upwards)
    // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
    // will return the immediate first child underneath TableCellNode instead of RootNode.
    isShadowRoot() {
      return false;
    }
    /** @deprecated @internal */
    canMergeWith(node) {
      return false;
    }
    extractWithChild(child, selection, destination) {
      return false;
    }
    /**
     * Determines whether this node, when empty, can merge with a first block
     * of nodes being inserted.
     *
     * This method is specifically called in {@link RangeSelection.insertNodes}
     * to determine merging behavior during nodes insertion.
     *
     * @example
     * // In a ListItemNode or QuoteNode implementation:
     * canMergeWhenEmpty(): true {
     *  return true;
     * }
     */
    canMergeWhenEmpty() {
      return false;
    }
    /** @internal */
    reconcileObservedMutation(dom, editor) {
      const slot = this.getDOMSlot(dom);
      let currentDOM = slot.getFirstChild();
      for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {
        const correctDOM = editor.getElementByKey(currentNode.getKey());
        if (correctDOM === null) {
          continue;
        }
        if (currentDOM == null) {
          slot.insertChild(correctDOM);
          currentDOM = correctDOM;
        } else if (currentDOM !== correctDOM) {
          slot.replaceChild(correctDOM, currentDOM);
        }
        currentDOM = currentDOM.nextSibling;
      }
    }
  };
  function $isElementNode(node) {
    return node instanceof ElementNode;
  }
  function isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {
    let node = point.getNode();
    while (node) {
      const nodeKey = node.__key;
      if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {
        return true;
      }
      node = node.getParent();
    }
    return false;
  }
  var DecoratorNode = class extends LexicalNode {
    /** @internal */
    /**
     * The returned value is added to the LexicalEditor._decorators
     */
    decorate(editor, config) {
      return null;
    }
    isIsolated() {
      return false;
    }
    isInline() {
      return true;
    }
    isKeyboardSelectable() {
      return true;
    }
  };
  function $isDecoratorNode(node) {
    return node instanceof DecoratorNode;
  }
  var RootNode = class _RootNode extends ElementNode {
    /** @internal */
    __cachedText;
    static getType() {
      return "root";
    }
    static clone() {
      return new _RootNode();
    }
    constructor() {
      super("root");
      this.__cachedText = null;
    }
    getTopLevelElementOrThrow() {
      {
        formatDevErrorMessage(`getTopLevelElementOrThrow: root nodes are not top level elements`);
      }
    }
    getTextContent() {
      const cachedText = this.__cachedText;
      if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {
        if (cachedText !== null) {
          return cachedText;
        }
      }
      return super.getTextContent();
    }
    remove() {
      {
        formatDevErrorMessage(`remove: cannot be called on root nodes`);
      }
    }
    replace(node) {
      {
        formatDevErrorMessage(`replace: cannot be called on root nodes`);
      }
    }
    insertBefore(nodeToInsert) {
      {
        formatDevErrorMessage(`insertBefore: cannot be called on root nodes`);
      }
    }
    insertAfter(nodeToInsert) {
      {
        formatDevErrorMessage(`insertAfter: cannot be called on root nodes`);
      }
    }
    // View
    updateDOM(prevNode, dom) {
      return false;
    }
    // Mutate
    splice(start3, deleteCount, nodesToInsert) {
      for (const node of nodesToInsert) {
        if (!($isElementNode(node) || $isDecoratorNode(node))) {
          formatDevErrorMessage(`rootNode.splice: Only element or decorator nodes can be inserted to the root node`);
        }
      }
      return super.splice(start3, deleteCount, nodesToInsert);
    }
    static importJSON(serializedNode) {
      return $getRoot().updateFromJSON(serializedNode);
    }
    collapseAtStart() {
      return true;
    }
  };
  function $createRootNode() {
    return new RootNode();
  }
  function $isRootNode(node) {
    return node instanceof RootNode;
  }
  function editorStateHasDirtySelection(editorState, editor) {
    const currentSelection = editor.getEditorState()._selection;
    const pendingSelection = editorState._selection;
    if (pendingSelection !== null) {
      if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {
        return true;
      }
    } else if (currentSelection !== null) {
      return true;
    }
    return false;
  }
  function cloneEditorState(current) {
    return new EditorState(new Map(current._nodeMap));
  }
  function createEmptyEditorState() {
    return new EditorState(/* @__PURE__ */ new Map([["root", $createRootNode()]]));
  }
  function exportNodeToJSON(node) {
    const serializedNode = node.exportJSON();
    const nodeClass = node.constructor;
    if (serializedNode.type !== nodeClass.getType()) {
      {
        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
      }
    }
    if ($isElementNode(node)) {
      const serializedChildren = serializedNode.children;
      if (!Array.isArray(serializedChildren)) {
        {
          formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
        }
      }
      const children = node.getChildren();
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        const serializedChildNode = exportNodeToJSON(child);
        serializedChildren.push(serializedChildNode);
      }
    }
    return serializedNode;
  }
  function $isEditorState(x2) {
    return x2 instanceof EditorState;
  }
  var EditorState = class _EditorState {
    _nodeMap;
    _selection;
    _flushSync;
    _readOnly;
    constructor(nodeMap, selection) {
      this._nodeMap = nodeMap;
      this._selection = selection || null;
      this._flushSync = false;
      this._readOnly = false;
    }
    isEmpty() {
      return this._nodeMap.size === 1 && this._selection === null;
    }
    read(callbackFn, options) {
      return readEditorState(options && options.editor || null, this, callbackFn);
    }
    clone(selection) {
      const editorState = new _EditorState(this._nodeMap, selection === void 0 ? this._selection : selection);
      editorState._readOnly = true;
      return editorState;
    }
    toJSON() {
      return readEditorState(null, this, () => ({
        root: exportNodeToJSON($getRoot())
      }));
    }
  };
  var ArtificialNode__DO_NOT_USE = class extends ElementNode {
    static getType() {
      return "artificial";
    }
    createDOM(config) {
      const dom = document.createElement("div");
      return dom;
    }
  };
  var ParagraphNode = class _ParagraphNode extends ElementNode {
    /** @internal */
    static getType() {
      return "paragraph";
    }
    static clone(node) {
      return new _ParagraphNode(node.__key);
    }
    // View
    createDOM(config) {
      const dom = document.createElement("p");
      const classNames = getCachedClassNameArray(config.theme, "paragraph");
      if (classNames !== void 0) {
        const domClassList = dom.classList;
        domClassList.add(...classNames);
      }
      return dom;
    }
    updateDOM(prevNode, dom, config) {
      return false;
    }
    static importDOM() {
      return {
        p: (node) => ({
          conversion: $convertParagraphElement,
          priority: 0
        })
      };
    }
    exportDOM(editor) {
      const {
        element
      } = super.exportDOM(editor);
      if (isHTMLElement(element)) {
        if (this.isEmpty()) {
          element.append(document.createElement("br"));
        }
        const formatType = this.getFormatType();
        if (formatType) {
          element.style.textAlign = formatType;
        }
      }
      return {
        element
      };
    }
    static importJSON(serializedNode) {
      return $createParagraphNode().updateFromJSON(serializedNode);
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        // These are included explicitly for backwards compatibility
        textFormat: this.getTextFormat(),
        textStyle: this.getTextStyle()
      };
    }
    // Mutation
    insertNewAfter(rangeSelection, restoreSelection) {
      const newElement = $createParagraphNode();
      newElement.setTextFormat(rangeSelection.format);
      newElement.setTextStyle(rangeSelection.style);
      const direction = this.getDirection();
      newElement.setDirection(direction);
      newElement.setFormat(this.getFormatType());
      newElement.setStyle(this.getStyle());
      this.insertAfter(newElement, restoreSelection);
      return newElement;
    }
    collapseAtStart() {
      const children = this.getChildren();
      if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === "") {
        const nextSibling = this.getNextSibling();
        if (nextSibling !== null) {
          this.selectNext();
          this.remove();
          return true;
        }
        const prevSibling = this.getPreviousSibling();
        if (prevSibling !== null) {
          this.selectPrevious();
          this.remove();
          return true;
        }
      }
      return false;
    }
  };
  function $convertParagraphElement(element) {
    const node = $createParagraphNode();
    if (element.style) {
      node.setFormat(element.style.textAlign);
      setNodeIndentFromDOM(element, node);
    }
    return {
      node
    };
  }
  function $createParagraphNode() {
    return $applyNodeReplacement(new ParagraphNode());
  }
  function $isParagraphNode(node) {
    return node instanceof ParagraphNode;
  }
  var DEFAULT_SKIP_INITIALIZATION = false;
  var COMMAND_PRIORITY_EDITOR = 0;
  var COMMAND_PRIORITY_LOW = 1;
  var COMMAND_PRIORITY_NORMAL = 2;
  var COMMAND_PRIORITY_HIGH = 3;
  var COMMAND_PRIORITY_CRITICAL = 4;
  function resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {
    const keyNodeMap = editor._keyToDOMMap;
    keyNodeMap.clear();
    editor._editorState = createEmptyEditorState();
    editor._pendingEditorState = pendingEditorState;
    editor._compositionKey = null;
    editor._dirtyType = NO_DIRTY_NODES;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements.clear();
    editor._normalizedNodes = /* @__PURE__ */ new Set();
    editor._updateTags = /* @__PURE__ */ new Set();
    editor._updates = [];
    editor._blockCursorElement = null;
    const observer2 = editor._observer;
    if (observer2 !== null) {
      observer2.disconnect();
      editor._observer = null;
    }
    if (prevRootElement !== null) {
      prevRootElement.textContent = "";
    }
    if (nextRootElement !== null) {
      nextRootElement.textContent = "";
      keyNodeMap.set("root", nextRootElement);
    }
  }
  function initializeConversionCache(nodes, additionalConversions) {
    const conversionCache = /* @__PURE__ */ new Map();
    const handledConversions = /* @__PURE__ */ new Set();
    const addConversionsToCache = (map3) => {
      Object.keys(map3).forEach((key) => {
        let currentCache = conversionCache.get(key);
        if (currentCache === void 0) {
          currentCache = [];
          conversionCache.set(key, currentCache);
        }
        currentCache.push(map3[key]);
      });
    };
    nodes.forEach((node) => {
      const importDOM = node.klass.importDOM;
      if (importDOM == null || handledConversions.has(importDOM)) {
        return;
      }
      handledConversions.add(importDOM);
      const map3 = importDOM.call(node.klass);
      if (map3 !== null) {
        addConversionsToCache(map3);
      }
    });
    if (additionalConversions) {
      addConversionsToCache(additionalConversions);
    }
    return conversionCache;
  }
  function getTransformSetFromKlass(klass) {
    const transforms = /* @__PURE__ */ new Set();
    const staticTransforms = /* @__PURE__ */ new Set();
    let currentKlass = klass;
    while (currentKlass) {
      const {
        ownNodeConfig
      } = getStaticNodeConfig(currentKlass);
      const staticTransform = currentKlass.transform;
      if (!staticTransforms.has(staticTransform)) {
        staticTransforms.add(staticTransform);
        const transform = currentKlass.transform();
        if (transform) {
          transforms.add(transform);
        }
      }
      if (ownNodeConfig) {
        const $transform = ownNodeConfig.$transform;
        if ($transform) {
          transforms.add($transform);
        }
        currentKlass = ownNodeConfig.extends;
      } else {
        const parent = Object.getPrototypeOf(currentKlass);
        currentKlass = parent.prototype instanceof LexicalNode && parent !== LexicalNode ? parent : void 0;
      }
    }
    return transforms;
  }
  function createEditor(editorConfig) {
    const config = editorConfig || {};
    const activeEditor2 = internalGetActiveEditor();
    const theme2 = config.theme || {};
    const parentEditor = editorConfig === void 0 ? activeEditor2 : config.parentEditor || null;
    const disableEvents = config.disableEvents || false;
    const editorState = createEmptyEditorState();
    const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());
    const initialEditorState = config.editorState;
    const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...config.nodes || []];
    const {
      onError,
      html: html2
    } = config;
    const isEditable = config.editable !== void 0 ? config.editable : true;
    let registeredNodes;
    if (editorConfig === void 0 && activeEditor2 !== null) {
      registeredNodes = activeEditor2._nodes;
    } else {
      registeredNodes = /* @__PURE__ */ new Map();
      for (let i2 = 0; i2 < nodes.length; i2++) {
        let klass = nodes[i2];
        let replace = null;
        let replaceWithKlass = null;
        if (typeof klass !== "function") {
          const options = klass;
          klass = options.replace;
          replace = options.with;
          replaceWithKlass = options.withKlass || null;
        }
        void getStaticNodeConfig(klass);
        {
          const name = klass.name;
          const nodeType = hasOwnStaticMethod(klass, "getType") && klass.getType();
          if (replaceWithKlass) {
            if (!(replaceWithKlass.prototype instanceof klass)) {
              formatDevErrorMessage(`${replaceWithKlass.name} doesn't extend the ${name}`);
            }
          } else if (replace) {
            console.warn(`Override for ${name} specifies 'replace' without 'withKlass'. 'withKlass' will be required in a future version.`);
          }
          if (name !== "RootNode" && nodeType !== "root" && nodeType !== "artificial" && // This is mostly for the unit test suite which
          // uses LexicalNode in an otherwise incorrect way
          // by mocking its static getType
          klass !== LexicalNode) {
            ["getType", "clone"].forEach((method) => {
              if (!hasOwnStaticMethod(klass, method)) {
                console.warn(`${name} must implement static "${method}" method`);
              }
            });
            if (!hasOwnStaticMethod(klass, "importDOM") && hasOwnExportDOM(klass)) {
              console.warn(`${name} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`);
            }
            if (!hasOwnStaticMethod(klass, "importJSON")) {
              console.warn(`${name} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`);
            }
          }
        }
        const type = klass.getType();
        const transforms = getTransformSetFromKlass(klass);
        registeredNodes.set(type, {
          exportDOM: html2 && html2.export ? html2.export.get(klass) : void 0,
          klass,
          replace,
          replaceWithKlass,
          sharedNodeState: createSharedNodeState(nodes[i2]),
          transforms
        });
      }
    }
    const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {
      disableEvents,
      namespace,
      theme: theme2
    }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html2 ? html2.import : void 0), isEditable, editorConfig);
    if (initialEditorState !== void 0) {
      editor._pendingEditorState = initialEditorState;
      editor._dirtyType = FULL_RECONCILE;
    }
    return editor;
  }
  var LexicalEditor = class {
    /** @internal */
    /** The version with build identifiers for this editor (since 0.17.1) */
    static version;
    /** @internal */
    _headless;
    /** @internal */
    _parentEditor;
    /** @internal */
    _rootElement;
    /** @internal */
    _editorState;
    /** @internal */
    _pendingEditorState;
    /** @internal */
    _compositionKey;
    /** @internal */
    _deferred;
    /** @internal */
    _keyToDOMMap;
    /** @internal */
    _updates;
    /** @internal */
    _updating;
    /** @internal */
    _listeners;
    /** @internal */
    _commands;
    /** @internal */
    _nodes;
    /** @internal */
    _decorators;
    /** @internal */
    _pendingDecorators;
    /** @internal */
    _config;
    /** @internal */
    _dirtyType;
    /** @internal */
    _cloneNotNeeded;
    /** @internal */
    _dirtyLeaves;
    /** @internal */
    _dirtyElements;
    /** @internal */
    _normalizedNodes;
    /** @internal */
    _updateTags;
    /** @internal */
    _observer;
    /** @internal */
    _key;
    /** @internal */
    _onError;
    /** @internal */
    _htmlConversions;
    /** @internal */
    _window;
    /** @internal */
    _editable;
    /** @internal */
    _blockCursorElement;
    /** @internal */
    _createEditorArgs;
    /** @internal */
    constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable, createEditorArgs) {
      this._createEditorArgs = createEditorArgs;
      this._parentEditor = parentEditor;
      this._rootElement = null;
      this._editorState = editorState;
      this._pendingEditorState = null;
      this._compositionKey = null;
      this._deferred = [];
      this._keyToDOMMap = /* @__PURE__ */ new Map();
      this._updates = [];
      this._updating = false;
      this._listeners = {
        decorator: /* @__PURE__ */ new Set(),
        editable: /* @__PURE__ */ new Set(),
        mutation: /* @__PURE__ */ new Map(),
        root: /* @__PURE__ */ new Set(),
        textcontent: /* @__PURE__ */ new Set(),
        update: /* @__PURE__ */ new Set()
      };
      this._commands = /* @__PURE__ */ new Map();
      this._config = config;
      this._nodes = nodes;
      this._decorators = {};
      this._pendingDecorators = null;
      this._dirtyType = NO_DIRTY_NODES;
      this._cloneNotNeeded = /* @__PURE__ */ new Set();
      this._dirtyLeaves = /* @__PURE__ */ new Set();
      this._dirtyElements = /* @__PURE__ */ new Map();
      this._normalizedNodes = /* @__PURE__ */ new Set();
      this._updateTags = /* @__PURE__ */ new Set();
      this._observer = null;
      this._key = createUID();
      this._onError = onError;
      this._htmlConversions = htmlConversions;
      this._editable = editable;
      this._headless = parentEditor !== null && parentEditor._headless;
      this._window = null;
      this._blockCursorElement = null;
    }
    /**
     *
     * @returns true if the editor is currently in "composition" mode due to receiving input
     * through an IME, or 3P extension, for example. Returns false otherwise.
     */
    isComposing() {
      return this._compositionKey != null;
    }
    /**
     * Registers a listener for Editor update event. Will trigger the provided callback
     * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerUpdateListener(listener) {
      const listenerSetOrMap = this._listeners.update;
      listenerSetOrMap.add(listener);
      return () => {
        listenerSetOrMap.delete(listener);
      };
    }
    /**
     * Registers a listener for for when the editor changes between editable and non-editable states.
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerEditableListener(listener) {
      const listenerSetOrMap = this._listeners.editable;
      listenerSetOrMap.add(listener);
      return () => {
        listenerSetOrMap.delete(listener);
      };
    }
    /**
     * Registers a listener for when the editor's decorator object changes. The decorator object contains
     * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerDecoratorListener(listener) {
      const listenerSetOrMap = this._listeners.decorator;
      listenerSetOrMap.add(listener);
      return () => {
        listenerSetOrMap.delete(listener);
      };
    }
    /**
     * Registers a listener for when Lexical commits an update to the DOM and the text content of
     * the editor changes from the previous state of the editor. If the text content is the
     * same between updates, no notifications to the listeners will happen.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerTextContentListener(listener) {
      const listenerSetOrMap = this._listeners.textcontent;
      listenerSetOrMap.add(listener);
      return () => {
        listenerSetOrMap.delete(listener);
      };
    }
    /**
     * Registers a listener for when the editor's root DOM element (the content editable
     * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
     *  element. The root listener function is executed directly upon registration and then on
     * any subsequent update.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerRootListener(listener) {
      const listenerSetOrMap = this._listeners.root;
      listener(this._rootElement, null);
      listenerSetOrMap.add(listener);
      return () => {
        listener(null, this._rootElement);
        listenerSetOrMap.delete(listener);
      };
    }
    /**
     * Registers a listener that will trigger anytime the provided command
     * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.
     * Listeners that run at a higher priority can "intercept" commands and
     * prevent them from propagating to other handlers by returning true.
     *
     * Listeners are always invoked in an {@link LexicalEditor.update} and can
     * call dollar functions.
     *
     * Listeners registered at the same priority level will run
     * deterministically in the order of registration.
     *
     * @param command - the command that will trigger the callback.
     * @param listener - the function that will execute when the command is dispatched.
     * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
     *   (or {@link COMMAND_PRIORITY_EDITOR} |
     *     {@link COMMAND_PRIORITY_LOW} |
     *     {@link COMMAND_PRIORITY_NORMAL} |
     *     {@link COMMAND_PRIORITY_HIGH} |
     *     {@link COMMAND_PRIORITY_CRITICAL})
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerCommand(command, listener, priority) {
      if (priority === void 0) {
        {
          formatDevErrorMessage(`Listener for type "command" requires a "priority".`);
        }
      }
      const commandsMap = this._commands;
      if (!commandsMap.has(command)) {
        commandsMap.set(command, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
      }
      const listenersInPriorityOrder = commandsMap.get(command);
      if (listenersInPriorityOrder === void 0) {
        {
          formatDevErrorMessage(`registerCommand: Command ${String(command)} not found in command map`);
        }
      }
      const listeners = listenersInPriorityOrder[priority];
      listeners.add(listener);
      return () => {
        listeners.delete(listener);
        if (listenersInPriorityOrder.every((listenersSet) => listenersSet.size === 0)) {
          commandsMap.delete(command);
        }
      };
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * mutated. The listener will receive a list of nodes along with the type of mutation
     * that was performed on each: created, destroyed, or updated.
     *
     * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
     * {@link LexicalEditor.getElementByKey} can be used for this.
     *
     * If any existing nodes are in the DOM, and skipInitialization is not true, the listener
     * will be called immediately with an updateTag of 'registerMutationListener' where all
     * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option
     * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).
     *
     * @param klass - The class of the node that you want to listen to mutations on.
     * @param listener - The logic you want to run when the node is mutated.
     * @param options - see {@link MutationListenerOptions}
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerMutationListener(klass, listener, options) {
      const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;
      const mutations = this._listeners.mutation;
      let klassSet = mutations.get(listener);
      if (klassSet === void 0) {
        klassSet = /* @__PURE__ */ new Set();
        mutations.set(listener, klassSet);
      }
      klassSet.add(klassToMutate);
      const skipInitialization = options && options.skipInitialization;
      if (!(skipInitialization === void 0 ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {
        this.initializeMutationListener(listener, klassToMutate);
      }
      return () => {
        klassSet.delete(klassToMutate);
        if (klassSet.size === 0) {
          mutations.delete(listener);
        }
      };
    }
    /** @internal */
    getRegisteredNode(klass) {
      const registeredNode = this._nodes.get(klass.getType());
      if (registeredNode === void 0) {
        {
          formatDevErrorMessage(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
        }
      }
      return registeredNode;
    }
    /** @internal */
    resolveRegisteredNodeAfterReplacements(registeredNode) {
      while (registeredNode.replaceWithKlass) {
        registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);
      }
      return registeredNode;
    }
    /** @internal */
    initializeMutationListener(listener, klass) {
      const prevEditorState = this._editorState;
      const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());
      if (!nodeMap) {
        return;
      }
      const nodeMutationMap = /* @__PURE__ */ new Map();
      for (const k2 of nodeMap.keys()) {
        nodeMutationMap.set(k2, "created");
      }
      if (nodeMutationMap.size > 0) {
        listener(nodeMutationMap, {
          dirtyLeaves: /* @__PURE__ */ new Set(),
          prevEditorState,
          updateTags: /* @__PURE__ */ new Set(["registerMutationListener"])
        });
      }
    }
    /** @internal */
    registerNodeTransformToKlass(klass, listener) {
      const registeredNode = this.getRegisteredNode(klass);
      registeredNode.transforms.add(listener);
      return registeredNode;
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * marked dirty during an update. The listener will continue to run as long as the node
     * is marked dirty. There are no guarantees around the order of transform execution!
     *
     * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
     * @param klass - The class of the node that you want to run transforms on.
     * @param listener - The logic you want to run when the node is updated.
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerNodeTransform(klass, listener) {
      const registeredNode = this.registerNodeTransformToKlass(klass, listener);
      const registeredNodes = [registeredNode];
      const replaceWithKlass = registeredNode.replaceWithKlass;
      if (replaceWithKlass != null) {
        const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);
        registeredNodes.push(registeredReplaceWithNode);
      }
      markNodesWithTypesAsDirty(this, registeredNodes.map((node) => node.klass.getType()));
      return () => {
        registeredNodes.forEach((node) => node.transforms.delete(listener));
      };
    }
    /**
     * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered the provided node type, false otherwise.
     */
    hasNode(node) {
      return this._nodes.has(node.getType());
    }
    /**
     * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered all of the provided node types, false otherwise.
     */
    hasNodes(nodes) {
      return nodes.every(this.hasNode.bind(this));
    }
    /**
     * Dispatches a command of the specified type with the specified payload.
     * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
     * for this type, passing them the provided payload. The command listeners
     * will be triggered in an implicit {@link LexicalEditor.update}, unless
     * this was invoked from inside an update in which case that update context
     * will be re-used (as if this was a dollar function itself).
     * @param type - the type of command listeners to trigger.
     * @param payload - the data to pass as an argument to the command listeners.
     */
    dispatchCommand(type, payload) {
      return dispatchCommand(this, type, payload);
    }
    /**
     * Gets a map of all decorators in the editor.
     * @returns A mapping of call decorator keys to their decorated content
     */
    getDecorators() {
      return this._decorators;
    }
    /**
     *
     * @returns the current root element of the editor. If you want to register
     * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
     * this reference may not be stable.
     */
    getRootElement() {
      return this._rootElement;
    }
    /**
     * Gets the key of the editor
     * @returns The editor key
     */
    getKey() {
      return this._key;
    }
    /**
     * Imperatively set the root contenteditable element that Lexical listens
     * for events on.
     */
    setRootElement(nextRootElement) {
      const prevRootElement = this._rootElement;
      if (nextRootElement !== prevRootElement) {
        const classNames = getCachedClassNameArray(this._config.theme, "root");
        const pendingEditorState = this._pendingEditorState || this._editorState;
        this._rootElement = nextRootElement;
        resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);
        if (prevRootElement !== null) {
          if (!this._config.disableEvents) {
            removeRootElementEvents(prevRootElement);
          }
          if (classNames != null) {
            prevRootElement.classList.remove(...classNames);
          }
        }
        if (nextRootElement !== null) {
          const windowObj = getDefaultView(nextRootElement);
          const style = nextRootElement.style;
          style.userSelect = "text";
          style.whiteSpace = "pre-wrap";
          style.wordBreak = "break-word";
          nextRootElement.setAttribute("data-lexical-editor", "true");
          this._window = windowObj;
          this._dirtyType = FULL_RECONCILE;
          initMutationObserver(this);
          this._updateTags.add(HISTORY_MERGE_TAG);
          $commitPendingUpdates(this);
          if (!this._config.disableEvents) {
            addRootElementEvents(nextRootElement, this);
          }
          if (classNames != null) {
            nextRootElement.classList.add(...classNames);
          }
          {
            const nextRootElementParent = nextRootElement.parentElement;
            if (nextRootElementParent != null && ["flex", "inline-flex"].includes(getComputedStyle(nextRootElementParent).display)) {
              console.warn(`When using "display: flex" or "display: inline-flex" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);
            }
          }
        } else {
          this._window = null;
          this._updateTags.add(HISTORY_MERGE_TAG);
          $commitPendingUpdates(this);
        }
        triggerListeners("root", this, false, nextRootElement, prevRootElement);
      }
    }
    /**
     * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
     * @returns the HTMLElement rendered by the LexicalNode associated with the key.
     * @param key - the key of the LexicalNode.
     */
    getElementByKey(key) {
      return this._keyToDOMMap.get(key) || null;
    }
    /**
     * Gets the active editor state.
     * @returns The editor state
     */
    getEditorState() {
      return this._editorState;
    }
    /**
     * Imperatively set the EditorState. Triggers reconciliation like an update.
     * @param editorState - the state to set the editor
     * @param options - options for the update.
     */
    setEditorState(editorState, options) {
      if (editorState.isEmpty()) {
        {
          formatDevErrorMessage(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);
        }
      }
      let writableEditorState = editorState;
      if (writableEditorState._readOnly) {
        writableEditorState = cloneEditorState(editorState);
        writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;
      }
      flushRootMutations(this);
      const pendingEditorState = this._pendingEditorState;
      const tags = this._updateTags;
      const tag = options !== void 0 ? options.tag : null;
      if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {
        if (tag != null) {
          tags.add(tag);
        }
        $commitPendingUpdates(this);
      }
      this._pendingEditorState = writableEditorState;
      this._dirtyType = FULL_RECONCILE;
      this._dirtyElements.set("root", false);
      this._compositionKey = null;
      if (tag != null) {
        tags.add(tag);
      }
      if (!this._updating) {
        $commitPendingUpdates(this);
      }
    }
    /**
     * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
     * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
     * deserialization from JSON stored in a database uses this method.
     * @param maybeStringifiedEditorState
     * @param updateFn
     * @returns
     */
    parseEditorState(maybeStringifiedEditorState, updateFn) {
      const serializedEditorState = typeof maybeStringifiedEditorState === "string" ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
      return parseEditorState(serializedEditorState, this, updateFn);
    }
    /**
     * Executes a read of the editor's state, with the
     * editor context available (useful for exporting and read-only DOM
     * operations). Much like update, but prevents any mutation of the
     * editor's state. Any pending updates will be flushed immediately before
     * the read.
     * @param callbackFn - A function that has access to read-only editor state.
     */
    read(callbackFn) {
      $commitPendingUpdates(this);
      return this.getEditorState().read(callbackFn, {
        editor: this
      });
    }
    /**
     * Executes an update to the editor state. The updateFn callback is the ONLY place
     * where Lexical editor state can be safely mutated.
     * @param updateFn - A function that has access to writable editor state.
     * @param options - A bag of options to control the behavior of the update.
     */
    update(updateFn, options) {
      updateEditor(this, updateFn, options);
    }
    /**
     * Focuses the editor by marking the existing selection as dirty, or by
     * creating a new selection at `defaultSelection` if one does not already
     * exist. If you want to force a specific selection, you should call
     * `root.selectStart()` or `root.selectEnd()` in an update.
     *
     * @param callbackFn - A function to run after the editor is focused.
     * @param options - A bag of options
     */
    focus(callbackFn, options = {}) {
      const rootElement = this._rootElement;
      if (rootElement !== null) {
        rootElement.setAttribute("autocapitalize", "off");
        updateEditorSync(this, () => {
          const selection = $getSelection();
          const root = $getRoot();
          if (selection !== null) {
            if (!selection.dirty) {
              $setSelection(selection.clone());
            }
          } else if (root.getChildrenSize() !== 0) {
            if (options.defaultSelection === "rootStart") {
              root.selectStart();
            } else {
              root.selectEnd();
            }
          }
          $addUpdateTag(FOCUS_TAG);
          $onUpdate(() => {
            rootElement.removeAttribute("autocapitalize");
            if (callbackFn) {
              callbackFn();
            }
          });
        });
        if (this._pendingEditorState === null) {
          rootElement.removeAttribute("autocapitalize");
        }
      }
    }
    /**
     * Removes focus from the editor.
     */
    blur() {
      const rootElement = this._rootElement;
      if (rootElement !== null) {
        rootElement.blur();
      }
      const domSelection = getDOMSelection(this._window);
      if (domSelection !== null) {
        domSelection.removeAllRanges();
      }
    }
    /**
     * Returns true if the editor is editable, false otherwise.
     * @returns True if the editor is editable, false otherwise.
     */
    isEditable() {
      return this._editable;
    }
    /**
     * Sets the editable property of the editor. When false, the
     * editor will not listen for user events on the underling contenteditable.
     * @param editable - the value to set the editable mode to.
     */
    setEditable(editable) {
      if (this._editable !== editable) {
        this._editable = editable;
        triggerListeners("editable", this, true, editable);
      }
    }
    /**
     * Returns a JSON-serializable javascript object NOT a JSON string.
     * You still must call JSON.stringify (or something else) to turn the
     * state into a string you can transfer over the wire and store in a database.
     *
     * See {@link LexicalNode.exportJSON}
     *
     * @returns A JSON-serializable javascript object
     */
    toJSON() {
      return {
        editorState: this._editorState.toJSON()
      };
    }
  };
  LexicalEditor.version = "0.38.2+dev.esm";
  var pendingNodeToClone = null;
  function setPendingNodeToClone(pendingNode) {
    pendingNodeToClone = pendingNode;
  }
  function getPendingNodeToClone() {
    const node = pendingNodeToClone;
    pendingNodeToClone = null;
    return node;
  }
  var keyCounter = 1;
  function resetRandomKey() {
    keyCounter = 1;
  }
  function generateRandomKey() {
    return "" + keyCounter++;
  }
  function getRegisteredNodeOrThrow(editor, nodeType) {
    const registeredNode = getRegisteredNode(editor, nodeType);
    if (registeredNode === void 0) {
      {
        formatDevErrorMessage(`registeredNode: Type ${nodeType} not found`);
      }
    }
    return registeredNode;
  }
  function getRegisteredNode(editor, nodeType) {
    return editor._nodes.get(nodeType);
  }
  var scheduleMicroTask = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => {
    Promise.resolve().then(fn);
  };
  function $isSelectionCapturedInDecorator(node) {
    return $isDecoratorNode($getNearestNodeFromDOMNode(node));
  }
  function isSelectionCapturedInDecoratorInput(anchorDOM) {
    const activeElement = document.activeElement;
    if (!isHTMLElement(activeElement)) {
      return false;
    }
    const nodeName = activeElement.nodeName;
    return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === "INPUT" || nodeName === "TEXTAREA" || activeElement.contentEditable === "true" && getEditorPropertyFromDOMNode(activeElement) == null);
  }
  function isSelectionWithinEditor(editor, anchorDOM, focusDOM) {
    const rootElement = editor.getRootElement();
    try {
      return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor
      anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;
    } catch (_error) {
      return false;
    }
  }
  function isLexicalEditor(editor) {
    return editor instanceof LexicalEditor;
  }
  function getNearestEditorFromDOMNode(node) {
    let currentNode = node;
    while (currentNode != null) {
      const editor = getEditorPropertyFromDOMNode(currentNode);
      if (isLexicalEditor(editor)) {
        return editor;
      }
      currentNode = getParentElement(currentNode);
    }
    return null;
  }
  function getEditorPropertyFromDOMNode(node) {
    return node ? node.__lexicalEditor : null;
  }
  function getTextDirection(text2) {
    if (RTL_REGEX.test(text2)) {
      return "rtl";
    }
    if (LTR_REGEX.test(text2)) {
      return "ltr";
    }
    return null;
  }
  function $isTokenOrTab(node) {
    return $isTabNode(node) || node.isToken();
  }
  function $isTokenOrSegmented(node) {
    return $isTokenOrTab(node) || node.isSegmented();
  }
  function isDOMTextNode(node) {
    return isDOMNode(node) && node.nodeType === DOM_TEXT_TYPE;
  }
  function isDOMDocumentNode(node) {
    return isDOMNode(node) && node.nodeType === DOM_DOCUMENT_TYPE;
  }
  function getDOMTextNode(element) {
    let node = element;
    while (node != null) {
      if (isDOMTextNode(node)) {
        return node;
      }
      node = node.firstChild;
    }
    return null;
  }
  function toggleTextFormatType(format, type, alignWithFormat) {
    const activeFormat = TEXT_TYPE_TO_FORMAT[type];
    if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {
      return format;
    }
    let newFormat = format ^ activeFormat;
    if (type === "subscript") {
      newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;
    } else if (type === "superscript") {
      newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;
    } else if (type === "lowercase") {
      newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;
      newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;
    } else if (type === "uppercase") {
      newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;
      newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;
    } else if (type === "capitalize") {
      newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;
      newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;
    }
    return newFormat;
  }
  function $isLeafNode(node) {
    return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);
  }
  function $setNodeKey(node, existingKey) {
    const pendingNode = getPendingNodeToClone();
    existingKey = existingKey || pendingNode && pendingNode.__key;
    if (existingKey != null) {
      {
        errorOnNodeKeyConstructorMismatch(node, existingKey, pendingNode);
      }
      node.__key = existingKey;
      return;
    }
    errorOnReadOnly();
    errorOnInfiniteTransforms();
    const editor = getActiveEditor();
    const editorState = getActiveEditorState();
    const key = generateRandomKey();
    editorState._nodeMap.set(key, node);
    if ($isElementNode(node)) {
      editor._dirtyElements.set(key, true);
    } else {
      editor._dirtyLeaves.add(key);
    }
    editor._cloneNotNeeded.add(key);
    editor._dirtyType = HAS_DIRTY_NODES;
    node.__key = key;
  }
  function errorOnNodeKeyConstructorMismatch(node, existingKey, pendingNode) {
    const editorState = internalGetActiveEditorState();
    if (!editorState) {
      return;
    }
    const existingNode = editorState._nodeMap.get(existingKey);
    if (pendingNode) {
      if (!(existingKey === pendingNode.__key)) {
        formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} (type ${node.getType()}) has an incorrect clone implementation, got ${String(existingKey)} for nodeKey when expecting ${pendingNode.__key}`);
      }
    }
    if (existingNode && existingNode.constructor !== node.constructor) {
      if (node.constructor.name !== existingNode.constructor.name) {
        {
          formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);
        }
      } else {
        {
          formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);
        }
      }
    }
  }
  function internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {
    let nextParentKey = parentKey;
    while (nextParentKey !== null) {
      if (dirtyElements.has(nextParentKey)) {
        return;
      }
      const node = nodeMap.get(nextParentKey);
      if (node === void 0) {
        break;
      }
      dirtyElements.set(nextParentKey, false);
      nextParentKey = node.__parent;
    }
  }
  function removeFromParent(node) {
    const oldParent = node.getParent();
    if (oldParent !== null) {
      const writableNode = node.getWritable();
      const writableParent = oldParent.getWritable();
      const prevSibling = node.getPreviousSibling();
      const nextSibling = node.getNextSibling();
      const nextSiblingKey = nextSibling !== null ? nextSibling.__key : null;
      const prevSiblingKey = prevSibling !== null ? prevSibling.__key : null;
      const writablePrevSibling = prevSibling !== null ? prevSibling.getWritable() : null;
      const writableNextSibling = nextSibling !== null ? nextSibling.getWritable() : null;
      if (prevSibling === null) {
        writableParent.__first = nextSiblingKey;
      }
      if (nextSibling === null) {
        writableParent.__last = prevSiblingKey;
      }
      if (writablePrevSibling !== null) {
        writablePrevSibling.__next = nextSiblingKey;
      }
      if (writableNextSibling !== null) {
        writableNextSibling.__prev = prevSiblingKey;
      }
      writableNode.__prev = null;
      writableNode.__next = null;
      writableNode.__parent = null;
      writableParent.__size--;
    }
  }
  function internalMarkNodeAsDirty(node) {
    errorOnInfiniteTransforms();
    if (!!$isEphemeral(node)) {
      formatDevErrorMessage(`internalMarkNodeAsDirty: Ephemeral nodes must not be marked as dirty (key ${node.__key} type ${node.__type})`);
    }
    const latest = node.getLatest();
    const parent = latest.__parent;
    const editorState = getActiveEditorState();
    const editor = getActiveEditor();
    const nodeMap = editorState._nodeMap;
    const dirtyElements = editor._dirtyElements;
    if (parent !== null) {
      internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);
    }
    const key = latest.__key;
    editor._dirtyType = HAS_DIRTY_NODES;
    if ($isElementNode(node)) {
      dirtyElements.set(key, true);
    } else {
      editor._dirtyLeaves.add(key);
    }
  }
  function internalMarkSiblingsAsDirty(node) {
    const previousNode = node.getPreviousSibling();
    const nextNode = node.getNextSibling();
    if (previousNode !== null) {
      internalMarkNodeAsDirty(previousNode);
    }
    if (nextNode !== null) {
      internalMarkNodeAsDirty(nextNode);
    }
  }
  function $setCompositionKey(compositionKey) {
    errorOnReadOnly();
    const editor = getActiveEditor();
    const previousCompositionKey = editor._compositionKey;
    if (compositionKey !== previousCompositionKey) {
      editor._compositionKey = compositionKey;
      if (previousCompositionKey !== null) {
        const node = $getNodeByKey(previousCompositionKey);
        if (node !== null) {
          node.getWritable();
        }
      }
      if (compositionKey !== null) {
        const node = $getNodeByKey(compositionKey);
        if (node !== null) {
          node.getWritable();
        }
      }
    }
  }
  function $getCompositionKey() {
    if (isCurrentlyReadOnlyMode()) {
      return null;
    }
    const editor = getActiveEditor();
    return editor._compositionKey;
  }
  function $getNodeByKey(key, _editorState) {
    const editorState = _editorState || getActiveEditorState();
    const node = editorState._nodeMap.get(key);
    if (node === void 0) {
      return null;
    }
    return node;
  }
  function $getNodeFromDOMNode(dom, editorState) {
    const editor = getActiveEditor();
    const key = getNodeKeyFromDOMNode(dom, editor);
    if (key !== void 0) {
      return $getNodeByKey(key, editorState);
    }
    return null;
  }
  function setNodeKeyOnDOMNode(dom, editor, key) {
    const prop = `__lexicalKey_${editor._key}`;
    dom[prop] = key;
  }
  function getNodeKeyFromDOMNode(dom, editor) {
    const prop = `__lexicalKey_${editor._key}`;
    return dom[prop];
  }
  function $getNearestNodeFromDOMNode(startingDOM, editorState) {
    let dom = startingDOM;
    while (dom != null) {
      const node = $getNodeFromDOMNode(dom, editorState);
      if (node !== null) {
        return node;
      }
      dom = getParentElement(dom);
    }
    return null;
  }
  function cloneDecorators(editor) {
    const currentDecorators = editor._decorators;
    const pendingDecorators = Object.assign({}, currentDecorators);
    editor._pendingDecorators = pendingDecorators;
    return pendingDecorators;
  }
  function getEditorStateTextContent(editorState) {
    return editorState.read(() => $getRoot().getTextContent());
  }
  function markNodesWithTypesAsDirty(editor, types) {
    const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());
    const dirtyNodeMaps = [];
    for (const type of types) {
      const nodeMap = cachedMap.get(type);
      if (nodeMap) {
        dirtyNodeMaps.push(nodeMap);
      }
    }
    if (dirtyNodeMaps.length === 0) {
      return;
    }
    editor.update(() => {
      for (const nodeMap of dirtyNodeMaps) {
        for (const nodeKey of nodeMap.keys()) {
          const latest = $getNodeByKey(nodeKey);
          if (latest) {
            latest.markDirty();
          }
        }
      }
    }, editor._pendingEditorState === null ? {
      tag: HISTORY_MERGE_TAG
    } : void 0);
  }
  function $getRoot() {
    return internalGetRoot(getActiveEditorState());
  }
  function internalGetRoot(editorState) {
    return editorState._nodeMap.get("root");
  }
  function $setSelection(selection) {
    errorOnReadOnly();
    const editorState = getActiveEditorState();
    if (selection !== null) {
      {
        if (Object.isFrozen(selection)) {
          {
            formatDevErrorMessage(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);
          }
        }
      }
      selection.dirty = true;
      selection.setCachedNodes(null);
    }
    editorState._selection = selection;
  }
  function $flushMutations() {
    errorOnReadOnly();
    const editor = getActiveEditor();
    flushRootMutations(editor);
  }
  function $getNodeFromDOM(dom) {
    const editor = getActiveEditor();
    const nodeKey = getNodeKeyFromDOMTree(dom, editor);
    if (nodeKey === null) {
      const rootElement = editor.getRootElement();
      if (dom === rootElement) {
        return $getNodeByKey("root");
      }
      return null;
    }
    return $getNodeByKey(nodeKey);
  }
  function getNodeKeyFromDOMTree(dom, editor) {
    let node = dom;
    while (node != null) {
      const key = getNodeKeyFromDOMNode(node, editor);
      if (key !== void 0) {
        return key;
      }
      node = getParentElement(node);
    }
    return null;
  }
  function doesContainSurrogatePair(str) {
    return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(str);
  }
  function getEditorsToPropagate(editor) {
    const editorsToPropagate = [];
    let currentEditor = editor;
    while (currentEditor !== null) {
      editorsToPropagate.push(currentEditor);
      currentEditor = currentEditor._parentEditor;
    }
    return editorsToPropagate;
  }
  function createUID() {
    return Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 5);
  }
  function getAnchorTextFromDOM(anchorNode) {
    return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;
  }
  function $updateSelectedTextFromDOM(isCompositionEnd, editor, data2) {
    const domSelection = getDOMSelection(getWindow(editor));
    if (domSelection === null) {
      return;
    }
    const anchorNode = domSelection.anchorNode;
    let {
      anchorOffset,
      focusOffset
    } = domSelection;
    if (anchorNode !== null) {
      let textContent = getAnchorTextFromDOM(anchorNode);
      const node = $getNearestNodeFromDOMNode(anchorNode);
      if (textContent !== null && $isTextNode(node)) {
        if (textContent === COMPOSITION_SUFFIX && data2) {
          const offset = data2.length;
          textContent = data2;
          anchorOffset = offset;
          focusOffset = offset;
        }
        if (textContent !== null) {
          $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);
        }
      }
    }
  }
  function $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {
    let node = textNode;
    if (node.isAttached() && (compositionEnd || !node.isDirty())) {
      const isComposing = node.isComposing();
      let normalizedTextContent = textContent;
      if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {
        normalizedTextContent = textContent.slice(0, -1);
      }
      const prevTextContent = node.getTextContent();
      if (compositionEnd || normalizedTextContent !== prevTextContent) {
        if (normalizedTextContent === "") {
          $setCompositionKey(null);
          if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {
            const editor = getActiveEditor();
            setTimeout(() => {
              editor.update(() => {
                if (node.isAttached()) {
                  node.remove();
                }
              });
            }, 20);
          } else {
            node.remove();
          }
          return;
        }
        const parent = node.getParent();
        const prevSelection = $getPreviousSelection();
        const prevTextContentSize = node.getTextContentSize();
        const compositionKey = $getCompositionKey();
        const nodeKey = node.getKey();
        if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need
        // to clear this input from occurring as that action wasn't permitted.
        $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {
          node.markDirty();
          return;
        }
        const selection = $getSelection();
        if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {
          $setTextContentWithSelection(node, normalizedTextContent, selection);
          return;
        }
        selection.setTextNodeRange(node, anchorOffset, node, focusOffset);
        if (node.isSegmented()) {
          const originalTextContent = node.getTextContent();
          const replacement = $createTextNode(originalTextContent);
          node.replace(replacement);
          node = replacement;
        }
        $setTextContentWithSelection(node, normalizedTextContent, selection);
      }
    }
  }
  function $setTextContentWithSelection(node, textContent, selection) {
    node.setTextContent(textContent);
    if ($isRangeSelection(selection)) {
      const key = node.getKey();
      for (const k2 of ["anchor", "focus"]) {
        const pt = selection[k2];
        if (pt.type === "text" && pt.key === key) {
          pt.offset = $getTextNodeOffset(node, pt.offset, "clamp");
        }
      }
    }
  }
  function $previousSiblingDoesNotAcceptText(node) {
    const previousSibling = node.getPreviousSibling();
    return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();
  }
  function $shouldInsertTextAfterOrBeforeTextNode(selection, node) {
    if (node.isSegmented()) {
      return true;
    }
    if (!selection.isCollapsed()) {
      return false;
    }
    const offset = selection.anchor.offset;
    const parent = node.getParentOrThrow();
    const isToken = $isTokenOrTab(node);
    if (offset === 0) {
      return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);
    } else if (offset === node.getTextContentSize()) {
      return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;
    } else {
      return false;
    }
  }
  function matchModifier(event, mask, prop) {
    const expected = mask[prop] || false;
    return expected === "any" || expected === event[prop];
  }
  function isModifierMatch(event, mask) {
    return matchModifier(event, mask, "altKey") && matchModifier(event, mask, "ctrlKey") && matchModifier(event, mask, "shiftKey") && matchModifier(event, mask, "metaKey");
  }
  function isExactShortcutMatch(event, expectedKey, mask) {
    return isModifierMatch(event, mask) && event.key.toLowerCase() === expectedKey.toLowerCase();
  }
  var CONTROL_OR_META = {
    ctrlKey: !IS_APPLE,
    metaKey: IS_APPLE
  };
  var CONTROL_OR_ALT = {
    altKey: IS_APPLE,
    ctrlKey: !IS_APPLE
  };
  function isTab(event) {
    return isExactShortcutMatch(event, "Tab", {
      shiftKey: "any"
    });
  }
  function isBold(event) {
    return isExactShortcutMatch(event, "b", CONTROL_OR_META);
  }
  function isItalic(event) {
    return isExactShortcutMatch(event, "i", CONTROL_OR_META);
  }
  function isUnderline(event) {
    return isExactShortcutMatch(event, "u", CONTROL_OR_META);
  }
  function isParagraph(event) {
    return isExactShortcutMatch(event, "Enter", {
      altKey: "any",
      ctrlKey: "any",
      metaKey: "any"
    });
  }
  function isLineBreak(event) {
    return isExactShortcutMatch(event, "Enter", {
      altKey: "any",
      ctrlKey: "any",
      metaKey: "any",
      shiftKey: true
    });
  }
  function isOpenLineBreak(event) {
    return IS_APPLE && isExactShortcutMatch(event, "o", {
      ctrlKey: true
    });
  }
  function isDeleteWordBackward(event) {
    return isExactShortcutMatch(event, "Backspace", CONTROL_OR_ALT);
  }
  function isDeleteWordForward(event) {
    return isExactShortcutMatch(event, "Delete", CONTROL_OR_ALT);
  }
  function isDeleteLineBackward(event) {
    return IS_APPLE && isExactShortcutMatch(event, "Backspace", {
      metaKey: true
    });
  }
  function isDeleteLineForward(event) {
    return IS_APPLE && (isExactShortcutMatch(event, "Delete", {
      metaKey: true
    }) || isExactShortcutMatch(event, "k", {
      ctrlKey: true
    }));
  }
  function isDeleteBackward(event) {
    return isExactShortcutMatch(event, "Backspace", {
      shiftKey: "any"
    }) || IS_APPLE && isExactShortcutMatch(event, "h", {
      ctrlKey: true
    });
  }
  function isDeleteForward(event) {
    return isExactShortcutMatch(event, "Delete", {}) || IS_APPLE && isExactShortcutMatch(event, "d", {
      ctrlKey: true
    });
  }
  function isUndo(event) {
    return isExactShortcutMatch(event, "z", CONTROL_OR_META);
  }
  function isRedo(event) {
    if (IS_APPLE) {
      return isExactShortcutMatch(event, "z", {
        metaKey: true,
        shiftKey: true
      });
    }
    return isExactShortcutMatch(event, "y", {
      ctrlKey: true
    }) || isExactShortcutMatch(event, "z", {
      ctrlKey: true,
      shiftKey: true
    });
  }
  function isCopy(event) {
    return isExactShortcutMatch(event, "c", CONTROL_OR_META);
  }
  function isCut(event) {
    return isExactShortcutMatch(event, "x", CONTROL_OR_META);
  }
  function isMoveBackward(event) {
    return isExactShortcutMatch(event, "ArrowLeft", {
      shiftKey: "any"
    });
  }
  function isMoveToStart(event) {
    return isExactShortcutMatch(event, "ArrowLeft", CONTROL_OR_META);
  }
  function isMoveForward(event) {
    return isExactShortcutMatch(event, "ArrowRight", {
      shiftKey: "any"
    });
  }
  function isMoveToEnd(event) {
    return isExactShortcutMatch(event, "ArrowRight", CONTROL_OR_META);
  }
  function isMoveUp(event) {
    return isExactShortcutMatch(event, "ArrowUp", {
      altKey: "any",
      shiftKey: "any"
    });
  }
  function isMoveDown(event) {
    return isExactShortcutMatch(event, "ArrowDown", {
      altKey: "any",
      shiftKey: "any"
    });
  }
  function isModifier(event) {
    return event.ctrlKey || event.shiftKey || event.altKey || event.metaKey;
  }
  function isSpace(event) {
    return event.key === " ";
  }
  function isBackspace(event) {
    return event.key === "Backspace";
  }
  function isEscape(event) {
    return event.key === "Escape";
  }
  function isDelete(event) {
    return event.key === "Delete";
  }
  function isSelectAll(event) {
    return isExactShortcutMatch(event, "a", CONTROL_OR_META);
  }
  function $selectAll(selection) {
    const root = $getRoot();
    if ($isRangeSelection(selection)) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const topParent = anchorNode.getTopLevelElementOrThrow();
      const rootNode = topParent.getParentOrThrow();
      anchor.set(rootNode.getKey(), 0, "element");
      focus.set(rootNode.getKey(), rootNode.getChildrenSize(), "element");
      $normalizeSelection(selection);
      return selection;
    } else {
      const newSelection = root.select(0, root.getChildrenSize());
      $setSelection($normalizeSelection(newSelection));
      return newSelection;
    }
  }
  function getCachedClassNameArray(classNamesTheme, classNameThemeType) {
    if (classNamesTheme.__lexicalClassNameCache === void 0) {
      classNamesTheme.__lexicalClassNameCache = {};
    }
    const classNamesCache = classNamesTheme.__lexicalClassNameCache;
    const cachedClassNames = classNamesCache[classNameThemeType];
    if (cachedClassNames !== void 0) {
      return cachedClassNames;
    }
    const classNames = classNamesTheme[classNameThemeType];
    if (typeof classNames === "string") {
      const classNamesArr = normalizeClassNames(classNames);
      classNamesCache[classNameThemeType] = classNamesArr;
      return classNamesArr;
    }
    return classNames;
  }
  function setMutatedNode(mutatedNodes2, registeredNodes, mutationListeners, node, mutation) {
    if (mutationListeners.size === 0) {
      return;
    }
    const nodeType = node.__type;
    const nodeKey = node.__key;
    const registeredNode = registeredNodes.get(nodeType);
    if (registeredNode === void 0) {
      {
        formatDevErrorMessage(`Type ${nodeType} not in registeredNodes`);
      }
    }
    const klass = registeredNode.klass;
    let mutatedNodesByType = mutatedNodes2.get(klass);
    if (mutatedNodesByType === void 0) {
      mutatedNodesByType = /* @__PURE__ */ new Map();
      mutatedNodes2.set(klass, mutatedNodesByType);
    }
    const prevMutation = mutatedNodesByType.get(nodeKey);
    const isMove = prevMutation === "destroyed" && mutation === "created";
    if (prevMutation === void 0 || isMove) {
      mutatedNodesByType.set(nodeKey, isMove ? "updated" : mutation);
    }
  }
  function $nodesOfType(klass) {
    const klassType = klass.getType();
    const editorState = getActiveEditorState();
    if (editorState._readOnly) {
      const nodes2 = getCachedTypeToNodeMap(editorState).get(klassType);
      return nodes2 ? Array.from(nodes2.values()) : [];
    }
    const nodes = editorState._nodeMap;
    const nodesOfType = [];
    for (const [, node] of nodes) {
      if (node instanceof klass && node.__type === klassType && node.isAttached()) {
        nodesOfType.push(node);
      }
    }
    return nodesOfType;
  }
  function resolveElement(element, isBackward, focusOffset) {
    const parent = element.getParent();
    let offset = focusOffset;
    let block = element;
    if (parent !== null) {
      if (isBackward && focusOffset === 0) {
        offset = block.getIndexWithinParent();
        block = parent;
      } else if (!isBackward && focusOffset === block.getChildrenSize()) {
        offset = block.getIndexWithinParent() + 1;
        block = parent;
      }
    }
    return block.getChildAtIndex(isBackward ? offset - 1 : offset);
  }
  function $getAdjacentNode(focus, isBackward) {
    const focusOffset = focus.offset;
    if (focus.type === "element") {
      const block = focus.getNode();
      return resolveElement(block, isBackward, focusOffset);
    } else {
      const focusNode = focus.getNode();
      if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {
        const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();
        if (possibleNode === null) {
          return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));
        }
        return possibleNode;
      }
    }
    return null;
  }
  function isFirefoxClipboardEvents(editor) {
    const event = getWindow(editor).event;
    const inputType = event && event.inputType;
    return inputType === "insertFromPaste" || inputType === "insertFromPasteAsQuotation";
  }
  function dispatchCommand(editor, command, payload) {
    return triggerCommandListeners(editor, command, payload);
  }
  function $textContentRequiresDoubleLinebreakAtEnd(node) {
    return !$isRootNode(node) && !node.isLastChild() && !node.isInline();
  }
  function getElementByKeyOrThrow(editor, key) {
    const element = editor._keyToDOMMap.get(key);
    if (element === void 0) {
      {
        formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key}`);
      }
    }
    return element;
  }
  function getParentElement(node) {
    const parentElement = node.assignedSlot || node.parentElement;
    return isDocumentFragment(parentElement) ? parentElement.host : parentElement;
  }
  function getDOMOwnerDocument(target) {
    return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;
  }
  function scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {
    const doc = getDOMOwnerDocument(rootElement);
    const defaultView = getDefaultView(doc);
    if (doc === null || defaultView === null) {
      return;
    }
    let {
      top: currentTop,
      bottom: currentBottom
    } = selectionRect;
    let targetTop = 0;
    let targetBottom = 0;
    let element = rootElement;
    while (element !== null) {
      const isBodyElement = element === doc.body;
      if (isBodyElement) {
        targetTop = 0;
        targetBottom = getWindow(editor).innerHeight;
      } else {
        const targetRect = element.getBoundingClientRect();
        targetTop = targetRect.top;
        targetBottom = targetRect.bottom;
      }
      let diff = 0;
      if (currentTop < targetTop) {
        diff = -(targetTop - currentTop);
      } else if (currentBottom > targetBottom) {
        diff = currentBottom - targetBottom;
      }
      if (diff !== 0) {
        if (isBodyElement) {
          defaultView.scrollBy(0, diff);
        } else {
          const scrollTop = element.scrollTop;
          element.scrollTop += diff;
          const yOffset = element.scrollTop - scrollTop;
          currentTop -= yOffset;
          currentBottom -= yOffset;
        }
      }
      if (isBodyElement) {
        break;
      }
      element = getParentElement(element);
    }
  }
  function $hasUpdateTag(tag) {
    const editor = getActiveEditor();
    return editor._updateTags.has(tag);
  }
  function $addUpdateTag(tag) {
    errorOnReadOnly();
    const editor = getActiveEditor();
    editor._updateTags.add(tag);
  }
  function $onUpdate(updateFn) {
    errorOnReadOnly();
    const editor = getActiveEditor();
    editor._deferred.push(updateFn);
  }
  function $maybeMoveChildrenSelectionToParent(parentNode) {
    const selection = $getSelection();
    if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {
      return selection;
    }
    const {
      anchor,
      focus
    } = selection;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    if ($hasAncestor(anchorNode, parentNode)) {
      anchor.set(parentNode.__key, 0, "element");
    }
    if ($hasAncestor(focusNode, parentNode)) {
      focus.set(parentNode.__key, 0, "element");
    }
    return selection;
  }
  function $hasAncestor(child, targetNode) {
    let parent = child.getParent();
    while (parent !== null) {
      if (parent.is(targetNode)) {
        return true;
      }
      parent = parent.getParent();
    }
    return false;
  }
  function getDefaultView(domElem) {
    const ownerDoc = getDOMOwnerDocument(domElem);
    return ownerDoc ? ownerDoc.defaultView : null;
  }
  function getWindow(editor) {
    const windowObj = editor._window;
    if (windowObj === null) {
      {
        formatDevErrorMessage(`window object not found`);
      }
    }
    return windowObj;
  }
  function $isInlineElementOrDecoratorNode(node) {
    return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();
  }
  function $getNearestRootOrShadowRoot(node) {
    let parent = node.getParentOrThrow();
    while (parent !== null) {
      if ($isRootOrShadowRoot(parent)) {
        return parent;
      }
      parent = parent.getParentOrThrow();
    }
    return parent;
  }
  function $isRootOrShadowRoot(node) {
    return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();
  }
  function $copyNode(node) {
    const copy = node.constructor.clone(node);
    $setNodeKey(copy, null);
    copy.afterCloneFrom(node);
    return copy;
  }
  function $applyNodeReplacement(node) {
    const editor = getActiveEditor();
    const nodeType = node.getType();
    const registeredNode = getRegisteredNode(editor, nodeType);
    if (!(registeredNode !== void 0)) {
      formatDevErrorMessage(`$applyNodeReplacement node ${node.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.`);
    }
    const {
      replace,
      replaceWithKlass
    } = registeredNode;
    if (replace !== null) {
      const replacementNode = replace(node);
      const replacementNodeKlass = replacementNode.constructor;
      if (replaceWithKlass !== null) {
        if (!(replacementNode instanceof replaceWithKlass)) {
          formatDevErrorMessage(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node.constructor.name} with type ${nodeType}`);
        }
      } else {
        if (!(replacementNode instanceof node.constructor && replacementNodeKlass !== node.constructor)) {
          formatDevErrorMessage(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node.constructor.name} with type ${nodeType}.`);
        }
      }
      if (!(replacementNode.__key !== node.__key)) {
        formatDevErrorMessage(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);
      }
      return replacementNode;
    }
    return node;
  }
  function errorOnInsertTextNodeOnRoot(node, insertNode) {
    const parentNode = node.getParent();
    if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {
      {
        formatDevErrorMessage(`Only element or decorator nodes can be inserted in to the root node`);
      }
    }
  }
  function $getNodeByKeyOrThrow(key) {
    const node = $getNodeByKey(key);
    if (node === null) {
      {
        formatDevErrorMessage(`Expected node with key ${key} to exist but it's not in the nodeMap.`);
      }
    }
    return node;
  }
  function createBlockCursorElement(editorConfig) {
    const theme2 = editorConfig.theme;
    const element = document.createElement("div");
    element.contentEditable = "false";
    element.setAttribute("data-lexical-cursor", "true");
    let blockCursorTheme = theme2.blockCursor;
    if (blockCursorTheme !== void 0) {
      if (typeof blockCursorTheme === "string") {
        const classNamesArr = normalizeClassNames(blockCursorTheme);
        blockCursorTheme = theme2.blockCursor = classNamesArr;
      }
      if (blockCursorTheme !== void 0) {
        element.classList.add(...blockCursorTheme);
      }
    }
    return element;
  }
  function needsBlockCursor(node) {
    return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();
  }
  function removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {
    rootElement.style.removeProperty("caret-color");
    editor._blockCursorElement = null;
    const parentElement = blockCursorElement.parentElement;
    if (parentElement !== null) {
      parentElement.removeChild(blockCursorElement);
    }
  }
  function updateDOMBlockCursorElement(editor, rootElement, nextSelection) {
    let blockCursorElement = editor._blockCursorElement;
    if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === "element" && rootElement.contains(document.activeElement)) {
      const anchor = nextSelection.anchor;
      const elementNode = anchor.getNode();
      const offset = anchor.offset;
      const elementNodeSize = elementNode.getChildrenSize();
      let isBlockCursor = false;
      let insertBeforeElement = null;
      if (offset === elementNodeSize) {
        const child = elementNode.getChildAtIndex(offset - 1);
        if (needsBlockCursor(child)) {
          isBlockCursor = true;
        }
      } else {
        const child = elementNode.getChildAtIndex(offset);
        if (child !== null && needsBlockCursor(child)) {
          const sibling = child.getPreviousSibling();
          if (sibling === null || needsBlockCursor(sibling)) {
            isBlockCursor = true;
            insertBeforeElement = editor.getElementByKey(child.__key);
          }
        }
      }
      if (isBlockCursor) {
        const elementDOM = editor.getElementByKey(elementNode.__key);
        if (blockCursorElement === null) {
          editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);
        }
        rootElement.style.caretColor = "transparent";
        if (insertBeforeElement === null) {
          elementDOM.appendChild(blockCursorElement);
        } else {
          elementDOM.insertBefore(blockCursorElement, insertBeforeElement);
        }
        return;
      }
    }
    if (blockCursorElement !== null) {
      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
    }
  }
  function getDOMSelection(targetWindow) {
    return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();
  }
  function getDOMSelectionFromTarget(eventTarget) {
    const defaultView = getDefaultView(eventTarget);
    return defaultView ? defaultView.getSelection() : null;
  }
  function $splitNode(node, offset) {
    let startNode = node.getChildAtIndex(offset);
    if (startNode == null) {
      startNode = node;
    }
    if (!!$isRootOrShadowRoot(node)) {
      formatDevErrorMessage(`Can not call $splitNode() on root element`);
    }
    const recurse = (currentNode) => {
      const parent = currentNode.getParentOrThrow();
      const isParentRoot = $isRootOrShadowRoot(parent);
      const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);
      if (isParentRoot) {
        if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {
          formatDevErrorMessage(`Children of a root must be ElementNode`);
        }
        currentNode.insertAfter(nodeToMove);
        return [currentNode, nodeToMove, nodeToMove];
      } else {
        const [leftTree2, rightTree2, newParent] = recurse(parent);
        const nextSiblings = currentNode.getNextSiblings();
        newParent.append(nodeToMove, ...nextSiblings);
        return [leftTree2, rightTree2, nodeToMove];
      }
    };
    const [leftTree, rightTree] = recurse(startNode);
    return [leftTree, rightTree];
  }
  function isHTMLAnchorElement(x2) {
    return isHTMLElement(x2) && x2.tagName === "A";
  }
  function isHTMLElement(x2) {
    return isDOMNode(x2) && x2.nodeType === DOM_ELEMENT_TYPE;
  }
  function isDOMNode(x2) {
    return typeof x2 === "object" && x2 !== null && "nodeType" in x2 && typeof x2.nodeType === "number";
  }
  function isDocumentFragment(x2) {
    return isDOMNode(x2) && x2.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;
  }
  function isInlineDomNode(node) {
    const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|mark|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
    return node.nodeName.match(inlineNodes) !== null;
  }
  function isBlockDomNode(node) {
    const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
    return node.nodeName.match(blockNodes) !== null;
  }
  function INTERNAL_$isBlock(node) {
    if ($isDecoratorNode(node) && !node.isInline()) {
      return true;
    }
    if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {
      return false;
    }
    const firstChild = node.getFirstChild();
    const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();
    return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;
  }
  function $getEditor() {
    return getActiveEditor();
  }
  var cachedNodeMaps = /* @__PURE__ */ new WeakMap();
  var EMPTY_TYPE_TO_NODE_MAP = /* @__PURE__ */ new Map();
  function getCachedTypeToNodeMap(editorState) {
    if (!editorState._readOnly && editorState.isEmpty()) {
      return EMPTY_TYPE_TO_NODE_MAP;
    }
    if (!editorState._readOnly) {
      formatDevErrorMessage(`getCachedTypeToNodeMap called with a writable EditorState`);
    }
    let typeToNodeMap = cachedNodeMaps.get(editorState);
    if (!typeToNodeMap) {
      typeToNodeMap = computeTypeToNodeMap(editorState);
      cachedNodeMaps.set(editorState, typeToNodeMap);
    }
    return typeToNodeMap;
  }
  function computeTypeToNodeMap(editorState) {
    const typeToNodeMap = /* @__PURE__ */ new Map();
    for (const [nodeKey, node] of editorState._nodeMap) {
      const nodeType = node.__type;
      let nodeMap = typeToNodeMap.get(nodeType);
      if (!nodeMap) {
        nodeMap = /* @__PURE__ */ new Map();
        typeToNodeMap.set(nodeType, nodeMap);
      }
      nodeMap.set(nodeKey, node);
    }
    return typeToNodeMap;
  }
  function $cloneWithProperties(latestNode) {
    const constructor = latestNode.constructor;
    const mutableNode = constructor.clone(latestNode);
    mutableNode.afterCloneFrom(latestNode);
    {
      if (!(mutableNode.__key === latestNode.__key)) {
        formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);
      }
      if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {
        formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrode afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);
      }
    }
    return mutableNode;
  }
  function $cloneWithPropertiesEphemeral(latestNode) {
    return $markEphemeral($cloneWithProperties(latestNode));
  }
  function setNodeIndentFromDOM(elementDom, elementNode) {
    const indentSize = parseInt(elementDom.style.paddingInlineStart, 10) || 0;
    const indent = Math.round(indentSize / 40);
    elementNode.setIndent(indent);
  }
  function setDOMUnmanaged(elementDom) {
    const el = elementDom;
    el.__lexicalUnmanaged = true;
  }
  function isDOMUnmanaged(elementDom) {
    const el = elementDom;
    return el.__lexicalUnmanaged === true;
  }
  function hasOwn2(o2, k2) {
    return Object.prototype.hasOwnProperty.call(o2, k2);
  }
  function hasOwnStaticMethod(klass, k2) {
    return hasOwn2(klass, k2) && klass[k2] !== LexicalNode[k2];
  }
  function hasOwnExportDOM(klass) {
    return hasOwn2(klass.prototype, "exportDOM");
  }
  function isAbstractNodeClass(klass) {
    if (!(klass === LexicalNode || klass.prototype instanceof LexicalNode)) {
      let ownNodeType = "<unknown>";
      let version2 = "<unknown>";
      try {
        ownNodeType = klass.getType();
      } catch (_err) {
      }
      try {
        if (LexicalEditor.version) {
          version2 = JSON.parse(LexicalEditor.version);
        }
      } catch (_err) {
      }
      {
        formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) does not subclass LexicalNode from the lexical package used by this editor (version ${version2}). All lexical and @lexical/* packages used by an editor must have identical versions. If you suspect the version does match, then the problem may be caused by multiple copies of the same lexical module (e.g. both esm and cjs, or included directly in multiple entrypoints).`);
      }
    }
    return klass === DecoratorNode || klass === ElementNode || klass === LexicalNode;
  }
  function getStaticNodeConfig(klass) {
    const nodeConfigRecord = PROTOTYPE_CONFIG_METHOD in klass.prototype ? klass.prototype[PROTOTYPE_CONFIG_METHOD]() : void 0;
    const isAbstract = isAbstractNodeClass(klass);
    const nodeType = !isAbstract && hasOwnStaticMethod(klass, "getType") ? klass.getType() : void 0;
    let ownNodeConfig;
    let ownNodeType = nodeType;
    if (nodeConfigRecord) {
      if (nodeType) {
        ownNodeConfig = nodeConfigRecord[nodeType];
      } else {
        for (const [k2, v3] of Object.entries(nodeConfigRecord)) {
          ownNodeType = k2;
          ownNodeConfig = v3;
        }
      }
    }
    if (!isAbstract && ownNodeType) {
      if (!hasOwnStaticMethod(klass, "getType")) {
        klass.getType = () => ownNodeType;
      }
      if (!hasOwnStaticMethod(klass, "clone")) {
        if (TextNode.length === 0) {
          if (!(klass.length === 0)) {
            formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) must implement a static clone method since its constructor has ${String(klass.length)} required arguments (expecting 0). Use an explicit default in the first argument of your constructor(prop: T=X, nodeKey?: NodeKey).`);
          }
        }
        klass.clone = (prevNode) => {
          setPendingNodeToClone(prevNode);
          return new klass();
        };
      }
      if (!hasOwnStaticMethod(klass, "importJSON")) {
        if (TextNode.length === 0) {
          if (!(klass.length === 0)) {
            formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) must implement a static importJSON method since its constructor has ${String(klass.length)} required arguments (expecting 0). Use an explicit default in the first argument of your constructor(prop: T=X, nodeKey?: NodeKey).`);
          }
        }
        klass.importJSON = ownNodeConfig && ownNodeConfig.$importJSON || ((serializedNode) => new klass().updateFromJSON(serializedNode));
      }
      if (!hasOwnStaticMethod(klass, "importDOM") && ownNodeConfig) {
        const {
          importDOM
        } = ownNodeConfig;
        if (importDOM) {
          klass.importDOM = () => importDOM;
        }
      }
    }
    return {
      ownNodeConfig,
      ownNodeType
    };
  }
  function $create(klass) {
    const editor = $getEditor();
    errorOnReadOnly();
    const registeredNode = editor.resolveRegisteredNodeAfterReplacements(editor.getRegisteredNode(klass));
    return new registeredNode.klass();
  }
  var $findMatchingParent = (startingNode, findFn) => {
    let curr = startingNode;
    while (curr != null && !$isRootNode(curr)) {
      if (findFn(curr)) {
        return curr;
      }
      curr = curr.getParent();
    }
    return null;
  };
  var FLIP_DIRECTION = {
    next: "previous",
    previous: "next"
  };
  var AbstractCaret = class {
    origin;
    constructor(origin) {
      this.origin = origin;
    }
    [Symbol.iterator]() {
      return makeStepwiseIterator({
        hasNext: $isSiblingCaret,
        initial: this.getAdjacentCaret(),
        map: (caret) => caret,
        step: (caret) => caret.getAdjacentCaret()
      });
    }
    getAdjacentCaret() {
      return $getSiblingCaret(this.getNodeAtCaret(), this.direction);
    }
    getSiblingCaret() {
      return $getSiblingCaret(this.origin, this.direction);
    }
    remove() {
      const node = this.getNodeAtCaret();
      if (node) {
        node.remove();
      }
      return this;
    }
    replaceOrInsert(node, includeChildren) {
      const target = this.getNodeAtCaret();
      if (node.is(this.origin) || node.is(target)) ;
      else if (target === null) {
        this.insert(node);
      } else {
        target.replace(node, includeChildren);
      }
      return this;
    }
    splice(deleteCount, nodes, nodesDirection = "next") {
      const nodeIter = nodesDirection === this.direction ? nodes : Array.from(nodes).reverse();
      let caret = this;
      const parent = this.getParentAtCaret();
      const nodesToRemove = /* @__PURE__ */ new Map();
      for (let removeCaret = caret.getAdjacentCaret(); removeCaret !== null && nodesToRemove.size < deleteCount; removeCaret = removeCaret.getAdjacentCaret()) {
        const writableNode = removeCaret.origin.getWritable();
        nodesToRemove.set(writableNode.getKey(), writableNode);
      }
      for (const node of nodeIter) {
        if (nodesToRemove.size > 0) {
          const target = caret.getNodeAtCaret();
          if (target) {
            nodesToRemove.delete(target.getKey());
            nodesToRemove.delete(node.getKey());
            if (target.is(node) || caret.origin.is(node)) ;
            else {
              const nodeParent = node.getParent();
              if (nodeParent && nodeParent.is(parent)) {
                node.remove();
              }
              target.replace(node);
            }
          } else {
            if (!(target !== null)) {
              formatDevErrorMessage(`NodeCaret.splice: Underflow of expected nodesToRemove during splice (keys: ${Array.from(nodesToRemove).join(" ")})`);
            }
          }
        } else {
          caret.insert(node);
        }
        caret = $getSiblingCaret(node, this.direction);
      }
      for (const node of nodesToRemove.values()) {
        node.remove();
      }
      return this;
    }
  };
  var AbstractChildCaret = class _AbstractChildCaret extends AbstractCaret {
    type = "child";
    getLatest() {
      const origin = this.origin.getLatest();
      return origin === this.origin ? this : $getChildCaret(origin, this.direction);
    }
    /**
     * Get the SiblingCaret from this origin in the same direction.
     *
     * @param mode 'root' to return null at the root, 'shadowRoot' to return null at the root or any shadow root
     * @returns A SiblingCaret with this origin, or null if origin is a root according to mode.
     */
    getParentCaret(mode = "root") {
      return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);
    }
    getFlipped() {
      const dir = flipDirection(this.direction);
      return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin, dir);
    }
    getParentAtCaret() {
      return this.origin;
    }
    getChildCaret() {
      return this;
    }
    isSameNodeCaret(other) {
      return other instanceof _AbstractChildCaret && this.direction === other.direction && this.origin.is(other.origin);
    }
    isSamePointCaret(other) {
      return this.isSameNodeCaret(other);
    }
  };
  var ChildCaretFirst = class extends AbstractChildCaret {
    direction = "next";
    getNodeAtCaret() {
      return this.origin.getFirstChild();
    }
    insert(node) {
      this.origin.splice(0, 0, [node]);
      return this;
    }
  };
  var ChildCaretLast = class extends AbstractChildCaret {
    direction = "previous";
    getNodeAtCaret() {
      return this.origin.getLastChild();
    }
    insert(node) {
      this.origin.splice(this.origin.getChildrenSize(), 0, [node]);
      return this;
    }
  };
  var MODE_PREDICATE = {
    root: $isRootNode,
    shadowRoot: $isRootOrShadowRoot
  };
  function flipDirection(direction) {
    return FLIP_DIRECTION[direction];
  }
  function $filterByMode(node, mode = "root") {
    return MODE_PREDICATE[mode](node) ? null : node;
  }
  var AbstractSiblingCaret = class _AbstractSiblingCaret extends AbstractCaret {
    type = "sibling";
    getLatest() {
      const origin = this.origin.getLatest();
      return origin === this.origin ? this : $getSiblingCaret(origin, this.direction);
    }
    getSiblingCaret() {
      return this;
    }
    getParentAtCaret() {
      return this.origin.getParent();
    }
    getChildCaret() {
      return $isElementNode(this.origin) ? $getChildCaret(this.origin, this.direction) : null;
    }
    getParentCaret(mode = "root") {
      return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);
    }
    getFlipped() {
      const dir = flipDirection(this.direction);
      return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin.getParentOrThrow(), dir);
    }
    isSamePointCaret(other) {
      return other instanceof _AbstractSiblingCaret && this.direction === other.direction && this.origin.is(other.origin);
    }
    isSameNodeCaret(other) {
      return (other instanceof _AbstractSiblingCaret || other instanceof AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);
    }
  };
  var AbstractTextPointCaret = class _AbstractTextPointCaret extends AbstractCaret {
    type = "text";
    offset;
    constructor(origin, offset) {
      super(origin);
      this.offset = offset;
    }
    getLatest() {
      const origin = this.origin.getLatest();
      return origin === this.origin ? this : $getTextPointCaret(origin, this.direction, this.offset);
    }
    getParentAtCaret() {
      return this.origin.getParent();
    }
    getChildCaret() {
      return null;
    }
    getParentCaret(mode = "root") {
      return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);
    }
    getFlipped() {
      return $getTextPointCaret(this.origin, flipDirection(this.direction), this.offset);
    }
    isSamePointCaret(other) {
      return other instanceof _AbstractTextPointCaret && this.direction === other.direction && this.origin.is(other.origin) && this.offset === other.offset;
    }
    isSameNodeCaret(other) {
      return (other instanceof AbstractSiblingCaret || other instanceof _AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);
    }
    getSiblingCaret() {
      return $getSiblingCaret(this.origin, this.direction);
    }
  };
  function $isTextPointCaret(caret) {
    return caret instanceof AbstractTextPointCaret;
  }
  function $isNodeCaret(caret) {
    return caret instanceof AbstractCaret;
  }
  function $isSiblingCaret(caret) {
    return caret instanceof AbstractSiblingCaret;
  }
  function $isChildCaret(caret) {
    return caret instanceof AbstractChildCaret;
  }
  var SiblingCaretNext = class extends AbstractSiblingCaret {
    direction = "next";
    getNodeAtCaret() {
      return this.origin.getNextSibling();
    }
    insert(node) {
      this.origin.insertAfter(node);
      return this;
    }
  };
  var SiblingCaretPrevious = class extends AbstractSiblingCaret {
    direction = "previous";
    getNodeAtCaret() {
      return this.origin.getPreviousSibling();
    }
    insert(node) {
      this.origin.insertBefore(node);
      return this;
    }
  };
  var TextPointCaretNext = class extends AbstractTextPointCaret {
    direction = "next";
    getNodeAtCaret() {
      return this.origin.getNextSibling();
    }
    insert(node) {
      this.origin.insertAfter(node);
      return this;
    }
  };
  var TextPointCaretPrevious = class extends AbstractTextPointCaret {
    direction = "previous";
    getNodeAtCaret() {
      return this.origin.getPreviousSibling();
    }
    insert(node) {
      this.origin.insertBefore(node);
      return this;
    }
  };
  var TEXT_CTOR = {
    next: TextPointCaretNext,
    previous: TextPointCaretPrevious
  };
  var SIBLING_CTOR = {
    next: SiblingCaretNext,
    previous: SiblingCaretPrevious
  };
  var CHILD_CTOR = {
    next: ChildCaretFirst,
    previous: ChildCaretLast
  };
  function $getSiblingCaret(origin, direction) {
    return origin ? new SIBLING_CTOR[direction](origin) : null;
  }
  function $getTextPointCaret(origin, direction, offset) {
    return origin ? new TEXT_CTOR[direction](origin, $getTextNodeOffset(origin, offset)) : null;
  }
  function $getTextNodeOffset(origin, offset, mode = "error") {
    const size2 = origin.getTextContentSize();
    let numericOffset = offset === "next" ? size2 : offset === "previous" ? 0 : offset;
    if (numericOffset < 0 || numericOffset > size2) {
      if (!(mode === "clamp")) {
        formatDevErrorMessage(`$getTextNodeOffset: invalid offset ${String(offset)} for size ${String(size2)} at key ${origin.getKey()}`);
      }
      numericOffset = numericOffset < 0 ? 0 : size2;
    }
    return numericOffset;
  }
  function $getTextPointCaretSlice(caret, distance) {
    return new TextPointCaretSliceImpl(caret, distance);
  }
  function $getChildCaret(origin, direction) {
    return $isElementNode(origin) ? new CHILD_CTOR[direction](origin) : null;
  }
  function $getChildCaretOrSelf(caret) {
    return caret && caret.getChildCaret() || caret;
  }
  function $getAdjacentChildCaret(caret) {
    return caret && $getChildCaretOrSelf(caret.getAdjacentCaret());
  }
  var CaretRangeImpl = class _CaretRangeImpl {
    type = "node-caret-range";
    direction;
    anchor;
    focus;
    constructor(anchor, focus, direction) {
      this.anchor = anchor;
      this.focus = focus;
      this.direction = direction;
    }
    getLatest() {
      const anchor = this.anchor.getLatest();
      const focus = this.focus.getLatest();
      return anchor === this.anchor && focus === this.focus ? this : new _CaretRangeImpl(anchor, focus, this.direction);
    }
    isCollapsed() {
      return this.anchor.isSamePointCaret(this.focus);
    }
    getTextSlices() {
      const getSlice = (k2) => {
        const caret = this[k2].getLatest();
        return $isTextPointCaret(caret) ? $getSliceFromTextPointCaret(caret, k2) : null;
      };
      const anchorSlice = getSlice("anchor");
      const focusSlice = getSlice("focus");
      if (anchorSlice && focusSlice) {
        const {
          caret: anchorCaret
        } = anchorSlice;
        const {
          caret: focusCaret
        } = focusSlice;
        if (anchorCaret.isSameNodeCaret(focusCaret)) {
          return [$getTextPointCaretSlice(anchorCaret, focusCaret.offset - anchorCaret.offset), null];
        }
      }
      return [anchorSlice, focusSlice];
    }
    iterNodeCarets(rootMode = "root") {
      const anchor = $isTextPointCaret(this.anchor) ? this.anchor.getSiblingCaret() : this.anchor.getLatest();
      const focus = this.focus.getLatest();
      const isTextFocus = $isTextPointCaret(focus);
      const step = (state) => state.isSameNodeCaret(focus) ? null : $getAdjacentChildCaret(state) || state.getParentCaret(rootMode);
      return makeStepwiseIterator({
        hasNext: (state) => state !== null && !(isTextFocus && focus.isSameNodeCaret(state)),
        initial: anchor.isSameNodeCaret(focus) ? null : step(anchor),
        map: (state) => state,
        step
      });
    }
    [Symbol.iterator]() {
      return this.iterNodeCarets("root");
    }
  };
  var TextPointCaretSliceImpl = class {
    type = "slice";
    caret;
    distance;
    constructor(caret, distance) {
      this.caret = caret;
      this.distance = distance;
    }
    getSliceIndices() {
      const {
        distance,
        caret: {
          offset
        }
      } = this;
      const offsetB = offset + distance;
      return offsetB < offset ? [offsetB, offset] : [offset, offsetB];
    }
    getTextContent() {
      const [startIndex, endIndex] = this.getSliceIndices();
      return this.caret.origin.getTextContent().slice(startIndex, endIndex);
    }
    getTextContentSize() {
      return Math.abs(this.distance);
    }
    removeTextSlice() {
      const {
        caret: {
          origin,
          direction
        }
      } = this;
      const [indexStart, indexEnd] = this.getSliceIndices();
      const text2 = origin.getTextContent();
      return $getTextPointCaret(origin.setTextContent(text2.slice(0, indexStart) + text2.slice(indexEnd)), direction, indexStart);
    }
  };
  function $getSliceFromTextPointCaret(caret, anchorOrFocus) {
    const {
      direction,
      origin
    } = caret;
    const offsetB = $getTextNodeOffset(origin, anchorOrFocus === "focus" ? flipDirection(direction) : direction);
    return $getTextPointCaretSlice(caret, offsetB - caret.offset);
  }
  function $isTextPointCaretSlice(caretOrSlice) {
    return caretOrSlice instanceof TextPointCaretSliceImpl;
  }
  function $extendCaretToRange(anchor) {
    return $getCaretRange(anchor, $getSiblingCaret($getRoot(), anchor.direction));
  }
  function $getCollapsedCaretRange(anchor) {
    return $getCaretRange(anchor, anchor);
  }
  function $getCaretRange(anchor, focus) {
    if (!(anchor.direction === focus.direction)) {
      formatDevErrorMessage(`$getCaretRange: anchor and focus must be in the same direction`);
    }
    return new CaretRangeImpl(anchor, focus, anchor.direction);
  }
  function makeStepwiseIterator(config) {
    const {
      initial,
      hasNext,
      step,
      map: map3
    } = config;
    let state = initial;
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        if (!hasNext(state)) {
          return {
            done: true,
            value: void 0
          };
        }
        const rval = {
          done: false,
          value: map3(state)
        };
        state = step(state);
        return rval;
      }
    };
  }
  function compareNumber(a2, b3) {
    return Math.sign(a2 - b3);
  }
  function $comparePointCaretNext(a2, b3) {
    const compare = $getCommonAncestor(a2.origin, b3.origin);
    if (!(compare !== null)) {
      formatDevErrorMessage(`$comparePointCaretNext: a (key ${a2.origin.getKey()}) and b (key ${b3.origin.getKey()}) do not have a common ancestor`);
    }
    switch (compare.type) {
      case "same": {
        const aIsText = a2.type === "text";
        const bIsText = b3.type === "text";
        return aIsText && bIsText ? compareNumber(a2.offset, b3.offset) : a2.type === b3.type ? 0 : aIsText ? -1 : bIsText ? 1 : a2.type === "child" ? -1 : 1;
      }
      case "ancestor": {
        return a2.type === "child" ? -1 : 1;
      }
      case "descendant": {
        return b3.type === "child" ? 1 : -1;
      }
      case "branch": {
        return $getCommonAncestorResultBranchOrder(compare);
      }
    }
  }
  function $getCommonAncestorResultBranchOrder(compare) {
    const {
      a: a2,
      b: b3
    } = compare;
    const aKey = a2.__key;
    const bKey = b3.__key;
    let na = a2;
    let nb = b3;
    for (; na && nb; na = na.getNextSibling(), nb = nb.getNextSibling()) {
      if (na.__key === bKey) {
        return -1;
      } else if (nb.__key === aKey) {
        return 1;
      }
    }
    return na === null ? 1 : -1;
  }
  function $isSameNode(reference, other) {
    return other.is(reference);
  }
  function $initialElementTuple(node) {
    return $isElementNode(node) ? [node.getLatest(), null] : [node.getParent(), node.getLatest()];
  }
  function $getCommonAncestor(a2, b3) {
    if (a2.is(b3)) {
      return {
        commonAncestor: a2,
        type: "same"
      };
    }
    const aMap = /* @__PURE__ */ new Map();
    for (let [parent, child] = $initialElementTuple(a2); parent; child = parent, parent = parent.getParent()) {
      aMap.set(parent, child);
    }
    for (let [parent, child] = $initialElementTuple(b3); parent; child = parent, parent = parent.getParent()) {
      const aChild = aMap.get(parent);
      if (aChild === void 0) ;
      else if (aChild === null) {
        if (!$isSameNode(a2, parent)) {
          formatDevErrorMessage(`$originComparison: ancestor logic error`);
        }
        return {
          commonAncestor: parent,
          type: "ancestor"
        };
      } else if (child === null) {
        if (!$isSameNode(b3, parent)) {
          formatDevErrorMessage(`$originComparison: descendant logic error`);
        }
        return {
          commonAncestor: parent,
          type: "descendant"
        };
      } else {
        if (!(($isElementNode(aChild) || $isSameNode(a2, aChild)) && ($isElementNode(child) || $isSameNode(b3, child)) && parent.is(aChild.getParent()) && parent.is(child.getParent()))) {
          formatDevErrorMessage(`$originComparison: branch logic error`);
        }
        return {
          a: aChild,
          b: child,
          commonAncestor: parent,
          type: "branch"
        };
      }
    }
    return null;
  }
  function $caretFromPoint(point, direction) {
    const {
      type,
      key,
      offset
    } = point;
    const node = $getNodeByKeyOrThrow(point.key);
    if (type === "text") {
      if (!$isTextNode(node)) {
        formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key} that does not inherit from TextNode encountered for text point`);
      }
      return $getTextPointCaret(node, direction, offset);
    }
    if (!$isElementNode(node)) {
      formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key} that does not inherit from ElementNode encountered for element point`);
    }
    return $getChildCaretAtIndex(node, point.offset, direction);
  }
  function $setPointFromCaret(point, caret) {
    const {
      origin,
      direction
    } = caret;
    const isNext = direction === "next";
    if ($isTextPointCaret(caret)) {
      point.set(origin.getKey(), caret.offset, "text");
    } else if ($isSiblingCaret(caret)) {
      if ($isTextNode(origin)) {
        point.set(origin.getKey(), $getTextNodeOffset(origin, direction), "text");
      } else {
        point.set(origin.getParentOrThrow().getKey(), origin.getIndexWithinParent() + (isNext ? 1 : 0), "element");
      }
    } else {
      if (!($isChildCaret(caret) && $isElementNode(origin))) {
        formatDevErrorMessage(`$setPointFromCaret: exhaustiveness check`);
      }
      point.set(origin.getKey(), isNext ? 0 : origin.getChildrenSize(), "element");
    }
  }
  function $setSelectionFromCaretRange(caretRange) {
    const currentSelection = $getSelection();
    const selection = $isRangeSelection(currentSelection) ? currentSelection : $createRangeSelection();
    $updateRangeSelectionFromCaretRange(selection, caretRange);
    $setSelection(selection);
    return selection;
  }
  function $updateRangeSelectionFromCaretRange(selection, caretRange) {
    $setPointFromCaret(selection.anchor, caretRange.anchor);
    $setPointFromCaret(selection.focus, caretRange.focus);
  }
  function $caretRangeFromSelection(selection) {
    const {
      anchor,
      focus
    } = selection;
    const anchorCaret = $caretFromPoint(anchor, "next");
    const focusCaret = $caretFromPoint(focus, "next");
    const direction = $comparePointCaretNext(anchorCaret, focusCaret) <= 0 ? "next" : "previous";
    return $getCaretRange($getCaretInDirection(anchorCaret, direction), $getCaretInDirection(focusCaret, direction));
  }
  function $rewindSiblingCaret(caret) {
    const {
      direction,
      origin
    } = caret;
    const rewindOrigin = $getSiblingCaret(origin, flipDirection(direction)).getNodeAtCaret();
    return rewindOrigin ? $getSiblingCaret(rewindOrigin, direction) : $getChildCaret(origin.getParentOrThrow(), direction);
  }
  function $getAnchorCandidates(anchor, rootMode = "root") {
    const carets = [anchor];
    for (let parent = $isChildCaret(anchor) ? anchor.getParentCaret(rootMode) : anchor.getSiblingCaret(); parent !== null; parent = parent.getParentCaret(rootMode)) {
      carets.push($rewindSiblingCaret(parent));
    }
    return carets;
  }
  function $isCaretAttached(caret) {
    return !!caret && caret.origin.isAttached();
  }
  function $removeTextFromCaretRange(initialRange, sliceMode = "removeEmptySlices") {
    if (initialRange.isCollapsed()) {
      return initialRange;
    }
    const rootMode = "root";
    const nextDirection = "next";
    let sliceState = sliceMode;
    const range2 = $getCaretRangeInDirection(initialRange, nextDirection);
    const anchorCandidates = $getAnchorCandidates(range2.anchor, rootMode);
    const focusCandidates = $getAnchorCandidates(range2.focus.getFlipped(), rootMode);
    const seenStart = /* @__PURE__ */ new Set();
    const removedNodes = [];
    for (const caret of range2.iterNodeCarets(rootMode)) {
      if ($isChildCaret(caret)) {
        seenStart.add(caret.origin.getKey());
      } else if ($isSiblingCaret(caret)) {
        const {
          origin
        } = caret;
        if (!$isElementNode(origin) || seenStart.has(origin.getKey())) {
          removedNodes.push(origin);
        }
      }
    }
    for (const node of removedNodes) {
      node.remove();
    }
    for (const slice of range2.getTextSlices()) {
      if (!slice) {
        continue;
      }
      const {
        origin
      } = slice.caret;
      const contentSize = origin.getTextContentSize();
      const caretBefore = $rewindSiblingCaret($getSiblingCaret(origin, nextDirection));
      const mode = origin.getMode();
      if (Math.abs(slice.distance) === contentSize && sliceState === "removeEmptySlices" || mode === "token" && slice.distance !== 0) {
        caretBefore.remove();
      } else if (slice.distance !== 0) {
        sliceState = "removeEmptySlices";
        let nextCaret = slice.removeTextSlice();
        const sliceOrigin = slice.caret.origin;
        if (mode === "segmented") {
          const src = nextCaret.origin;
          const plainTextNode = $createTextNode(src.getTextContent()).setStyle(src.getStyle()).setFormat(src.getFormat());
          caretBefore.replaceOrInsert(plainTextNode);
          nextCaret = $getTextPointCaret(plainTextNode, nextDirection, nextCaret.offset);
        }
        if (sliceOrigin.is(anchorCandidates[0].origin)) {
          anchorCandidates[0] = nextCaret;
        }
        if (sliceOrigin.is(focusCandidates[0].origin)) {
          focusCandidates[0] = nextCaret.getFlipped();
        }
      }
    }
    let anchorCandidate;
    let focusCandidate;
    for (const candidate of anchorCandidates) {
      if ($isCaretAttached(candidate)) {
        anchorCandidate = $normalizeCaret(candidate);
        break;
      }
    }
    for (const candidate of focusCandidates) {
      if ($isCaretAttached(candidate)) {
        focusCandidate = $normalizeCaret(candidate);
        break;
      }
    }
    const mergeTargets = $getBlockMergeTargets(anchorCandidate, focusCandidate, seenStart);
    if (mergeTargets) {
      const [anchorBlock, focusBlock] = mergeTargets;
      $getChildCaret(anchorBlock, "previous").splice(0, focusBlock.getChildren());
      focusBlock.remove();
    }
    const bestCandidate = [anchorCandidate, focusCandidate, ...anchorCandidates, ...focusCandidates].find($isCaretAttached);
    if (bestCandidate) {
      const anchor = $getCaretInDirection($normalizeCaret(bestCandidate), initialRange.direction);
      return $getCollapsedCaretRange(anchor);
    }
    {
      formatDevErrorMessage(`$removeTextFromCaretRange: selection was lost, could not find a new anchor given candidates with keys: ${JSON.stringify(anchorCandidates.map((n2) => n2.origin.__key))}`);
    }
  }
  function $getBlockMergeTargets(anchor, focus, seenStart) {
    if (!anchor || !focus) {
      return null;
    }
    const anchorParent = anchor.getParentAtCaret();
    const focusParent = focus.getParentAtCaret();
    if (!anchorParent || !focusParent) {
      return null;
    }
    const anchorElements = anchorParent.getParents().reverse();
    anchorElements.push(anchorParent);
    const focusElements = focusParent.getParents().reverse();
    focusElements.push(focusParent);
    const maxLen = Math.min(anchorElements.length, focusElements.length);
    let commonAncestorCount;
    for (commonAncestorCount = 0; commonAncestorCount < maxLen && anchorElements[commonAncestorCount] === focusElements[commonAncestorCount]; commonAncestorCount++) {
    }
    const $getBlock = (arr, predicate) => {
      let block;
      for (let i2 = commonAncestorCount; i2 < arr.length; i2++) {
        const ancestor = arr[i2];
        if ($isRootOrShadowRoot(ancestor)) {
          return;
        } else if (!block && predicate(ancestor)) {
          block = ancestor;
        }
      }
      return block;
    };
    const anchorBlock = $getBlock(anchorElements, INTERNAL_$isBlock);
    const focusBlock = anchorBlock && $getBlock(focusElements, (node) => seenStart.has(node.getKey()) && INTERNAL_$isBlock(node));
    return anchorBlock && focusBlock ? [anchorBlock, focusBlock] : null;
  }
  function $getDeepestChildOrSelf(initialCaret) {
    let caret = initialCaret;
    while ($isChildCaret(caret)) {
      const adjacent = $getAdjacentChildCaret(caret);
      if (!$isChildCaret(adjacent)) {
        break;
      }
      caret = adjacent;
    }
    return caret;
  }
  function $normalizeCaret(initialCaret) {
    const caret = $getDeepestChildOrSelf(initialCaret.getLatest());
    const {
      direction
    } = caret;
    if ($isTextNode(caret.origin)) {
      return $isTextPointCaret(caret) ? caret : $getTextPointCaret(caret.origin, direction, direction);
    }
    const adj = caret.getAdjacentCaret();
    return $isSiblingCaret(adj) && $isTextNode(adj.origin) ? $getTextPointCaret(adj.origin, direction, flipDirection(direction)) : caret;
  }
  function $isExtendableTextPointCaret(caret) {
    return $isTextPointCaret(caret) && caret.offset !== $getTextNodeOffset(caret.origin, caret.direction);
  }
  function $getCaretInDirection(caret, direction) {
    return caret.direction === direction ? caret : caret.getFlipped();
  }
  function $getCaretRangeInDirection(range2, direction) {
    if (range2.direction === direction) {
      return range2;
    }
    return $getCaretRange(
      // focus and anchor get flipped here
      $getCaretInDirection(range2.focus, direction),
      $getCaretInDirection(range2.anchor, direction)
    );
  }
  function $getChildCaretAtIndex(parent, index2, direction) {
    let caret = $getChildCaret(parent, "next");
    for (let i2 = 0; i2 < index2; i2++) {
      const nextCaret = caret.getAdjacentCaret();
      if (nextCaret === null) {
        break;
      }
      caret = nextCaret;
    }
    return $getCaretInDirection(caret, direction);
  }
  function $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = "root") {
    let depthDiff = 0;
    let caret = startCaret;
    let nextCaret = $getAdjacentChildCaret(caret);
    while (nextCaret === null) {
      depthDiff--;
      nextCaret = caret.getParentCaret(rootMode);
      if (!nextCaret) {
        return null;
      }
      caret = nextCaret;
      nextCaret = $getAdjacentChildCaret(caret);
    }
    return nextCaret && [nextCaret, depthDiff];
  }
  function $getAdjacentNodes(initialCaret) {
    const siblings = [];
    for (let caret = initialCaret.getAdjacentCaret(); caret; caret = caret.getAdjacentCaret()) {
      siblings.push(caret.origin);
    }
    return siblings;
  }
  function $splitTextPointCaret(textPointCaret) {
    const {
      origin,
      offset,
      direction
    } = textPointCaret;
    if (offset === $getTextNodeOffset(origin, direction)) {
      return textPointCaret.getSiblingCaret();
    } else if (offset === $getTextNodeOffset(origin, flipDirection(direction))) {
      return $rewindSiblingCaret(textPointCaret.getSiblingCaret());
    }
    const [textNode] = origin.splitText(offset);
    if (!$isTextNode(textNode)) {
      formatDevErrorMessage(`$splitTextPointCaret: splitText must return at least one TextNode`);
    }
    return $getCaretInDirection($getSiblingCaret(textNode, "next"), direction);
  }
  function $alwaysSplit(_node, _edge) {
    return true;
  }
  function $splitAtPointCaretNext(pointCaret, {
    $copyElementNode = $copyNode,
    $splitTextPointCaretNext = $splitTextPointCaret,
    rootMode = "shadowRoot",
    $shouldSplit = $alwaysSplit
  } = {}) {
    if ($isTextPointCaret(pointCaret)) {
      return $splitTextPointCaretNext(pointCaret);
    }
    const parentCaret = pointCaret.getParentCaret(rootMode);
    if (parentCaret) {
      const {
        origin
      } = parentCaret;
      if ($isChildCaret(pointCaret) && !(origin.canBeEmpty() && $shouldSplit(origin, "first"))) {
        return $rewindSiblingCaret(parentCaret);
      }
      const siblings = $getAdjacentNodes(pointCaret);
      if (siblings.length > 0 || origin.canBeEmpty() && $shouldSplit(origin, "last")) {
        parentCaret.insert($copyElementNode(origin).splice(0, 0, siblings));
      }
    }
    return parentCaret;
  }
  // @__NO_SIDE_EFFECTS__
  function defineExtension(extension) {
    return extension;
  }
  // @__NO_SIDE_EFFECTS__
  function configExtension(...args) {
    return args;
  }
  // @__NO_SIDE_EFFECTS__
  function declarePeerDependency(name, config) {
    return [name, config];
  }
  // @__NO_SIDE_EFFECTS__
  function safeCast(value) {
    return value;
  }
  function shallowMergeConfig(config, overrides2) {
    if (!overrides2 || config === overrides2) {
      return config;
    }
    for (const k2 in overrides2) {
      if (config[k2] !== overrides2[k2]) {
        return {
          ...config,
          ...overrides2
        };
      }
    }
    return config;
  }

  // node_modules/lexical/Lexical.mjs
  var mod = true ? Lexical_dev_exports : Lexical_prod_exports;
  var $addUpdateTag2 = mod.$addUpdateTag;
  var $applyNodeReplacement2 = mod.$applyNodeReplacement;
  var $caretFromPoint2 = mod.$caretFromPoint;
  var $caretRangeFromSelection2 = mod.$caretRangeFromSelection;
  var $cloneWithProperties2 = mod.$cloneWithProperties;
  var $cloneWithPropertiesEphemeral2 = mod.$cloneWithPropertiesEphemeral;
  var $comparePointCaretNext2 = mod.$comparePointCaretNext;
  var $copyNode2 = mod.$copyNode;
  var $create2 = mod.$create;
  var $createLineBreakNode2 = mod.$createLineBreakNode;
  var $createNodeSelection2 = mod.$createNodeSelection;
  var $createParagraphNode2 = mod.$createParagraphNode;
  var $createPoint2 = mod.$createPoint;
  var $createRangeSelection2 = mod.$createRangeSelection;
  var $createRangeSelectionFromDom2 = mod.$createRangeSelectionFromDom;
  var $createTabNode2 = mod.$createTabNode;
  var $createTextNode2 = mod.$createTextNode;
  var $extendCaretToRange2 = mod.$extendCaretToRange;
  var $findMatchingParent2 = mod.$findMatchingParent;
  var $getAdjacentChildCaret2 = mod.$getAdjacentChildCaret;
  var $getAdjacentNode2 = mod.$getAdjacentNode;
  var $getAdjacentSiblingOrParentSiblingCaret2 = mod.$getAdjacentSiblingOrParentSiblingCaret;
  var $getCaretInDirection2 = mod.$getCaretInDirection;
  var $getCaretRange2 = mod.$getCaretRange;
  var $getCaretRangeInDirection2 = mod.$getCaretRangeInDirection;
  var $getCharacterOffsets2 = mod.$getCharacterOffsets;
  var $getChildCaret2 = mod.$getChildCaret;
  var $getChildCaretAtIndex2 = mod.$getChildCaretAtIndex;
  var $getChildCaretOrSelf2 = mod.$getChildCaretOrSelf;
  var $getCollapsedCaretRange2 = mod.$getCollapsedCaretRange;
  var $getCommonAncestor2 = mod.$getCommonAncestor;
  var $getCommonAncestorResultBranchOrder2 = mod.$getCommonAncestorResultBranchOrder;
  var $getEditor2 = mod.$getEditor;
  var $getNearestNodeFromDOMNode2 = mod.$getNearestNodeFromDOMNode;
  var $getNearestRootOrShadowRoot2 = mod.$getNearestRootOrShadowRoot;
  var $getNodeByKey2 = mod.$getNodeByKey;
  var $getNodeByKeyOrThrow2 = mod.$getNodeByKeyOrThrow;
  var $getNodeFromDOMNode2 = mod.$getNodeFromDOMNode;
  var $getPreviousSelection2 = mod.$getPreviousSelection;
  var $getRoot2 = mod.$getRoot;
  var $getSelection2 = mod.$getSelection;
  var $getSiblingCaret2 = mod.$getSiblingCaret;
  var $getState2 = mod.$getState;
  var $getStateChange2 = mod.$getStateChange;
  var $getTextContent2 = mod.$getTextContent;
  var $getTextNodeOffset2 = mod.$getTextNodeOffset;
  var $getTextPointCaret2 = mod.$getTextPointCaret;
  var $getTextPointCaretSlice2 = mod.$getTextPointCaretSlice;
  var $getWritableNodeState2 = mod.$getWritableNodeState;
  var $hasAncestor2 = mod.$hasAncestor;
  var $hasUpdateTag2 = mod.$hasUpdateTag;
  var $insertNodes2 = mod.$insertNodes;
  var $isBlockElementNode2 = mod.$isBlockElementNode;
  var $isChildCaret2 = mod.$isChildCaret;
  var $isDecoratorNode2 = mod.$isDecoratorNode;
  var $isEditorState2 = mod.$isEditorState;
  var $isElementNode2 = mod.$isElementNode;
  var $isExtendableTextPointCaret2 = mod.$isExtendableTextPointCaret;
  var $isInlineElementOrDecoratorNode2 = mod.$isInlineElementOrDecoratorNode;
  var $isLeafNode2 = mod.$isLeafNode;
  var $isLineBreakNode2 = mod.$isLineBreakNode;
  var $isNodeCaret2 = mod.$isNodeCaret;
  var $isNodeSelection2 = mod.$isNodeSelection;
  var $isParagraphNode2 = mod.$isParagraphNode;
  var $isRangeSelection2 = mod.$isRangeSelection;
  var $isRootNode2 = mod.$isRootNode;
  var $isRootOrShadowRoot2 = mod.$isRootOrShadowRoot;
  var $isSiblingCaret2 = mod.$isSiblingCaret;
  var $isTabNode2 = mod.$isTabNode;
  var $isTextNode2 = mod.$isTextNode;
  var $isTextPointCaret2 = mod.$isTextPointCaret;
  var $isTextPointCaretSlice2 = mod.$isTextPointCaretSlice;
  var $isTokenOrSegmented2 = mod.$isTokenOrSegmented;
  var $isTokenOrTab2 = mod.$isTokenOrTab;
  var $nodesOfType2 = mod.$nodesOfType;
  var $normalizeCaret2 = mod.$normalizeCaret;
  var $normalizeSelection__EXPERIMENTAL = mod.$normalizeSelection__EXPERIMENTAL;
  var $onUpdate2 = mod.$onUpdate;
  var $parseSerializedNode2 = mod.$parseSerializedNode;
  var $removeTextFromCaretRange2 = mod.$removeTextFromCaretRange;
  var $rewindSiblingCaret2 = mod.$rewindSiblingCaret;
  var $selectAll2 = mod.$selectAll;
  var $setCompositionKey2 = mod.$setCompositionKey;
  var $setPointFromCaret2 = mod.$setPointFromCaret;
  var $setSelection2 = mod.$setSelection;
  var $setSelectionFromCaretRange2 = mod.$setSelectionFromCaretRange;
  var $setState2 = mod.$setState;
  var $splitAtPointCaretNext2 = mod.$splitAtPointCaretNext;
  var $splitNode2 = mod.$splitNode;
  var $updateRangeSelectionFromCaretRange2 = mod.$updateRangeSelectionFromCaretRange;
  var ArtificialNode__DO_NOT_USE2 = mod.ArtificialNode__DO_NOT_USE;
  var BLUR_COMMAND2 = mod.BLUR_COMMAND;
  var CAN_REDO_COMMAND2 = mod.CAN_REDO_COMMAND;
  var CAN_UNDO_COMMAND2 = mod.CAN_UNDO_COMMAND;
  var CLEAR_EDITOR_COMMAND2 = mod.CLEAR_EDITOR_COMMAND;
  var CLEAR_HISTORY_COMMAND2 = mod.CLEAR_HISTORY_COMMAND;
  var CLICK_COMMAND2 = mod.CLICK_COMMAND;
  var COLLABORATION_TAG2 = mod.COLLABORATION_TAG;
  var COMMAND_PRIORITY_CRITICAL2 = mod.COMMAND_PRIORITY_CRITICAL;
  var COMMAND_PRIORITY_EDITOR2 = mod.COMMAND_PRIORITY_EDITOR;
  var COMMAND_PRIORITY_HIGH2 = mod.COMMAND_PRIORITY_HIGH;
  var COMMAND_PRIORITY_LOW2 = mod.COMMAND_PRIORITY_LOW;
  var COMMAND_PRIORITY_NORMAL2 = mod.COMMAND_PRIORITY_NORMAL;
  var CONTROLLED_TEXT_INSERTION_COMMAND2 = mod.CONTROLLED_TEXT_INSERTION_COMMAND;
  var COPY_COMMAND2 = mod.COPY_COMMAND;
  var CUT_COMMAND2 = mod.CUT_COMMAND;
  var DELETE_CHARACTER_COMMAND2 = mod.DELETE_CHARACTER_COMMAND;
  var DELETE_LINE_COMMAND2 = mod.DELETE_LINE_COMMAND;
  var DELETE_WORD_COMMAND2 = mod.DELETE_WORD_COMMAND;
  var DRAGEND_COMMAND2 = mod.DRAGEND_COMMAND;
  var DRAGOVER_COMMAND2 = mod.DRAGOVER_COMMAND;
  var DRAGSTART_COMMAND2 = mod.DRAGSTART_COMMAND;
  var DROP_COMMAND2 = mod.DROP_COMMAND;
  var DecoratorNode2 = mod.DecoratorNode;
  var ElementNode2 = mod.ElementNode;
  var FOCUS_COMMAND2 = mod.FOCUS_COMMAND;
  var FORMAT_ELEMENT_COMMAND2 = mod.FORMAT_ELEMENT_COMMAND;
  var FORMAT_TEXT_COMMAND2 = mod.FORMAT_TEXT_COMMAND;
  var HISTORIC_TAG2 = mod.HISTORIC_TAG;
  var HISTORY_MERGE_TAG2 = mod.HISTORY_MERGE_TAG;
  var HISTORY_PUSH_TAG2 = mod.HISTORY_PUSH_TAG;
  var INDENT_CONTENT_COMMAND2 = mod.INDENT_CONTENT_COMMAND;
  var INSERT_LINE_BREAK_COMMAND2 = mod.INSERT_LINE_BREAK_COMMAND;
  var INSERT_PARAGRAPH_COMMAND2 = mod.INSERT_PARAGRAPH_COMMAND;
  var INSERT_TAB_COMMAND2 = mod.INSERT_TAB_COMMAND;
  var INTERNAL_$isBlock2 = mod.INTERNAL_$isBlock;
  var IS_ALL_FORMATTING2 = mod.IS_ALL_FORMATTING;
  var IS_BOLD2 = mod.IS_BOLD;
  var IS_CODE2 = mod.IS_CODE;
  var IS_HIGHLIGHT2 = mod.IS_HIGHLIGHT;
  var IS_ITALIC2 = mod.IS_ITALIC;
  var IS_STRIKETHROUGH2 = mod.IS_STRIKETHROUGH;
  var IS_SUBSCRIPT2 = mod.IS_SUBSCRIPT;
  var IS_SUPERSCRIPT2 = mod.IS_SUPERSCRIPT;
  var IS_UNDERLINE2 = mod.IS_UNDERLINE;
  var KEY_ARROW_DOWN_COMMAND2 = mod.KEY_ARROW_DOWN_COMMAND;
  var KEY_ARROW_LEFT_COMMAND2 = mod.KEY_ARROW_LEFT_COMMAND;
  var KEY_ARROW_RIGHT_COMMAND2 = mod.KEY_ARROW_RIGHT_COMMAND;
  var KEY_ARROW_UP_COMMAND2 = mod.KEY_ARROW_UP_COMMAND;
  var KEY_BACKSPACE_COMMAND2 = mod.KEY_BACKSPACE_COMMAND;
  var KEY_DELETE_COMMAND2 = mod.KEY_DELETE_COMMAND;
  var KEY_DOWN_COMMAND2 = mod.KEY_DOWN_COMMAND;
  var KEY_ENTER_COMMAND2 = mod.KEY_ENTER_COMMAND;
  var KEY_ESCAPE_COMMAND2 = mod.KEY_ESCAPE_COMMAND;
  var KEY_MODIFIER_COMMAND2 = mod.KEY_MODIFIER_COMMAND;
  var KEY_SPACE_COMMAND2 = mod.KEY_SPACE_COMMAND;
  var KEY_TAB_COMMAND2 = mod.KEY_TAB_COMMAND;
  var LineBreakNode2 = mod.LineBreakNode;
  var MOVE_TO_END2 = mod.MOVE_TO_END;
  var MOVE_TO_START2 = mod.MOVE_TO_START;
  var NODE_STATE_KEY2 = mod.NODE_STATE_KEY;
  var OUTDENT_CONTENT_COMMAND2 = mod.OUTDENT_CONTENT_COMMAND;
  var PASTE_COMMAND2 = mod.PASTE_COMMAND;
  var PASTE_TAG2 = mod.PASTE_TAG;
  var ParagraphNode2 = mod.ParagraphNode;
  var REDO_COMMAND2 = mod.REDO_COMMAND;
  var REMOVE_TEXT_COMMAND2 = mod.REMOVE_TEXT_COMMAND;
  var RootNode2 = mod.RootNode;
  var SELECTION_CHANGE_COMMAND2 = mod.SELECTION_CHANGE_COMMAND;
  var SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2 = mod.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;
  var SELECT_ALL_COMMAND2 = mod.SELECT_ALL_COMMAND;
  var SKIP_COLLAB_TAG2 = mod.SKIP_COLLAB_TAG;
  var SKIP_DOM_SELECTION_TAG2 = mod.SKIP_DOM_SELECTION_TAG;
  var SKIP_SCROLL_INTO_VIEW_TAG2 = mod.SKIP_SCROLL_INTO_VIEW_TAG;
  var SKIP_SELECTION_FOCUS_TAG2 = mod.SKIP_SELECTION_FOCUS_TAG;
  var TEXT_TYPE_TO_FORMAT2 = mod.TEXT_TYPE_TO_FORMAT;
  var TabNode2 = mod.TabNode;
  var TextNode2 = mod.TextNode;
  var UNDO_COMMAND2 = mod.UNDO_COMMAND;
  var buildImportMap2 = mod.buildImportMap;
  var configExtension2 = mod.configExtension;
  var createCommand2 = mod.createCommand;
  var createEditor2 = mod.createEditor;
  var createSharedNodeState2 = mod.createSharedNodeState;
  var createState2 = mod.createState;
  var declarePeerDependency2 = mod.declarePeerDependency;
  var defineExtension2 = mod.defineExtension;
  var flipDirection2 = mod.flipDirection;
  var getDOMOwnerDocument2 = mod.getDOMOwnerDocument;
  var getDOMSelection2 = mod.getDOMSelection;
  var getDOMSelectionFromTarget2 = mod.getDOMSelectionFromTarget;
  var getDOMTextNode2 = mod.getDOMTextNode;
  var getEditorPropertyFromDOMNode2 = mod.getEditorPropertyFromDOMNode;
  var getNearestEditorFromDOMNode2 = mod.getNearestEditorFromDOMNode;
  var getRegisteredNode2 = mod.getRegisteredNode;
  var getRegisteredNodeOrThrow2 = mod.getRegisteredNodeOrThrow;
  var getStaticNodeConfig2 = mod.getStaticNodeConfig;
  var getTextDirection2 = mod.getTextDirection;
  var getTransformSetFromKlass2 = mod.getTransformSetFromKlass;
  var isBlockDomNode2 = mod.isBlockDomNode;
  var isCurrentlyReadOnlyMode2 = mod.isCurrentlyReadOnlyMode;
  var isDOMDocumentNode2 = mod.isDOMDocumentNode;
  var isDOMNode2 = mod.isDOMNode;
  var isDOMTextNode2 = mod.isDOMTextNode;
  var isDOMUnmanaged2 = mod.isDOMUnmanaged;
  var isDocumentFragment2 = mod.isDocumentFragment;
  var isExactShortcutMatch2 = mod.isExactShortcutMatch;
  var isHTMLAnchorElement2 = mod.isHTMLAnchorElement;
  var isHTMLElement2 = mod.isHTMLElement;
  var isInlineDomNode2 = mod.isInlineDomNode;
  var isLexicalEditor2 = mod.isLexicalEditor;
  var isModifierMatch2 = mod.isModifierMatch;
  var isSelectionCapturedInDecoratorInput2 = mod.isSelectionCapturedInDecoratorInput;
  var isSelectionWithinEditor2 = mod.isSelectionWithinEditor;
  var makeStepwiseIterator2 = mod.makeStepwiseIterator;
  var removeFromParent2 = mod.removeFromParent;
  var resetRandomKey2 = mod.resetRandomKey;
  var safeCast2 = mod.safeCast;
  var setDOMUnmanaged2 = mod.setDOMUnmanaged;
  var setNodeIndentFromDOM2 = mod.setNodeIndentFromDOM;
  var shallowMergeConfig2 = mod.shallowMergeConfig;

  // node_modules/@lexical/selection/LexicalSelection.dev.mjs
  function formatDevErrorMessage2(message) {
    throw new Error(message);
  }
  var CSS_TO_STYLES = /* @__PURE__ */ new Map();
  function getDOMTextNode3(element) {
    let node = element;
    while (node != null) {
      if (node.nodeType === Node.TEXT_NODE) {
        return node;
      }
      node = node.firstChild;
    }
    return null;
  }
  function getDOMIndexWithinParent(node) {
    const parent = node.parentNode;
    if (parent == null) {
      throw new Error("Should never happen");
    }
    return [parent, Array.from(parent.childNodes).indexOf(node)];
  }
  function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
    const anchorKey = anchorNode.getKey();
    const focusKey = focusNode.getKey();
    const range2 = document.createRange();
    let anchorDOM = editor.getElementByKey(anchorKey);
    let focusDOM = editor.getElementByKey(focusKey);
    let anchorOffset = _anchorOffset;
    let focusOffset = _focusOffset;
    if ($isTextNode2(anchorNode)) {
      anchorDOM = getDOMTextNode3(anchorDOM);
    }
    if ($isTextNode2(focusNode)) {
      focusDOM = getDOMTextNode3(focusDOM);
    }
    if (anchorNode === void 0 || focusNode === void 0 || anchorDOM === null || focusDOM === null) {
      return null;
    }
    if (anchorDOM.nodeName === "BR") {
      [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
    }
    if (focusDOM.nodeName === "BR") {
      [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
    }
    const firstChild = anchorDOM.firstChild;
    if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === "BR" && anchorOffset === 0 && focusOffset === 0) {
      focusOffset = 1;
    }
    try {
      range2.setStart(anchorDOM, anchorOffset);
      range2.setEnd(focusDOM, focusOffset);
    } catch (_e2) {
      return null;
    }
    if (range2.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
      range2.setStart(focusDOM, focusOffset);
      range2.setEnd(anchorDOM, anchorOffset);
    }
    return range2;
  }
  function createRectsFromDOMRange(editor, range2) {
    const rootElement = editor.getRootElement();
    if (rootElement === null) {
      return [];
    }
    const rootRect = rootElement.getBoundingClientRect();
    const computedStyle = getComputedStyle(rootElement);
    const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
    const selectionRects = Array.from(range2.getClientRects());
    let selectionRectsLength = selectionRects.length;
    selectionRects.sort((a2, b3) => {
      const top = a2.top - b3.top;
      if (Math.abs(top) <= 3) {
        return a2.left - b3.left;
      }
      return top;
    });
    let prevRect;
    for (let i2 = 0; i2 < selectionRectsLength; i2++) {
      const selectionRect = selectionRects[i2];
      const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;
      const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;
      if (isOverlappingRect || selectionSpansElement) {
        selectionRects.splice(i2--, 1);
        selectionRectsLength--;
        continue;
      }
      prevRect = selectionRect;
    }
    return selectionRects;
  }
  function getStyleObjectFromRawCSS(css) {
    const styleObject = {};
    if (!css) {
      return styleObject;
    }
    const styles = css.split(";");
    for (const style of styles) {
      if (style !== "") {
        const [key, value] = style.split(/:([^]+)/);
        if (key && value) {
          styleObject[key.trim()] = value.trim();
        }
      }
    }
    return styleObject;
  }
  function getStyleObjectFromCSS(css) {
    let value = CSS_TO_STYLES.get(css);
    if (value === void 0) {
      value = getStyleObjectFromRawCSS(css);
      CSS_TO_STYLES.set(css, value);
    }
    {
      Object.freeze(value);
    }
    return value;
  }
  function getCSSFromStyleObject(styles) {
    let css = "";
    for (const style in styles) {
      if (style) {
        css += `${style}: ${styles[style]};`;
      }
    }
    return css;
  }
  function $getComputedStyleForElement(element) {
    const editor = $getEditor2();
    const domElement = editor.getElementByKey(element.getKey());
    if (domElement === null) {
      return null;
    }
    const view = domElement.ownerDocument.defaultView;
    if (view === null) {
      return null;
    }
    return view.getComputedStyle(domElement);
  }
  function $getComputedStyleForParent(node) {
    const parent = $isRootNode2(node) ? node : node.getParentOrThrow();
    return $getComputedStyleForElement(parent);
  }
  function $isParentRTL(node) {
    const styles = $getComputedStyleForParent(node);
    return styles !== null && styles.direction === "rtl";
  }
  function $sliceSelectedTextNodeContent(selection, textNode, mutates = "self") {
    const anchorAndFocus = selection.getStartEndPoints();
    if (textNode.isSelected(selection) && !$isTokenOrSegmented2(textNode) && anchorAndFocus !== null) {
      const [anchor, focus] = anchorAndFocus;
      const isBackward = selection.isBackward();
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      const isAnchor = textNode.is(anchorNode);
      const isFocus = textNode.is(focusNode);
      if (isAnchor || isFocus) {
        const [anchorOffset, focusOffset] = $getCharacterOffsets2(selection);
        const isSame = anchorNode.is(focusNode);
        const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
        const isLast = textNode.is(isBackward ? anchorNode : focusNode);
        let startOffset = 0;
        let endOffset = void 0;
        if (isSame) {
          startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
          endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
        } else if (isFirst) {
          const offset = isBackward ? focusOffset : anchorOffset;
          startOffset = offset;
          endOffset = void 0;
        } else if (isLast) {
          const offset = isBackward ? anchorOffset : focusOffset;
          startOffset = 0;
          endOffset = offset;
        }
        const text2 = textNode.__text.slice(startOffset, endOffset);
        if (text2 !== textNode.__text) {
          if (mutates === "clone") {
            textNode = $cloneWithPropertiesEphemeral2(textNode);
          }
          textNode.__text = text2;
        }
      }
    }
    return textNode;
  }
  function $isAtNodeEnd(point) {
    if (point.type === "text") {
      return point.offset === point.getNode().getTextContentSize();
    }
    const node = point.getNode();
    if (!$isElementNode2(node)) {
      formatDevErrorMessage2(`isAtNodeEnd: node must be a TextNode or ElementNode`);
    }
    return point.offset === node.getChildrenSize();
  }
  function $trimTextContentFromAnchor(editor, anchor, delCount) {
    let currentNode = anchor.getNode();
    let remaining = delCount;
    if ($isElementNode2(currentNode)) {
      const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
      if (descendantNode !== null) {
        currentNode = descendantNode;
      }
    }
    while (remaining > 0 && currentNode !== null) {
      if ($isElementNode2(currentNode)) {
        const lastDescendant = currentNode.getLastDescendant();
        if (lastDescendant !== null) {
          currentNode = lastDescendant;
        }
      }
      let nextNode = currentNode.getPreviousSibling();
      let additionalElementWhitespace = 0;
      if (nextNode === null) {
        let parent = currentNode.getParentOrThrow();
        let parentSibling = parent.getPreviousSibling();
        while (parentSibling === null) {
          parent = parent.getParent();
          if (parent === null) {
            nextNode = null;
            break;
          }
          parentSibling = parent.getPreviousSibling();
        }
        if (parent !== null) {
          additionalElementWhitespace = parent.isInline() ? 0 : 2;
          nextNode = parentSibling;
        }
      }
      let text2 = currentNode.getTextContent();
      if (text2 === "" && $isElementNode2(currentNode) && !currentNode.isInline()) {
        text2 = "\n\n";
      }
      const currentNodeSize = text2.length;
      if (!$isTextNode2(currentNode) || remaining >= currentNodeSize) {
        const parent = currentNode.getParent();
        currentNode.remove();
        if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode2(parent)) {
          parent.remove();
        }
        remaining -= currentNodeSize + additionalElementWhitespace;
        currentNode = nextNode;
      } else {
        const key = currentNode.getKey();
        const prevTextContent = editor.getEditorState().read(() => {
          const prevNode = $getNodeByKey2(key);
          if ($isTextNode2(prevNode) && prevNode.isSimpleText()) {
            return prevNode.getTextContent();
          }
          return null;
        });
        const offset = currentNodeSize - remaining;
        const slicedText = text2.slice(0, offset);
        if (prevTextContent !== null && prevTextContent !== text2) {
          const prevSelection = $getPreviousSelection2();
          let target = currentNode;
          if (!currentNode.isSimpleText()) {
            const textNode = $createTextNode2(prevTextContent);
            currentNode.replace(textNode);
            target = textNode;
          } else {
            currentNode.setTextContent(prevTextContent);
          }
          if ($isRangeSelection2(prevSelection) && prevSelection.isCollapsed()) {
            const prevOffset = prevSelection.anchor.offset;
            target.select(prevOffset, prevOffset);
          }
        } else if (currentNode.isSimpleText()) {
          const isSelected = anchor.key === key;
          let anchorOffset = anchor.offset;
          if (anchorOffset < remaining) {
            anchorOffset = currentNodeSize;
          }
          const splitStart = isSelected ? anchorOffset - remaining : 0;
          const splitEnd = isSelected ? anchorOffset : offset;
          if (isSelected && splitStart === 0) {
            const [excessNode] = currentNode.splitText(splitStart, splitEnd);
            excessNode.remove();
          } else {
            const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
            excessNode.remove();
          }
        } else {
          const textNode = $createTextNode2(slicedText);
          currentNode.replace(textNode);
        }
        remaining = 0;
      }
    }
  }
  function $addNodeStyle(node) {
    const CSSText = node.getStyle();
    const styles = getStyleObjectFromRawCSS(CSSText);
    CSS_TO_STYLES.set(CSSText, styles);
  }
  function $patchStyle(target, patch) {
    if (!($isRangeSelection2(target) ? target.isCollapsed() : $isTextNode2(target) || $isElementNode2(target))) {
      formatDevErrorMessage2(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);
    }
    const prevStyles = getStyleObjectFromCSS($isRangeSelection2(target) ? target.style : $isTextNode2(target) ? target.getStyle() : target.getTextStyle());
    const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {
      if (typeof value === "function") {
        styles[key] = value(prevStyles[key], target);
      } else if (value === null) {
        delete styles[key];
      } else {
        styles[key] = value;
      }
      return styles;
    }, {
      ...prevStyles
    });
    const newCSSText = getCSSFromStyleObject(newStyles);
    if ($isRangeSelection2(target) || $isTextNode2(target)) {
      target.setStyle(newCSSText);
    } else {
      target.setTextStyle(newCSSText);
    }
    CSS_TO_STYLES.set(newCSSText, newStyles);
  }
  function $patchStyleText(selection, patch) {
    if ($isRangeSelection2(selection) && selection.isCollapsed()) {
      $patchStyle(selection, patch);
      const emptyNode = selection.anchor.getNode();
      if ($isElementNode2(emptyNode) && emptyNode.isEmpty()) {
        $patchStyle(emptyNode, patch);
      }
    }
    $forEachSelectedTextNode((textNode) => {
      $patchStyle(textNode, patch);
    });
  }
  function $forEachSelectedTextNode(fn) {
    const selection = $getSelection2();
    if (!selection) {
      return;
    }
    const slicedTextNodes = /* @__PURE__ */ new Map();
    const getSliceIndices = (node) => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];
    if ($isRangeSelection2(selection)) {
      for (const slice of $caretRangeFromSelection2(selection).getTextSlices()) {
        if (slice) {
          slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());
        }
      }
    }
    const selectedNodes = selection.getNodes();
    for (const selectedNode of selectedNodes) {
      if (!($isTextNode2(selectedNode) && selectedNode.canHaveFormat())) {
        continue;
      }
      const [startOffset, endOffset] = getSliceIndices(selectedNode);
      if (endOffset === startOffset) {
        continue;
      }
      if ($isTokenOrSegmented2(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {
        fn(selectedNode);
      } else {
        const splitNodes = selectedNode.splitText(startOffset, endOffset);
        const replacement = splitNodes[startOffset === 0 ? 0 : 1];
        fn(replacement);
      }
    }
    if ($isRangeSelection2(selection) && selection.anchor.type === "text" && selection.focus.type === "text" && selection.anchor.key === selection.focus.key) {
      $ensureForwardRangeSelection(selection);
    }
  }
  function $ensureForwardRangeSelection(selection) {
    if (selection.isBackward()) {
      const {
        anchor,
        focus
      } = selection;
      const {
        key,
        offset,
        type
      } = anchor;
      anchor.set(focus.key, focus.offset, focus.type);
      focus.set(key, offset, type);
    }
  }
  function $copyBlockFormatIndent(srcNode, destNode) {
    const format = srcNode.getFormatType();
    const indent = srcNode.getIndent();
    if (format !== destNode.getFormatType()) {
      destNode.setFormat(format);
    }
    if (indent !== destNode.getIndent()) {
      destNode.setIndent(indent);
    }
  }
  function $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {
    if (selection === null) {
      return;
    }
    const anchorAndFocus = selection.getStartEndPoints();
    const blockMap = /* @__PURE__ */ new Map();
    let newSelection = null;
    if (anchorAndFocus) {
      const [anchor, focus] = anchorAndFocus;
      newSelection = $createRangeSelection2();
      newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);
      newSelection.focus.set(focus.key, focus.offset, focus.type);
      const anchorBlock = $findMatchingParent2(anchor.getNode(), INTERNAL_$isBlock2);
      const focusBlock = $findMatchingParent2(focus.getNode(), INTERNAL_$isBlock2);
      if ($isElementNode2(anchorBlock)) {
        blockMap.set(anchorBlock.getKey(), anchorBlock);
      }
      if ($isElementNode2(focusBlock)) {
        blockMap.set(focusBlock.getKey(), focusBlock);
      }
    }
    for (const node of selection.getNodes()) {
      if ($isElementNode2(node) && INTERNAL_$isBlock2(node)) {
        blockMap.set(node.getKey(), node);
      } else if (anchorAndFocus === null) {
        const ancestorBlock = $findMatchingParent2(node, INTERNAL_$isBlock2);
        if ($isElementNode2(ancestorBlock)) {
          blockMap.set(ancestorBlock.getKey(), ancestorBlock);
        }
      }
    }
    for (const [key, prevNode] of blockMap) {
      const element = $createElement();
      $afterCreateElement(prevNode, element);
      prevNode.replace(element, true);
      if (newSelection) {
        if (key === newSelection.anchor.key) {
          newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);
        }
        if (key === newSelection.focus.key) {
          newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);
        }
      }
    }
    if (newSelection && selection.is($getSelection2())) {
      $setSelection2(newSelection);
    }
  }
  function isPointAttached(point) {
    return point.getNode().isAttached();
  }
  function $removeParentEmptyElements(startingNode) {
    let node = startingNode;
    while (node !== null && !$isRootOrShadowRoot2(node)) {
      const latest = node.getLatest();
      const parentNode = node.getParent();
      if (latest.getChildrenSize() === 0) {
        node.remove(true);
      }
      node = parentNode;
    }
  }
  function $wrapNodes(selection, createElement2, wrappingElement = null) {
    const anchorAndFocus = selection.getStartEndPoints();
    const anchor = anchorAndFocus ? anchorAndFocus[0] : null;
    const nodes = selection.getNodes();
    const nodesLength = nodes.length;
    if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === "element" && anchor.getNode().getChildrenSize() === 0)) {
      const target = anchor.type === "text" ? anchor.getNode().getParentOrThrow() : anchor.getNode();
      const children = target.getChildren();
      let element = createElement2();
      element.setFormat(target.getFormatType());
      element.setIndent(target.getIndent());
      children.forEach((child) => element.append(child));
      if (wrappingElement) {
        element = wrappingElement.append(element);
      }
      target.replace(element);
      return;
    }
    let topLevelNode = null;
    let descendants = [];
    for (let i2 = 0; i2 < nodesLength; i2++) {
      const node = nodes[i2];
      if ($isRootOrShadowRoot2(node)) {
        $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);
        descendants = [];
        topLevelNode = node;
      } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor2(node, topLevelNode)) {
        descendants.push(node);
      } else {
        $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);
        descendants = [node];
      }
    }
    $wrapNodesImpl(selection, descendants, descendants.length, createElement2, wrappingElement);
  }
  function $wrapNodesImpl(selection, nodes, nodesLength, createElement2, wrappingElement = null) {
    if (nodes.length === 0) {
      return;
    }
    const firstNode = nodes[0];
    const elementMapping = /* @__PURE__ */ new Map();
    const elements2 = [];
    let target = $isElementNode2(firstNode) ? firstNode : firstNode.getParentOrThrow();
    if (target.isInline()) {
      target = target.getParentOrThrow();
    }
    let targetIsPrevSibling = false;
    while (target !== null) {
      const prevSibling = target.getPreviousSibling();
      if (prevSibling !== null) {
        target = prevSibling;
        targetIsPrevSibling = true;
        break;
      }
      target = target.getParentOrThrow();
      if ($isRootOrShadowRoot2(target)) {
        break;
      }
    }
    const emptyElements = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < nodesLength; i2++) {
      const node = nodes[i2];
      if ($isElementNode2(node) && node.getChildrenSize() === 0) {
        emptyElements.add(node.getKey());
      }
    }
    const movedNodes = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < nodesLength; i2++) {
      const node = nodes[i2];
      let parent = node.getParent();
      if (parent !== null && parent.isInline()) {
        parent = parent.getParent();
      }
      if (parent !== null && $isLeafNode2(node) && !movedNodes.has(node.getKey())) {
        const parentKey = parent.getKey();
        if (elementMapping.get(parentKey) === void 0) {
          const targetElement = createElement2();
          targetElement.setFormat(parent.getFormatType());
          targetElement.setIndent(parent.getIndent());
          elements2.push(targetElement);
          elementMapping.set(parentKey, targetElement);
          parent.getChildren().forEach((child) => {
            targetElement.append(child);
            movedNodes.add(child.getKey());
            if ($isElementNode2(child)) {
              child.getChildrenKeys().forEach((key) => movedNodes.add(key));
            }
          });
          $removeParentEmptyElements(parent);
        }
      } else if (emptyElements.has(node.getKey())) {
        if (!$isElementNode2(node)) {
          formatDevErrorMessage2(`Expected node in emptyElements to be an ElementNode`);
        }
        const targetElement = createElement2();
        targetElement.setFormat(node.getFormatType());
        targetElement.setIndent(node.getIndent());
        elements2.push(targetElement);
        node.remove(true);
      }
    }
    if (wrappingElement !== null) {
      for (let i2 = 0; i2 < elements2.length; i2++) {
        const element = elements2[i2];
        wrappingElement.append(element);
      }
    }
    let lastElement = null;
    if ($isRootOrShadowRoot2(target)) {
      if (targetIsPrevSibling) {
        if (wrappingElement !== null) {
          target.insertAfter(wrappingElement);
        } else {
          for (let i2 = elements2.length - 1; i2 >= 0; i2--) {
            const element = elements2[i2];
            target.insertAfter(element);
          }
        }
      } else {
        const firstChild = target.getFirstChild();
        if ($isElementNode2(firstChild)) {
          target = firstChild;
        }
        if (firstChild === null) {
          if (wrappingElement) {
            target.append(wrappingElement);
          } else {
            for (let i2 = 0; i2 < elements2.length; i2++) {
              const element = elements2[i2];
              target.append(element);
              lastElement = element;
            }
          }
        } else {
          if (wrappingElement !== null) {
            firstChild.insertBefore(wrappingElement);
          } else {
            for (let i2 = 0; i2 < elements2.length; i2++) {
              const element = elements2[i2];
              firstChild.insertBefore(element);
              lastElement = element;
            }
          }
        }
      }
    } else {
      if (wrappingElement) {
        target.insertAfter(wrappingElement);
      } else {
        for (let i2 = elements2.length - 1; i2 >= 0; i2--) {
          const element = elements2[i2];
          target.insertAfter(element);
          lastElement = element;
        }
      }
    }
    const prevSelection = $getPreviousSelection2();
    if ($isRangeSelection2(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
      $setSelection2(prevSelection.clone());
    } else if (lastElement !== null) {
      lastElement.selectEnd();
    } else {
      selection.dirty = true;
    }
  }
  function $isEditorVerticalOrientation(selection) {
    const computedStyle = $getComputedStyle(selection);
    return computedStyle !== null && computedStyle.writingMode === "vertical-rl";
  }
  function $getComputedStyle(selection) {
    const anchorNode = selection.anchor.getNode();
    if ($isElementNode2(anchorNode)) {
      return $getComputedStyleForElement(anchorNode);
    }
    return $getComputedStyleForParent(anchorNode);
  }
  function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
    const isVertical = $isEditorVerticalOrientation(selection);
    let adjustedIsBackward = isVertical ? !isBackward : isBackward;
    if ($isParentElementRTL(selection)) {
      adjustedIsBackward = !adjustedIsBackward;
    }
    const focusCaret = $caretFromPoint2(selection.focus, adjustedIsBackward ? "previous" : "next");
    if ($isExtendableTextPointCaret2(focusCaret)) {
      return false;
    }
    for (const nextCaret of $extendCaretToRange2(focusCaret)) {
      if ($isChildCaret2(nextCaret)) {
        return !nextCaret.origin.isInline();
      } else if ($isElementNode2(nextCaret.origin)) {
        continue;
      } else if ($isDecoratorNode2(nextCaret.origin)) {
        return true;
      }
      break;
    }
    return false;
  }
  function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
    selection.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
  }
  function $isParentElementRTL(selection) {
    const computedStyle = $getComputedStyle(selection);
    return computedStyle !== null && computedStyle.direction === "rtl";
  }
  function $moveCharacter(selection, isHoldingShift, isBackward) {
    const isRTL = $isParentElementRTL(selection);
    const isVertical = $isEditorVerticalOrientation(selection);
    let adjustedIsBackward;
    if (isVertical) {
      adjustedIsBackward = !isBackward;
    } else if (isRTL) {
      adjustedIsBackward = !isBackward;
    } else {
      adjustedIsBackward = isBackward;
    }
    $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, "character");
  }
  function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {
    const css = node.getStyle();
    const styleObject = getStyleObjectFromCSS(css);
    if (styleObject !== null) {
      return styleObject[styleProperty] || defaultValue;
    }
    return defaultValue;
  }
  function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = "") {
    let styleValue = null;
    const nodes = selection.getNodes();
    const anchor = selection.anchor;
    const focus = selection.focus;
    const isBackward = selection.isBackward();
    const endOffset = isBackward ? focus.offset : anchor.offset;
    const endNode = isBackward ? focus.getNode() : anchor.getNode();
    if ($isRangeSelection2(selection) && selection.isCollapsed() && selection.style !== "") {
      const css = selection.style;
      const styleObject = getStyleObjectFromCSS(css);
      if (styleObject !== null && styleProperty in styleObject) {
        return styleObject[styleProperty];
      }
    }
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if (i2 !== 0 && endOffset === 0 && node.is(endNode)) {
        continue;
      }
      if ($isTextNode2(node)) {
        const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);
        if (styleValue === null) {
          styleValue = nodeStyleValue;
        } else if (styleValue !== nodeStyleValue) {
          styleValue = "";
          break;
        }
      }
    }
    return styleValue === null ? defaultValue : styleValue;
  }
  var trimTextContentFromAnchor = $trimTextContentFromAnchor;

  // node_modules/@lexical/selection/LexicalSelection.mjs
  var mod2 = true ? LexicalSelection_dev_exports : LexicalSelection_prod_exports;
  var $addNodeStyle2 = mod2.$addNodeStyle;
  var $cloneWithProperties3 = mod2.$cloneWithProperties;
  var $copyBlockFormatIndent2 = mod2.$copyBlockFormatIndent;
  var $ensureForwardRangeSelection2 = mod2.$ensureForwardRangeSelection;
  var $forEachSelectedTextNode2 = mod2.$forEachSelectedTextNode;
  var $getComputedStyleForElement2 = mod2.$getComputedStyleForElement;
  var $getComputedStyleForParent2 = mod2.$getComputedStyleForParent;
  var $getSelectionStyleValueForProperty2 = mod2.$getSelectionStyleValueForProperty;
  var $isAtNodeEnd2 = mod2.$isAtNodeEnd;
  var $isParentElementRTL2 = mod2.$isParentElementRTL;
  var $isParentRTL2 = mod2.$isParentRTL;
  var $moveCaretSelection2 = mod2.$moveCaretSelection;
  var $moveCharacter2 = mod2.$moveCharacter;
  var $patchStyleText2 = mod2.$patchStyleText;
  var $selectAll3 = mod2.$selectAll;
  var $setBlocksType2 = mod2.$setBlocksType;
  var $shouldOverrideDefaultCharacterSelection2 = mod2.$shouldOverrideDefaultCharacterSelection;
  var $sliceSelectedTextNodeContent2 = mod2.$sliceSelectedTextNodeContent;
  var $trimTextContentFromAnchor2 = mod2.$trimTextContentFromAnchor;
  var $wrapNodes2 = mod2.$wrapNodes;
  var createDOMRange2 = mod2.createDOMRange;
  var createRectsFromDOMRange2 = mod2.createRectsFromDOMRange;
  var getCSSFromStyleObject2 = mod2.getCSSFromStyleObject;
  var getStyleObjectFromCSS2 = mod2.getStyleObjectFromCSS;
  var trimTextContentFromAnchor2 = mod2.trimTextContentFromAnchor;

  // node_modules/@lexical/list/LexicalList.dev.mjs
  var LexicalList_dev_exports = {};
  __export(LexicalList_dev_exports, {
    $createListItemNode: () => $createListItemNode,
    $createListNode: () => $createListNode,
    $getListDepth: () => $getListDepth,
    $handleListInsertParagraph: () => $handleListInsertParagraph,
    $insertList: () => $insertList,
    $isListItemNode: () => $isListItemNode,
    $isListNode: () => $isListNode,
    $removeList: () => $removeList,
    CheckListExtension: () => CheckListExtension,
    INSERT_CHECK_LIST_COMMAND: () => INSERT_CHECK_LIST_COMMAND,
    INSERT_ORDERED_LIST_COMMAND: () => INSERT_ORDERED_LIST_COMMAND,
    INSERT_UNORDERED_LIST_COMMAND: () => INSERT_UNORDERED_LIST_COMMAND,
    ListExtension: () => ListExtension,
    ListItemNode: () => ListItemNode,
    ListNode: () => ListNode,
    REMOVE_LIST_COMMAND: () => REMOVE_LIST_COMMAND,
    UPDATE_LIST_START_COMMAND: () => UPDATE_LIST_START_COMMAND,
    insertList: () => insertList,
    registerCheckList: () => registerCheckList,
    registerList: () => registerList,
    registerListStrictIndentTransform: () => registerListStrictIndentTransform,
    removeList: () => removeList
  });

  // node_modules/@lexical/extension/LexicalExtension.dev.mjs
  var LexicalExtension_dev_exports = {};
  __export(LexicalExtension_dev_exports, {
    $createHorizontalRuleNode: () => $createHorizontalRuleNode,
    $isHorizontalRuleNode: () => $isHorizontalRuleNode,
    AutoFocusExtension: () => AutoFocusExtension,
    ClearEditorExtension: () => ClearEditorExtension,
    EditorStateExtension: () => EditorStateExtension,
    HorizontalRuleExtension: () => HorizontalRuleExtension,
    HorizontalRuleNode: () => HorizontalRuleNode,
    INSERT_HORIZONTAL_RULE_COMMAND: () => INSERT_HORIZONTAL_RULE_COMMAND,
    InitialStateExtension: () => InitialStateExtension,
    LexicalBuilder: () => LexicalBuilder,
    NodeSelectionExtension: () => NodeSelectionExtension,
    TabIndentationExtension: () => TabIndentationExtension,
    batch: () => o,
    buildEditorFromExtensions: () => buildEditorFromExtensions,
    computed: () => w,
    configExtension: () => configExtension2,
    declarePeerDependency: () => declarePeerDependency2,
    defineExtension: () => defineExtension2,
    effect: () => E,
    getExtensionDependencyFromEditor: () => getExtensionDependencyFromEditor,
    getKnownTypesAndNodes: () => getKnownTypesAndNodes,
    getPeerDependencyFromEditor: () => getPeerDependencyFromEditor,
    getPeerDependencyFromEditorOrThrow: () => getPeerDependencyFromEditorOrThrow,
    namedSignals: () => namedSignals,
    registerClearEditor: () => registerClearEditor,
    registerTabIndentation: () => registerTabIndentation,
    safeCast: () => safeCast2,
    shallowMergeConfig: () => shallowMergeConfig2,
    signal: () => d,
    untracked: () => h,
    watchedSignal: () => watchedSignal
  });

  // node_modules/@lexical/utils/LexicalUtils.dev.mjs
  var LexicalUtils_dev_exports = {};
  __export(LexicalUtils_dev_exports, {
    $descendantsMatching: () => $descendantsMatching,
    $dfs: () => $dfs,
    $dfsIterator: () => $dfsIterator,
    $filter: () => $filter,
    $findMatchingParent: () => $findMatchingParent2,
    $firstToLastIterator: () => $firstToLastIterator,
    $getAdjacentCaret: () => $getAdjacentCaret,
    $getAdjacentSiblingOrParentSiblingCaret: () => $getAdjacentSiblingOrParentSiblingCaret2,
    $getDepth: () => $getDepth,
    $getNearestBlockElementAncestorOrThrow: () => $getNearestBlockElementAncestorOrThrow,
    $getNearestNodeOfType: () => $getNearestNodeOfType,
    $getNextRightPreorderNode: () => $getNextRightPreorderNode,
    $getNextSiblingOrParentSibling: () => $getNextSiblingOrParentSibling,
    $insertFirst: () => $insertFirst,
    $insertNodeToNearestRoot: () => $insertNodeToNearestRoot,
    $insertNodeToNearestRootAtCaret: () => $insertNodeToNearestRootAtCaret,
    $isEditorIsNestedEditor: () => $isEditorIsNestedEditor,
    $lastToFirstIterator: () => $lastToFirstIterator,
    $restoreEditorState: () => $restoreEditorState,
    $reverseDfs: () => $reverseDfs,
    $reverseDfsIterator: () => $reverseDfsIterator,
    $splitNode: () => $splitNode2,
    $unwrapAndFilterDescendants: () => $unwrapAndFilterDescendants,
    $unwrapNode: () => $unwrapNode,
    $wrapNodeInElement: () => $wrapNodeInElement,
    CAN_USE_BEFORE_INPUT: () => CAN_USE_BEFORE_INPUT2,
    CAN_USE_DOM: () => CAN_USE_DOM2,
    IS_ANDROID: () => IS_ANDROID2,
    IS_ANDROID_CHROME: () => IS_ANDROID_CHROME2,
    IS_APPLE: () => IS_APPLE2,
    IS_APPLE_WEBKIT: () => IS_APPLE_WEBKIT2,
    IS_CHROME: () => IS_CHROME2,
    IS_FIREFOX: () => IS_FIREFOX2,
    IS_IOS: () => IS_IOS2,
    IS_SAFARI: () => IS_SAFARI2,
    addClassNamesToElement: () => addClassNamesToElement,
    calculateZoomLevel: () => calculateZoomLevel,
    isBlockDomNode: () => isBlockDomNode2,
    isHTMLAnchorElement: () => isHTMLAnchorElement2,
    isHTMLElement: () => isHTMLElement2,
    isInlineDomNode: () => isInlineDomNode2,
    isMimeType: () => isMimeType,
    makeStateWrapper: () => makeStateWrapper,
    markSelection: () => markSelection,
    mediaFileReader: () => mediaFileReader,
    mergeRegister: () => mergeRegister,
    objectKlassEquals: () => objectKlassEquals,
    positionNodeOnRange: () => mlcPositionNodeOnRange,
    registerNestedElementResolver: () => registerNestedElementResolver,
    removeClassNamesFromElement: () => removeClassNamesFromElement,
    selectionAlwaysOnDisplay: () => selectionAlwaysOnDisplay
  });
  function formatDevErrorMessage3(message) {
    throw new Error(message);
  }
  var CAN_USE_DOM$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  var documentMode2 = CAN_USE_DOM$1 && "documentMode" in document ? document.documentMode : null;
  var IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
  var IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
  var CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && "InputEvent" in window && !documentMode2 ? "getTargetRanges" in new window.InputEvent("input") : false;
  var IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
  var IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  var IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);
  var IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
  var IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;
  var IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && IS_APPLE$1 && !IS_CHROME$1;
  function normalizeClassNames2(...classNames) {
    const rval = [];
    for (const className of classNames) {
      if (className && typeof className === "string") {
        for (const [s2] of className.matchAll(/\S+/g)) {
          rval.push(s2);
        }
      }
    }
    return rval;
  }
  function mergeRegister(...func) {
    return () => {
      for (let i2 = func.length - 1; i2 >= 0; i2--) {
        func[i2]();
      }
      func.length = 0;
    };
  }
  function px(value) {
    return `${value}px`;
  }
  var mutationObserverConfig = {
    attributes: true,
    characterData: true,
    childList: true,
    subtree: true
  };
  function prependDOMNode(parent, node) {
    parent.insertBefore(node, parent.firstChild);
  }
  function mlcPositionNodeOnRange(editor, range2, onReposition) {
    let rootDOMNode = null;
    let parentDOMNode = null;
    let observer2 = null;
    let lastNodes = [];
    const wrapperNode = document.createElement("div");
    wrapperNode.style.position = "relative";
    function position() {
      if (!(rootDOMNode !== null)) {
        formatDevErrorMessage3(`Unexpected null rootDOMNode`);
      }
      if (!(parentDOMNode !== null)) {
        formatDevErrorMessage3(`Unexpected null parentDOMNode`);
      }
      const {
        left: parentLeft,
        top: parentTop
      } = parentDOMNode.getBoundingClientRect();
      const rects = createRectsFromDOMRange2(editor, range2);
      if (!wrapperNode.isConnected) {
        prependDOMNode(parentDOMNode, wrapperNode);
      }
      let hasRepositioned = false;
      for (let i2 = 0; i2 < rects.length; i2++) {
        const rect = rects[i2];
        const rectNode = lastNodes[i2] || document.createElement("div");
        const rectNodeStyle = rectNode.style;
        if (rectNodeStyle.position !== "absolute") {
          rectNodeStyle.position = "absolute";
          hasRepositioned = true;
        }
        const left = px(rect.left - parentLeft);
        if (rectNodeStyle.left !== left) {
          rectNodeStyle.left = left;
          hasRepositioned = true;
        }
        const top = px(rect.top - parentTop);
        if (rectNodeStyle.top !== top) {
          rectNode.style.top = top;
          hasRepositioned = true;
        }
        const width = px(rect.width);
        if (rectNodeStyle.width !== width) {
          rectNode.style.width = width;
          hasRepositioned = true;
        }
        const height = px(rect.height);
        if (rectNodeStyle.height !== height) {
          rectNode.style.height = height;
          hasRepositioned = true;
        }
        if (rectNode.parentNode !== wrapperNode) {
          wrapperNode.append(rectNode);
          hasRepositioned = true;
        }
        lastNodes[i2] = rectNode;
      }
      while (lastNodes.length > rects.length) {
        lastNodes.pop();
      }
      if (hasRepositioned) {
        onReposition(lastNodes);
      }
    }
    function stop2() {
      parentDOMNode = null;
      rootDOMNode = null;
      if (observer2 !== null) {
        observer2.disconnect();
      }
      observer2 = null;
      wrapperNode.remove();
      for (const node of lastNodes) {
        node.remove();
      }
      lastNodes = [];
    }
    function restart() {
      const currentRootDOMNode = editor.getRootElement();
      if (currentRootDOMNode === null) {
        return stop2();
      }
      const currentParentDOMNode = currentRootDOMNode.parentElement;
      if (!isHTMLElement2(currentParentDOMNode)) {
        return stop2();
      }
      stop2();
      rootDOMNode = currentRootDOMNode;
      parentDOMNode = currentParentDOMNode;
      observer2 = new MutationObserver((mutations) => {
        const nextRootDOMNode = editor.getRootElement();
        const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;
        if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {
          return restart();
        }
        for (const mutation of mutations) {
          if (!wrapperNode.contains(mutation.target)) {
            return position();
          }
        }
      });
      observer2.observe(currentParentDOMNode, mutationObserverConfig);
      position();
    }
    const removeRootListener = editor.registerRootListener(restart);
    return () => {
      removeRootListener();
      stop2();
    };
  }
  function $getOrderedSelectionPoints(selection) {
    const points = selection.getStartEndPoints();
    return selection.isBackward() ? [points[1], points[0]] : points;
  }
  function rangeTargetFromPoint(point, node, dom) {
    if (point.type === "text" || !$isElementNode2(node)) {
      const textDOM = getDOMTextNode2(dom) || dom;
      return [textDOM, point.offset];
    } else {
      const slot = node.getDOMSlot(dom);
      return [slot.element, slot.getFirstChildOffset() + point.offset];
    }
  }
  function rangeFromPoints(editor, start3, startNode, startDOM, end, endNode, endDOM) {
    const editorDocument = editor._window ? editor._window.document : document;
    const range2 = editorDocument.createRange();
    range2.setStart(...rangeTargetFromPoint(start3, startNode, startDOM));
    range2.setEnd(...rangeTargetFromPoint(end, endNode, endDOM));
    return range2;
  }
  function markSelection(editor, onReposition) {
    let previousAnchorNode = null;
    let previousAnchorNodeDOM = null;
    let previousAnchorOffset = null;
    let previousFocusNode = null;
    let previousFocusNodeDOM = null;
    let previousFocusOffset = null;
    let removeRangeListener = () => {
    };
    function compute(editorState) {
      editorState.read(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) {
          previousAnchorNode = null;
          previousAnchorOffset = null;
          previousFocusNode = null;
          previousFocusOffset = null;
          removeRangeListener();
          removeRangeListener = () => {
          };
          return;
        }
        const [start3, end] = $getOrderedSelectionPoints(selection);
        const currentStartNode = start3.getNode();
        const currentStartNodeKey = currentStartNode.getKey();
        const currentStartOffset = start3.offset;
        const currentEndNode = end.getNode();
        const currentEndNodeKey = currentEndNode.getKey();
        const currentEndOffset = end.offset;
        const currentStartNodeDOM = editor.getElementByKey(currentStartNodeKey);
        const currentEndNodeDOM = editor.getElementByKey(currentEndNodeKey);
        const differentStartDOM = previousAnchorNode === null || currentStartNodeDOM !== previousAnchorNodeDOM || currentStartOffset !== previousAnchorOffset || currentStartNodeKey !== previousAnchorNode.getKey();
        const differentEndDOM = previousFocusNode === null || currentEndNodeDOM !== previousFocusNodeDOM || currentEndOffset !== previousFocusOffset || currentEndNodeKey !== previousFocusNode.getKey();
        if ((differentStartDOM || differentEndDOM) && currentStartNodeDOM !== null && currentEndNodeDOM !== null) {
          const range2 = rangeFromPoints(editor, start3, currentStartNode, currentStartNodeDOM, end, currentEndNode, currentEndNodeDOM);
          removeRangeListener();
          removeRangeListener = mlcPositionNodeOnRange(editor, range2, (domNodes) => {
            if (onReposition === void 0) {
              for (const domNode of domNodes) {
                const domNodeStyle = domNode.style;
                if (domNodeStyle.background !== "Highlight") {
                  domNodeStyle.background = "Highlight";
                }
                if (domNodeStyle.color !== "HighlightText") {
                  domNodeStyle.color = "HighlightText";
                }
                if (domNodeStyle.marginTop !== px(-1.5)) {
                  domNodeStyle.marginTop = px(-1.5);
                }
                if (domNodeStyle.paddingTop !== px(4)) {
                  domNodeStyle.paddingTop = px(4);
                }
                if (domNodeStyle.paddingBottom !== px(0)) {
                  domNodeStyle.paddingBottom = px(0);
                }
              }
            } else {
              onReposition(domNodes);
            }
          });
        }
        previousAnchorNode = currentStartNode;
        previousAnchorNodeDOM = currentStartNodeDOM;
        previousAnchorOffset = currentStartOffset;
        previousFocusNode = currentEndNode;
        previousFocusNodeDOM = currentEndNodeDOM;
        previousFocusOffset = currentEndOffset;
      });
    }
    compute(editor.getEditorState());
    return mergeRegister(editor.registerUpdateListener(({
      editorState
    }) => compute(editorState)), () => {
      removeRangeListener();
    });
  }
  function selectionAlwaysOnDisplay(editor) {
    let removeSelectionMark = null;
    const onSelectionChange2 = () => {
      const domSelection = getSelection();
      const domAnchorNode = domSelection && domSelection.anchorNode;
      const editorRootElement = editor.getRootElement();
      const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);
      if (isSelectionInsideEditor) {
        if (removeSelectionMark !== null) {
          removeSelectionMark();
          removeSelectionMark = null;
        }
      } else {
        if (removeSelectionMark === null) {
          removeSelectionMark = markSelection(editor);
        }
      }
    };
    document.addEventListener("selectionchange", onSelectionChange2);
    return () => {
      if (removeSelectionMark !== null) {
        removeSelectionMark();
      }
      document.removeEventListener("selectionchange", onSelectionChange2);
    };
  }
  var CAN_USE_BEFORE_INPUT2 = CAN_USE_BEFORE_INPUT$1;
  var CAN_USE_DOM2 = CAN_USE_DOM$1;
  var IS_ANDROID2 = IS_ANDROID$1;
  var IS_ANDROID_CHROME2 = IS_ANDROID_CHROME$1;
  var IS_APPLE2 = IS_APPLE$1;
  var IS_APPLE_WEBKIT2 = IS_APPLE_WEBKIT$1;
  var IS_CHROME2 = IS_CHROME$1;
  var IS_FIREFOX2 = IS_FIREFOX$1;
  var IS_IOS2 = IS_IOS$1;
  var IS_SAFARI2 = IS_SAFARI$1;
  function addClassNamesToElement(element, ...classNames) {
    const classesToAdd = normalizeClassNames2(...classNames);
    if (classesToAdd.length > 0) {
      element.classList.add(...classesToAdd);
    }
  }
  function removeClassNamesFromElement(element, ...classNames) {
    const classesToRemove = normalizeClassNames2(...classNames);
    if (classesToRemove.length > 0) {
      element.classList.remove(...classesToRemove);
    }
  }
  function isMimeType(file, acceptableMimeTypes) {
    for (const acceptableType of acceptableMimeTypes) {
      if (file.type.startsWith(acceptableType)) {
        return true;
      }
    }
    return false;
  }
  function mediaFileReader(files, acceptableMimeTypes) {
    const filesIterator = files[Symbol.iterator]();
    return new Promise((resolve2, reject) => {
      const processed = [];
      const handleNextFile = () => {
        const {
          done,
          value: file
        } = filesIterator.next();
        if (done) {
          return resolve2(processed);
        }
        const fileReader = new FileReader();
        fileReader.addEventListener("error", reject);
        fileReader.addEventListener("load", () => {
          const result = fileReader.result;
          if (typeof result === "string") {
            processed.push({
              file,
              result
            });
          }
          handleNextFile();
        });
        if (isMimeType(file, acceptableMimeTypes)) {
          fileReader.readAsDataURL(file);
        } else {
          handleNextFile();
        }
      };
      handleNextFile();
    });
  }
  function $dfs(startNode, endNode) {
    return Array.from($dfsIterator(startNode, endNode));
  }
  function $getAdjacentCaret(caret) {
    return caret ? caret.getAdjacentCaret() : null;
  }
  function $reverseDfs(startNode, endNode) {
    return Array.from($reverseDfsIterator(startNode, endNode));
  }
  function $dfsIterator(startNode, endNode) {
    return $dfsCaretIterator("next", startNode, endNode);
  }
  function $getEndCaret(startNode, direction) {
    const rval = $getAdjacentSiblingOrParentSiblingCaret2($getSiblingCaret2(startNode, direction));
    return rval && rval[0];
  }
  function $dfsCaretIterator(direction, startNode, endNode) {
    const root = $getRoot2();
    const start3 = startNode || root;
    const startCaret = $isElementNode2(start3) ? $getChildCaret2(start3, direction) : $getSiblingCaret2(start3, direction);
    const startDepth = $getDepth(start3);
    const endCaret = endNode ? $getAdjacentChildCaret2($getChildCaretOrSelf2($getSiblingCaret2(endNode, direction))) : $getEndCaret(start3, direction);
    let depth = startDepth;
    return makeStepwiseIterator2({
      hasNext: (state) => state !== null,
      initial: startCaret,
      map: (state) => ({
        depth,
        node: state.origin
      }),
      step: (state) => {
        if (state.isSameNodeCaret(endCaret)) {
          return null;
        }
        if ($isChildCaret2(state)) {
          depth++;
        }
        const rval = $getAdjacentSiblingOrParentSiblingCaret2(state);
        if (!rval || rval[0].isSameNodeCaret(endCaret)) {
          return null;
        }
        depth += rval[1];
        return rval[0];
      }
    });
  }
  function $getNextSiblingOrParentSibling(node) {
    const rval = $getAdjacentSiblingOrParentSiblingCaret2($getSiblingCaret2(node, "next"));
    return rval && [rval[0].origin, rval[1]];
  }
  function $getDepth(node) {
    let depth = -1;
    for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {
      depth++;
    }
    return depth;
  }
  function $getNextRightPreorderNode(startingNode) {
    const startCaret = $getChildCaretOrSelf2($getSiblingCaret2(startingNode, "previous"));
    const next = $getAdjacentSiblingOrParentSiblingCaret2(startCaret, "root");
    return next && next[0].origin;
  }
  function $reverseDfsIterator(startNode, endNode) {
    return $dfsCaretIterator("previous", startNode, endNode);
  }
  function $getNearestNodeOfType(node, klass) {
    let parent = node;
    while (parent != null) {
      if (parent instanceof klass) {
        return parent;
      }
      parent = parent.getParent();
    }
    return null;
  }
  function $getNearestBlockElementAncestorOrThrow(startNode) {
    const blockNode = $findMatchingParent2(startNode, (node) => $isElementNode2(node) && !node.isInline());
    if (!$isElementNode2(blockNode)) {
      {
        formatDevErrorMessage3(`Expected node ${startNode.__key} to have closest block element node.`);
      }
    }
    return blockNode;
  }
  function registerNestedElementResolver(editor, targetNode, cloneNode2, handleOverlap) {
    const $isTargetNode = (node) => {
      return node instanceof targetNode;
    };
    const $findMatch = (node) => {
      const children = node.getChildren();
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if ($isTargetNode(child)) {
          return null;
        }
      }
      let parentNode = node;
      let childNode = node;
      while (parentNode !== null) {
        childNode = parentNode;
        parentNode = parentNode.getParent();
        if ($isTargetNode(parentNode)) {
          return {
            child: childNode,
            parent: parentNode
          };
        }
      }
      return null;
    };
    const $elementNodeTransform = (node) => {
      const match = $findMatch(node);
      if (match !== null) {
        const {
          child,
          parent
        } = match;
        if (child.is(node)) {
          handleOverlap(parent, node);
          const nextSiblings = child.getNextSiblings();
          const nextSiblingsLength = nextSiblings.length;
          parent.insertAfter(child);
          if (nextSiblingsLength !== 0) {
            const newParent = cloneNode2(parent);
            child.insertAfter(newParent);
            for (let i2 = 0; i2 < nextSiblingsLength; i2++) {
              newParent.append(nextSiblings[i2]);
            }
          }
          if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
            parent.remove();
          }
        }
      }
    };
    return editor.registerNodeTransform(targetNode, $elementNodeTransform);
  }
  function $restoreEditorState(editor, editorState) {
    const FULL_RECONCILE2 = 2;
    const nodeMap = /* @__PURE__ */ new Map();
    const activeEditorState2 = editor._pendingEditorState;
    for (const [key, node] of editorState._nodeMap) {
      nodeMap.set(key, $cloneWithProperties2(node));
    }
    if (activeEditorState2) {
      activeEditorState2._nodeMap = nodeMap;
    }
    editor._dirtyType = FULL_RECONCILE2;
    const selection = editorState._selection;
    $setSelection2(selection === null ? null : selection.clone());
  }
  function $insertNodeToNearestRoot(node) {
    const selection = $getSelection2() || $getPreviousSelection2();
    let initialCaret;
    if ($isRangeSelection2(selection)) {
      initialCaret = $caretFromPoint2(selection.focus, "next");
    } else {
      if (selection != null) {
        const nodes = selection.getNodes();
        const lastNode = nodes[nodes.length - 1];
        if (lastNode) {
          initialCaret = $getSiblingCaret2(lastNode, "next");
        }
      }
      initialCaret = initialCaret || $getChildCaret2($getRoot2(), "previous").getFlipped().insert($createParagraphNode2());
    }
    const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);
    const adjacent = $getAdjacentChildCaret2(insertCaret);
    const selectionCaret = $isChildCaret2(adjacent) ? $normalizeCaret2(adjacent) : insertCaret;
    $setSelectionFromCaretRange2($getCollapsedCaretRange2(selectionCaret));
    return node.getLatest();
  }
  function $insertNodeToNearestRootAtCaret(node, caret, options) {
    let insertCaret = $getCaretInDirection2(caret, "next");
    for (let nextCaret = insertCaret; nextCaret; nextCaret = $splitAtPointCaretNext2(nextCaret, options)) {
      insertCaret = nextCaret;
    }
    if (!!$isTextPointCaret2(insertCaret)) {
      formatDevErrorMessage3(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);
    }
    insertCaret.insert(node.isInline() ? $createParagraphNode2().append(node) : node);
    return $getCaretInDirection2($getSiblingCaret2(node.getLatest(), "next"), caret.direction);
  }
  function $wrapNodeInElement(node, createElementNode) {
    const elementNode = createElementNode();
    node.replace(elementNode);
    elementNode.append(node);
    return elementNode;
  }
  function objectKlassEquals(object, objectClass) {
    return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
  }
  function $filter(nodes, filterFn) {
    const result = [];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = filterFn(nodes[i2]);
      if (node !== null) {
        result.push(node);
      }
    }
    return result;
  }
  function $insertFirst(parent, node) {
    $getChildCaret2(parent, "next").insert(node);
  }
  var NEEDS_MANUAL_ZOOM = IS_FIREFOX2 || !CAN_USE_DOM2 ? false : void 0;
  function needsManualZoom() {
    if (NEEDS_MANUAL_ZOOM === void 0) {
      const div = document.createElement("div");
      div.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;";
      document.body.appendChild(div);
      const noZoom = div.getBoundingClientRect();
      div.style.setProperty("zoom", "2");
      NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;
      document.body.removeChild(div);
    }
    return NEEDS_MANUAL_ZOOM;
  }
  function calculateZoomLevel(element) {
    let zoom = 1;
    if (needsManualZoom()) {
      while (element) {
        zoom *= Number(window.getComputedStyle(element).getPropertyValue("zoom"));
        element = element.parentElement;
      }
    }
    return zoom;
  }
  function $isEditorIsNestedEditor(editor) {
    return editor._parentEditor !== null;
  }
  function $unwrapAndFilterDescendants(root, $predicate) {
    return $unwrapAndFilterDescendantsImpl(root, $predicate, null);
  }
  function $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {
    let didMutate = false;
    for (const node of $lastToFirstIterator(root)) {
      if ($predicate(node)) {
        if ($onSuccess !== null) {
          $onSuccess(node);
        }
        continue;
      }
      didMutate = true;
      if ($isElementNode2(node)) {
        $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || ((child) => node.insertAfter(child)));
      }
      node.remove();
    }
    return didMutate;
  }
  function $descendantsMatching(children, $predicate) {
    const result = [];
    const stack = Array.from(children).reverse();
    for (let child = stack.pop(); child !== void 0; child = stack.pop()) {
      if ($predicate(child)) {
        result.push(child);
      } else if ($isElementNode2(child)) {
        for (const grandchild of $lastToFirstIterator(child)) {
          stack.push(grandchild);
        }
      }
    }
    return result;
  }
  function $firstToLastIterator(node) {
    return $childIterator($getChildCaret2(node, "next"));
  }
  function $lastToFirstIterator(node) {
    return $childIterator($getChildCaret2(node, "previous"));
  }
  function $childIterator(startCaret) {
    const seen = /* @__PURE__ */ new Set();
    return makeStepwiseIterator2({
      hasNext: $isSiblingCaret2,
      initial: startCaret.getAdjacentCaret(),
      map: (caret) => {
        const origin = caret.origin.getLatest();
        if (seen !== null) {
          const key = origin.getKey();
          if (!!seen.has(key)) {
            formatDevErrorMessage3(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);
          }
          seen.add(key);
        }
        return origin;
      },
      step: (caret) => caret.getAdjacentCaret()
    });
  }
  function $unwrapNode(node) {
    $rewindSiblingCaret2($getSiblingCaret2(node, "next")).splice(1, node.getChildren());
  }
  function makeStateWrapper(stateConfig) {
    const $get = (node) => $getState2(node, stateConfig);
    const $set = (node, valueOrUpdater) => $setState2(node, stateConfig, valueOrUpdater);
    return {
      $get,
      $set,
      accessors: [$get, $set],
      makeGetterMethod: () => function $getter() {
        return $get(this);
      },
      makeSetterMethod: () => function $setter(valueOrUpdater) {
        return $set(this, valueOrUpdater);
      },
      stateConfig
    };
  }

  // node_modules/@lexical/utils/LexicalUtils.mjs
  var mod3 = true ? LexicalUtils_dev_exports : LexicalUtils_prod_exports;
  var $descendantsMatching2 = mod3.$descendantsMatching;
  var $dfs2 = mod3.$dfs;
  var $dfsIterator2 = mod3.$dfsIterator;
  var $filter2 = mod3.$filter;
  var $findMatchingParent3 = mod3.$findMatchingParent;
  var $firstToLastIterator2 = mod3.$firstToLastIterator;
  var $getAdjacentCaret2 = mod3.$getAdjacentCaret;
  var $getAdjacentSiblingOrParentSiblingCaret3 = mod3.$getAdjacentSiblingOrParentSiblingCaret;
  var $getDepth2 = mod3.$getDepth;
  var $getNearestBlockElementAncestorOrThrow2 = mod3.$getNearestBlockElementAncestorOrThrow;
  var $getNearestNodeOfType2 = mod3.$getNearestNodeOfType;
  var $getNextRightPreorderNode2 = mod3.$getNextRightPreorderNode;
  var $getNextSiblingOrParentSibling2 = mod3.$getNextSiblingOrParentSibling;
  var $insertFirst2 = mod3.$insertFirst;
  var $insertNodeToNearestRoot2 = mod3.$insertNodeToNearestRoot;
  var $insertNodeToNearestRootAtCaret2 = mod3.$insertNodeToNearestRootAtCaret;
  var $isEditorIsNestedEditor2 = mod3.$isEditorIsNestedEditor;
  var $lastToFirstIterator2 = mod3.$lastToFirstIterator;
  var $restoreEditorState2 = mod3.$restoreEditorState;
  var $reverseDfs2 = mod3.$reverseDfs;
  var $reverseDfsIterator2 = mod3.$reverseDfsIterator;
  var $splitNode3 = mod3.$splitNode;
  var $unwrapAndFilterDescendants2 = mod3.$unwrapAndFilterDescendants;
  var $unwrapNode2 = mod3.$unwrapNode;
  var $wrapNodeInElement2 = mod3.$wrapNodeInElement;
  var CAN_USE_BEFORE_INPUT3 = mod3.CAN_USE_BEFORE_INPUT;
  var CAN_USE_DOM3 = mod3.CAN_USE_DOM;
  var IS_ANDROID3 = mod3.IS_ANDROID;
  var IS_ANDROID_CHROME3 = mod3.IS_ANDROID_CHROME;
  var IS_APPLE3 = mod3.IS_APPLE;
  var IS_APPLE_WEBKIT3 = mod3.IS_APPLE_WEBKIT;
  var IS_CHROME3 = mod3.IS_CHROME;
  var IS_FIREFOX3 = mod3.IS_FIREFOX;
  var IS_IOS3 = mod3.IS_IOS;
  var IS_SAFARI3 = mod3.IS_SAFARI;
  var addClassNamesToElement2 = mod3.addClassNamesToElement;
  var calculateZoomLevel2 = mod3.calculateZoomLevel;
  var isBlockDomNode3 = mod3.isBlockDomNode;
  var isHTMLAnchorElement3 = mod3.isHTMLAnchorElement;
  var isHTMLElement3 = mod3.isHTMLElement;
  var isInlineDomNode3 = mod3.isInlineDomNode;
  var isMimeType2 = mod3.isMimeType;
  var makeStateWrapper2 = mod3.makeStateWrapper;
  var markSelection2 = mod3.markSelection;
  var mediaFileReader2 = mod3.mediaFileReader;
  var mergeRegister2 = mod3.mergeRegister;
  var objectKlassEquals2 = mod3.objectKlassEquals;
  var positionNodeOnRange = mod3.positionNodeOnRange;
  var registerNestedElementResolver2 = mod3.registerNestedElementResolver;
  var removeClassNamesFromElement2 = mod3.removeClassNamesFromElement;
  var selectionAlwaysOnDisplay2 = mod3.selectionAlwaysOnDisplay;

  // node_modules/@lexical/extension/LexicalExtension.dev.mjs
  var i = Symbol.for("preact-signals");
  function t() {
    if (r > 1) {
      r--;
      return;
    }
    let i2, t2 = false;
    while (void 0 !== s) {
      let o2 = s;
      s = void 0;
      f++;
      while (void 0 !== o2) {
        const n2 = o2.o;
        o2.o = void 0;
        o2.f &= -3;
        if (!(8 & o2.f) && v(o2)) try {
          o2.c();
        } catch (o3) {
          if (!t2) {
            i2 = o3;
            t2 = true;
          }
        }
        o2 = n2;
      }
    }
    f = 0;
    r--;
    if (t2) throw i2;
  }
  function o(i2) {
    if (r > 0) return i2();
    r++;
    try {
      return i2();
    } finally {
      t();
    }
  }
  var n;
  var s;
  function h(i2) {
    const t2 = n;
    n = void 0;
    try {
      return i2();
    } finally {
      n = t2;
    }
  }
  var r = 0;
  var f = 0;
  var e = 0;
  function u(i2) {
    if (void 0 === n) return;
    let t2 = i2.n;
    if (void 0 === t2 || t2.t !== n) {
      t2 = { i: 0, S: i2, p: n.s, n: void 0, t: n, e: void 0, x: void 0, r: t2 };
      if (void 0 !== n.s) n.s.n = t2;
      n.s = t2;
      i2.n = t2;
      if (32 & n.f) i2.S(t2);
      return t2;
    } else if (-1 === t2.i) {
      t2.i = 0;
      if (void 0 !== t2.n) {
        t2.n.p = t2.p;
        if (void 0 !== t2.p) t2.p.n = t2.n;
        t2.p = n.s;
        t2.n = void 0;
        n.s.n = t2;
        n.s = t2;
      }
      return t2;
    }
  }
  function c(i2, t2) {
    this.v = i2;
    this.i = 0;
    this.n = void 0;
    this.t = void 0;
    this.W = null == t2 ? void 0 : t2.watched;
    this.Z = null == t2 ? void 0 : t2.unwatched;
    this.name = null == t2 ? void 0 : t2.name;
  }
  c.prototype.brand = i;
  c.prototype.h = function() {
    return true;
  };
  c.prototype.S = function(i2) {
    const t2 = this.t;
    if (t2 !== i2 && void 0 === i2.e) {
      i2.x = t2;
      this.t = i2;
      if (void 0 !== t2) t2.e = i2;
      else h(() => {
        var i3;
        null == (i3 = this.W) || i3.call(this);
      });
    }
  };
  c.prototype.U = function(i2) {
    if (void 0 !== this.t) {
      const t2 = i2.e, o2 = i2.x;
      if (void 0 !== t2) {
        t2.x = o2;
        i2.e = void 0;
      }
      if (void 0 !== o2) {
        o2.e = t2;
        i2.x = void 0;
      }
      if (i2 === this.t) {
        this.t = o2;
        if (void 0 === o2) h(() => {
          var i3;
          null == (i3 = this.Z) || i3.call(this);
        });
      }
    }
  };
  c.prototype.subscribe = function(i2) {
    return E(() => {
      const t2 = this.value, o2 = n;
      n = void 0;
      try {
        i2(t2);
      } finally {
        n = o2;
      }
    }, { name: "sub" });
  };
  c.prototype.valueOf = function() {
    return this.value;
  };
  c.prototype.toString = function() {
    return this.value + "";
  };
  c.prototype.toJSON = function() {
    return this.value;
  };
  c.prototype.peek = function() {
    const i2 = n;
    n = void 0;
    try {
      return this.value;
    } finally {
      n = i2;
    }
  };
  Object.defineProperty(c.prototype, "value", { get() {
    const i2 = u(this);
    if (void 0 !== i2) i2.i = this.i;
    return this.v;
  }, set(i2) {
    if (i2 !== this.v) {
      if (f > 100) throw new Error("Cycle detected");
      this.v = i2;
      this.i++;
      e++;
      r++;
      try {
        for (let i3 = this.t; void 0 !== i3; i3 = i3.x) i3.t.N();
      } finally {
        t();
      }
    }
  } });
  function d(i2, t2) {
    return new c(i2, t2);
  }
  function v(i2) {
    for (let t2 = i2.s; void 0 !== t2; t2 = t2.n) if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i) return true;
    return false;
  }
  function l(i2) {
    for (let t2 = i2.s; void 0 !== t2; t2 = t2.n) {
      const o2 = t2.S.n;
      if (void 0 !== o2) t2.r = o2;
      t2.S.n = t2;
      t2.i = -1;
      if (void 0 === t2.n) {
        i2.s = t2;
        break;
      }
    }
  }
  function y(i2) {
    let t2, o2 = i2.s;
    while (void 0 !== o2) {
      const i3 = o2.p;
      if (-1 === o2.i) {
        o2.S.U(o2);
        if (void 0 !== i3) i3.n = o2.n;
        if (void 0 !== o2.n) o2.n.p = i3;
      } else t2 = o2;
      o2.S.n = o2.r;
      if (void 0 !== o2.r) o2.r = void 0;
      o2 = i3;
    }
    i2.s = t2;
  }
  function a(i2, t2) {
    c.call(this, void 0);
    this.x = i2;
    this.s = void 0;
    this.g = e - 1;
    this.f = 4;
    this.W = null == t2 ? void 0 : t2.watched;
    this.Z = null == t2 ? void 0 : t2.unwatched;
    this.name = null == t2 ? void 0 : t2.name;
  }
  a.prototype = new c();
  a.prototype.h = function() {
    this.f &= -3;
    if (1 & this.f) return false;
    if (32 == (36 & this.f)) return true;
    this.f &= -5;
    if (this.g === e) return true;
    this.g = e;
    this.f |= 1;
    if (this.i > 0 && !v(this)) {
      this.f &= -2;
      return true;
    }
    const i2 = n;
    try {
      l(this);
      n = this;
      const i3 = this.x();
      if (16 & this.f || this.v !== i3 || 0 === this.i) {
        this.v = i3;
        this.f &= -17;
        this.i++;
      }
    } catch (i3) {
      this.v = i3;
      this.f |= 16;
      this.i++;
    }
    n = i2;
    y(this);
    this.f &= -2;
    return true;
  };
  a.prototype.S = function(i2) {
    if (void 0 === this.t) {
      this.f |= 36;
      for (let i3 = this.s; void 0 !== i3; i3 = i3.n) i3.S.S(i3);
    }
    c.prototype.S.call(this, i2);
  };
  a.prototype.U = function(i2) {
    if (void 0 !== this.t) {
      c.prototype.U.call(this, i2);
      if (void 0 === this.t) {
        this.f &= -33;
        for (let i3 = this.s; void 0 !== i3; i3 = i3.n) i3.S.U(i3);
      }
    }
  };
  a.prototype.N = function() {
    if (!(2 & this.f)) {
      this.f |= 6;
      for (let i2 = this.t; void 0 !== i2; i2 = i2.x) i2.t.N();
    }
  };
  Object.defineProperty(a.prototype, "value", { get() {
    if (1 & this.f) throw new Error("Cycle detected");
    const i2 = u(this);
    this.h();
    if (void 0 !== i2) i2.i = this.i;
    if (16 & this.f) throw this.v;
    return this.v;
  } });
  function w(i2, t2) {
    return new a(i2, t2);
  }
  function _(i2) {
    const o2 = i2.u;
    i2.u = void 0;
    if ("function" == typeof o2) {
      r++;
      const s2 = n;
      n = void 0;
      try {
        o2();
      } catch (t2) {
        i2.f &= -2;
        i2.f |= 8;
        b(i2);
        throw t2;
      } finally {
        n = s2;
        t();
      }
    }
  }
  function b(i2) {
    for (let t2 = i2.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
    i2.x = void 0;
    i2.s = void 0;
    _(i2);
  }
  function g(i2) {
    if (n !== this) throw new Error("Out-of-order effect");
    y(this);
    n = i2;
    this.f &= -2;
    if (8 & this.f) b(this);
    t();
  }
  function p(i2, t2) {
    this.x = i2;
    this.u = void 0;
    this.s = void 0;
    this.o = void 0;
    this.f = 32;
    this.name = null == t2 ? void 0 : t2.name;
  }
  p.prototype.c = function() {
    const i2 = this.S();
    try {
      if (8 & this.f) return;
      if (void 0 === this.x) return;
      const t2 = this.x();
      if ("function" == typeof t2) this.u = t2;
    } finally {
      i2();
    }
  };
  p.prototype.S = function() {
    if (1 & this.f) throw new Error("Cycle detected");
    this.f |= 1;
    this.f &= -9;
    _(this);
    l(this);
    r++;
    const i2 = n;
    n = this;
    return g.bind(this, i2);
  };
  p.prototype.N = function() {
    if (!(2 & this.f)) {
      this.f |= 2;
      this.o = s;
      s = this;
    }
  };
  p.prototype.d = function() {
    this.f |= 8;
    if (!(1 & this.f)) b(this);
  };
  p.prototype.dispose = function() {
    this.d();
  };
  function E(i2, t2) {
    const o2 = new p(i2, t2);
    try {
      o2.c();
    } catch (i3) {
      o2.d();
      throw i3;
    }
    const n2 = o2.d.bind(o2);
    n2[Symbol.dispose] = n2;
    return n2;
  }
  function namedSignals(defaults2, opts = {}) {
    const initial = {};
    for (const k2 in defaults2) {
      const v3 = opts[k2];
      const store2 = d(v3 === void 0 ? defaults2[k2] : v3);
      initial[k2] = store2;
    }
    return initial;
  }
  var AutoFocusExtension = defineExtension2({
    build: (editor, config, state) => {
      return namedSignals(config);
    },
    config: safeCast2({
      defaultSelection: "rootEnd",
      disabled: false
    }),
    name: "@lexical/extension/AutoFocus",
    register(editor, config, state) {
      const stores2 = state.getOutput();
      return E(() => stores2.disabled.value ? void 0 : editor.registerRootListener((rootElement) => {
        editor.focus(() => {
          const activeElement = document.activeElement;
          if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {
            rootElement.focus({
              preventScroll: true
            });
          }
        }, {
          defaultSelection: stores2.defaultSelection.peek()
        });
      }));
    }
  });
  function $defaultOnClear() {
    const root = $getRoot2();
    const selection = $getSelection2();
    const paragraph = $createParagraphNode2();
    root.clear();
    root.append(paragraph);
    if (selection !== null) {
      paragraph.select();
    }
    if ($isRangeSelection2(selection)) {
      selection.format = 0;
    }
  }
  function registerClearEditor(editor, $onClear = $defaultOnClear) {
    return editor.registerCommand(CLEAR_EDITOR_COMMAND2, (payload) => {
      editor.update($onClear);
      return true;
    }, COMMAND_PRIORITY_EDITOR2);
  }
  var ClearEditorExtension = defineExtension2({
    build(editor, config, state) {
      return namedSignals(config);
    },
    config: safeCast2({
      $onClear: $defaultOnClear
    }),
    name: "@lexical/extension/ClearEditor",
    register(editor, config, state) {
      const {
        $onClear
      } = state.getOutput();
      return E(() => registerClearEditor(editor, $onClear.value));
    }
  });
  function getKnownTypesAndNodes(config) {
    const types = /* @__PURE__ */ new Set();
    const nodes = /* @__PURE__ */ new Set();
    for (const klassOrReplacement of getNodeConfig(config)) {
      const klass = typeof klassOrReplacement === "function" ? klassOrReplacement : klassOrReplacement.replace;
      types.add(klass.getType());
      nodes.add(klass);
    }
    return {
      nodes,
      types
    };
  }
  function getNodeConfig(config) {
    return (typeof config.nodes === "function" ? config.nodes() : config.nodes) || [];
  }
  function watchedSignal(getSnapshot, register) {
    let dispose;
    return d(getSnapshot(), {
      unwatched() {
        if (dispose) {
          dispose();
          dispose = void 0;
        }
      },
      watched() {
        this.value = getSnapshot();
        dispose = register(this);
      }
    });
  }
  var EditorStateExtension = defineExtension2({
    build(editor) {
      return watchedSignal(() => editor.getEditorState(), (editorStateSignal) => editor.registerUpdateListener((payload) => {
        editorStateSignal.value = payload.editorState;
      }));
    },
    name: "@lexical/extension/EditorState"
  });
  function formatDevErrorMessage4(message) {
    throw new Error(message);
  }
  function deepThemeMergeInPlace(a2, b3) {
    if (a2 && b3 && !Array.isArray(b3) && typeof a2 === "object" && typeof b3 === "object") {
      const aObj = a2;
      const bObj = b3;
      for (const k2 in bObj) {
        aObj[k2] = deepThemeMergeInPlace(aObj[k2], bObj[k2]);
      }
      return a2;
    }
    return b3;
  }
  var ExtensionRepStateIds = {
    /* eslint-disable sort-keys-fix/sort-keys-fix */
    unmarked: 0,
    temporary: 1,
    permanent: 2,
    configured: 3,
    initialized: 4,
    built: 5,
    registered: 6,
    afterRegistration: 7
    /* eslint-enable sort-keys-fix/sort-keys-fix */
  };
  function isExactlyUnmarkedExtensionRepState(state) {
    return state.id === ExtensionRepStateIds.unmarked;
  }
  function isExactlyTemporaryExtensionRepState(state) {
    return state.id === ExtensionRepStateIds.temporary;
  }
  function isExactlyPermanentExtensionRepState(state) {
    return state.id === ExtensionRepStateIds.permanent;
  }
  function isConfiguredExtensionRepState(state) {
    return state.id >= ExtensionRepStateIds.configured;
  }
  function isInitializedExtensionRepState(state) {
    return state.id >= ExtensionRepStateIds.initialized;
  }
  function isBuiltExtensionRepState(state) {
    return state.id >= ExtensionRepStateIds.built;
  }
  function isAfterRegistrationState(state) {
    return state.id >= ExtensionRepStateIds.afterRegistration;
  }
  function applyTemporaryMark(state) {
    if (!isExactlyUnmarkedExtensionRepState(state)) {
      formatDevErrorMessage4(`LexicalBuilder: Can not apply a temporary mark from state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.unmarked)} unmarked)`);
    }
    return Object.assign(state, {
      id: ExtensionRepStateIds.temporary
    });
  }
  function applyPermanentMark(state) {
    if (!isExactlyTemporaryExtensionRepState(state)) {
      formatDevErrorMessage4(`LexicalBuilder: Can not apply a permanent mark from state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.temporary)} temporary)`);
    }
    return Object.assign(state, {
      id: ExtensionRepStateIds.permanent
    });
  }
  function applyConfiguredState(state, config, registerState) {
    return Object.assign(state, {
      config,
      id: ExtensionRepStateIds.configured,
      registerState
    });
  }
  function applyInitializedState(state, initResult, registerState) {
    return Object.assign(state, {
      id: ExtensionRepStateIds.initialized,
      initResult,
      registerState
    });
  }
  function applyBuiltState(state, output, registerState) {
    return Object.assign(state, {
      id: ExtensionRepStateIds.built,
      output,
      registerState
    });
  }
  function applyRegisteredState(state) {
    return Object.assign(state, {
      id: ExtensionRepStateIds.registered
    });
  }
  function applyAfterRegistrationState(state) {
    return Object.assign(state, {
      id: ExtensionRepStateIds.afterRegistration
    });
  }
  function rollbackToBuiltState(state) {
    return Object.assign(state, {
      id: ExtensionRepStateIds.built
    });
  }
  var emptySet = /* @__PURE__ */ new Set();
  var ExtensionRep = class {
    builder;
    configs;
    _dependency;
    _peerNameSet;
    extension;
    state;
    _signal;
    constructor(builder, extension) {
      this.builder = builder;
      this.extension = extension;
      this.configs = /* @__PURE__ */ new Set();
      this.state = {
        id: ExtensionRepStateIds.unmarked
      };
    }
    mergeConfigs() {
      let config = this.extension.config || {};
      const mergeConfig = this.extension.mergeConfig ? this.extension.mergeConfig.bind(this.extension) : shallowMergeConfig2;
      for (const cfg of this.configs) {
        config = mergeConfig(config, cfg);
      }
      return config;
    }
    init(editorConfig) {
      const initialState = this.state;
      if (!isExactlyPermanentExtensionRepState(initialState)) {
        formatDevErrorMessage4(`ExtensionRep: Can not configure from state id ${String(initialState.id)}`);
      }
      const initState = {
        getDependency: this.getInitDependency.bind(this),
        getDirectDependentNames: this.getDirectDependentNames.bind(this),
        getPeer: this.getInitPeer.bind(this),
        getPeerNameSet: this.getPeerNameSet.bind(this)
      };
      const buildState = {
        ...initState,
        getDependency: this.getDependency.bind(this),
        getInitResult: this.getInitResult.bind(this),
        getPeer: this.getPeer.bind(this)
      };
      const state = applyConfiguredState(initialState, this.mergeConfigs(), initState);
      this.state = state;
      let initResult;
      if (this.extension.init) {
        initResult = this.extension.init(editorConfig, state.config, initState);
      }
      this.state = applyInitializedState(state, initResult, buildState);
    }
    build(editor) {
      const state = this.state;
      if (!(state.id === ExtensionRepStateIds.initialized)) {
        formatDevErrorMessage4(`ExtensionRep: register called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.built)} initialized)`);
      }
      let output;
      if (this.extension.build) {
        output = this.extension.build(editor, state.config, state.registerState);
      }
      const registerState = {
        ...state.registerState,
        getOutput: () => output,
        getSignal: this.getSignal.bind(this)
      };
      this.state = applyBuiltState(state, output, registerState);
    }
    register(editor, signal2) {
      this._signal = signal2;
      const state = this.state;
      if (!(state.id === ExtensionRepStateIds.built)) {
        formatDevErrorMessage4(`ExtensionRep: register called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.built)} built)`);
      }
      const cleanup2 = this.extension.register && this.extension.register(editor, state.config, state.registerState);
      this.state = applyRegisteredState(state);
      return () => {
        const afterRegistrationState = this.state;
        if (!(afterRegistrationState.id === ExtensionRepStateIds.afterRegistration)) {
          formatDevErrorMessage4(`ExtensionRep: rollbackToBuiltState called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.afterRegistration)} afterRegistration)`);
        }
        this.state = rollbackToBuiltState(afterRegistrationState);
        if (cleanup2) {
          cleanup2();
        }
      };
    }
    afterRegistration(editor) {
      const state = this.state;
      if (!(state.id === ExtensionRepStateIds.registered)) {
        formatDevErrorMessage4(`ExtensionRep: afterRegistration called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.registered)} registered)`);
      }
      let rval;
      if (this.extension.afterRegistration) {
        rval = this.extension.afterRegistration(editor, state.config, state.registerState);
      }
      this.state = applyAfterRegistrationState(state);
      return rval;
    }
    getSignal() {
      if (!(this._signal !== void 0)) {
        formatDevErrorMessage4(`ExtensionRep.getSignal() called before register`);
      }
      return this._signal;
    }
    getInitResult() {
      if (!(this.extension.init !== void 0)) {
        formatDevErrorMessage4(`ExtensionRep: getInitResult() called for Extension ${this.extension.name} that does not define init`);
      }
      const state = this.state;
      if (!isInitializedExtensionRepState(state)) {
        formatDevErrorMessage4(`ExtensionRep: getInitResult() called for ExtensionRep in state id ${String(state.id)} < ${String(ExtensionRepStateIds.initialized)} (initialized)`);
      }
      return state.initResult;
    }
    getInitPeer(name) {
      const rep = this.builder.extensionNameMap.get(name);
      return rep ? rep.getExtensionInitDependency() : void 0;
    }
    getExtensionInitDependency() {
      const state = this.state;
      if (!isConfiguredExtensionRepState(state)) {
        formatDevErrorMessage4(`ExtensionRep: getExtensionInitDependency called in state id ${String(state.id)} (expected >= ${String(ExtensionRepStateIds.configured)} configured)`);
      }
      return {
        config: state.config
      };
    }
    getPeer(name) {
      const rep = this.builder.extensionNameMap.get(name);
      return rep ? rep.getExtensionDependency() : void 0;
    }
    getInitDependency(dep) {
      const rep = this.builder.getExtensionRep(dep);
      if (!(rep !== void 0)) {
        formatDevErrorMessage4(`LexicalExtensionBuilder: Extension ${this.extension.name} missing dependency extension ${dep.name} to be in registry`);
      }
      return rep.getExtensionInitDependency();
    }
    getDependency(dep) {
      const rep = this.builder.getExtensionRep(dep);
      if (!(rep !== void 0)) {
        formatDevErrorMessage4(`LexicalExtensionBuilder: Extension ${this.extension.name} missing dependency extension ${dep.name} to be in registry`);
      }
      return rep.getExtensionDependency();
    }
    getState() {
      const state = this.state;
      if (!isAfterRegistrationState(state)) {
        formatDevErrorMessage4(`ExtensionRep getState called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.afterRegistration)} afterRegistration)`);
      }
      return state;
    }
    getDirectDependentNames() {
      return this.builder.incomingEdges.get(this.extension.name) || emptySet;
    }
    getPeerNameSet() {
      let s2 = this._peerNameSet;
      if (!s2) {
        s2 = new Set((this.extension.peerDependencies || []).map(([name]) => name));
        this._peerNameSet = s2;
      }
      return s2;
    }
    getExtensionDependency() {
      if (!this._dependency) {
        const state = this.state;
        if (!isBuiltExtensionRepState(state)) {
          formatDevErrorMessage4(`Extension ${this.extension.name} used as a dependency before build`);
        }
        this._dependency = {
          config: state.config,
          init: state.initResult,
          output: state.output
        };
      }
      return this._dependency;
    }
  };
  var HISTORY_MERGE_OPTIONS = {
    tag: HISTORY_MERGE_TAG2
  };
  function $defaultInitializer() {
    const root = $getRoot2();
    if (root.isEmpty()) {
      root.append($createParagraphNode2());
    }
  }
  var InitialStateExtension = defineExtension2({
    config: safeCast2({
      setOptions: HISTORY_MERGE_OPTIONS,
      updateOptions: HISTORY_MERGE_OPTIONS
    }),
    init({
      $initialEditorState = $defaultInitializer
    }) {
      return {
        $initialEditorState,
        initialized: false
      };
    },
    // eslint-disable-next-line sort-keys-fix/sort-keys-fix -- typescript inference is order dependent here for some reason
    afterRegistration(editor, {
      updateOptions,
      setOptions
    }, state) {
      const initResult = state.getInitResult();
      if (!initResult.initialized) {
        initResult.initialized = true;
        const {
          $initialEditorState
        } = initResult;
        if ($isEditorState2($initialEditorState)) {
          editor.setEditorState($initialEditorState, setOptions);
        } else if (typeof $initialEditorState === "function") {
          editor.update(() => {
            $initialEditorState(editor);
          }, updateOptions);
        } else if ($initialEditorState && (typeof $initialEditorState === "string" || typeof $initialEditorState === "object")) {
          const parsedEditorState = editor.parseEditorState($initialEditorState);
          editor.setEditorState(parsedEditorState, setOptions);
        }
      }
      return () => {
      };
    },
    name: "@lexical/extension/InitialState",
    // These are automatically added by createEditor, we add them here so they are
    // visible during extensionRep.init so extensions can see all known types before the
    // editor is created.
    // (excluding ArtificialNode__DO_NOT_USE because it isn't really public API
    // and shouldn't change anything)
    nodes: [RootNode2, TextNode2, LineBreakNode2, TabNode2, ParagraphNode2]
  });
  var builderSymbol = Symbol.for("@lexical/extension/LexicalBuilder");
  function buildEditorFromExtensions(...extensions) {
    return LexicalBuilder.fromExtensions(extensions).buildEditor();
  }
  function noop2() {
  }
  function defaultOnError(err) {
    throw err;
  }
  function maybeWithBuilder(editor) {
    return editor;
  }
  function normalizeExtensionArgument(arg) {
    return Array.isArray(arg) ? arg : [arg];
  }
  var PACKAGE_VERSION = "0.38.2+dev.esm";
  var LexicalBuilder = class _LexicalBuilder {
    roots;
    extensionNameMap;
    outgoingConfigEdges;
    incomingEdges;
    conflicts;
    _sortedExtensionReps;
    PACKAGE_VERSION;
    constructor(roots) {
      this.outgoingConfigEdges = /* @__PURE__ */ new Map();
      this.incomingEdges = /* @__PURE__ */ new Map();
      this.extensionNameMap = /* @__PURE__ */ new Map();
      this.conflicts = /* @__PURE__ */ new Map();
      this.PACKAGE_VERSION = PACKAGE_VERSION;
      this.roots = roots;
      for (const extension of roots) {
        this.addExtension(extension);
      }
    }
    static fromExtensions(extensions) {
      const roots = [normalizeExtensionArgument(InitialStateExtension)];
      for (const extension of extensions) {
        roots.push(normalizeExtensionArgument(extension));
      }
      return new _LexicalBuilder(roots);
    }
    static maybeFromEditor(editor) {
      const builder = maybeWithBuilder(editor)[builderSymbol];
      if (builder) {
        if (!(builder.PACKAGE_VERSION === PACKAGE_VERSION)) {
          formatDevErrorMessage4(`LexicalBuilder.fromEditor: The given editor was created with LexicalBuilder ${builder.PACKAGE_VERSION} but this version is ${PACKAGE_VERSION}. A project should have exactly one copy of LexicalBuilder`);
        }
        if (!(builder instanceof _LexicalBuilder)) {
          formatDevErrorMessage4(`LexicalBuilder.fromEditor: There are multiple copies of the same version of LexicalBuilder in your project, and this editor was created with another one. Your project, or one of its dependencies, has its package.json and/or bundler configured incorrectly.`);
        }
      }
      return builder;
    }
    /** Look up the editor that was created by this LexicalBuilder or throw */
    static fromEditor(editor) {
      const builder = _LexicalBuilder.maybeFromEditor(editor);
      if (!(builder !== void 0)) {
        formatDevErrorMessage4(`LexicalBuilder.fromEditor: The given editor was not created with LexicalBuilder`);
      }
      return builder;
    }
    constructEditor() {
      const {
        $initialEditorState: _$initialEditorState,
        onError,
        ...editorConfig
      } = this.buildCreateEditorArgs();
      const editor = Object.assign(createEditor2({
        ...editorConfig,
        ...onError ? {
          onError: (err) => {
            onError(err, editor);
          }
        } : {}
      }), {
        [builderSymbol]: this
      });
      for (const extensionRep of this.sortedExtensionReps()) {
        extensionRep.build(editor);
      }
      return editor;
    }
    buildEditor() {
      let disposeOnce = noop2;
      function dispose() {
        try {
          disposeOnce();
        } finally {
          disposeOnce = noop2;
        }
      }
      const editor = Object.assign(this.constructEditor(), {
        dispose,
        [Symbol.dispose]: dispose
      });
      disposeOnce = mergeRegister2(this.registerEditor(editor), () => editor.setRootElement(null));
      return editor;
    }
    hasExtensionByName(name) {
      return this.extensionNameMap.has(name);
    }
    getExtensionRep(extension) {
      const rep = this.extensionNameMap.get(extension.name);
      if (rep) {
        if (!(rep.extension === extension)) {
          formatDevErrorMessage4(`LexicalBuilder: A registered extension with name ${extension.name} exists but does not match the given extension`);
        }
        return rep;
      }
    }
    addEdge(fromExtensionName, toExtensionName, configs) {
      const outgoing = this.outgoingConfigEdges.get(fromExtensionName);
      if (outgoing) {
        outgoing.set(toExtensionName, configs);
      } else {
        this.outgoingConfigEdges.set(fromExtensionName, /* @__PURE__ */ new Map([[toExtensionName, configs]]));
      }
      const incoming = this.incomingEdges.get(toExtensionName);
      if (incoming) {
        incoming.add(fromExtensionName);
      } else {
        this.incomingEdges.set(toExtensionName, /* @__PURE__ */ new Set([fromExtensionName]));
      }
    }
    addExtension(arg) {
      if (!(this._sortedExtensionReps === void 0)) {
        formatDevErrorMessage4(`LexicalBuilder: addExtension called after finalization`);
      }
      const normalized = normalizeExtensionArgument(arg);
      const [extension] = normalized;
      if (!(typeof extension.name === "string")) {
        formatDevErrorMessage4(`LexicalBuilder: extension name must be string, not ${typeof extension.name}`);
      }
      let extensionRep = this.extensionNameMap.get(extension.name);
      if (!(extensionRep === void 0 || extensionRep.extension === extension)) {
        formatDevErrorMessage4(`LexicalBuilder: Multiple extensions registered with name ${extension.name}, names must be unique`);
      }
      if (!extensionRep) {
        extensionRep = new ExtensionRep(this, extension);
        this.extensionNameMap.set(extension.name, extensionRep);
        const hasConflict = this.conflicts.get(extension.name);
        if (typeof hasConflict === "string") {
          {
            formatDevErrorMessage4(`LexicalBuilder: extension ${extension.name} conflicts with ${hasConflict}`);
          }
        }
        for (const name of extension.conflictsWith || []) {
          if (!!this.extensionNameMap.has(name)) {
            formatDevErrorMessage4(`LexicalBuilder: extension ${extension.name} conflicts with ${name}`);
          }
          this.conflicts.set(name, extension.name);
        }
        for (const dep of extension.dependencies || []) {
          const normDep = normalizeExtensionArgument(dep);
          this.addEdge(extension.name, normDep[0].name, normDep.slice(1));
          this.addExtension(normDep);
        }
        for (const [depName, config] of extension.peerDependencies || []) {
          this.addEdge(extension.name, depName, config ? [config] : []);
        }
      }
    }
    sortedExtensionReps() {
      if (this._sortedExtensionReps) {
        return this._sortedExtensionReps;
      }
      const sortedExtensionReps = [];
      const visit = (rep, fromExtensionName) => {
        let mark = rep.state;
        if (isExactlyPermanentExtensionRepState(mark)) {
          return;
        }
        const extensionName = rep.extension.name;
        if (!isExactlyUnmarkedExtensionRepState(mark)) {
          formatDevErrorMessage4(`LexicalBuilder: Circular dependency detected for Extension ${extensionName} from ${fromExtensionName || "[unknown]"}`);
        }
        mark = applyTemporaryMark(mark);
        rep.state = mark;
        const outgoingConfigEdges = this.outgoingConfigEdges.get(extensionName);
        if (outgoingConfigEdges) {
          for (const toExtensionName of outgoingConfigEdges.keys()) {
            const toRep = this.extensionNameMap.get(toExtensionName);
            if (toRep) {
              visit(toRep, extensionName);
            }
          }
        }
        mark = applyPermanentMark(mark);
        rep.state = mark;
        sortedExtensionReps.push(rep);
      };
      for (const rep of this.extensionNameMap.values()) {
        if (isExactlyUnmarkedExtensionRepState(rep.state)) {
          visit(rep);
        }
      }
      for (const rep of sortedExtensionReps) {
        for (const [toExtensionName, configs] of this.outgoingConfigEdges.get(rep.extension.name) || []) {
          if (configs.length > 0) {
            const toRep = this.extensionNameMap.get(toExtensionName);
            if (toRep) {
              for (const config of configs) {
                toRep.configs.add(config);
              }
            }
          }
        }
      }
      for (const [extension, ...configs] of this.roots) {
        if (configs.length > 0) {
          const toRep = this.extensionNameMap.get(extension.name);
          if (!(toRep !== void 0)) {
            formatDevErrorMessage4(`LexicalBuilder: Expecting existing ExtensionRep for ${extension.name}`);
          }
          for (const config of configs) {
            toRep.configs.add(config);
          }
        }
      }
      this._sortedExtensionReps = sortedExtensionReps;
      return this._sortedExtensionReps;
    }
    registerEditor(editor) {
      const extensionReps = this.sortedExtensionReps();
      const controller = new AbortController();
      const cleanups = [() => controller.abort()];
      const signal2 = controller.signal;
      for (const extensionRep of extensionReps) {
        const cleanup2 = extensionRep.register(editor, signal2);
        if (cleanup2) {
          cleanups.push(cleanup2);
        }
      }
      for (const extensionRep of extensionReps) {
        const cleanup2 = extensionRep.afterRegistration(editor);
        if (cleanup2) {
          cleanups.push(cleanup2);
        }
      }
      return mergeRegister2(...cleanups);
    }
    buildCreateEditorArgs() {
      const config = {};
      const nodes = /* @__PURE__ */ new Set();
      const replacedNodes = /* @__PURE__ */ new Map();
      const htmlExport = /* @__PURE__ */ new Map();
      const htmlImport = {};
      const theme2 = {};
      const extensionReps = this.sortedExtensionReps();
      for (const extensionRep of extensionReps) {
        const {
          extension
        } = extensionRep;
        if (extension.onError !== void 0) {
          config.onError = extension.onError;
        }
        if (extension.disableEvents !== void 0) {
          config.disableEvents = extension.disableEvents;
        }
        if (extension.parentEditor !== void 0) {
          config.parentEditor = extension.parentEditor;
        }
        if (extension.editable !== void 0) {
          config.editable = extension.editable;
        }
        if (extension.namespace !== void 0) {
          config.namespace = extension.namespace;
        }
        if (extension.$initialEditorState !== void 0) {
          config.$initialEditorState = extension.$initialEditorState;
        }
        if (extension.nodes) {
          for (const node of getNodeConfig(extension)) {
            if (typeof node !== "function") {
              const conflictExtension = replacedNodes.get(node.replace);
              if (conflictExtension) {
                {
                  formatDevErrorMessage4(`LexicalBuilder: Extension ${extension.name} can not register replacement for node ${node.replace.name} because ${conflictExtension.extension.name} already did`);
                }
              }
              replacedNodes.set(node.replace, extensionRep);
            }
            nodes.add(node);
          }
        }
        if (extension.html) {
          if (extension.html.export) {
            for (const [k2, v3] of extension.html.export.entries()) {
              htmlExport.set(k2, v3);
            }
          }
          if (extension.html.import) {
            Object.assign(htmlImport, extension.html.import);
          }
        }
        if (extension.theme) {
          deepThemeMergeInPlace(theme2, extension.theme);
        }
      }
      if (Object.keys(theme2).length > 0) {
        config.theme = theme2;
      }
      if (nodes.size) {
        config.nodes = [...nodes];
      }
      const hasImport = Object.keys(htmlImport).length > 0;
      const hasExport = htmlExport.size > 0;
      if (hasImport || hasExport) {
        config.html = {};
        if (hasImport) {
          config.html.import = htmlImport;
        }
        if (hasExport) {
          config.html.export = htmlExport;
        }
      }
      for (const extensionRep of extensionReps) {
        extensionRep.init(config);
      }
      if (!config.onError) {
        config.onError = defaultOnError;
      }
      return config;
    }
  };
  function getExtensionDependencyFromEditor(editor, extension) {
    const builder = LexicalBuilder.fromEditor(editor);
    const rep = builder.getExtensionRep(extension);
    if (!(rep !== void 0)) {
      formatDevErrorMessage4(`getExtensionDependencyFromEditor: Extension ${extension.name} was not built when creating this editor`);
    }
    return rep.getExtensionDependency();
  }
  function getPeerDependencyFromEditor(editor, extensionName) {
    const builder = LexicalBuilder.fromEditor(editor);
    const peer = builder.extensionNameMap.get(extensionName);
    return peer ? peer.getExtensionDependency() : void 0;
  }
  function getPeerDependencyFromEditorOrThrow(editor, extensionName) {
    const dep = getPeerDependencyFromEditor(editor, extensionName);
    if (!(dep !== void 0)) {
      formatDevErrorMessage4(`getPeerDependencyFromEditorOrThrow: Editor was not built with Extension ${extensionName}`);
    }
    return dep;
  }
  var EMPTY_SET = /* @__PURE__ */ new Set();
  var NodeSelectionExtension = defineExtension2({
    build(editor, config, state) {
      const editorStateStore = state.getDependency(EditorStateExtension).output;
      const watchedNodeStore = d({
        watchedNodeKeys: /* @__PURE__ */ new Map()
      });
      const selectedNodeKeys = watchedSignal(() => void 0, () => E(() => {
        const prevSelectedNodeKeys = selectedNodeKeys.peek();
        const {
          watchedNodeKeys
        } = watchedNodeStore.value;
        let nextSelectedNodeKeys;
        let didChange = false;
        editorStateStore.value.read(() => {
          const selection = $getSelection2();
          if (selection) {
            for (const [key, listeners] of watchedNodeKeys.entries()) {
              if (listeners.size === 0) {
                watchedNodeKeys.delete(key);
                continue;
              }
              const node = $getNodeByKey2(key);
              const isSelected = node && node.isSelected() || false;
              didChange = didChange || isSelected !== (prevSelectedNodeKeys ? prevSelectedNodeKeys.has(key) : false);
              if (isSelected) {
                nextSelectedNodeKeys = nextSelectedNodeKeys || /* @__PURE__ */ new Set();
                nextSelectedNodeKeys.add(key);
              }
            }
          }
        });
        if (!(!didChange && nextSelectedNodeKeys && prevSelectedNodeKeys && nextSelectedNodeKeys.size === prevSelectedNodeKeys.size)) {
          selectedNodeKeys.value = nextSelectedNodeKeys;
        }
      }));
      function watchNodeKey(key) {
        const watcher = w(() => (selectedNodeKeys.value || EMPTY_SET).has(key));
        const {
          watchedNodeKeys
        } = watchedNodeStore.peek();
        let listeners = watchedNodeKeys.get(key);
        const hadListener = listeners !== void 0;
        listeners = listeners || /* @__PURE__ */ new Set();
        listeners.add(watcher);
        if (!hadListener) {
          watchedNodeKeys.set(key, listeners);
          watchedNodeStore.value = {
            watchedNodeKeys
          };
        }
        return watcher;
      }
      return {
        watchNodeKey
      };
    },
    dependencies: [EditorStateExtension],
    name: "@lexical/extension/NodeSelection"
  });
  var INSERT_HORIZONTAL_RULE_COMMAND = createCommand2("INSERT_HORIZONTAL_RULE_COMMAND");
  var HorizontalRuleNode = class _HorizontalRuleNode extends DecoratorNode2 {
    static getType() {
      return "horizontalrule";
    }
    static clone(node) {
      return new _HorizontalRuleNode(node.__key);
    }
    static importJSON(serializedNode) {
      return $createHorizontalRuleNode().updateFromJSON(serializedNode);
    }
    static importDOM() {
      return {
        hr: () => ({
          conversion: $convertHorizontalRuleElement,
          priority: 0
        })
      };
    }
    exportDOM() {
      return {
        element: document.createElement("hr")
      };
    }
    createDOM(config) {
      const element = document.createElement("hr");
      addClassNamesToElement2(element, config.theme.hr);
      return element;
    }
    getTextContent() {
      return "\n";
    }
    isInline() {
      return false;
    }
    updateDOM() {
      return false;
    }
  };
  function $convertHorizontalRuleElement() {
    return {
      node: $createHorizontalRuleNode()
    };
  }
  function $createHorizontalRuleNode() {
    return $create2(HorizontalRuleNode);
  }
  function $isHorizontalRuleNode(node) {
    return node instanceof HorizontalRuleNode;
  }
  function $toggleNodeSelection(node, shiftKey = false) {
    const selection = $getSelection2();
    const wasSelected = node.isSelected();
    const key = node.getKey();
    let nodeSelection;
    if (shiftKey && $isNodeSelection2(selection)) {
      nodeSelection = selection;
    } else {
      nodeSelection = $createNodeSelection2();
      $setSelection2(nodeSelection);
    }
    if (wasSelected) {
      nodeSelection.delete(key);
    } else {
      nodeSelection.add(key);
    }
  }
  var HorizontalRuleExtension = defineExtension2({
    dependencies: [EditorStateExtension, NodeSelectionExtension],
    name: "@lexical/extension/HorizontalRule",
    nodes: [HorizontalRuleNode],
    register(editor, config, state) {
      const {
        watchNodeKey
      } = state.getDependency(NodeSelectionExtension).output;
      const nodeSelectionStore = d({
        nodeSelections: /* @__PURE__ */ new Map()
      });
      const isSelectedClassName = editor._config.theme.hrSelected ?? "selected";
      return mergeRegister2(editor.registerCommand(CLICK_COMMAND2, (event) => {
        if (isDOMNode2(event.target)) {
          const node = $getNodeFromDOMNode2(event.target);
          if ($isHorizontalRuleNode(node)) {
            $toggleNodeSelection(node, event.shiftKey);
            return true;
          }
        }
        return false;
      }, COMMAND_PRIORITY_LOW2), editor.registerMutationListener(HorizontalRuleNode, (nodes, payload) => {
        o(() => {
          let didChange = false;
          const {
            nodeSelections
          } = nodeSelectionStore.peek();
          for (const [k2, v3] of nodes.entries()) {
            if (v3 === "destroyed") {
              nodeSelections.delete(k2);
              didChange = true;
            } else {
              const prev = nodeSelections.get(k2);
              const dom = editor.getElementByKey(k2);
              if (prev) {
                prev.domNode.value = dom;
              } else {
                didChange = true;
                nodeSelections.set(k2, {
                  domNode: d(dom),
                  selectedSignal: watchNodeKey(k2)
                });
              }
            }
          }
          if (didChange) {
            nodeSelectionStore.value = {
              nodeSelections
            };
          }
        });
      }), E(() => {
        const effects2 = [];
        for (const {
          domNode,
          selectedSignal
        } of nodeSelectionStore.value.nodeSelections.values()) {
          effects2.push(E(() => {
            const dom = domNode.value;
            if (dom) {
              const isSelected = selectedSignal.value;
              if (isSelected) {
                addClassNamesToElement2(dom, isSelectedClassName);
              } else {
                removeClassNamesFromElement2(dom, isSelectedClassName);
              }
            }
          }));
        }
        return mergeRegister2(...effects2);
      }));
    }
  });
  function $indentOverTab(selection) {
    const nodes = selection.getNodes();
    const canIndentBlockNodes = $filter2(nodes, (node) => {
      if ($isBlockElementNode2(node) && node.canIndent()) {
        return node;
      }
      return null;
    });
    if (canIndentBlockNodes.length > 0) {
      return true;
    }
    const anchor = selection.anchor;
    const focus = selection.focus;
    const first = focus.isBefore(anchor) ? focus : anchor;
    const firstNode = first.getNode();
    const firstBlock = $getNearestBlockElementAncestorOrThrow2(firstNode);
    if (firstBlock.canIndent()) {
      const firstBlockKey = firstBlock.getKey();
      let selectionAtStart = $createRangeSelection2();
      selectionAtStart.anchor.set(firstBlockKey, 0, "element");
      selectionAtStart.focus.set(firstBlockKey, 0, "element");
      selectionAtStart = $normalizeSelection__EXPERIMENTAL(selectionAtStart);
      if (selectionAtStart.anchor.is(first)) {
        return true;
      }
    }
    return false;
  }
  function registerTabIndentation(editor, maxIndent) {
    return mergeRegister2(editor.registerCommand(KEY_TAB_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      event.preventDefault();
      const command = $indentOverTab(selection) ? event.shiftKey ? OUTDENT_CONTENT_COMMAND2 : INDENT_CONTENT_COMMAND2 : INSERT_TAB_COMMAND2;
      return editor.dispatchCommand(command, void 0);
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INDENT_CONTENT_COMMAND2, () => {
      const currentMaxIndent = typeof maxIndent === "number" ? maxIndent : maxIndent ? maxIndent.peek() : null;
      if (currentMaxIndent == null) {
        return false;
      }
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const indents = selection.getNodes().map((node) => $getNearestBlockElementAncestorOrThrow2(node).getIndent());
      return Math.max(...indents) + 1 >= currentMaxIndent;
    }, COMMAND_PRIORITY_CRITICAL2));
  }
  var TabIndentationExtension = defineExtension2({
    build(editor, config, state) {
      return namedSignals(config);
    },
    config: safeCast2({
      disabled: false,
      maxIndent: null
    }),
    name: "@lexical/extension/TabIndentation",
    register(editor, config, state) {
      const {
        disabled,
        maxIndent
      } = state.getOutput();
      return E(() => {
        if (!disabled.value) {
          return registerTabIndentation(editor, maxIndent);
        }
      });
    }
  });

  // node_modules/@lexical/extension/LexicalExtension.mjs
  var mod4 = true ? LexicalExtension_dev_exports : LexicalExtension_prod_exports;
  var $createHorizontalRuleNode2 = mod4.$createHorizontalRuleNode;
  var $isHorizontalRuleNode2 = mod4.$isHorizontalRuleNode;
  var AutoFocusExtension2 = mod4.AutoFocusExtension;
  var ClearEditorExtension2 = mod4.ClearEditorExtension;
  var EditorStateExtension2 = mod4.EditorStateExtension;
  var HorizontalRuleExtension2 = mod4.HorizontalRuleExtension;
  var HorizontalRuleNode2 = mod4.HorizontalRuleNode;
  var INSERT_HORIZONTAL_RULE_COMMAND2 = mod4.INSERT_HORIZONTAL_RULE_COMMAND;
  var InitialStateExtension2 = mod4.InitialStateExtension;
  var LexicalBuilder2 = mod4.LexicalBuilder;
  var NodeSelectionExtension2 = mod4.NodeSelectionExtension;
  var TabIndentationExtension2 = mod4.TabIndentationExtension;
  var batch = mod4.batch;
  var buildEditorFromExtensions2 = mod4.buildEditorFromExtensions;
  var computed = mod4.computed;
  var configExtension3 = mod4.configExtension;
  var declarePeerDependency3 = mod4.declarePeerDependency;
  var defineExtension3 = mod4.defineExtension;
  var effect3 = mod4.effect;
  var getExtensionDependencyFromEditor2 = mod4.getExtensionDependencyFromEditor;
  var getKnownTypesAndNodes2 = mod4.getKnownTypesAndNodes;
  var getPeerDependencyFromEditor2 = mod4.getPeerDependencyFromEditor;
  var getPeerDependencyFromEditorOrThrow2 = mod4.getPeerDependencyFromEditorOrThrow;
  var namedSignals2 = mod4.namedSignals;
  var registerClearEditor2 = mod4.registerClearEditor;
  var registerTabIndentation2 = mod4.registerTabIndentation;
  var safeCast3 = mod4.safeCast;
  var shallowMergeConfig3 = mod4.shallowMergeConfig;
  var signal = mod4.signal;
  var untracked = mod4.untracked;
  var watchedSignal2 = mod4.watchedSignal;

  // node_modules/@lexical/list/LexicalList.dev.mjs
  function formatDevErrorMessage5(message) {
    throw new Error(message);
  }
  function $getListDepth(listNode) {
    let depth = 1;
    let parent = listNode.getParent();
    while (parent != null) {
      if ($isListItemNode(parent)) {
        const parentList = parent.getParent();
        if ($isListNode(parentList)) {
          depth++;
          parent = parentList.getParent();
          continue;
        }
        {
          formatDevErrorMessage5(`A ListItemNode must have a ListNode for a parent.`);
        }
      }
      return depth;
    }
    return depth;
  }
  function $getTopListNode(listItem) {
    let list = listItem.getParent();
    if (!$isListNode(list)) {
      {
        formatDevErrorMessage5(`A ListItemNode must have a ListNode for a parent.`);
      }
    }
    let parent = list;
    while (parent !== null) {
      parent = parent.getParent();
      if ($isListNode(parent)) {
        list = parent;
      }
    }
    return list;
  }
  function $getAllListItems(node) {
    let listItemNodes = [];
    const listChildren = node.getChildren().filter($isListItemNode);
    for (let i2 = 0; i2 < listChildren.length; i2++) {
      const listItemNode = listChildren[i2];
      const firstChild = listItemNode.getFirstChild();
      if ($isListNode(firstChild)) {
        listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
      } else {
        listItemNodes.push(listItemNode);
      }
    }
    return listItemNodes;
  }
  function isNestedListNode(node) {
    return $isListItemNode(node) && $isListNode(node.getFirstChild());
  }
  function $removeHighestEmptyListParent(sublist) {
    let emptyListPtr = sublist;
    while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {
      const parent = emptyListPtr.getParent();
      if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {
        break;
      }
      emptyListPtr = parent;
    }
    emptyListPtr.remove();
  }
  function $wrapInListItem(node) {
    const listItemWrapper = $createListItemNode();
    return listItemWrapper.append(node);
  }
  function $isSelectingEmptyListItem(anchorNode, nodes) {
    return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
  }
  function $insertList(listType) {
    const selection = $getSelection2();
    if (selection !== null) {
      let nodes = selection.getNodes();
      if ($isRangeSelection2(selection)) {
        const anchorAndFocus = selection.getStartEndPoints();
        if (!(anchorAndFocus !== null)) {
          formatDevErrorMessage5(`insertList: anchor should be defined`);
        }
        const [anchor] = anchorAndFocus;
        const anchorNode = anchor.getNode();
        const anchorNodeParent = anchorNode.getParent();
        if ($isRootOrShadowRoot2(anchorNode)) {
          const firstChild = anchorNode.getFirstChild();
          if (firstChild) {
            nodes = firstChild.selectStart().getNodes();
          } else {
            const paragraph = $createParagraphNode2();
            anchorNode.append(paragraph);
            nodes = paragraph.select().getNodes();
          }
        } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {
          const list = $createListNode(listType);
          if ($isRootOrShadowRoot2(anchorNodeParent)) {
            anchorNode.replace(list);
            const listItem = $createListItemNode();
            if ($isElementNode2(anchorNode)) {
              listItem.setFormat(anchorNode.getFormatType());
              listItem.setIndent(anchorNode.getIndent());
            }
            list.append(listItem);
          } else if ($isListItemNode(anchorNode)) {
            const parent = anchorNode.getParentOrThrow();
            append(list, parent.getChildren());
            parent.replace(list);
          }
          return;
        }
      }
      const handled = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node = nodes[i2];
        if ($isElementNode2(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {
          $createListOrMerge(node, listType);
          continue;
        }
        let parent = $isLeafNode2(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;
        while (parent != null) {
          const parentKey = parent.getKey();
          if ($isListNode(parent)) {
            if (!handled.has(parentKey)) {
              const newListNode = $createListNode(listType);
              append(newListNode, parent.getChildren());
              parent.replace(newListNode);
              handled.add(parentKey);
            }
            break;
          } else {
            const nextParent = parent.getParent();
            if ($isRootOrShadowRoot2(nextParent) && !handled.has(parentKey)) {
              handled.add(parentKey);
              $createListOrMerge(parent, listType);
              break;
            }
            parent = nextParent;
          }
        }
      }
    }
  }
  function append(node, nodesToAppend) {
    node.splice(node.getChildrenSize(), 0, nodesToAppend);
  }
  function $createListOrMerge(node, listType) {
    if ($isListNode(node)) {
      return node;
    }
    const previousSibling = node.getPreviousSibling();
    const nextSibling = node.getNextSibling();
    const listItem = $createListItemNode();
    append(listItem, node.getChildren());
    let targetList;
    if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {
      previousSibling.append(listItem);
      if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
        append(previousSibling, nextSibling.getChildren());
        nextSibling.remove();
      }
      targetList = previousSibling;
    } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
      nextSibling.getFirstChildOrThrow().insertBefore(listItem);
      targetList = nextSibling;
    } else {
      const list = $createListNode(listType);
      list.append(listItem);
      node.replace(list);
      targetList = list;
    }
    listItem.setFormat(node.getFormatType());
    listItem.setIndent(node.getIndent());
    node.remove();
    return targetList;
  }
  function mergeLists(list1, list2) {
    const listItem1 = list1.getLastChild();
    const listItem2 = list2.getFirstChild();
    if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {
      mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());
      listItem2.remove();
    }
    const toMerge = list2.getChildren();
    if (toMerge.length > 0) {
      list1.append(...toMerge);
    }
    list2.remove();
  }
  function $removeList() {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      const listNodes = /* @__PURE__ */ new Set();
      const nodes = selection.getNodes();
      const anchorNode = selection.anchor.getNode();
      if ($isSelectingEmptyListItem(anchorNode, nodes)) {
        listNodes.add($getTopListNode(anchorNode));
      } else {
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node = nodes[i2];
          if ($isLeafNode2(node)) {
            const listItemNode = $getNearestNodeOfType2(node, ListItemNode);
            if (listItemNode != null) {
              listNodes.add($getTopListNode(listItemNode));
            }
          }
        }
      }
      for (const listNode of listNodes) {
        let insertionPoint = listNode;
        const listItems = $getAllListItems(listNode);
        for (const listItemNode of listItems) {
          const paragraph = $createParagraphNode2().setTextStyle(selection.style).setTextFormat(selection.format);
          append(paragraph, listItemNode.getChildren());
          insertionPoint.insertAfter(paragraph);
          insertionPoint = paragraph;
          if (listItemNode.__key === selection.anchor.key) {
            $setPointFromCaret2(selection.anchor, $normalizeCaret2($getChildCaret2(paragraph, "next")));
          }
          if (listItemNode.__key === selection.focus.key) {
            $setPointFromCaret2(selection.focus, $normalizeCaret2($getChildCaret2(paragraph, "next")));
          }
          listItemNode.remove();
        }
        listNode.remove();
      }
    }
  }
  function updateChildrenListItemValue(list) {
    const isNotChecklist = list.getListType() !== "check";
    let value = list.getStart();
    for (const child of list.getChildren()) {
      if ($isListItemNode(child)) {
        if (child.getValue() !== value) {
          child.setValue(value);
        }
        if (isNotChecklist && child.getLatest().__checked != null) {
          child.setChecked(void 0);
        }
        if (!$isListNode(child.getFirstChild())) {
          value++;
        }
      }
    }
  }
  function mergeNextSiblingListIfSameType(list) {
    const nextSibling = list.getNextSibling();
    if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {
      mergeLists(list, nextSibling);
    }
  }
  function $handleIndent(listItemNode) {
    const removed = /* @__PURE__ */ new Set();
    if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
      return;
    }
    const parent = listItemNode.getParent();
    const nextSibling = listItemNode.getNextSibling();
    const previousSibling = listItemNode.getPreviousSibling();
    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {
      const innerList = previousSibling.getFirstChild();
      if ($isListNode(innerList)) {
        innerList.append(listItemNode);
        const nextInnerList = nextSibling.getFirstChild();
        if ($isListNode(nextInnerList)) {
          const children = nextInnerList.getChildren();
          append(innerList, children);
          nextSibling.remove();
          removed.add(nextSibling.getKey());
        }
      }
    } else if (isNestedListNode(nextSibling)) {
      const innerList = nextSibling.getFirstChild();
      if ($isListNode(innerList)) {
        const firstChild = innerList.getFirstChild();
        if (firstChild !== null) {
          firstChild.insertBefore(listItemNode);
        }
      }
    } else if (isNestedListNode(previousSibling)) {
      const innerList = previousSibling.getFirstChild();
      if ($isListNode(innerList)) {
        innerList.append(listItemNode);
      }
    } else {
      if ($isListNode(parent)) {
        const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());
        const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());
        newListItem.append(newList);
        newList.append(listItemNode);
        if (previousSibling) {
          previousSibling.insertAfter(newListItem);
        } else if (nextSibling) {
          nextSibling.insertBefore(newListItem);
        } else {
          parent.append(newListItem);
        }
      }
    }
  }
  function $handleOutdent(listItemNode) {
    if (isNestedListNode(listItemNode)) {
      return;
    }
    const parentList = listItemNode.getParent();
    const grandparentListItem = parentList ? parentList.getParent() : void 0;
    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : void 0;
    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {
      const firstChild = parentList ? parentList.getFirstChild() : void 0;
      const lastChild = parentList ? parentList.getLastChild() : void 0;
      if (listItemNode.is(firstChild)) {
        grandparentListItem.insertBefore(listItemNode);
        if (parentList.isEmpty()) {
          grandparentListItem.remove();
        }
      } else if (listItemNode.is(lastChild)) {
        grandparentListItem.insertAfter(listItemNode);
        if (parentList.isEmpty()) {
          grandparentListItem.remove();
        }
      } else {
        const listType = parentList.getListType();
        const previousSiblingsListItem = $createListItemNode();
        const previousSiblingsList = $createListNode(listType);
        previousSiblingsListItem.append(previousSiblingsList);
        listItemNode.getPreviousSiblings().forEach((sibling) => previousSiblingsList.append(sibling));
        const nextSiblingsListItem = $createListItemNode();
        const nextSiblingsList = $createListNode(listType);
        nextSiblingsListItem.append(nextSiblingsList);
        append(nextSiblingsList, listItemNode.getNextSiblings());
        grandparentListItem.insertBefore(previousSiblingsListItem);
        grandparentListItem.insertAfter(nextSiblingsListItem);
        grandparentListItem.replace(listItemNode);
      }
    }
  }
  function $handleListInsertParagraph() {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection) || !selection.isCollapsed()) {
      return false;
    }
    const anchor = selection.anchor.getNode();
    if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {
      return false;
    }
    const topListNode = $getTopListNode(anchor);
    const parent = anchor.getParent();
    if (!$isListNode(parent)) {
      formatDevErrorMessage5(`A ListItemNode must have a ListNode for a parent.`);
    }
    const grandparent = parent.getParent();
    let replacementNode;
    if ($isRootOrShadowRoot2(grandparent)) {
      replacementNode = $createParagraphNode2();
      topListNode.insertAfter(replacementNode);
    } else if ($isListItemNode(grandparent)) {
      replacementNode = $createListItemNode();
      grandparent.insertAfter(replacementNode);
    } else {
      return false;
    }
    replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();
    const nextSiblings = anchor.getNextSiblings();
    if (nextSiblings.length > 0) {
      const newList = $createListNode(parent.getListType());
      if ($isListItemNode(replacementNode)) {
        const newListItem = $createListItemNode();
        newListItem.append(newList);
        replacementNode.insertAfter(newListItem);
      } else {
        replacementNode.insertAfter(newList);
      }
      newList.append(...nextSiblings);
    }
    $removeHighestEmptyListParent(anchor);
    return true;
  }
  function normalizeClassNames3(...classNames) {
    const rval = [];
    for (const className of classNames) {
      if (className && typeof className === "string") {
        for (const [s2] of className.matchAll(/\S+/g)) {
          rval.push(s2);
        }
      }
    }
    return rval;
  }
  function applyMarkerStyles(dom, node, prevNode) {
    const styles = getStyleObjectFromCSS2(node.__textStyle);
    for (const k2 in styles) {
      dom.style.setProperty(`--listitem-marker-${k2}`, styles[k2]);
    }
    if (prevNode) {
      for (const k2 in getStyleObjectFromCSS2(prevNode.__textStyle)) {
        if (!(k2 in styles)) {
          dom.style.removeProperty(`--listitem-marker-${k2}`);
        }
      }
    }
  }
  var ListItemNode = class extends ElementNode2 {
    /** @internal */
    __value;
    /** @internal */
    __checked;
    /** @internal */
    $config() {
      return this.config("listitem", {
        $transform: (node) => {
          if (node.__checked == null) {
            return;
          }
          const parent = node.getParent();
          if ($isListNode(parent)) {
            if (parent.getListType() !== "check" && node.getChecked() != null) {
              node.setChecked(void 0);
            }
          }
        },
        extends: ElementNode2,
        importDOM: buildImportMap2({
          li: () => ({
            conversion: $convertListItemElement,
            priority: 0
          })
        })
      });
    }
    constructor(value = 1, checked = void 0, key) {
      super(key);
      this.__value = value === void 0 ? 1 : value;
      this.__checked = checked;
    }
    afterCloneFrom(prevNode) {
      super.afterCloneFrom(prevNode);
      this.__value = prevNode.__value;
      this.__checked = prevNode.__checked;
    }
    createDOM(config) {
      const element = document.createElement("li");
      this.updateListItemDOM(null, element, config);
      return element;
    }
    updateListItemDOM(prevNode, dom, config) {
      updateListItemChecked(dom, this, prevNode);
      dom.value = this.__value;
      $setListItemThemeClassNames(dom, config.theme, this);
      const prevStyle = prevNode ? prevNode.__style : "";
      const nextStyle = this.__style;
      if (prevStyle !== nextStyle) {
        if (nextStyle === "") {
          dom.removeAttribute("style");
        } else {
          dom.style.cssText = nextStyle;
        }
      }
      applyMarkerStyles(dom, this, prevNode);
    }
    updateDOM(prevNode, dom, config) {
      const element = dom;
      this.updateListItemDOM(prevNode, element, config);
      return false;
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);
    }
    exportDOM(editor) {
      const element = this.createDOM(editor._config);
      const formatType = this.getFormatType();
      if (formatType) {
        element.style.textAlign = formatType;
      }
      const direction = this.getDirection();
      if (direction) {
        element.dir = direction;
      }
      return {
        element
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        value: this.getValue()
      };
    }
    append(...nodes) {
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node = nodes[i2];
        if ($isElementNode2(node) && this.canMergeWith(node)) {
          const children = node.getChildren();
          this.append(...children);
          node.remove();
        } else {
          super.append(node);
        }
      }
      return this;
    }
    replace(replaceWithNode, includeChildren) {
      if ($isListItemNode(replaceWithNode)) {
        return super.replace(replaceWithNode);
      }
      this.setIndent(0);
      const list = this.getParentOrThrow();
      if (!$isListNode(list)) {
        return replaceWithNode;
      }
      if (list.__first === this.getKey()) {
        list.insertBefore(replaceWithNode);
      } else if (list.__last === this.getKey()) {
        list.insertAfter(replaceWithNode);
      } else {
        const newList = $createListNode(list.getListType());
        let nextSibling = this.getNextSibling();
        while (nextSibling) {
          const nodeToAppend = nextSibling;
          nextSibling = nextSibling.getNextSibling();
          newList.append(nodeToAppend);
        }
        list.insertAfter(replaceWithNode);
        replaceWithNode.insertAfter(newList);
      }
      if (includeChildren) {
        if (!$isElementNode2(replaceWithNode)) {
          formatDevErrorMessage5(`includeChildren should only be true for ElementNodes`);
        }
        this.getChildren().forEach((child) => {
          replaceWithNode.append(child);
        });
      }
      this.remove();
      if (list.getChildrenSize() === 0) {
        list.remove();
      }
      return replaceWithNode;
    }
    insertAfter(node, restoreSelection = true) {
      const listNode = this.getParentOrThrow();
      if (!$isListNode(listNode)) {
        {
          formatDevErrorMessage5(`insertAfter: list node is not parent of list item node`);
        }
      }
      if ($isListItemNode(node)) {
        return super.insertAfter(node, restoreSelection);
      }
      const siblings = this.getNextSiblings();
      listNode.insertAfter(node, restoreSelection);
      if (siblings.length !== 0) {
        const newListNode = $createListNode(listNode.getListType());
        siblings.forEach((sibling) => newListNode.append(sibling));
        node.insertAfter(newListNode, restoreSelection);
      }
      return node;
    }
    remove(preserveEmptyParent) {
      const prevSibling = this.getPreviousSibling();
      const nextSibling = this.getNextSibling();
      super.remove(preserveEmptyParent);
      if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {
        mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());
        nextSibling.remove();
      }
    }
    insertNewAfter(_3, restoreSelection = true) {
      const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : void 0);
      this.insertAfter(newElement, restoreSelection);
      return newElement;
    }
    collapseAtStart(selection) {
      const paragraph = $createParagraphNode2();
      const children = this.getChildren();
      children.forEach((child) => paragraph.append(child));
      const listNode = this.getParentOrThrow();
      const listNodeParent = listNode.getParentOrThrow();
      const isIndented = $isListItemNode(listNodeParent);
      if (listNode.getChildrenSize() === 1) {
        if (isIndented) {
          listNode.remove();
          listNodeParent.select();
        } else {
          listNode.insertBefore(paragraph);
          listNode.remove();
          const anchor = selection.anchor;
          const focus = selection.focus;
          const key = paragraph.getKey();
          if (anchor.type === "element" && anchor.getNode().is(this)) {
            anchor.set(key, anchor.offset, "element");
          }
          if (focus.type === "element" && focus.getNode().is(this)) {
            focus.set(key, focus.offset, "element");
          }
        }
      } else {
        listNode.insertBefore(paragraph);
        this.remove();
      }
      return true;
    }
    getValue() {
      const self2 = this.getLatest();
      return self2.__value;
    }
    setValue(value) {
      const self2 = this.getWritable();
      self2.__value = value;
      return self2;
    }
    getChecked() {
      const self2 = this.getLatest();
      let listType;
      const parent = this.getParent();
      if ($isListNode(parent)) {
        listType = parent.getListType();
      }
      return listType === "check" ? Boolean(self2.__checked) : void 0;
    }
    setChecked(checked) {
      const self2 = this.getWritable();
      self2.__checked = checked;
      return self2;
    }
    toggleChecked() {
      const self2 = this.getWritable();
      return self2.setChecked(!self2.__checked);
    }
    getIndent() {
      const parent = this.getParent();
      if (parent === null || !this.isAttached()) {
        return this.getLatest().__indent;
      }
      let listNodeParent = parent.getParentOrThrow();
      let indentLevel = 0;
      while ($isListItemNode(listNodeParent)) {
        listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
        indentLevel++;
      }
      return indentLevel;
    }
    setIndent(indent) {
      if (!(typeof indent === "number")) {
        formatDevErrorMessage5(`Invalid indent value.`);
      }
      indent = Math.floor(indent);
      if (!(indent >= 0)) {
        formatDevErrorMessage5(`Indent value must be non-negative.`);
      }
      let currentIndent = this.getIndent();
      while (currentIndent !== indent) {
        if (currentIndent < indent) {
          $handleIndent(this);
          currentIndent++;
        } else {
          $handleOutdent(this);
          currentIndent--;
        }
      }
      return this;
    }
    /** @deprecated @internal */
    canInsertAfter(node) {
      return $isListItemNode(node);
    }
    /** @deprecated @internal */
    canReplaceWith(replacement) {
      return $isListItemNode(replacement);
    }
    canMergeWith(node) {
      return $isListItemNode(node) || $isParagraphNode2(node);
    }
    extractWithChild(child, selection) {
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;
    }
    isParentRequired() {
      return true;
    }
    createParentElementNode() {
      return $createListNode("bullet");
    }
    canMergeWhenEmpty() {
      return true;
    }
  };
  function $setListItemThemeClassNames(dom, editorThemeClasses, node) {
    const classesToAdd = [];
    const classesToRemove = [];
    const listTheme = editorThemeClasses.list;
    const listItemClassName = listTheme ? listTheme.listitem : void 0;
    let nestedListItemClassName;
    if (listTheme && listTheme.nested) {
      nestedListItemClassName = listTheme.nested.listitem;
    }
    if (listItemClassName !== void 0) {
      classesToAdd.push(...normalizeClassNames3(listItemClassName));
    }
    if (listTheme) {
      const parentNode = node.getParent();
      const isCheckList = $isListNode(parentNode) && parentNode.getListType() === "check";
      const checked = node.getChecked();
      if (!isCheckList || checked) {
        classesToRemove.push(listTheme.listitemUnchecked);
      }
      if (!isCheckList || !checked) {
        classesToRemove.push(listTheme.listitemChecked);
      }
      if (isCheckList) {
        classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
      }
    }
    if (nestedListItemClassName !== void 0) {
      const nestedListItemClasses = normalizeClassNames3(nestedListItemClassName);
      if (node.getChildren().some((child) => $isListNode(child))) {
        classesToAdd.push(...nestedListItemClasses);
      } else {
        classesToRemove.push(...nestedListItemClasses);
      }
    }
    if (classesToRemove.length > 0) {
      removeClassNamesFromElement2(dom, ...classesToRemove);
    }
    if (classesToAdd.length > 0) {
      addClassNamesToElement2(dom, ...classesToAdd);
    }
  }
  function updateListItemChecked(dom, listItemNode, prevListItemNode) {
    const parent = listItemNode.getParent();
    const isCheckbox2 = $isListNode(parent) && parent.getListType() === "check" && // Only add attributes for leaf list items
    !$isListNode(listItemNode.getFirstChild());
    if (!isCheckbox2) {
      dom.removeAttribute("role");
      dom.removeAttribute("tabIndex");
      dom.removeAttribute("aria-checked");
    } else {
      dom.setAttribute("role", "checkbox");
      dom.setAttribute("tabIndex", "-1");
      if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
        dom.setAttribute("aria-checked", listItemNode.getChecked() ? "true" : "false");
      }
    }
  }
  function $convertListItemElement(domNode) {
    const isGitHubCheckList = domNode.classList.contains("task-list-item");
    if (isGitHubCheckList) {
      for (const child of domNode.children) {
        if (child.tagName === "INPUT") {
          return $convertCheckboxInput(child);
        }
      }
    }
    const isJoplinCheckList = domNode.classList.contains("joplin-checkbox");
    if (isJoplinCheckList) {
      for (const child of domNode.children) {
        if (child.classList.contains("checkbox-wrapper") && child.children.length > 0 && child.children[0].tagName === "INPUT") {
          return $convertCheckboxInput(child.children[0]);
        }
      }
    }
    const ariaCheckedAttr = domNode.getAttribute("aria-checked");
    const checked = ariaCheckedAttr === "true" ? true : ariaCheckedAttr === "false" ? false : void 0;
    return {
      node: $createListItemNode(checked)
    };
  }
  function $convertCheckboxInput(domNode) {
    const isCheckboxInput = domNode.getAttribute("type") === "checkbox";
    if (!isCheckboxInput) {
      return {
        node: null
      };
    }
    const checked = domNode.hasAttribute("checked");
    return {
      node: $createListItemNode(checked)
    };
  }
  function $createListItemNode(checked) {
    return $applyNodeReplacement2(new ListItemNode(void 0, checked));
  }
  function $isListItemNode(node) {
    return node instanceof ListItemNode;
  }
  var ListNode = class extends ElementNode2 {
    /** @internal */
    __tag;
    /** @internal */
    __start;
    /** @internal */
    __listType;
    /** @internal */
    $config() {
      return this.config("list", {
        $transform: (node) => {
          mergeNextSiblingListIfSameType(node);
          updateChildrenListItemValue(node);
        },
        extends: ElementNode2,
        importDOM: buildImportMap2({
          ol: () => ({
            conversion: $convertListNode,
            priority: 0
          }),
          ul: () => ({
            conversion: $convertListNode,
            priority: 0
          })
        })
      });
    }
    constructor(listType = "number", start3 = 1, key) {
      super(key);
      const _listType = TAG_TO_LIST_TYPE[listType] || listType;
      this.__listType = _listType;
      this.__tag = _listType === "number" ? "ol" : "ul";
      this.__start = start3;
    }
    afterCloneFrom(prevNode) {
      super.afterCloneFrom(prevNode);
      this.__listType = prevNode.__listType;
      this.__tag = prevNode.__tag;
      this.__start = prevNode.__start;
    }
    getTag() {
      return this.getLatest().__tag;
    }
    setListType(type) {
      const writable = this.getWritable();
      writable.__listType = type;
      writable.__tag = type === "number" ? "ol" : "ul";
      return writable;
    }
    getListType() {
      return this.getLatest().__listType;
    }
    getStart() {
      return this.getLatest().__start;
    }
    setStart(start3) {
      const self2 = this.getWritable();
      self2.__start = start3;
      return self2;
    }
    // View
    createDOM(config, _editor) {
      const tag = this.__tag;
      const dom = document.createElement(tag);
      if (this.__start !== 1) {
        dom.setAttribute("start", String(this.__start));
      }
      dom.__lexicalListType = this.__listType;
      $setListThemeClassNames(dom, config.theme, this);
      return dom;
    }
    updateDOM(prevNode, dom, config) {
      if (prevNode.__tag !== this.__tag || prevNode.__listType !== this.__listType) {
        return true;
      }
      $setListThemeClassNames(dom, config.theme, this);
      return false;
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);
    }
    exportDOM(editor) {
      const element = this.createDOM(editor._config, editor);
      if (isHTMLElement3(element)) {
        if (this.__start !== 1) {
          element.setAttribute("start", String(this.__start));
        }
        if (this.__listType === "check") {
          element.setAttribute("__lexicalListType", "check");
        }
      }
      return {
        element
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        listType: this.getListType(),
        start: this.getStart(),
        tag: this.getTag()
      };
    }
    canBeEmpty() {
      return false;
    }
    canIndent() {
      return false;
    }
    splice(start3, deleteCount, nodesToInsert) {
      let listItemNodesToInsert = nodesToInsert;
      for (let i2 = 0; i2 < nodesToInsert.length; i2++) {
        const node = nodesToInsert[i2];
        if (!$isListItemNode(node)) {
          if (listItemNodesToInsert === nodesToInsert) {
            listItemNodesToInsert = [...nodesToInsert];
          }
          listItemNodesToInsert[i2] = $createListItemNode().append($isElementNode2(node) && !($isListNode(node) || node.isInline()) ? $createTextNode2(node.getTextContent()) : node);
        }
      }
      return super.splice(start3, deleteCount, listItemNodesToInsert);
    }
    extractWithChild(child) {
      return $isListItemNode(child);
    }
  };
  function $setListThemeClassNames(dom, editorThemeClasses, node) {
    const classesToAdd = [];
    const classesToRemove = [];
    const listTheme = editorThemeClasses.list;
    if (listTheme !== void 0) {
      const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];
      const listDepth = $getListDepth(node) - 1;
      const normalizedListDepth = listDepth % listLevelsClassNames.length;
      const listLevelClassName = listLevelsClassNames[normalizedListDepth];
      const listClassName = listTheme[node.__tag];
      let nestedListClassName;
      const nestedListTheme = listTheme.nested;
      const checklistClassName = listTheme.checklist;
      if (nestedListTheme !== void 0 && nestedListTheme.list) {
        nestedListClassName = nestedListTheme.list;
      }
      if (listClassName !== void 0) {
        classesToAdd.push(listClassName);
      }
      if (checklistClassName !== void 0 && node.__listType === "check") {
        classesToAdd.push(checklistClassName);
      }
      if (listLevelClassName !== void 0) {
        classesToAdd.push(...normalizeClassNames3(listLevelClassName));
        for (let i2 = 0; i2 < listLevelsClassNames.length; i2++) {
          if (i2 !== normalizedListDepth) {
            classesToRemove.push(node.__tag + i2);
          }
        }
      }
      if (nestedListClassName !== void 0) {
        const nestedListItemClasses = normalizeClassNames3(nestedListClassName);
        if (listDepth > 1) {
          classesToAdd.push(...nestedListItemClasses);
        } else {
          classesToRemove.push(...nestedListItemClasses);
        }
      }
    }
    if (classesToRemove.length > 0) {
      removeClassNamesFromElement2(dom, ...classesToRemove);
    }
    if (classesToAdd.length > 0) {
      addClassNamesToElement2(dom, ...classesToAdd);
    }
  }
  function $normalizeChildren(nodes) {
    const normalizedListItems = [];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if ($isListItemNode(node)) {
        normalizedListItems.push(node);
        const children = node.getChildren();
        if (children.length > 1) {
          children.forEach((child) => {
            if ($isListNode(child)) {
              normalizedListItems.push($wrapInListItem(child));
            }
          });
        }
      } else {
        normalizedListItems.push($wrapInListItem(node));
      }
    }
    return normalizedListItems;
  }
  function isDomChecklist(domNode) {
    if (domNode.getAttribute("__lexicallisttype") === "check" || // is github checklist
    domNode.classList.contains("contains-task-list") || // is joplin checklist
    domNode.getAttribute("data-is-checklist") === "1") {
      return true;
    }
    for (const child of domNode.childNodes) {
      if (isHTMLElement3(child) && child.hasAttribute("aria-checked")) {
        return true;
      }
    }
    return false;
  }
  function $convertListNode(domNode) {
    const nodeName = domNode.nodeName.toLowerCase();
    let node = null;
    if (nodeName === "ol") {
      const start3 = domNode.start;
      node = $createListNode("number", start3);
    } else if (nodeName === "ul") {
      if (isDomChecklist(domNode)) {
        node = $createListNode("check");
      } else {
        node = $createListNode("bullet");
      }
    }
    return {
      after: $normalizeChildren,
      node
    };
  }
  var TAG_TO_LIST_TYPE = {
    ol: "number",
    ul: "bullet"
  };
  function $createListNode(listType = "number", start3 = 1) {
    return $applyNodeReplacement2(new ListNode(listType, start3));
  }
  function $isListNode(node) {
    return node instanceof ListNode;
  }
  var INSERT_CHECK_LIST_COMMAND = createCommand2("INSERT_CHECK_LIST_COMMAND");
  function registerCheckList(editor) {
    return mergeRegister2(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {
      $insertList("check");
      return true;
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, (event) => {
      return handleArrowUpOrDown(event, editor, false);
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_UP_COMMAND2, (event) => {
      return handleArrowUpOrDown(event, editor, true);
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ESCAPE_COMMAND2, () => {
      const activeItem = getActiveCheckListItem();
      if (activeItem != null) {
        const rootElement = editor.getRootElement();
        if (rootElement != null) {
          rootElement.focus();
        }
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_SPACE_COMMAND2, (event) => {
      const activeItem = getActiveCheckListItem();
      if (activeItem != null && editor.isEditable()) {
        editor.update(() => {
          const listItemNode = $getNearestNodeFromDOMNode2(activeItem);
          if ($isListItemNode(listItemNode)) {
            event.preventDefault();
            listItemNode.toggleChecked();
          }
        });
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_LEFT_COMMAND2, (event) => {
      return editor.getEditorState().read(() => {
        const selection = $getSelection2();
        if ($isRangeSelection2(selection) && selection.isCollapsed()) {
          const {
            anchor
          } = selection;
          const isElement = anchor.type === "element";
          if (isElement || anchor.offset === 0) {
            const anchorNode = anchor.getNode();
            const elementNode = $findMatchingParent3(anchorNode, (node) => $isElementNode2(node) && !node.isInline());
            if ($isListItemNode(elementNode)) {
              const parent = elementNode.getParent();
              if ($isListNode(parent) && parent.getListType() === "check" && (isElement || elementNode.getFirstDescendant() === anchorNode)) {
                const domNode = editor.getElementByKey(elementNode.__key);
                if (domNode != null && document.activeElement !== domNode) {
                  domNode.focus();
                  event.preventDefault();
                  return true;
                }
              }
            }
          }
        }
        return false;
      });
    }, COMMAND_PRIORITY_LOW2), editor.registerRootListener((rootElement, prevElement) => {
      if (rootElement !== null) {
        rootElement.addEventListener("click", handleClick);
        rootElement.addEventListener("pointerdown", handlePointerDown);
      }
      if (prevElement !== null) {
        prevElement.removeEventListener("click", handleClick);
        prevElement.removeEventListener("pointerdown", handlePointerDown);
      }
    }));
  }
  function handleCheckItemEvent(event, callback2) {
    const target = event.target;
    if (!isHTMLElement3(target)) {
      return;
    }
    const firstChild = target.firstChild;
    if (isHTMLElement3(firstChild) && (firstChild.tagName === "UL" || firstChild.tagName === "OL")) {
      return;
    }
    const parentNode = target.parentNode;
    if (!parentNode || parentNode.__lexicalListType !== "check") {
      return;
    }
    const rect = target.getBoundingClientRect();
    const zoom = calculateZoomLevel2(target);
    const clientX = event.clientX / zoom;
    const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, "::before") : {
      width: "0px"
    };
    const beforeWidthInPixels = parseFloat(beforeStyles.width);
    const isTouchEvent = event.pointerType === "touch";
    const clickAreaPadding = isTouchEvent ? 32 : 0;
    if (target.dir === "rtl" ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {
      callback2();
    }
  }
  function handleClick(event) {
    handleCheckItemEvent(event, () => {
      if (isHTMLElement3(event.target)) {
        const domNode = event.target;
        const editor = getNearestEditorFromDOMNode2(domNode);
        if (editor != null && editor.isEditable()) {
          editor.update(() => {
            const node = $getNearestNodeFromDOMNode2(domNode);
            if ($isListItemNode(node)) {
              domNode.focus();
              node.toggleChecked();
            }
          });
        }
      }
    });
  }
  function handlePointerDown(event) {
    handleCheckItemEvent(event, () => {
      event.preventDefault();
    });
  }
  function getActiveCheckListItem() {
    const activeElement = document.activeElement;
    return isHTMLElement3(activeElement) && activeElement.tagName === "LI" && activeElement.parentNode != null && // @ts-ignore internal field
    activeElement.parentNode.__lexicalListType === "check" ? activeElement : null;
  }
  function findCheckListItemSibling(node, backward) {
    let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();
    let parent = node;
    while (sibling == null && $isListItemNode(parent)) {
      parent = parent.getParentOrThrow().getParent();
      if (parent != null) {
        sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();
      }
    }
    while ($isListItemNode(sibling)) {
      const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();
      if (!$isListNode(firstChild)) {
        return sibling;
      }
      sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();
    }
    return null;
  }
  function handleArrowUpOrDown(event, editor, backward) {
    const activeItem = getActiveCheckListItem();
    if (activeItem != null) {
      editor.update(() => {
        const listItem = $getNearestNodeFromDOMNode2(activeItem);
        if (!$isListItemNode(listItem)) {
          return;
        }
        const nextListItem = findCheckListItemSibling(listItem, backward);
        if (nextListItem != null) {
          nextListItem.selectStart();
          const dom = editor.getElementByKey(nextListItem.__key);
          if (dom != null) {
            event.preventDefault();
            setTimeout(() => {
              dom.focus();
            }, 0);
          }
        }
      });
    }
    return false;
  }
  var UPDATE_LIST_START_COMMAND = createCommand2("UPDATE_LIST_START_COMMAND");
  var INSERT_UNORDERED_LIST_COMMAND = createCommand2("INSERT_UNORDERED_LIST_COMMAND");
  var INSERT_ORDERED_LIST_COMMAND = createCommand2("INSERT_ORDERED_LIST_COMMAND");
  var REMOVE_LIST_COMMAND = createCommand2("REMOVE_LIST_COMMAND");
  function registerList(editor) {
    const removeListener2 = mergeRegister2(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {
      $insertList("number");
      return true;
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(UPDATE_LIST_START_COMMAND, (payload) => {
      const {
        listNodeKey,
        newStart
      } = payload;
      const listNode = $getNodeByKey2(listNodeKey);
      if (!$isListNode(listNode)) {
        return false;
      }
      if (listNode.getListType() === "number") {
        listNode.setStart(newStart);
        updateChildrenListItemValue(listNode);
      }
      return true;
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {
      $insertList("bullet");
      return true;
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(REMOVE_LIST_COMMAND, () => {
      $removeList();
      return true;
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => $handleListInsertParagraph(), COMMAND_PRIORITY_LOW2), editor.registerNodeTransform(ListItemNode, (node) => {
      const firstChild = node.getFirstChild();
      if (firstChild) {
        if ($isTextNode2(firstChild)) {
          const style = firstChild.getStyle();
          const format = firstChild.getFormat();
          if (node.getTextStyle() !== style) {
            node.setTextStyle(style);
          }
          if (node.getTextFormat() !== format) {
            node.setTextFormat(format);
          }
        }
      } else {
        const selection = $getSelection2();
        if ($isRangeSelection2(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {
          node.setTextStyle(selection.style).setTextFormat(selection.format);
        }
      }
    }), editor.registerNodeTransform(TextNode2, (node) => {
      const listItemParentNode = node.getParent();
      if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {
        const style = node.getStyle();
        const format = node.getFormat();
        if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {
          listItemParentNode.setTextStyle(style).setTextFormat(format);
        }
      }
    }));
    return removeListener2;
  }
  function registerListStrictIndentTransform(editor) {
    const $formatListIndentStrict = (listItemNode) => {
      const listNode = listItemNode.getParent();
      if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {
        return;
      }
      const startingListItemNode = $findMatchingParent3(listItemNode, (node) => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));
      if (startingListItemNode === null && listItemNode.getIndent() > 0) {
        listItemNode.setIndent(0);
      } else if ($isListItemNode(startingListItemNode)) {
        const prevListItemNode = startingListItemNode.getPreviousSibling();
        if ($isListItemNode(prevListItemNode)) {
          const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);
          const endListNode = endListItemNode.getParent();
          if ($isListNode(endListNode)) {
            const prevDepth = $getListDepth(endListNode);
            const depth = $getListDepth(listNode);
            if (prevDepth + 1 < depth) {
              listItemNode.setIndent(prevDepth);
            }
          }
        }
      }
    };
    const $processListWithStrictIndent = (listNode) => {
      const queue2 = [listNode];
      while (queue2.length > 0) {
        const node = queue2.shift();
        if (!$isListNode(node)) {
          continue;
        }
        for (const child of node.getChildren()) {
          if ($isListItemNode(child)) {
            $formatListIndentStrict(child);
            const firstChild = child.getFirstChild();
            if ($isListNode(firstChild)) {
              queue2.push(firstChild);
            }
          }
        }
      }
    };
    return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);
  }
  function $findChildrenEndListItemNode(listItemNode) {
    let current = listItemNode;
    let firstChild = current.getFirstChild();
    while ($isListNode(firstChild)) {
      const lastChild = firstChild.getLastChild();
      if ($isListItemNode(lastChild)) {
        current = lastChild;
        firstChild = current.getFirstChild();
      } else {
        break;
      }
    }
    return current;
  }
  function insertList(editor, listType) {
    editor.update(() => $insertList(listType));
  }
  function removeList(editor) {
    editor.update(() => $removeList());
  }
  var ListExtension = defineExtension2({
    build(editor, config, state) {
      return namedSignals2(config);
    },
    config: safeCast2({
      hasStrictIndent: false
    }),
    name: "@lexical/list/List",
    nodes: [ListNode, ListItemNode],
    register(editor, config, state) {
      const stores2 = state.getOutput();
      return mergeRegister2(registerList(editor), effect3(() => stores2.hasStrictIndent.value ? registerListStrictIndentTransform(editor) : void 0));
    }
  });
  var CheckListExtension = defineExtension2({
    dependencies: [ListExtension],
    name: "@lexical/list/CheckList",
    register: registerCheckList
  });

  // node_modules/@lexical/list/LexicalList.mjs
  var mod5 = true ? LexicalList_dev_exports : LexicalList_prod_exports;
  var $createListItemNode2 = mod5.$createListItemNode;
  var $createListNode2 = mod5.$createListNode;
  var $getListDepth2 = mod5.$getListDepth;
  var $handleListInsertParagraph2 = mod5.$handleListInsertParagraph;
  var $insertList2 = mod5.$insertList;
  var $isListItemNode2 = mod5.$isListItemNode;
  var $isListNode2 = mod5.$isListNode;
  var $removeList2 = mod5.$removeList;
  var CheckListExtension2 = mod5.CheckListExtension;
  var INSERT_CHECK_LIST_COMMAND2 = mod5.INSERT_CHECK_LIST_COMMAND;
  var INSERT_ORDERED_LIST_COMMAND2 = mod5.INSERT_ORDERED_LIST_COMMAND;
  var INSERT_UNORDERED_LIST_COMMAND2 = mod5.INSERT_UNORDERED_LIST_COMMAND;
  var ListExtension2 = mod5.ListExtension;
  var ListItemNode2 = mod5.ListItemNode;
  var ListNode2 = mod5.ListNode;
  var REMOVE_LIST_COMMAND2 = mod5.REMOVE_LIST_COMMAND;
  var UPDATE_LIST_START_COMMAND2 = mod5.UPDATE_LIST_START_COMMAND;
  var insertList2 = mod5.insertList;
  var registerCheckList2 = mod5.registerCheckList;
  var registerList2 = mod5.registerList;
  var registerListStrictIndentTransform2 = mod5.registerListStrictIndentTransform;
  var removeList2 = mod5.removeList;

  // node_modules/@lexical/rich-text/LexicalRichText.dev.mjs
  var LexicalRichText_dev_exports = {};
  __export(LexicalRichText_dev_exports, {
    $createHeadingNode: () => $createHeadingNode,
    $createQuoteNode: () => $createQuoteNode,
    $isHeadingNode: () => $isHeadingNode,
    $isQuoteNode: () => $isQuoteNode,
    DRAG_DROP_PASTE: () => DRAG_DROP_PASTE,
    HeadingNode: () => HeadingNode,
    QuoteNode: () => QuoteNode,
    RichTextExtension: () => RichTextExtension,
    eventFiles: () => eventFiles,
    registerRichText: () => registerRichText
  });

  // node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs
  var LexicalClipboard_dev_exports = {};
  __export(LexicalClipboard_dev_exports, {
    $generateJSONFromSelectedNodes: () => $generateJSONFromSelectedNodes,
    $generateNodesFromSerializedNodes: () => $generateNodesFromSerializedNodes,
    $getClipboardDataFromSelection: () => $getClipboardDataFromSelection,
    $getHtmlContent: () => $getHtmlContent,
    $getLexicalContent: () => $getLexicalContent,
    $insertDataTransferForPlainText: () => $insertDataTransferForPlainText,
    $insertDataTransferForRichText: () => $insertDataTransferForRichText,
    $insertGeneratedNodes: () => $insertGeneratedNodes,
    copyToClipboard: () => copyToClipboard,
    setLexicalClipboardDataTransfer: () => setLexicalClipboardDataTransfer
  });

  // node_modules/@lexical/html/LexicalHtml.dev.mjs
  var LexicalHtml_dev_exports = {};
  __export(LexicalHtml_dev_exports, {
    $generateHtmlFromNodes: () => $generateHtmlFromNodes,
    $generateNodesFromDOM: () => $generateNodesFromDOM
  });
  function $generateNodesFromDOM(editor, dom) {
    const elements2 = isDOMDocumentNode2(dom) ? dom.body.childNodes : dom.childNodes;
    let lexicalNodes = [];
    const allArtificialNodes = [];
    for (const element of elements2) {
      if (!IGNORE_TAGS.has(element.nodeName)) {
        const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);
        if (lexicalNode !== null) {
          lexicalNodes = lexicalNodes.concat(lexicalNode);
        }
      }
    }
    $unwrapArtificialNodes(allArtificialNodes);
    return lexicalNodes;
  }
  function $generateHtmlFromNodes(editor, selection) {
    if (typeof document === "undefined" || typeof window === "undefined" && typeof global.window === "undefined") {
      throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    }
    const container = document.createElement("div");
    const root = $getRoot2();
    const topLevelChildren = root.getChildren();
    for (let i2 = 0; i2 < topLevelChildren.length; i2++) {
      const topLevelNode = topLevelChildren[i2];
      $appendNodesToHTML(editor, topLevelNode, container, selection);
    }
    return container.innerHTML;
  }
  function $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {
    let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
    const shouldExclude = $isElementNode2(currentNode) && currentNode.excludeFromCopy("html");
    let target = currentNode;
    if (selection !== null && $isTextNode2(currentNode)) {
      target = $sliceSelectedTextNodeContent2(selection, currentNode, "clone");
    }
    const children = $isElementNode2(target) ? target.getChildren() : [];
    const registeredNode = getRegisteredNode2(editor, target.getType());
    let exportOutput;
    if (registeredNode && registeredNode.exportDOM !== void 0) {
      exportOutput = registeredNode.exportDOM(editor, target);
    } else {
      exportOutput = target.exportDOM(editor);
    }
    const {
      element,
      after
    } = exportOutput;
    if (!element) {
      return false;
    }
    const fragment = document.createDocumentFragment();
    for (let i2 = 0; i2 < children.length; i2++) {
      const childNode = children[i2];
      const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);
      if (!shouldInclude && $isElementNode2(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "html")) {
        shouldInclude = true;
      }
    }
    if (shouldInclude && !shouldExclude) {
      if (isHTMLElement3(element) || isDocumentFragment2(element)) {
        element.append(fragment);
      }
      parentElement.append(element);
      if (after) {
        const newElement = after.call(target, element);
        if (newElement) {
          if (isDocumentFragment2(element)) {
            element.replaceChildren(newElement);
          } else {
            element.replaceWith(newElement);
          }
        }
      }
    } else {
      parentElement.append(fragment);
    }
    return shouldInclude;
  }
  function getConversionFunction(domNode, editor) {
    const {
      nodeName
    } = domNode;
    const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
    let currentConversion = null;
    if (cachedConversions !== void 0) {
      for (const cachedConversion of cachedConversions) {
        const domConversion = cachedConversion(domNode);
        if (domConversion !== null && (currentConversion === null || // Given equal priority, prefer the last registered importer
        // which is typically an application custom node or HTMLConfig['import']
        (currentConversion.priority || 0) <= (domConversion.priority || 0))) {
          currentConversion = domConversion;
        }
      }
    }
    return currentConversion !== null ? currentConversion.conversion : null;
  }
  var IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode) {
    let lexicalNodes = [];
    if (IGNORE_TAGS.has(node.nodeName)) {
      return lexicalNodes;
    }
    let currentLexicalNode = null;
    const transformFunction = getConversionFunction(node, editor);
    const transformOutput = transformFunction ? transformFunction(node) : null;
    let postTransform = null;
    if (transformOutput !== null) {
      postTransform = transformOutput.after;
      const transformNodes = transformOutput.node;
      currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
      if (currentLexicalNode !== null) {
        for (const [, forChildFunction] of forChildMap) {
          currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
          if (!currentLexicalNode) {
            break;
          }
        }
        if (currentLexicalNode) {
          lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]);
        }
      }
      if (transformOutput.forChild != null) {
        forChildMap.set(node.nodeName, transformOutput.forChild);
      }
    }
    const children = node.childNodes;
    let childLexicalNodes = [];
    const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot2(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode2(currentLexicalNode) || hasBlockAncestorLexicalNode;
    for (let i2 = 0; i2 < children.length; i2++) {
      childLexicalNodes.push(...$createNodesFromDOM(children[i2], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));
    }
    if (postTransform != null) {
      childLexicalNodes = postTransform(childLexicalNodes);
    }
    if (isBlockDomNode3(node)) {
      if (!hasBlockAncestorLexicalNodeForChildren) {
        childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode2);
      } else {
        childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {
          const artificialNode = new ArtificialNode__DO_NOT_USE2();
          allArtificialNodes.push(artificialNode);
          return artificialNode;
        });
      }
    }
    if (currentLexicalNode == null) {
      if (childLexicalNodes.length > 0) {
        lexicalNodes = lexicalNodes.concat(childLexicalNodes);
      } else {
        if (isBlockDomNode3(node) && isDomNodeBetweenTwoInlineNodes(node)) {
          lexicalNodes = lexicalNodes.concat($createLineBreakNode2());
        }
      }
    } else {
      if ($isElementNode2(currentLexicalNode)) {
        currentLexicalNode.append(...childLexicalNodes);
      }
    }
    return lexicalNodes;
  }
  function wrapContinuousInlines(domNode, nodes, createWrapperFn) {
    const textAlign = domNode.style.textAlign;
    const out = [];
    let continuousInlines = [];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if ($isBlockElementNode2(node)) {
        if (textAlign && !node.getFormat()) {
          node.setFormat(textAlign);
        }
        out.push(node);
      } else {
        continuousInlines.push(node);
        if (i2 === nodes.length - 1 || i2 < nodes.length - 1 && $isBlockElementNode2(nodes[i2 + 1])) {
          const wrapper = createWrapperFn();
          wrapper.setFormat(textAlign);
          wrapper.append(...continuousInlines);
          out.push(wrapper);
          continuousInlines = [];
        }
      }
    }
    return out;
  }
  function $unwrapArtificialNodes(allArtificialNodes) {
    for (const node of allArtificialNodes) {
      if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE2) {
        node.insertAfter($createLineBreakNode2());
      }
    }
    for (const node of allArtificialNodes) {
      const children = node.getChildren();
      for (const child of children) {
        node.insertBefore(child);
      }
      node.remove();
    }
  }
  function isDomNodeBetweenTwoInlineNodes(node) {
    if (node.nextSibling == null || node.previousSibling == null) {
      return false;
    }
    return isInlineDomNode2(node.nextSibling) && isInlineDomNode2(node.previousSibling);
  }

  // node_modules/@lexical/html/LexicalHtml.mjs
  var mod6 = true ? LexicalHtml_dev_exports : LexicalHtml_prod_exports;
  var $generateHtmlFromNodes2 = mod6.$generateHtmlFromNodes;
  var $generateNodesFromDOM2 = mod6.$generateNodesFromDOM;

  // node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs
  function formatDevErrorMessage6(message) {
    throw new Error(message);
  }
  function $getHtmlContent(editor, selection = $getSelection2()) {
    if (selection == null) {
      {
        formatDevErrorMessage6(`Expected valid LexicalSelection`);
      }
    }
    if ($isRangeSelection2(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
      return "";
    }
    return $generateHtmlFromNodes2(editor, selection);
  }
  function $getLexicalContent(editor, selection = $getSelection2()) {
    if (selection == null) {
      {
        formatDevErrorMessage6(`Expected valid LexicalSelection`);
      }
    }
    if ($isRangeSelection2(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
      return null;
    }
    return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));
  }
  function $insertDataTransferForPlainText(dataTransfer, selection) {
    const text2 = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
    if (text2 != null) {
      selection.insertRawText(text2);
    }
  }
  function $insertDataTransferForRichText(dataTransfer, selection, editor) {
    const lexicalString = dataTransfer.getData("application/x-lexical-editor");
    if (lexicalString) {
      try {
        const payload = JSON.parse(lexicalString);
        if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
          const nodes = $generateNodesFromSerializedNodes(payload.nodes);
          return $insertGeneratedNodes(editor, nodes, selection);
        }
      } catch (error2) {
        console.error(error2);
      }
    }
    const htmlString = dataTransfer.getData("text/html");
    const plainString = dataTransfer.getData("text/plain");
    if (htmlString && plainString !== htmlString) {
      try {
        const parser = new DOMParser();
        const dom = parser.parseFromString(trustHTML(htmlString), "text/html");
        const nodes = $generateNodesFromDOM2(editor, dom);
        return $insertGeneratedNodes(editor, nodes, selection);
      } catch (error2) {
        console.error(error2);
      }
    }
    const text2 = plainString || dataTransfer.getData("text/uri-list");
    if (text2 != null) {
      if ($isRangeSelection2(selection)) {
        const parts = text2.split(/(\r?\n|\t)/);
        if (parts[parts.length - 1] === "") {
          parts.pop();
        }
        for (let i2 = 0; i2 < parts.length; i2++) {
          const currentSelection = $getSelection2();
          if ($isRangeSelection2(currentSelection)) {
            const part = parts[i2];
            if (part === "\n" || part === "\r\n") {
              currentSelection.insertParagraph();
            } else if (part === "	") {
              currentSelection.insertNodes([$createTabNode2()]);
            } else {
              currentSelection.insertText(part);
            }
          }
        }
      } else {
        selection.insertRawText(text2);
      }
    }
  }
  function trustHTML(html2) {
    if (window.trustedTypes && window.trustedTypes.createPolicy) {
      const policy = window.trustedTypes.createPolicy("lexical", {
        createHTML: (input) => input
      });
      return policy.createHTML(html2);
    }
    return html2;
  }
  function $insertGeneratedNodes(editor, nodes, selection) {
    if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, {
      nodes,
      selection
    })) {
      selection.insertNodes(nodes);
      $updateSelectionOnInsert(selection);
    }
    return;
  }
  function $updateSelectionOnInsert(selection) {
    if ($isRangeSelection2(selection) && selection.isCollapsed()) {
      const anchor = selection.anchor;
      let nodeToInspect = null;
      const anchorCaret = $caretFromPoint2(anchor, "previous");
      if (anchorCaret) {
        if ($isTextPointCaret2(anchorCaret)) {
          nodeToInspect = anchorCaret.origin;
        } else {
          const range2 = $getCaretRange2(anchorCaret, $getChildCaret2($getRoot2(), "next").getFlipped());
          for (const caret of range2) {
            if ($isTextNode2(caret.origin)) {
              nodeToInspect = caret.origin;
              break;
            } else if ($isElementNode2(caret.origin) && !caret.origin.isInline()) {
              break;
            }
          }
        }
      }
      if (nodeToInspect && $isTextNode2(nodeToInspect)) {
        const newFormat = nodeToInspect.getFormat();
        const newStyle = nodeToInspect.getStyle();
        if (selection.format !== newFormat || selection.style !== newStyle) {
          selection.format = newFormat;
          selection.style = newStyle;
          selection.dirty = true;
        }
      }
    }
  }
  function exportNodeToJSON2(node) {
    const serializedNode = node.exportJSON();
    const nodeClass = node.constructor;
    if (serializedNode.type !== nodeClass.getType()) {
      {
        formatDevErrorMessage6(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
      }
    }
    if ($isElementNode2(node)) {
      const serializedChildren = serializedNode.children;
      if (!Array.isArray(serializedChildren)) {
        {
          formatDevErrorMessage6(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
        }
      }
    }
    return serializedNode;
  }
  function $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {
    let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
    const shouldExclude = $isElementNode2(currentNode) && currentNode.excludeFromCopy("html");
    let target = currentNode;
    if (selection !== null && $isTextNode2(target)) {
      target = $sliceSelectedTextNodeContent2(selection, target, "clone");
    }
    const children = $isElementNode2(target) ? target.getChildren() : [];
    const serializedNode = exportNodeToJSON2(target);
    if ($isTextNode2(target) && target.getTextContentSize() === 0) {
      shouldInclude = false;
    }
    for (let i2 = 0; i2 < children.length; i2++) {
      const childNode = children[i2];
      const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);
      if (!shouldInclude && $isElementNode2(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "clone")) {
        shouldInclude = true;
      }
    }
    if (shouldInclude && !shouldExclude) {
      targetArray.push(serializedNode);
    } else if (Array.isArray(serializedNode.children)) {
      for (let i2 = 0; i2 < serializedNode.children.length; i2++) {
        const serializedChildNode = serializedNode.children[i2];
        targetArray.push(serializedChildNode);
      }
    }
    return shouldInclude;
  }
  function $generateJSONFromSelectedNodes(editor, selection) {
    const nodes = [];
    const root = $getRoot2();
    const topLevelChildren = root.getChildren();
    for (let i2 = 0; i2 < topLevelChildren.length; i2++) {
      const topLevelNode = topLevelChildren[i2];
      $appendNodesToJSON(editor, selection, topLevelNode, nodes);
    }
    return {
      namespace: editor._config.namespace,
      nodes
    };
  }
  function $generateNodesFromSerializedNodes(serializedNodes) {
    const nodes = [];
    for (let i2 = 0; i2 < serializedNodes.length; i2++) {
      const serializedNode = serializedNodes[i2];
      const node = $parseSerializedNode2(serializedNode);
      if ($isTextNode2(node)) {
        $addNodeStyle2(node);
      }
      nodes.push(node);
    }
    return nodes;
  }
  var EVENT_LATENCY = 50;
  var clipboardEventTimeout = null;
  async function copyToClipboard(editor, event, data2) {
    if (clipboardEventTimeout !== null) {
      return false;
    }
    if (event !== null) {
      return new Promise((resolve2, reject) => {
        editor.update(() => {
          resolve2($copyToClipboardEvent(editor, event, data2));
        });
      });
    }
    const rootElement = editor.getRootElement();
    const editorWindow = editor._window || window;
    const windowDocument = editorWindow.document;
    const domSelection = getDOMSelection2(editorWindow);
    if (rootElement === null || domSelection === null) {
      return false;
    }
    const element = windowDocument.createElement("span");
    element.style.cssText = "position: fixed; top: -1000px;";
    element.append(windowDocument.createTextNode("#"));
    rootElement.append(element);
    const range2 = new Range();
    range2.setStart(element, 0);
    range2.setEnd(element, 1);
    domSelection.removeAllRanges();
    domSelection.addRange(range2);
    return new Promise((resolve2, reject) => {
      const removeListener2 = editor.registerCommand(COPY_COMMAND2, (secondEvent) => {
        if (objectKlassEquals2(secondEvent, ClipboardEvent)) {
          removeListener2();
          if (clipboardEventTimeout !== null) {
            editorWindow.clearTimeout(clipboardEventTimeout);
            clipboardEventTimeout = null;
          }
          resolve2($copyToClipboardEvent(editor, secondEvent, data2));
        }
        return true;
      }, COMMAND_PRIORITY_CRITICAL2);
      clipboardEventTimeout = editorWindow.setTimeout(() => {
        removeListener2();
        clipboardEventTimeout = null;
        resolve2(false);
      }, EVENT_LATENCY);
      windowDocument.execCommand("copy");
      element.remove();
    });
  }
  function $copyToClipboardEvent(editor, event, data2) {
    if (data2 === void 0) {
      const domSelection = getDOMSelection2(editor._window);
      const selection = $getSelection2();
      if (!selection || selection.isCollapsed()) {
        return false;
      }
      if (!domSelection) {
        return false;
      }
      const anchorDOM = domSelection.anchorNode;
      const focusDOM = domSelection.focusNode;
      if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor2(editor, anchorDOM, focusDOM)) {
        return false;
      }
      data2 = $getClipboardDataFromSelection(selection);
    }
    event.preventDefault();
    const clipboardData = event.clipboardData;
    if (clipboardData === null) {
      return false;
    }
    setLexicalClipboardDataTransfer(clipboardData, data2);
    return true;
  }
  var clipboardDataFunctions = [["text/html", $getHtmlContent], ["application/x-lexical-editor", $getLexicalContent]];
  function $getClipboardDataFromSelection(selection = $getSelection2()) {
    const clipboardData = {
      "text/plain": selection ? selection.getTextContent() : ""
    };
    if (selection) {
      const editor = $getEditor2();
      for (const [mimeType, $editorFn] of clipboardDataFunctions) {
        const v3 = $editorFn(editor, selection);
        if (v3 !== null) {
          clipboardData[mimeType] = v3;
        }
      }
    }
    return clipboardData;
  }
  function setLexicalClipboardDataTransfer(clipboardData, data2) {
    for (const [k2] of clipboardDataFunctions) {
      if (data2[k2] === void 0) {
        clipboardData.setData(k2, "");
      }
    }
    for (const k2 in data2) {
      const v3 = data2[k2];
      if (v3 !== void 0) {
        clipboardData.setData(k2, v3);
      }
    }
  }

  // node_modules/@lexical/clipboard/LexicalClipboard.mjs
  var mod7 = true ? LexicalClipboard_dev_exports : LexicalClipboard_prod_exports;
  var $generateJSONFromSelectedNodes2 = mod7.$generateJSONFromSelectedNodes;
  var $generateNodesFromSerializedNodes2 = mod7.$generateNodesFromSerializedNodes;
  var $getClipboardDataFromSelection2 = mod7.$getClipboardDataFromSelection;
  var $getHtmlContent2 = mod7.$getHtmlContent;
  var $getLexicalContent2 = mod7.$getLexicalContent;
  var $insertDataTransferForPlainText2 = mod7.$insertDataTransferForPlainText;
  var $insertDataTransferForRichText2 = mod7.$insertDataTransferForRichText;
  var $insertGeneratedNodes2 = mod7.$insertGeneratedNodes;
  var copyToClipboard2 = mod7.copyToClipboard;
  var setLexicalClipboardDataTransfer2 = mod7.setLexicalClipboardDataTransfer;

  // node_modules/@lexical/dragon/LexicalDragon.dev.mjs
  var LexicalDragon_dev_exports = {};
  __export(LexicalDragon_dev_exports, {
    DragonExtension: () => DragonExtension,
    registerDragonSupport: () => registerDragonSupport
  });
  function registerDragonSupport(editor) {
    const origin = window.location.origin;
    const handler4 = (event) => {
      if (event.origin !== origin) {
        return;
      }
      const rootElement = editor.getRootElement();
      if (document.activeElement !== rootElement) {
        return;
      }
      const data2 = event.data;
      if (typeof data2 === "string") {
        let parsedData;
        try {
          parsedData = JSON.parse(data2);
        } catch (_e2) {
          return;
        }
        if (parsedData && parsedData.protocol === "nuanria_messaging" && parsedData.type === "request") {
          const payload = parsedData.payload;
          if (payload && payload.functionId === "makeChanges") {
            const args = payload.args;
            if (args) {
              const [elementStart, elementLength, text2, selStart, selLength] = args;
              editor.update(() => {
                const selection = $getSelection2();
                if ($isRangeSelection2(selection)) {
                  const anchor = selection.anchor;
                  let anchorNode = anchor.getNode();
                  let setSelStart = 0;
                  let setSelEnd = 0;
                  if ($isTextNode2(anchorNode)) {
                    if (elementStart >= 0 && elementLength >= 0) {
                      setSelStart = elementStart;
                      setSelEnd = elementStart + elementLength;
                      selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                    }
                  }
                  if (setSelStart !== setSelEnd || text2 !== "") {
                    selection.insertRawText(text2);
                    anchorNode = anchor.getNode();
                  }
                  if ($isTextNode2(anchorNode)) {
                    setSelStart = selStart;
                    setSelEnd = selStart + selLength;
                    const anchorNodeTextLength = anchorNode.getTextContentSize();
                    setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;
                    setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;
                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                  }
                  event.stopImmediatePropagation();
                }
              });
            }
          }
        }
      }
    };
    window.addEventListener("message", handler4, true);
    return () => {
      window.removeEventListener("message", handler4, true);
    };
  }
  var DragonExtension = defineExtension2({
    build: (editor, config, state) => namedSignals2(config),
    config: safeCast2({
      disabled: typeof window === "undefined"
    }),
    name: "@lexical/dragon",
    register: (editor, config, state) => effect3(() => state.getOutput().disabled.value ? void 0 : registerDragonSupport(editor))
  });

  // node_modules/@lexical/dragon/LexicalDragon.mjs
  var mod8 = true ? LexicalDragon_dev_exports : LexicalDragon_prod_exports;
  var DragonExtension2 = mod8.DragonExtension;
  var registerDragonSupport2 = mod8.registerDragonSupport;

  // node_modules/@lexical/rich-text/LexicalRichText.dev.mjs
  function caretFromPoint(x2, y3) {
    if (typeof document.caretRangeFromPoint !== "undefined") {
      const range2 = document.caretRangeFromPoint(x2, y3);
      if (range2 === null) {
        return null;
      }
      return {
        node: range2.startContainer,
        offset: range2.startOffset
      };
    } else if (document.caretPositionFromPoint !== "undefined") {
      const range2 = document.caretPositionFromPoint(x2, y3);
      if (range2 === null) {
        return null;
      }
      return {
        node: range2.offsetNode,
        offset: range2.offset
      };
    } else {
      return null;
    }
  }
  var CAN_USE_DOM4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  var documentMode3 = CAN_USE_DOM4 && "documentMode" in document ? document.documentMode : null;
  var IS_APPLE4 = CAN_USE_DOM4 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
  var CAN_USE_BEFORE_INPUT4 = CAN_USE_DOM4 && "InputEvent" in window && !documentMode3 ? "getTargetRanges" in new window.InputEvent("input") : false;
  var IS_SAFARI4 = CAN_USE_DOM4 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
  var IS_IOS4 = CAN_USE_DOM4 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  var IS_CHROME4 = CAN_USE_DOM4 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
  var IS_APPLE_WEBKIT4 = CAN_USE_DOM4 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && IS_APPLE4 && !IS_CHROME4;
  var DRAG_DROP_PASTE = createCommand2("DRAG_DROP_PASTE_FILE");
  var QuoteNode = class _QuoteNode extends ElementNode2 {
    static getType() {
      return "quote";
    }
    static clone(node) {
      return new _QuoteNode(node.__key);
    }
    // View
    createDOM(config) {
      const element = document.createElement("blockquote");
      addClassNamesToElement2(element, config.theme.quote);
      return element;
    }
    updateDOM(prevNode, dom) {
      return false;
    }
    static importDOM() {
      return {
        blockquote: (node) => ({
          conversion: $convertBlockquoteElement,
          priority: 0
        })
      };
    }
    exportDOM(editor) {
      const {
        element
      } = super.exportDOM(editor);
      if (isHTMLElement3(element)) {
        if (this.isEmpty()) {
          element.append(document.createElement("br"));
        }
        const formatType = this.getFormatType();
        if (formatType) {
          element.style.textAlign = formatType;
        }
        const direction = this.getDirection();
        if (direction) {
          element.dir = direction;
        }
      }
      return {
        element
      };
    }
    static importJSON(serializedNode) {
      return $createQuoteNode().updateFromJSON(serializedNode);
    }
    // Mutation
    insertNewAfter(_3, restoreSelection) {
      const newBlock = $createParagraphNode2();
      const direction = this.getDirection();
      newBlock.setDirection(direction);
      this.insertAfter(newBlock, restoreSelection);
      return newBlock;
    }
    collapseAtStart() {
      const paragraph = $createParagraphNode2();
      const children = this.getChildren();
      children.forEach((child) => paragraph.append(child));
      this.replace(paragraph);
      return true;
    }
    canMergeWhenEmpty() {
      return true;
    }
  };
  function $createQuoteNode() {
    return $applyNodeReplacement2(new QuoteNode());
  }
  function $isQuoteNode(node) {
    return node instanceof QuoteNode;
  }
  var HeadingNode = class _HeadingNode extends ElementNode2 {
    /** @internal */
    __tag;
    static getType() {
      return "heading";
    }
    static clone(node) {
      return new _HeadingNode(node.__tag, node.__key);
    }
    constructor(tag, key) {
      super(key);
      this.__tag = tag;
    }
    getTag() {
      return this.__tag;
    }
    setTag(tag) {
      const self2 = this.getWritable();
      this.__tag = tag;
      return self2;
    }
    // View
    createDOM(config) {
      const tag = this.__tag;
      const element = document.createElement(tag);
      const theme2 = config.theme;
      const classNames = theme2.heading;
      if (classNames !== void 0) {
        const className = classNames[tag];
        addClassNamesToElement2(element, className);
      }
      return element;
    }
    updateDOM(prevNode, dom, config) {
      return prevNode.__tag !== this.__tag;
    }
    static importDOM() {
      return {
        h1: (node) => ({
          conversion: $convertHeadingElement,
          priority: 0
        }),
        h2: (node) => ({
          conversion: $convertHeadingElement,
          priority: 0
        }),
        h3: (node) => ({
          conversion: $convertHeadingElement,
          priority: 0
        }),
        h4: (node) => ({
          conversion: $convertHeadingElement,
          priority: 0
        }),
        h5: (node) => ({
          conversion: $convertHeadingElement,
          priority: 0
        }),
        h6: (node) => ({
          conversion: $convertHeadingElement,
          priority: 0
        }),
        p: (node) => {
          const paragraph = node;
          const firstChild = paragraph.firstChild;
          if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
            return {
              conversion: () => ({
                node: null
              }),
              priority: 3
            };
          }
          return null;
        },
        span: (node) => {
          if (isGoogleDocsTitle(node)) {
            return {
              conversion: (domNode) => {
                return {
                  node: $createHeadingNode("h1")
                };
              },
              priority: 3
            };
          }
          return null;
        }
      };
    }
    exportDOM(editor) {
      const {
        element
      } = super.exportDOM(editor);
      if (isHTMLElement3(element)) {
        if (this.isEmpty()) {
          element.append(document.createElement("br"));
        }
        const formatType = this.getFormatType();
        if (formatType) {
          element.style.textAlign = formatType;
        }
        const direction = this.getDirection();
        if (direction) {
          element.dir = direction;
        }
      }
      return {
        element
      };
    }
    static importJSON(serializedNode) {
      return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        tag: this.getTag()
      };
    }
    // Mutation
    insertNewAfter(selection, restoreSelection = true) {
      const anchorOffet = selection ? selection.anchor.offset : 0;
      const lastDesc = this.getLastDescendant();
      const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();
      const newElement = isAtEnd || !selection ? $createParagraphNode2() : $createHeadingNode(this.getTag());
      const direction = this.getDirection();
      newElement.setDirection(direction);
      this.insertAfter(newElement, restoreSelection);
      if (anchorOffet === 0 && !this.isEmpty() && selection) {
        const paragraph = $createParagraphNode2();
        paragraph.select();
        this.replace(paragraph, true);
      }
      return newElement;
    }
    collapseAtStart() {
      const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode2();
      const children = this.getChildren();
      children.forEach((child) => newElement.append(child));
      this.replace(newElement);
      return true;
    }
    extractWithChild() {
      return true;
    }
  };
  function isGoogleDocsTitle(domNode) {
    if (domNode.nodeName.toLowerCase() === "span") {
      return domNode.style.fontSize === "26pt";
    }
    return false;
  }
  function $convertHeadingElement(element) {
    const nodeName = element.nodeName.toLowerCase();
    let node = null;
    if (nodeName === "h1" || nodeName === "h2" || nodeName === "h3" || nodeName === "h4" || nodeName === "h5" || nodeName === "h6") {
      node = $createHeadingNode(nodeName);
      if (element.style !== null) {
        setNodeIndentFromDOM2(element, node);
        node.setFormat(element.style.textAlign);
      }
    }
    return {
      node
    };
  }
  function $convertBlockquoteElement(element) {
    const node = $createQuoteNode();
    if (element.style !== null) {
      node.setFormat(element.style.textAlign);
      setNodeIndentFromDOM2(element, node);
    }
    return {
      node
    };
  }
  function $createHeadingNode(headingTag = "h1") {
    return $applyNodeReplacement2(new HeadingNode(headingTag));
  }
  function $isHeadingNode(node) {
    return node instanceof HeadingNode;
  }
  function onPasteForRichText(event, editor) {
    event.preventDefault();
    editor.update(() => {
      const selection = $getSelection2();
      const clipboardData = objectKlassEquals2(event, InputEvent) || objectKlassEquals2(event, KeyboardEvent) ? null : event.clipboardData;
      if (clipboardData != null && selection !== null) {
        $insertDataTransferForRichText2(clipboardData, selection, editor);
      }
    }, {
      tag: PASTE_TAG2
    });
  }
  async function onCutForRichText(event, editor) {
    await copyToClipboard2(editor, objectKlassEquals2(event, ClipboardEvent) ? event : null);
    editor.update(() => {
      const selection = $getSelection2();
      if ($isRangeSelection2(selection)) {
        selection.removeText();
      } else if ($isNodeSelection2(selection)) {
        selection.getNodes().forEach((node) => node.remove());
      }
    });
  }
  function eventFiles(event) {
    let dataTransfer = null;
    if (objectKlassEquals2(event, DragEvent)) {
      dataTransfer = event.dataTransfer;
    } else if (objectKlassEquals2(event, ClipboardEvent)) {
      dataTransfer = event.clipboardData;
    }
    if (dataTransfer === null) {
      return [false, [], false];
    }
    const types = dataTransfer.types;
    const hasFiles = types.includes("Files");
    const hasContent = types.includes("text/html") || types.includes("text/plain");
    return [hasFiles, Array.from(dataTransfer.files), hasContent];
  }
  function $handleIndentAndOutdent(indentOrOutdent) {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const alreadyHandled = /* @__PURE__ */ new Set();
    const nodes = selection.getNodes();
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      const key = node.getKey();
      if (alreadyHandled.has(key)) {
        continue;
      }
      const parentBlock = $findMatchingParent3(node, (parentNode) => $isElementNode2(parentNode) && !parentNode.isInline());
      if (parentBlock === null) {
        continue;
      }
      const parentKey = parentBlock.getKey();
      if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
        alreadyHandled.add(parentKey);
        indentOrOutdent(parentBlock);
      }
    }
    return alreadyHandled.size > 0;
  }
  function $isTargetWithinDecorator(target) {
    const node = $getNearestNodeFromDOMNode2(target);
    return $isDecoratorNode2(node);
  }
  function $isSelectionAtEndOfRoot(selection) {
    const focus = selection.focus;
    return focus.key === "root" && focus.offset === $getRoot2().getChildrenSize();
  }
  function $isSelectionCollapsedAtFrontOfIndentedBlock(selection) {
    if (!selection.isCollapsed()) {
      return false;
    }
    const {
      anchor
    } = selection;
    if (anchor.offset !== 0) {
      return false;
    }
    const anchorNode = anchor.getNode();
    if ($isRootNode2(anchorNode)) {
      return false;
    }
    const element = $getNearestBlockElementAncestorOrThrow2(anchorNode);
    return element.getIndent() > 0 && (element.is(anchorNode) || anchorNode.is(element.getFirstDescendant()));
  }
  function $resetCapitalization(selection) {
    for (const format of ["lowercase", "uppercase", "capitalize"]) {
      if (selection.hasFormat(format)) {
        selection.toggleFormat(format);
      }
    }
  }
  function registerRichText(editor) {
    const removeListener2 = mergeRegister2(editor.registerCommand(CLICK_COMMAND2, (payload) => {
      const selection = $getSelection2();
      if ($isNodeSelection2(selection)) {
        selection.clear();
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_CHARACTER_COMMAND2, (isBackward) => {
      const selection = $getSelection2();
      if ($isRangeSelection2(selection)) {
        selection.deleteCharacter(isBackward);
        return true;
      } else if ($isNodeSelection2(selection)) {
        selection.deleteNodes();
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_WORD_COMMAND2, (isBackward) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.deleteWord(isBackward);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_LINE_COMMAND2, (isBackward) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.deleteLine(isBackward);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (eventOrText) => {
      const selection = $getSelection2();
      if (typeof eventOrText === "string") {
        if (selection !== null) {
          selection.insertText(eventOrText);
        }
      } else {
        if (selection === null) {
          return false;
        }
        const dataTransfer = eventOrText.dataTransfer;
        if (dataTransfer != null) {
          $insertDataTransferForRichText2(dataTransfer, selection, editor);
        } else if ($isRangeSelection2(selection)) {
          const data2 = eventOrText.data;
          if (data2) {
            selection.insertText(data2);
          }
          return true;
        }
      }
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(REMOVE_TEXT_COMMAND2, () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.removeText();
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(FORMAT_TEXT_COMMAND2, (format) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.formatText(format);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(FORMAT_ELEMENT_COMMAND2, (format) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isNodeSelection2(selection)) {
        return false;
      }
      const nodes = selection.getNodes();
      for (const node of nodes) {
        const element = $findMatchingParent3(node, (parentNode) => $isElementNode2(parentNode) && !parentNode.isInline());
        if (element !== null) {
          element.setFormat(format);
        }
      }
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_LINE_BREAK_COMMAND2, (selectStart) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.insertLineBreak(selectStart);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.insertParagraph();
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_TAB_COMMAND2, () => {
      $insertNodes2([$createTabNode2()]);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INDENT_CONTENT_COMMAND2, () => {
      return $handleIndentAndOutdent((block) => {
        const indent = block.getIndent();
        block.setIndent(indent + 1);
      });
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(OUTDENT_CONTENT_COMMAND2, () => {
      return $handleIndentAndOutdent((block) => {
        const indent = block.getIndent();
        if (indent > 0) {
          block.setIndent(Math.max(0, indent - 1));
        }
      });
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_UP_COMMAND2, (event) => {
      const selection = $getSelection2();
      if ($isNodeSelection2(selection)) {
        const nodes = selection.getNodes();
        if (nodes.length > 0) {
          event.preventDefault();
          nodes[0].selectPrevious();
          return true;
        }
      } else if ($isRangeSelection2(selection)) {
        const possibleNode = $getAdjacentNode2(selection.focus, true);
        if (!event.shiftKey && $isDecoratorNode2(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
          possibleNode.selectPrevious();
          event.preventDefault();
          return true;
        }
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, (event) => {
      const selection = $getSelection2();
      if ($isNodeSelection2(selection)) {
        const nodes = selection.getNodes();
        if (nodes.length > 0) {
          event.preventDefault();
          nodes[0].selectNext(0, 0);
          return true;
        }
      } else if ($isRangeSelection2(selection)) {
        if ($isSelectionAtEndOfRoot(selection)) {
          event.preventDefault();
          return true;
        }
        const possibleNode = $getAdjacentNode2(selection.focus, false);
        if (!event.shiftKey && $isDecoratorNode2(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
          possibleNode.selectNext();
          event.preventDefault();
          return true;
        }
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_LEFT_COMMAND2, (event) => {
      const selection = $getSelection2();
      if ($isNodeSelection2(selection)) {
        const nodes = selection.getNodes();
        if (nodes.length > 0) {
          event.preventDefault();
          if ($isParentRTL2(nodes[0])) {
            nodes[0].selectNext(0, 0);
          } else {
            nodes[0].selectPrevious();
          }
          return true;
        }
      }
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      if ($shouldOverrideDefaultCharacterSelection2(selection, true)) {
        const isHoldingShift = event.shiftKey;
        event.preventDefault();
        $moveCharacter2(selection, isHoldingShift, true);
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND2, (event) => {
      const selection = $getSelection2();
      if ($isNodeSelection2(selection)) {
        const nodes = selection.getNodes();
        if (nodes.length > 0) {
          event.preventDefault();
          if ($isParentRTL2(nodes[0])) {
            nodes[0].selectPrevious();
          } else {
            nodes[0].selectNext(0, 0);
          }
          return true;
        }
      }
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const isHoldingShift = event.shiftKey;
      if ($shouldOverrideDefaultCharacterSelection2(selection, false)) {
        event.preventDefault();
        $moveCharacter2(selection, isHoldingShift, false);
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_BACKSPACE_COMMAND2, (event) => {
      if ($isTargetWithinDecorator(event.target)) {
        return false;
      }
      const selection = $getSelection2();
      if ($isRangeSelection2(selection)) {
        if ($isSelectionCollapsedAtFrontOfIndentedBlock(selection)) {
          event.preventDefault();
          return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND2, void 0);
        }
        if (IS_IOS4 && navigator.language === "ko-KR") {
          return false;
        }
      } else if (!$isNodeSelection2(selection)) {
        return false;
      }
      event.preventDefault();
      return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, true);
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_DELETE_COMMAND2, (event) => {
      if ($isTargetWithinDecorator(event.target)) {
        return false;
      }
      const selection = $getSelection2();
      if (!($isRangeSelection2(selection) || $isNodeSelection2(selection))) {
        return false;
      }
      event.preventDefault();
      return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, false);
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ENTER_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      $resetCapitalization(selection);
      if (event !== null) {
        if ((IS_IOS4 || IS_SAFARI4 || IS_APPLE_WEBKIT4) && CAN_USE_BEFORE_INPUT4) {
          return false;
        }
        event.preventDefault();
        if (event.shiftKey) {
          return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND2, false);
        }
      }
      return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND2, void 0);
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ESCAPE_COMMAND2, () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      editor.blur();
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DROP_COMMAND2, (event) => {
      const [, files] = eventFiles(event);
      if (files.length > 0) {
        const x2 = event.clientX;
        const y3 = event.clientY;
        const eventRange = caretFromPoint(x2, y3);
        if (eventRange !== null) {
          const {
            offset: domOffset,
            node: domNode
          } = eventRange;
          const node = $getNearestNodeFromDOMNode2(domNode);
          if (node !== null) {
            const selection2 = $createRangeSelection2();
            if ($isTextNode2(node)) {
              selection2.anchor.set(node.getKey(), domOffset, "text");
              selection2.focus.set(node.getKey(), domOffset, "text");
            } else {
              const parentKey = node.getParentOrThrow().getKey();
              const offset = node.getIndexWithinParent() + 1;
              selection2.anchor.set(parentKey, offset, "element");
              selection2.focus.set(parentKey, offset, "element");
            }
            const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection2);
            $setSelection2(normalizedSelection);
          }
          editor.dispatchCommand(DRAG_DROP_PASTE, files);
        }
        event.preventDefault();
        return true;
      }
      const selection = $getSelection2();
      if ($isRangeSelection2(selection)) {
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DRAGSTART_COMMAND2, (event) => {
      const [isFileTransfer] = eventFiles(event);
      const selection = $getSelection2();
      if (isFileTransfer && !$isRangeSelection2(selection)) {
        return false;
      }
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DRAGOVER_COMMAND2, (event) => {
      const [isFileTransfer] = eventFiles(event);
      const selection = $getSelection2();
      if (isFileTransfer && !$isRangeSelection2(selection)) {
        return false;
      }
      const x2 = event.clientX;
      const y3 = event.clientY;
      const eventRange = caretFromPoint(x2, y3);
      if (eventRange !== null) {
        const node = $getNearestNodeFromDOMNode2(eventRange.node);
        if ($isDecoratorNode2(node)) {
          event.preventDefault();
        }
      }
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(SELECT_ALL_COMMAND2, () => {
      $selectAll2();
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(COPY_COMMAND2, (event) => {
      copyToClipboard2(editor, objectKlassEquals2(event, ClipboardEvent) ? event : null);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CUT_COMMAND2, (event) => {
      onCutForRichText(event, editor);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(PASTE_COMMAND2, (event) => {
      const [, files, hasTextContent] = eventFiles(event);
      if (files.length > 0 && !hasTextContent) {
        editor.dispatchCommand(DRAG_DROP_PASTE, files);
        return true;
      }
      if (isDOMNode2(event.target) && isSelectionCapturedInDecoratorInput2(event.target)) {
        return false;
      }
      const selection = $getSelection2();
      if (selection !== null) {
        onPasteForRichText(event, editor);
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_SPACE_COMMAND2, (_3) => {
      const selection = $getSelection2();
      if ($isRangeSelection2(selection)) {
        $resetCapitalization(selection);
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_TAB_COMMAND2, (_3) => {
      const selection = $getSelection2();
      if ($isRangeSelection2(selection)) {
        $resetCapitalization(selection);
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2));
    return removeListener2;
  }
  var RichTextExtension = defineExtension2({
    conflictsWith: ["@lexical/plain-text"],
    dependencies: [DragonExtension2],
    name: "@lexical/rich-text",
    nodes: [HeadingNode, QuoteNode],
    register: registerRichText
  });

  // node_modules/@lexical/rich-text/LexicalRichText.mjs
  var mod9 = true ? LexicalRichText_dev_exports : LexicalRichText_prod_exports;
  var $createHeadingNode2 = mod9.$createHeadingNode;
  var $createQuoteNode2 = mod9.$createQuoteNode;
  var $isHeadingNode2 = mod9.$isHeadingNode;
  var $isQuoteNode2 = mod9.$isQuoteNode;
  var DRAG_DROP_PASTE2 = mod9.DRAG_DROP_PASTE;
  var HeadingNode2 = mod9.HeadingNode;
  var QuoteNode2 = mod9.QuoteNode;
  var RichTextExtension2 = mod9.RichTextExtension;
  var eventFiles2 = mod9.eventFiles;
  var registerRichText2 = mod9.registerRichText;

  // node_modules/@lexical/code/LexicalCode.dev.mjs
  var LexicalCode_dev_exports = {};
  __export(LexicalCode_dev_exports, {
    $createCodeHighlightNode: () => $createCodeHighlightNode,
    $createCodeNode: () => $createCodeNode,
    $getCodeLineDirection: () => $getCodeLineDirection,
    $getEndOfCodeInLine: () => $getEndOfCodeInLine,
    $getFirstCodeNodeOfLine: () => $getFirstCodeNodeOfLine,
    $getLastCodeNodeOfLine: () => $getLastCodeNodeOfLine,
    $getStartOfCodeInLine: () => $getStartOfCodeInLine,
    $isCodeHighlightNode: () => $isCodeHighlightNode,
    $isCodeNode: () => $isCodeNode,
    CODE_LANGUAGE_FRIENDLY_NAME_MAP: () => CODE_LANGUAGE_FRIENDLY_NAME_MAP,
    CODE_LANGUAGE_MAP: () => CODE_LANGUAGE_MAP,
    CodeExtension: () => CodeExtension,
    CodeHighlightNode: () => CodeHighlightNode,
    CodeNode: () => CodeNode,
    DEFAULT_CODE_LANGUAGE: () => DEFAULT_CODE_LANGUAGE,
    PrismTokenizer: () => PrismTokenizer,
    getCodeLanguageOptions: () => getCodeLanguageOptions,
    getCodeLanguages: () => getCodeLanguages,
    getCodeThemeOptions: () => getCodeThemeOptions,
    getDefaultCodeLanguage: () => getDefaultCodeLanguage,
    getEndOfCodeInLine: () => getEndOfCodeInLine,
    getFirstCodeNodeOfLine: () => getFirstCodeNodeOfLine,
    getLanguageFriendlyName: () => getLanguageFriendlyName,
    getLastCodeNodeOfLine: () => getLastCodeNodeOfLine,
    getStartOfCodeInLine: () => getStartOfCodeInLine,
    normalizeCodeLang: () => normalizeCodeLang,
    normalizeCodeLanguage: () => normalizeCodeLang,
    registerCodeHighlighting: () => registerCodeHighlighting
  });
  var import_prismjs = __toESM(require_prism(), 1);

  // node_modules/prismjs/components/prism-javascript.js
  Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
      Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: true
      }
    ],
    "keyword": [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });
  Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
  Prism.languages.insertBefore("javascript", "keyword", {
    "regex": {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: true,
          alias: "language-regex",
          inside: Prism.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    "parameter": [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism.languages.insertBefore("javascript", "string", {
    "hashbang": {
      pattern: /^#!.*/,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.javascript
          }
        },
        "string": /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: true,
      greedy: true,
      alias: "property"
    }
  });
  Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: true,
      alias: "property"
    }
  });
  if (Prism.languages.markup) {
    Prism.languages.markup.tag.addInlined("script", "javascript");
    Prism.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    );
  }
  Prism.languages.js = Prism.languages.javascript;

  // node_modules/prismjs/components/prism-markdown.js
  (function(Prism3) {
    var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function createInline(pattern) {
      pattern = pattern.replace(/<inner>/g, function() {
        return inner;
      });
      return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
    }
    var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
    var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
      return tableCell;
    });
    var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    Prism3.languages.markdown = Prism3.languages.extend("markup", {});
    Prism3.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: true,
        greedy: true,
        inside: {
          "punctuation": /^---|---$/,
          "front-matter": {
            pattern: /\S+(?:\s+\S+)*/,
            alias: ["yaml", "language-yaml"],
            inside: Prism3.languages.yaml
          }
        }
      },
      "blockquote": {
        // > ...
        pattern: /^>(?:[\t ]*>)*/m,
        alias: "punctuation"
      },
      "table": {
        pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
            lookbehind: true,
            inside: {
              "table-data": {
                pattern: RegExp(tableCell),
                inside: Prism3.languages.markdown
              },
              "punctuation": /\|/
            }
          },
          "table-line": {
            pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
            lookbehind: true,
            inside: {
              "punctuation": /\||:?-{3,}:?/
            }
          },
          "table-header-row": {
            pattern: RegExp("^" + tableRow + "$"),
            inside: {
              "table-header": {
                pattern: RegExp(tableCell),
                alias: "important",
                inside: Prism3.languages.markdown
              },
              "punctuation": /\|/
            }
          }
        }
      },
      "code": [
        {
          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: true,
          alias: "keyword"
        },
        {
          // ```optional language
          // code block
          // ```
          pattern: /^```[\s\S]*?^```$/m,
          greedy: true,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: true
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: true
            },
            "punctuation": /```/
          }
        }
      ],
      "title": [
        {
          // title 1
          // =======
          // title 2
          // -------
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        },
        {
          // # title 1
          // ###### title 6
          pattern: /(^\s*)#.+/m,
          lookbehind: true,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }
      ],
      "hr": {
        // ***
        // ---
        // * * *
        // -----------
        pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
        lookbehind: true,
        alias: "punctuation"
      },
      "list": {
        // * item
        // + item
        // - item
        // 1. item
        pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
        lookbehind: true,
        alias: "punctuation"
      },
      "url-reference": {
        // [id]: http://example.com "Optional title"
        // [id]: http://example.com 'Optional title'
        // [id]: http://example.com (Optional title)
        // [id]: <http://example.com> "Optional title"
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          "variable": {
            pattern: /^(!?\[)[^\]]+/,
            lookbehind: true
          },
          "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          "punctuation": /^[\[\]!:]|[<>]/
        },
        alias: "url"
      },
      "bold": {
        // **strong**
        // __strong__
        // allow one nested instance of italic text using the same delimiter
        pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          "content": {
            pattern: /(^..)[\s\S]+(?=..$)/,
            lookbehind: true,
            inside: {}
            // see below
          },
          "punctuation": /\*\*|__/
        }
      },
      "italic": {
        // *em*
        // _em_
        // allow one nested instance of bold text using the same delimiter
        pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          "content": {
            pattern: /(^.)[\s\S]+(?=.$)/,
            lookbehind: true,
            inside: {}
            // see below
          },
          "punctuation": /[*_]/
        }
      },
      "strike": {
        // ~~strike through~~
        // ~strike~
        // eslint-disable-next-line regexp/strict
        pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          "content": {
            pattern: /(^~~?)[\s\S]+(?=\1$)/,
            lookbehind: true,
            inside: {}
            // see below
          },
          "punctuation": /~~?/
        }
      },
      "code-snippet": {
        // `code`
        // ``code``
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: true,
        greedy: true,
        alias: ["code", "keyword"]
      },
      "url": {
        // [example](http://example.com "Optional title")
        // [example][id]
        // [example] [id]
        pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          "operator": /^!/,
          "content": {
            pattern: /(^\[)[^\]]+(?=\])/,
            lookbehind: true,
            inside: {}
            // see below
          },
          "variable": {
            pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
            lookbehind: true
          },
          "url": {
            pattern: /(^\]\()[^\s)]+/,
            lookbehind: true
          },
          "string": {
            pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
            lookbehind: true
          }
        }
      }
    });
    ["url", "bold", "italic", "strike"].forEach(function(token) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
        if (token !== inside) {
          Prism3.languages.markdown[token].inside.content.inside[inside] = Prism3.languages.markdown[inside];
        }
      });
    });
    Prism3.hooks.add("after-tokenize", function(env) {
      if (env.language !== "markdown" && env.language !== "md") {
        return;
      }
      function walkTokens(tokens) {
        if (!tokens || typeof tokens === "string") {
          return;
        }
        for (var i2 = 0, l4 = tokens.length; i2 < l4; i2++) {
          var token = tokens[i2];
          if (token.type !== "code") {
            walkTokens(token.content);
            continue;
          }
          var codeLang = token.content[1];
          var codeBlock = token.content[3];
          if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
            var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
            lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
            var alias = "language-" + lang;
            if (!codeBlock.alias) {
              codeBlock.alias = [alias];
            } else if (typeof codeBlock.alias === "string") {
              codeBlock.alias = [codeBlock.alias, alias];
            } else {
              codeBlock.alias.push(alias);
            }
          }
        }
      }
      walkTokens(env.tokens);
    });
    Prism3.hooks.add("wrap", function(env) {
      if (env.type !== "code-block") {
        return;
      }
      var codeLang = "";
      for (var i2 = 0, l4 = env.classes.length; i2 < l4; i2++) {
        var cls = env.classes[i2];
        var match = /language-(.+)/.exec(cls);
        if (match) {
          codeLang = match[1];
          break;
        }
      }
      var grammar = Prism3.languages[codeLang];
      if (!grammar) {
        if (codeLang && codeLang !== "none" && Prism3.plugins.autoloader) {
          var id2 = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
          env.attributes["id"] = id2;
          Prism3.plugins.autoloader.loadLanguages(codeLang, function() {
            var ele = document.getElementById(id2);
            if (ele) {
              ele.innerHTML = Prism3.highlight(ele.textContent, Prism3.languages[codeLang], codeLang);
            }
          });
        }
      } else {
        env.content = Prism3.highlight(textContent(env.content), grammar, codeLang);
      }
    });
    var tagPattern = RegExp(Prism3.languages.markup.tag.pattern.source, "gi");
    var KNOWN_ENTITY_NAMES = {
      "amp": "&",
      "lt": "<",
      "gt": ">",
      "quot": '"'
    };
    var fromCodePoint = String.fromCodePoint || String.fromCharCode;
    function textContent(html2) {
      var text2 = html2.replace(tagPattern, "");
      text2 = text2.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code) {
        code = code.toLowerCase();
        if (code[0] === "#") {
          var value;
          if (code[1] === "x") {
            value = parseInt(code.slice(2), 16);
          } else {
            value = Number(code.slice(1));
          }
          return fromCodePoint(value);
        } else {
          var known = KNOWN_ENTITY_NAMES[code];
          if (known) {
            return known;
          }
          return m2;
        }
      });
      return text2;
    }
    Prism3.languages.md = Prism3.languages.markdown;
  })(Prism);

  // node_modules/prismjs/components/prism-c.js
  Prism.languages.c = Prism.languages.extend("clike", {
    "comment": {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: true
    },
    "string": {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: true
    },
    "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    "function": /\b[a-z_]\w*(?=\s*\()/i,
    "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  });
  Prism.languages.insertBefore("c", "string", {
    "char": {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: true
    }
  });
  Prism.languages.insertBefore("c", "string", {
    "macro": {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: true,
      greedy: true,
      alias: "property",
      inside: {
        "string": [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: true
          },
          Prism.languages.c["string"]
        ],
        "char": Prism.languages.c["char"],
        "comment": Prism.languages.c["comment"],
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: true
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: true,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        "directive": {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: true,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        "punctuation": /##|\\(?=[\r\n])/,
        "expression": {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  });
  Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  });
  delete Prism.languages.c["boolean"];

  // node_modules/prismjs/components/prism-css.js
  (function(Prism3) {
    var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism3.languages.css = {
      "comment": /\/\*[\s\S]*?\*\//,
      "atrule": {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          "rule": /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: true,
            alias: "selector"
          },
          "keyword": {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: true
          }
          // See rest below
        }
      },
      "url": {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: true,
        inside: {
          "function": /^url/i,
          "punctuation": /^\(|\)$/,
          "string": {
            pattern: RegExp("^" + string.source + "$"),
            alias: "url"
          }
        }
      },
      "selector": {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
        lookbehind: true
      },
      "string": {
        pattern: string,
        greedy: true
      },
      "property": {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: true
      },
      "important": /!important\b/i,
      "function": {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: true
      },
      "punctuation": /[(){};:,]/
    };
    Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
    var markup = Prism3.languages.markup;
    if (markup) {
      markup.tag.addInlined("style", "css");
      markup.tag.addAttribute("style", "css");
    }
  })(Prism);

  // node_modules/prismjs/components/prism-objectivec.js
  Prism.languages.objectivec = Prism.languages.extend("c", {
    "string": {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: true
    },
    "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  });
  delete Prism.languages.objectivec["class-name"];
  Prism.languages.objc = Prism.languages.objectivec;

  // node_modules/prismjs/components/prism-sql.js
  Prism.languages.sql = {
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: true
    },
    "variable": [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: true
      },
      /@[\w.$]+/
    ],
    "string": {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: true,
      lookbehind: true
    },
    "identifier": {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /^`|`$/
      }
    },
    "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
    "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    "punctuation": /[;[\]()`,.]/
  };

  // node_modules/prismjs/components/prism-powershell.js
  (function(Prism3) {
    var powershell = Prism3.languages.powershell = {
      "comment": [
        {
          pattern: /(^|[^`])<#[\s\S]*?#>/,
          lookbehind: true
        },
        {
          pattern: /(^|[^`])#.*/,
          lookbehind: true
        }
      ],
      "string": [
        {
          pattern: /"(?:`[\s\S]|[^`"])*"/,
          greedy: true,
          inside: null
          // see below
        },
        {
          pattern: /'(?:[^']|'')*'/,
          greedy: true
        }
      ],
      // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
      // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
      "namespace": /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
      "boolean": /\$(?:false|true)\b/i,
      "variable": /\$\w+\b/,
      // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
      // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
      // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
      "function": [
        /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
        /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
      ],
      // per http://technet.microsoft.com/en-us/library/hh847744.aspx
      "keyword": /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
      "operator": {
        pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
        lookbehind: true
      },
      "punctuation": /[|{}[\];(),.]/
    };
    powershell.string[0].inside = {
      "function": {
        // Allow for one level of nesting
        pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
        lookbehind: true,
        inside: powershell
      },
      "boolean": powershell.boolean,
      "variable": powershell.variable
    };
  })(Prism);

  // node_modules/prismjs/components/prism-python.js
  Prism.languages.python = {
    "comment": {
      pattern: /(^|[^\\])#.*/,
      lookbehind: true,
      greedy: true
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: true,
      inside: {
        "interpolation": {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: true,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: true
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        "string": /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: true,
      alias: "string"
    },
    "string": {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: true
    },
    "function": {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: true
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: true
    },
    "decorator": {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: true,
      alias: ["annotation", "punctuation"],
      inside: {
        "punctuation": /\./
      }
    },
    "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    "boolean": /\b(?:False|None|True)\b/,
    "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    "punctuation": /[{}[\];(),.:]/
  };
  Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
  Prism.languages.py = Prism.languages.python;

  // node_modules/prismjs/components/prism-rust.js
  (function(Prism3) {
    var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
    for (var i2 = 0; i2 < 2; i2++) {
      multilineComment = multilineComment.replace(/<self>/g, function() {
        return multilineComment;
      });
    }
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return /[^\s\S]/.source;
    });
    Prism3.languages.rust = {
      "comment": [
        {
          pattern: RegExp(/(^|[^\\])/.source + multilineComment),
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: true
      },
      "char": {
        pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
        greedy: true
      },
      "attribute": {
        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
        greedy: true,
        alias: "attr-name",
        inside: {
          "string": null
          // see below
        }
      },
      // Closure params should not be confused with bitwise OR |
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: true,
        greedy: true,
        inside: {
          "closure-punctuation": {
            pattern: /^\||\|$/,
            alias: "punctuation"
          },
          rest: null
          // see below
        }
      },
      "lifetime-annotation": {
        pattern: /'\w+/,
        alias: "symbol"
      },
      "fragment-specifier": {
        pattern: /(\$\w+:)[a-z]+/,
        lookbehind: true,
        alias: "punctuation"
      },
      "variable": /\$\w+/,
      "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: true,
        alias: "function"
      },
      "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: true,
        alias: "class-name"
      },
      "module-declaration": [
        {
          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
          lookbehind: true,
          alias: "namespace"
        },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: true,
          alias: "namespace",
          inside: {
            "punctuation": /::/
          }
        }
      ],
      "keyword": [
        // https://github.com/rust-lang/reference/blob/master/src/keywords.md
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        // primitives and str
        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
      ],
      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
      // and Rust's naming conventions recommend snake_case anyway.
      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
      "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      "macro": {
        pattern: /\b\w+!/,
        alias: "property"
      },
      "constant": /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      "namespace": {
        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
        inside: {
          "punctuation": /::/
        }
      },
      // Hex, oct, bin, dec numbers with visual separators and type suffix
      "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      "boolean": /\b(?:false|true)\b/,
      "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    };
    Prism3.languages.rust["closure-params"].inside.rest = Prism3.languages.rust;
    Prism3.languages.rust["attribute"].inside["string"] = Prism3.languages.rust["string"];
  })(Prism);

  // node_modules/prismjs/components/prism-swift.js
  Prism.languages.swift = {
    "comment": {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: true,
      greedy: true
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "interpolation": {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: true,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          "punctuation": /\\(?=[\r\n])/,
          "string": /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "interpolation": {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: true,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          "string": /[\s\S]+/
        }
      }
    ],
    "directive": {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        "boolean": /\b(?:false|true)\b/,
        "number": /\b\d+(?:\.\d+)*\b/,
        "operator": /!|&&|\|\||[<>]=?/,
        "punctuation": /[(),]/
      }
    },
    "literal": {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    "attribute": {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "label": {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: true,
      alias: "important"
    },
    "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    "boolean": /\b(?:false|true)\b/,
    "nil": {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    "omit": {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    "function": /\b[a-z_]\w*(?=\s*\()/i,
    "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    "punctuation": /[{}[\]();,.:\\]/
  };
  Prism.languages.swift["string-literal"].forEach(function(rule) {
    rule.inside["interpolation"].inside = Prism.languages.swift;
  });

  // node_modules/prismjs/components/prism-typescript.js
  (function(Prism3) {
    Prism3.languages.typescript = Prism3.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    });
    Prism3.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      // keywords that have to be followed by an identifier
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      // This is for `import type *, {}`
      /\btype\b(?=\s*(?:[\{*]|$))/
    );
    delete Prism3.languages.typescript["parameter"];
    delete Prism3.languages.typescript["literal-property"];
    var typeInside = Prism3.languages.extend("typescript", {});
    delete typeInside["class-name"];
    Prism3.languages.typescript["class-name"].inside = typeInside;
    Prism3.languages.insertBefore("typescript", "function", {
      "decorator": {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          "at": {
            pattern: /^@/,
            alias: "operator"
          },
          "function": /^[\s\S]+/
        }
      },
      "generic-function": {
        // e.g. foo<T extends "bar" | "baz">( ...
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: true,
        inside: {
          "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          "generic": {
            pattern: /<[\s\S]+/,
            // everything after the first <
            alias: "class-name",
            inside: typeInside
          }
        }
      }
    });
    Prism3.languages.ts = Prism3.languages.typescript;
  })(Prism);

  // node_modules/prismjs/components/prism-java.js
  (function(Prism3) {
    var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
    var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
    var className = {
      pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: true,
      inside: {
        "namespace": {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /\./
      }
    };
    Prism3.languages.java = Prism3.languages.extend("clike", {
      "string": {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: true,
        greedy: true
      },
      "class-name": [
        className,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: true,
          inside: className.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
          lookbehind: true,
          inside: className.inside
        }
      ],
      "keyword": keywords,
      "function": [
        Prism3.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: true
        }
      ],
      "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      "operator": {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: true
      },
      "constant": /\b[A-Z][A-Z_\d]+\b/
    });
    Prism3.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: true,
        alias: "string"
      },
      "char": {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: true
      }
    });
    Prism3.languages.insertBefore("java", "class-name", {
      "annotation": {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: true,
        alias: "punctuation"
      },
      "generics": {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": className,
          "keyword": keywords,
          "punctuation": /[<>(),.:]/,
          "operator": /[?&|]/
        }
      },
      "import": [
        {
          pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: true,
          inside: {
            "namespace": className.inside.namespace,
            "punctuation": /\./,
            "operator": /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: true,
          alias: "static",
          inside: {
            "namespace": className.inside.namespace,
            "static": /\b\w+$/,
            "punctuation": /\./,
            "operator": /\*/,
            "class-name": /\w+/
          }
        }
      ],
      "namespace": {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return keywords.source;
          })
        ),
        lookbehind: true,
        inside: {
          "punctuation": /\./
        }
      }
    });
  })(Prism);

  // node_modules/prismjs/components/prism-cpp.js
  (function(Prism3) {
    var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
    var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return keyword.source;
    });
    Prism3.languages.cpp = Prism3.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return keyword.source;
          })),
          lookbehind: true
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      "keyword": keyword,
      "number": {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: true
      },
      "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      "boolean": /\b(?:false|true)\b/
    });
    Prism3.languages.insertBefore("cpp", "string", {
      "module": {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return modName;
          }) + ")"
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "string": /^[<"][\s\S]+/,
          "operator": /:/,
          "punctuation": /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: true
      }
    });
    Prism3.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          "function": /^\w+/,
          "generic": {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: Prism3.languages.cpp
          }
        }
      }
    });
    Prism3.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    });
    Prism3.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: true,
        greedy: true,
        inside: Prism3.languages.extend("cpp", {})
      }
    });
    Prism3.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, Prism3.languages.cpp["base-clause"]);
  })(Prism);

  // node_modules/@lexical/code/LexicalCode.dev.mjs
  function formatDevErrorMessage7(message) {
    throw new Error(message);
  }
  var DEFAULT_CODE_LANGUAGE = "javascript";
  var getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;
  function hasChildDOMNodeTag(node, tagName) {
    for (const child of node.childNodes) {
      if (isHTMLElement3(child) && child.tagName === tagName) {
        return true;
      }
      hasChildDOMNodeTag(child, tagName);
    }
    return false;
  }
  var LANGUAGE_DATA_ATTRIBUTE = "data-language";
  var HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = "data-highlight-language";
  var THEME_DATA_ATTRIBUTE = "data-theme";
  var CodeNode = class _CodeNode extends ElementNode2 {
    /** @internal */
    __language;
    /** @internal */
    __theme;
    /** @internal */
    __isSyntaxHighlightSupported;
    static getType() {
      return "code";
    }
    static clone(node) {
      return new _CodeNode(node.__language, node.__key);
    }
    constructor(language, key) {
      super(key);
      this.__language = language || void 0;
      this.__isSyntaxHighlightSupported = false;
      this.__theme = void 0;
    }
    afterCloneFrom(prevNode) {
      super.afterCloneFrom(prevNode);
      this.__language = prevNode.__language;
      this.__theme = prevNode.__theme;
      this.__isSyntaxHighlightSupported = prevNode.__isSyntaxHighlightSupported;
    }
    // View
    createDOM(config) {
      const element = document.createElement("code");
      addClassNamesToElement2(element, config.theme.code);
      element.setAttribute("spellcheck", "false");
      const language = this.getLanguage();
      if (language) {
        element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
        if (this.getIsSyntaxHighlightSupported()) {
          element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);
        }
      }
      const theme2 = this.getTheme();
      if (theme2) {
        element.setAttribute(THEME_DATA_ATTRIBUTE, theme2);
      }
      const style = this.getStyle();
      if (style) {
        element.setAttribute("style", style);
      }
      return element;
    }
    updateDOM(prevNode, dom, config) {
      const language = this.__language;
      const prevLanguage = prevNode.__language;
      if (language) {
        if (language !== prevLanguage) {
          dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
        }
      } else if (prevLanguage) {
        dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);
      }
      const isSyntaxHighlightSupported = this.__isSyntaxHighlightSupported;
      const prevIsSyntaxHighlightSupported = prevNode.__isSyntaxHighlightSupported;
      if (prevIsSyntaxHighlightSupported && prevLanguage) {
        if (isSyntaxHighlightSupported && language) {
          if (language !== prevLanguage) {
            dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);
          }
        } else {
          dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);
        }
      } else if (isSyntaxHighlightSupported && language) {
        dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);
      }
      const theme2 = this.__theme;
      const prevTheme = prevNode.__theme;
      if (theme2) {
        if (theme2 !== prevTheme) {
          dom.setAttribute(THEME_DATA_ATTRIBUTE, theme2);
        }
      } else if (prevTheme) {
        dom.removeAttribute(THEME_DATA_ATTRIBUTE);
      }
      const style = this.__style;
      const prevStyle = prevNode.__style;
      if (style) {
        if (style !== prevStyle) {
          dom.setAttribute("style", style);
        }
      } else if (prevStyle) {
        dom.removeAttribute("style");
      }
      return false;
    }
    exportDOM(editor) {
      const element = document.createElement("pre");
      addClassNamesToElement2(element, editor._config.theme.code);
      element.setAttribute("spellcheck", "false");
      const language = this.getLanguage();
      if (language) {
        element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
        if (this.getIsSyntaxHighlightSupported()) {
          element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);
        }
      }
      const theme2 = this.getTheme();
      if (theme2) {
        element.setAttribute(THEME_DATA_ATTRIBUTE, theme2);
      }
      const style = this.getStyle();
      if (style) {
        element.setAttribute("style", style);
      }
      return {
        element
      };
    }
    static importDOM() {
      return {
        // Typically <pre> is used for code blocks, and <code> for inline code styles
        // but if it's a multi line <code> we'll create a block. Pass through to
        // inline format handled by TextNode otherwise.
        code: (node) => {
          const isMultiLine = node.textContent != null && (/\r?\n/.test(node.textContent) || hasChildDOMNodeTag(node, "BR"));
          return isMultiLine ? {
            conversion: $convertPreElement,
            priority: 1
          } : null;
        },
        div: () => ({
          conversion: $convertDivElement,
          priority: 1
        }),
        pre: () => ({
          conversion: $convertPreElement,
          priority: 0
        }),
        table: (node) => {
          const table = node;
          if (isGitHubCodeTable(table)) {
            return {
              conversion: $convertTableElement,
              priority: 3
            };
          }
          return null;
        },
        td: (node) => {
          const td = node;
          const table = td.closest("table");
          if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {
            return {
              conversion: convertCodeNoop,
              priority: 3
            };
          }
          return null;
        },
        tr: (node) => {
          const tr = node;
          const table = tr.closest("table");
          if (table && isGitHubCodeTable(table)) {
            return {
              conversion: convertCodeNoop,
              priority: 3
            };
          }
          return null;
        }
      };
    }
    static importJSON(serializedNode) {
      return $createCodeNode().updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setLanguage(serializedNode.language).setTheme(serializedNode.theme);
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        language: this.getLanguage(),
        theme: this.getTheme()
      };
    }
    // Mutation
    insertNewAfter(selection, restoreSelection = true) {
      const children = this.getChildren();
      const childrenLength = children.length;
      if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === "\n" && children[childrenLength - 2].getTextContent() === "\n" && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {
        children[childrenLength - 1].remove();
        children[childrenLength - 2].remove();
        const newElement = $createParagraphNode2();
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      const {
        anchor,
        focus
      } = selection;
      const firstPoint = anchor.isBefore(focus) ? anchor : focus;
      const firstSelectionNode = firstPoint.getNode();
      if ($isTextNode2(firstSelectionNode)) {
        let node = $getFirstCodeNodeOfLine(firstSelectionNode);
        const insertNodes = [];
        while (true) {
          if ($isTabNode2(node)) {
            insertNodes.push($createTabNode2());
            node = node.getNextSibling();
          } else if ($isCodeHighlightNode(node)) {
            let spaces = 0;
            const text2 = node.getTextContent();
            const textSize = node.getTextContentSize();
            while (spaces < textSize && text2[spaces] === " ") {
              spaces++;
            }
            if (spaces !== 0) {
              insertNodes.push($createCodeHighlightNode(" ".repeat(spaces)));
            }
            if (spaces !== textSize) {
              break;
            }
            node = node.getNextSibling();
          } else {
            break;
          }
        }
        const split = firstSelectionNode.splitText(anchor.offset)[0];
        const x2 = anchor.offset === 0 ? 0 : 1;
        const index2 = split.getIndexWithinParent() + x2;
        const codeNode = firstSelectionNode.getParentOrThrow();
        const nodesToInsert = [$createLineBreakNode2(), ...insertNodes];
        codeNode.splice(index2, 0, nodesToInsert);
        const last = insertNodes[insertNodes.length - 1];
        if (last) {
          last.select();
        } else if (anchor.offset === 0) {
          split.selectPrevious();
        } else {
          split.getNextSibling().selectNext(0, 0);
        }
      }
      if ($isCodeNode(firstSelectionNode)) {
        const {
          offset
        } = selection.anchor;
        firstSelectionNode.splice(offset, 0, [$createLineBreakNode2()]);
        firstSelectionNode.select(offset + 1, offset + 1);
      }
      return null;
    }
    canIndent() {
      return false;
    }
    collapseAtStart() {
      const paragraph = $createParagraphNode2();
      const children = this.getChildren();
      children.forEach((child) => paragraph.append(child));
      this.replace(paragraph);
      return true;
    }
    setLanguage(language) {
      const writable = this.getWritable();
      writable.__language = language || void 0;
      return writable;
    }
    getLanguage() {
      return this.getLatest().__language;
    }
    setIsSyntaxHighlightSupported(isSupported) {
      const writable = this.getWritable();
      writable.__isSyntaxHighlightSupported = isSupported;
      return writable;
    }
    getIsSyntaxHighlightSupported() {
      return this.getLatest().__isSyntaxHighlightSupported;
    }
    setTheme(theme2) {
      const writable = this.getWritable();
      writable.__theme = theme2 || void 0;
      return writable;
    }
    getTheme() {
      return this.getLatest().__theme;
    }
  };
  function $createCodeNode(language, theme2) {
    return $create2(CodeNode).setLanguage(language).setTheme(theme2);
  }
  function $isCodeNode(node) {
    return node instanceof CodeNode;
  }
  function $convertPreElement(domNode) {
    const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);
    return {
      node: $createCodeNode(language)
    };
  }
  function $convertDivElement(domNode) {
    const div = domNode;
    const isCode = isCodeElement(div);
    if (!isCode && !isCodeChildElement(div)) {
      return {
        node: null
      };
    }
    return {
      node: isCode ? $createCodeNode() : null
    };
  }
  function $convertTableElement() {
    return {
      node: $createCodeNode()
    };
  }
  function convertCodeNoop() {
    return {
      node: null
    };
  }
  function isCodeElement(div) {
    return div.style.fontFamily.match("monospace") !== null;
  }
  function isCodeChildElement(node) {
    let parent = node.parentElement;
    while (parent !== null) {
      if (isCodeElement(parent)) {
        return true;
      }
      parent = parent.parentElement;
    }
    return false;
  }
  function isGitHubCodeCell(cell) {
    return cell.classList.contains("js-file-line");
  }
  function isGitHubCodeTable(table) {
    return table.classList.contains("js-file-line-container");
  }
  var CodeHighlightNode = class _CodeHighlightNode extends TextNode2 {
    /** @internal */
    __highlightType;
    constructor(text2 = "", highlightType, key) {
      super(text2, key);
      this.__highlightType = highlightType;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(node) {
      return new _CodeHighlightNode(node.__text, node.__highlightType || void 0, node.__key);
    }
    getHighlightType() {
      const self2 = this.getLatest();
      return self2.__highlightType;
    }
    setHighlightType(highlightType) {
      const self2 = this.getWritable();
      self2.__highlightType = highlightType || void 0;
      return self2;
    }
    canHaveFormat() {
      return false;
    }
    createDOM(config) {
      const element = super.createDOM(config);
      const className = getHighlightThemeClass(config.theme, this.__highlightType);
      addClassNamesToElement2(element, className);
      return element;
    }
    updateDOM(prevNode, dom, config) {
      const update = super.updateDOM(prevNode, dom, config);
      const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);
      const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);
      if (prevClassName !== nextClassName) {
        if (prevClassName) {
          removeClassNamesFromElement2(dom, prevClassName);
        }
        if (nextClassName) {
          addClassNamesToElement2(dom, nextClassName);
        }
      }
      return update;
    }
    static importJSON(serializedNode) {
      return $createCodeHighlightNode().updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setHighlightType(serializedNode.highlightType);
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        highlightType: this.getHighlightType()
      };
    }
    // Prevent formatting (bold, underline, etc)
    setFormat(format) {
      return this;
    }
    isParentRequired() {
      return true;
    }
    createParentElementNode() {
      return $createCodeNode();
    }
  };
  function getHighlightThemeClass(theme2, highlightType) {
    return highlightType && theme2 && theme2.codeHighlight && theme2.codeHighlight[highlightType];
  }
  function $createCodeHighlightNode(text2 = "", highlightType) {
    return $applyNodeReplacement2(new CodeHighlightNode(text2, highlightType));
  }
  function $isCodeHighlightNode(node) {
    return node instanceof CodeHighlightNode;
  }
  function $getLastMatchingCodeNode(anchor, direction) {
    let matchingNode = anchor;
    for (let caret = $getSiblingCaret2(anchor, direction); caret && ($isCodeHighlightNode(caret.origin) || $isTabNode2(caret.origin)); caret = $getAdjacentCaret2(caret)) {
      matchingNode = caret.origin;
    }
    return matchingNode;
  }
  function $getFirstCodeNodeOfLine(anchor) {
    return $getLastMatchingCodeNode(anchor, "previous");
  }
  function $getLastCodeNodeOfLine(anchor) {
    return $getLastMatchingCodeNode(anchor, "next");
  }
  function $getCodeLineDirection(anchor) {
    const start3 = $getFirstCodeNodeOfLine(anchor);
    const end = $getLastCodeNodeOfLine(anchor);
    let node = start3;
    while (node !== null) {
      if ($isCodeHighlightNode(node)) {
        const direction = getTextDirection2(node.getTextContent());
        if (direction !== null) {
          return direction;
        }
      }
      if (node === end) {
        break;
      }
      node = node.getNextSibling();
    }
    const parent = start3.getParent();
    if ($isElementNode2(parent)) {
      const parentDirection = parent.getDirection();
      if (parentDirection === "ltr" || parentDirection === "rtl") {
        return parentDirection;
      }
    }
    return null;
  }
  function $getStartOfCodeInLine(anchor, offset) {
    let last = null;
    let lastNonBlank = null;
    let node = anchor;
    let nodeOffset = offset;
    let nodeTextContent = anchor.getTextContent();
    while (true) {
      if (nodeOffset === 0) {
        node = node.getPreviousSibling();
        if (node === null) {
          break;
        }
        if (!($isCodeHighlightNode(node) || $isTabNode2(node) || $isLineBreakNode2(node))) {
          formatDevErrorMessage7(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);
        }
        if ($isLineBreakNode2(node)) {
          last = {
            node,
            offset: 1
          };
          break;
        }
        nodeOffset = Math.max(0, node.getTextContentSize() - 1);
        nodeTextContent = node.getTextContent();
      } else {
        nodeOffset--;
      }
      const character = nodeTextContent[nodeOffset];
      if ($isCodeHighlightNode(node) && character !== " ") {
        lastNonBlank = {
          node,
          offset: nodeOffset
        };
      }
    }
    if (lastNonBlank !== null) {
      return lastNonBlank;
    }
    let codeCharacterAtAnchorOffset = null;
    if (offset < anchor.getTextContentSize()) {
      if ($isCodeHighlightNode(anchor)) {
        codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];
      }
    } else {
      const nextSibling = anchor.getNextSibling();
      if ($isCodeHighlightNode(nextSibling)) {
        codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];
      }
    }
    if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== " ") {
      return last;
    } else {
      const nextNonBlank = findNextNonBlankInLine(anchor, offset);
      if (nextNonBlank !== null) {
        return nextNonBlank;
      } else {
        return last;
      }
    }
  }
  function findNextNonBlankInLine(anchor, offset) {
    let node = anchor;
    let nodeOffset = offset;
    let nodeTextContent = anchor.getTextContent();
    let nodeTextContentSize = anchor.getTextContentSize();
    while (true) {
      if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {
        node = node.getNextSibling();
        if (node === null || $isLineBreakNode2(node)) {
          return null;
        }
        if ($isCodeHighlightNode(node)) {
          nodeOffset = 0;
          nodeTextContent = node.getTextContent();
          nodeTextContentSize = node.getTextContentSize();
        }
      }
      if ($isCodeHighlightNode(node)) {
        if (nodeTextContent[nodeOffset] !== " ") {
          return {
            node,
            offset: nodeOffset
          };
        }
        nodeOffset++;
      }
    }
  }
  function $getEndOfCodeInLine(anchor) {
    const lastNode = $getLastCodeNodeOfLine(anchor);
    if (!!$isLineBreakNode2(lastNode)) {
      formatDevErrorMessage7(`Unexpected lineBreakNode in getEndOfCodeInLine`);
    }
    return lastNode;
  }
  var CodeExtension = defineExtension2({
    name: "@lexical/code",
    nodes: [CodeNode, CodeHighlightNode]
  });
  (function(Prism3) {
    Prism3.languages.diff = {
      "coord": [
        // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
        /^(?:\*{3}|-{3}|\+{3}).*$/m,
        // Match "@@ ... @@" coord lines in unified diff.
        /^@@.*@@$/m,
        // Match coord lines in normal diff (starts with a number).
        /^\d.*$/m
      ]
      // deleted, inserted, unchanged, diff
    };
    var PREFIXES = {
      "deleted-sign": "-",
      "deleted-arrow": "<",
      "inserted-sign": "+",
      "inserted-arrow": ">",
      "unchanged": " ",
      "diff": "!"
    };
    Object.keys(PREFIXES).forEach(function(name) {
      var prefix2 = PREFIXES[name];
      var alias = [];
      if (!/^\w+$/.test(name)) {
        alias.push(/\w+/.exec(name)[0]);
      }
      if (name === "diff") {
        alias.push("bold");
      }
      Prism3.languages.diff[name] = {
        pattern: RegExp("^(?:[" + prefix2 + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
        alias,
        inside: {
          "line": {
            pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
            lookbehind: true
          },
          "prefix": {
            pattern: /[\s\S]/,
            alias: /\w+/.exec(name)[0]
          }
        }
      };
    });
    Object.defineProperty(Prism3.languages.diff, "PREFIXES", {
      value: PREFIXES
    });
  })(Prism);
  var Prism$1 = globalThis.Prism || window.Prism;
  var CODE_LANGUAGE_FRIENDLY_NAME_MAP = {
    c: "C",
    clike: "C-like",
    cpp: "C++",
    css: "CSS",
    html: "HTML",
    java: "Java",
    js: "JavaScript",
    markdown: "Markdown",
    objc: "Objective-C",
    plain: "Plain Text",
    powershell: "PowerShell",
    py: "Python",
    rust: "Rust",
    sql: "SQL",
    swift: "Swift",
    typescript: "TypeScript",
    xml: "XML"
  };
  var CODE_LANGUAGE_MAP = {
    cpp: "cpp",
    java: "java",
    javascript: "js",
    md: "markdown",
    plaintext: "plain",
    python: "py",
    text: "plain",
    ts: "typescript"
  };
  function normalizeCodeLang(lang) {
    return CODE_LANGUAGE_MAP[lang] || lang;
  }
  function getLanguageFriendlyName(lang) {
    const _lang = normalizeCodeLang(lang);
    return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;
  }
  var getCodeLanguages = () => Object.keys(Prism$1.languages).filter(
    // Prism has several language helpers mixed into languages object
    // so filtering them out here to get langs list
    (language) => typeof Prism$1.languages[language] !== "function"
  ).sort();
  function getCodeLanguageOptions() {
    const options = [];
    for (const [lang, friendlyName] of Object.entries(CODE_LANGUAGE_FRIENDLY_NAME_MAP)) {
      options.push([lang, friendlyName]);
    }
    return options;
  }
  function getCodeThemeOptions() {
    const options = [];
    return options;
  }
  function getDiffedLanguage(language) {
    const DIFF_LANGUAGE_REGEX = /^diff-([\w-]+)/i;
    const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(language);
    return diffLanguageMatch ? diffLanguageMatch[1] : null;
  }
  function isCodeLanguageLoaded(language) {
    const diffedLanguage = getDiffedLanguage(language);
    const langId = diffedLanguage ? diffedLanguage : language;
    try {
      return langId ? Prism$1.languages.hasOwnProperty(langId) : false;
    } catch (_unused) {
      return false;
    }
  }
  async function loadCodeLanguage(language, editor, codeNodeKey) {
  }
  function getTextContent(token) {
    if (typeof token === "string") {
      return token;
    } else if (Array.isArray(token)) {
      return token.map(getTextContent).join("");
    } else {
      return getTextContent(token.content);
    }
  }
  function tokenizeDiffHighlight(tokens, language) {
    const diffLanguage = language;
    const diffGrammar = Prism$1.languages[diffLanguage];
    const env = {
      tokens
    };
    const PREFIXES = Prism$1.languages.diff.PREFIXES;
    for (const token of env.tokens) {
      if (typeof token === "string" || !(token.type in PREFIXES) || !Array.isArray(token.content)) {
        continue;
      }
      const type = token.type;
      let insertedPrefixes = 0;
      const getPrefixToken = () => {
        insertedPrefixes++;
        return new Prism$1.Token("prefix", PREFIXES[type], type.replace(/^(\w+).*/, "$1"));
      };
      const withoutPrefixes = token.content.filter((t2) => typeof t2 === "string" || t2.type !== "prefix");
      const prefixCount = token.content.length - withoutPrefixes.length;
      const diffTokens = Prism$1.tokenize(getTextContent(withoutPrefixes), diffGrammar);
      diffTokens.unshift(getPrefixToken());
      const LINE_BREAK = /\r\n|\n/g;
      const insertAfterLineBreakString = (text2) => {
        const result = [];
        LINE_BREAK.lastIndex = 0;
        let last = 0;
        let m2;
        while (insertedPrefixes < prefixCount && (m2 = LINE_BREAK.exec(text2))) {
          const end = m2.index + m2[0].length;
          result.push(text2.slice(last, end));
          last = end;
          result.push(getPrefixToken());
        }
        if (result.length === 0) {
          return void 0;
        }
        if (last < text2.length) {
          result.push(text2.slice(last));
        }
        return result;
      };
      const insertAfterLineBreak = (toks) => {
        for (let i2 = 0; i2 < toks.length && insertedPrefixes < prefixCount; i2++) {
          const tok = toks[i2];
          if (typeof tok === "string") {
            const inserted = insertAfterLineBreakString(tok);
            if (inserted) {
              toks.splice(i2, 1, ...inserted);
              i2 += inserted.length - 1;
            }
          } else if (typeof tok.content === "string") {
            const inserted = insertAfterLineBreakString(tok.content);
            if (inserted) {
              tok.content = inserted;
            }
          } else if (Array.isArray(tok.content)) {
            insertAfterLineBreak(tok.content);
          } else {
            insertAfterLineBreak([tok.content]);
          }
        }
      };
      insertAfterLineBreak(diffTokens);
      if (insertedPrefixes < prefixCount) {
        diffTokens.push(getPrefixToken());
      }
      token.content = diffTokens;
    }
    return env.tokens;
  }
  function $getHighlightNodes(codeNode, language) {
    const DIFF_LANGUAGE_REGEX = /^diff-([\w-]+)/i;
    const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(language);
    const code = codeNode.getTextContent();
    let tokens = Prism$1.tokenize(code, Prism$1.languages[diffLanguageMatch ? "diff" : language]);
    if (diffLanguageMatch) {
      tokens = tokenizeDiffHighlight(tokens, diffLanguageMatch[1]);
    }
    return $mapTokensToLexicalStructure(tokens);
  }
  function $mapTokensToLexicalStructure(tokens, type) {
    const nodes = [];
    for (const token of tokens) {
      if (typeof token === "string") {
        const partials = token.split(/(\n|\t)/);
        const partialsLength = partials.length;
        for (let i2 = 0; i2 < partialsLength; i2++) {
          const part = partials[i2];
          if (part === "\n" || part === "\r\n") {
            nodes.push($createLineBreakNode2());
          } else if (part === "	") {
            nodes.push($createTabNode2());
          } else if (part.length > 0) {
            nodes.push($createCodeHighlightNode(part, type));
          }
        }
      } else {
        const {
          content,
          alias
        } = token;
        if (typeof content === "string") {
          nodes.push(...$mapTokensToLexicalStructure([content], token.type === "prefix" && typeof alias === "string" ? alias : token.type));
        } else if (Array.isArray(content)) {
          nodes.push(...$mapTokensToLexicalStructure(content, token.type === "unchanged" ? void 0 : token.type));
        }
      }
    }
    return nodes;
  }
  var PrismTokenizer = {
    $tokenize(codeNode, language) {
      return $getHighlightNodes(codeNode, language || this.defaultLanguage);
    },
    defaultLanguage: DEFAULT_CODE_LANGUAGE,
    tokenize(code, language) {
      return Prism$1.tokenize(code, Prism$1.languages[language || ""] || Prism$1.languages[this.defaultLanguage]);
    }
  };
  function $textNodeTransform(node, editor, tokenizer) {
    const parentNode = node.getParent();
    if ($isCodeNode(parentNode)) {
      codeNodeTransform(parentNode, editor, tokenizer);
    } else if ($isCodeHighlightNode(node)) {
      node.replace($createTextNode2(node.__text));
    }
  }
  function updateCodeGutter(node, editor) {
    const codeElement = editor.getElementByKey(node.getKey());
    if (codeElement === null) {
      return;
    }
    const children = node.getChildren();
    const childrenLength = children.length;
    if (childrenLength === codeElement.__cachedChildrenLength) {
      return;
    }
    codeElement.__cachedChildrenLength = childrenLength;
    let gutter = "1";
    let count = 1;
    for (let i2 = 0; i2 < childrenLength; i2++) {
      if ($isLineBreakNode2(children[i2])) {
        gutter += "\n" + ++count;
      }
    }
    codeElement.setAttribute("data-gutter", gutter);
  }
  var nodesCurrentlyHighlighting = /* @__PURE__ */ new Set();
  function codeNodeTransform(node, editor, tokenizer) {
    const nodeKey = node.getKey();
    if (node.getLanguage() === void 0) {
      node.setLanguage(tokenizer.defaultLanguage);
    }
    const language = node.getLanguage() || tokenizer.defaultLanguage;
    if (isCodeLanguageLoaded(language)) {
      if (!node.getIsSyntaxHighlightSupported()) {
        node.setIsSyntaxHighlightSupported(true);
      }
    } else {
      if (node.getIsSyntaxHighlightSupported()) {
        node.setIsSyntaxHighlightSupported(false);
      }
      loadCodeLanguage(language, editor, nodeKey);
      return;
    }
    if (nodesCurrentlyHighlighting.has(nodeKey)) {
      return;
    }
    nodesCurrentlyHighlighting.add(nodeKey);
    editor.update(() => {
      $updateAndRetainSelection(nodeKey, () => {
        const currentNode = $getNodeByKey2(nodeKey);
        if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {
          return false;
        }
        const currentLanguage = currentNode.getLanguage() || tokenizer.defaultLanguage;
        const highlightNodes = tokenizer.$tokenize(currentNode, currentLanguage);
        const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);
        const {
          from: from2,
          to: to2,
          nodesForReplacement
        } = diffRange;
        if (from2 !== to2 || nodesForReplacement.length) {
          node.splice(from2, to2 - from2, nodesForReplacement);
          return true;
        }
        return false;
      });
    }, {
      onUpdate: () => {
        nodesCurrentlyHighlighting.delete(nodeKey);
      },
      skipTransforms: true
    });
  }
  function $updateAndRetainSelection(nodeKey, updateFn) {
    const node = $getNodeByKey2(nodeKey);
    if (!$isCodeNode(node) || !node.isAttached()) {
      return;
    }
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      updateFn();
      return;
    }
    const anchor = selection.anchor;
    const anchorOffset = anchor.offset;
    const isNewLineAnchor = anchor.type === "element" && $isLineBreakNode2(node.getChildAtIndex(anchor.offset - 1));
    let textOffset = 0;
    if (!isNewLineAnchor) {
      const anchorNode = anchor.getNode();
      textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {
        return offset + _node.getTextContentSize();
      }, 0);
    }
    const hasChanges = updateFn();
    if (!hasChanges) {
      return;
    }
    if (isNewLineAnchor) {
      anchor.getNode().select(anchorOffset, anchorOffset);
      return;
    }
    node.getChildren().some((_node) => {
      const isText = $isTextNode2(_node);
      if (isText || $isLineBreakNode2(_node)) {
        const textContentSize = _node.getTextContentSize();
        if (isText && textContentSize >= textOffset) {
          _node.select(textOffset, textOffset);
          return true;
        }
        textOffset -= textContentSize;
      }
      return false;
    });
  }
  function getDiffRange(prevNodes, nextNodes) {
    let leadingMatch = 0;
    while (leadingMatch < prevNodes.length) {
      if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {
        break;
      }
      leadingMatch++;
    }
    const prevNodesLength = prevNodes.length;
    const nextNodesLength = nextNodes.length;
    const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;
    let trailingMatch = 0;
    while (trailingMatch < maxTrailingMatch) {
      trailingMatch++;
      if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {
        trailingMatch--;
        break;
      }
    }
    const from2 = leadingMatch;
    const to2 = prevNodesLength - trailingMatch;
    const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);
    return {
      from: from2,
      nodesForReplacement,
      to: to2
    };
  }
  function isEqual(nodeA, nodeB) {
    return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || $isTabNode2(nodeA) && $isTabNode2(nodeB) || $isLineBreakNode2(nodeA) && $isLineBreakNode2(nodeB);
  }
  function $isSelectionInCode(selection) {
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const anchorNode = selection.anchor.getNode();
    const maybeAnchorCodeNode = $isCodeNode(anchorNode) ? anchorNode : anchorNode.getParent();
    const focusNode = selection.focus.getNode();
    const maybeFocusCodeNode = $isCodeNode(focusNode) ? focusNode : focusNode.getParent();
    return $isCodeNode(maybeAnchorCodeNode) && maybeAnchorCodeNode.is(maybeFocusCodeNode);
  }
  function $getCodeLines(selection) {
    const nodes = selection.getNodes();
    const lines = [];
    if (nodes.length === 1 && $isCodeNode(nodes[0])) {
      return lines;
    }
    let lastLine = [];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if (!($isCodeHighlightNode(node) || $isTabNode2(node) || $isLineBreakNode2(node))) {
        formatDevErrorMessage7(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);
      }
      if ($isLineBreakNode2(node)) {
        if (lastLine.length > 0) {
          lines.push(lastLine);
          lastLine = [];
        }
      } else {
        lastLine.push(node);
      }
    }
    if (lastLine.length > 0) {
      const selectionEnd = selection.isBackward() ? selection.anchor : selection.focus;
      const lastPoint = $createPoint2(lastLine[0].getKey(), 0, "text");
      if (!selectionEnd.is(lastPoint)) {
        lines.push(lastLine);
      }
    }
    return lines;
  }
  function $handleTab(shiftKey) {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection) || !$isSelectionInCode(selection)) {
      return null;
    }
    const indentOrOutdent = !shiftKey ? INDENT_CONTENT_COMMAND2 : OUTDENT_CONTENT_COMMAND2;
    const tabOrOutdent = !shiftKey ? INSERT_TAB_COMMAND2 : OUTDENT_CONTENT_COMMAND2;
    const anchor = selection.anchor;
    const focus = selection.focus;
    if (anchor.is(focus)) {
      return tabOrOutdent;
    }
    const codeLines = $getCodeLines(selection);
    if (codeLines.length !== 1) {
      return indentOrOutdent;
    }
    const codeLine = codeLines[0];
    const codeLineLength = codeLine.length;
    if (!(codeLineLength !== 0)) {
      formatDevErrorMessage7(`$getCodeLines only extracts non-empty lines`);
    }
    let selectionFirst;
    let selectionLast;
    if (selection.isBackward()) {
      selectionFirst = focus;
      selectionLast = anchor;
    } else {
      selectionFirst = anchor;
      selectionLast = focus;
    }
    const firstOfLine = $getFirstCodeNodeOfLine(codeLine[0]);
    const lastOfLine = $getLastCodeNodeOfLine(codeLine[0]);
    const anchorOfLine = $createPoint2(firstOfLine.getKey(), 0, "text");
    const focusOfLine = $createPoint2(lastOfLine.getKey(), lastOfLine.getTextContentSize(), "text");
    if (selectionFirst.isBefore(anchorOfLine)) {
      return indentOrOutdent;
    }
    if (focusOfLine.isBefore(selectionLast)) {
      return indentOrOutdent;
    }
    if (anchorOfLine.isBefore(selectionFirst) || selectionLast.isBefore(focusOfLine)) {
      return tabOrOutdent;
    }
    return indentOrOutdent;
  }
  function $handleMultilineIndent(type) {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection) || !$isSelectionInCode(selection)) {
      return false;
    }
    const codeLines = $getCodeLines(selection);
    const codeLinesLength = codeLines.length;
    if (codeLinesLength === 0 && selection.isCollapsed()) {
      if (type === INDENT_CONTENT_COMMAND2) {
        selection.insertNodes([$createTabNode2()]);
      }
      return true;
    }
    if (codeLinesLength === 0 && type === INDENT_CONTENT_COMMAND2 && selection.getTextContent() === "\n") {
      const tabNode = $createTabNode2();
      const lineBreakNode = $createLineBreakNode2();
      const direction = selection.isBackward() ? "previous" : "next";
      selection.insertNodes([tabNode, lineBreakNode]);
      $setSelectionFromCaretRange2($getCaretRangeInDirection2($getCaretRange2($getTextPointCaret2(tabNode, "next", 0), $normalizeCaret2($getSiblingCaret2(lineBreakNode, "next"))), direction));
      return true;
    }
    for (let i2 = 0; i2 < codeLinesLength; i2++) {
      const line = codeLines[i2];
      if (line.length > 0) {
        let firstOfLine = line[0];
        if (i2 === 0) {
          firstOfLine = $getFirstCodeNodeOfLine(firstOfLine);
        }
        if (type === INDENT_CONTENT_COMMAND2) {
          const tabNode = $createTabNode2();
          firstOfLine.insertBefore(tabNode);
          if (i2 === 0) {
            const anchorKey = selection.isBackward() ? "focus" : "anchor";
            const anchorLine = $createPoint2(firstOfLine.getKey(), 0, "text");
            if (selection[anchorKey].is(anchorLine)) {
              selection[anchorKey].set(tabNode.getKey(), 0, "text");
            }
          }
        } else if ($isTabNode2(firstOfLine)) {
          firstOfLine.remove();
        }
      }
    }
    return true;
  }
  function $handleShiftLines(type, event) {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const {
      anchor,
      focus
    } = selection;
    const anchorOffset = anchor.offset;
    const focusOffset = focus.offset;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    const arrowIsUp = type === KEY_ARROW_UP_COMMAND2;
    if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode2(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode2(focusNode))) {
      return false;
    }
    if (!event.altKey) {
      if (selection.isCollapsed()) {
        const codeNode = anchorNode.getParentOrThrow();
        if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {
          const codeNodeSibling = codeNode.getPreviousSibling();
          if (codeNodeSibling === null) {
            codeNode.selectPrevious();
            event.preventDefault();
            return true;
          }
        } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {
          const codeNodeSibling = codeNode.getNextSibling();
          if (codeNodeSibling === null) {
            codeNode.selectNext();
            event.preventDefault();
            return true;
          }
        }
      }
      return false;
    }
    let start3;
    let end;
    if (anchorNode.isBefore(focusNode)) {
      start3 = $getFirstCodeNodeOfLine(anchorNode);
      end = $getLastCodeNodeOfLine(focusNode);
    } else {
      start3 = $getFirstCodeNodeOfLine(focusNode);
      end = $getLastCodeNodeOfLine(anchorNode);
    }
    if (start3 == null || end == null) {
      return false;
    }
    const range2 = start3.getNodesBetween(end);
    for (let i2 = 0; i2 < range2.length; i2++) {
      const node = range2[i2];
      if (!$isCodeHighlightNode(node) && !$isTabNode2(node) && !$isLineBreakNode2(node)) {
        return false;
      }
    }
    event.preventDefault();
    event.stopPropagation();
    const linebreak = arrowIsUp ? start3.getPreviousSibling() : end.getNextSibling();
    if (!$isLineBreakNode2(linebreak)) {
      return true;
    }
    const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();
    if (sibling == null) {
      return true;
    }
    const maybeInsertionPoint = $isCodeHighlightNode(sibling) || $isTabNode2(sibling) || $isLineBreakNode2(sibling) ? arrowIsUp ? $getFirstCodeNodeOfLine(sibling) : $getLastCodeNodeOfLine(sibling) : null;
    let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;
    linebreak.remove();
    range2.forEach((node) => node.remove());
    if (type === KEY_ARROW_UP_COMMAND2) {
      range2.forEach((node) => insertionPoint.insertBefore(node));
      insertionPoint.insertBefore(linebreak);
    } else {
      insertionPoint.insertAfter(linebreak);
      insertionPoint = linebreak;
      range2.forEach((node) => {
        insertionPoint.insertAfter(node);
        insertionPoint = node;
      });
    }
    selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);
    return true;
  }
  function $handleMoveTo(type, event) {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const {
      anchor,
      focus
    } = selection;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    const isMoveToStart2 = type === MOVE_TO_START2;
    if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode2(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode2(focusNode))) {
      return false;
    }
    const focusLineNode = focusNode;
    const direction = $getCodeLineDirection(focusLineNode);
    const moveToStart = direction === "rtl" ? !isMoveToStart2 : isMoveToStart2;
    if (moveToStart) {
      const start3 = $getStartOfCodeInLine(focusLineNode, focus.offset);
      if (start3 !== null) {
        const {
          node,
          offset
        } = start3;
        if ($isLineBreakNode2(node)) {
          node.selectNext(0, 0);
        } else {
          selection.setTextNodeRange(node, offset, node, offset);
        }
      } else {
        focusLineNode.getParentOrThrow().selectStart();
      }
    } else {
      const node = $getEndOfCodeInLine(focusLineNode);
      node.select();
    }
    event.preventDefault();
    event.stopPropagation();
    return true;
  }
  function registerCodeHighlighting(editor, tokenizer) {
    if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {
      throw new Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    }
    if (tokenizer == null) {
      tokenizer = PrismTokenizer;
    }
    const registrations = [];
    if (editor._headless !== true) {
      registrations.push(editor.registerMutationListener(CodeNode, (mutations) => {
        editor.getEditorState().read(() => {
          for (const [key, type] of mutations) {
            if (type !== "destroyed") {
              const node = $getNodeByKey2(key);
              if (node !== null) {
                updateCodeGutter(node, editor);
              }
            }
          }
        });
      }, {
        skipInitialization: false
      }));
    }
    registrations.push(editor.registerNodeTransform(CodeNode, (node) => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(TextNode2, (node) => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, (node) => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(KEY_TAB_COMMAND2, (event) => {
      const command = $handleTab(event.shiftKey);
      if (command === null) {
        return false;
      }
      event.preventDefault();
      editor.dispatchCommand(command, void 0);
      return true;
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INSERT_TAB_COMMAND2, () => {
      const selection = $getSelection2();
      if (!$isSelectionInCode(selection)) {
        return false;
      }
      $insertNodes2([$createTabNode2()]);
      return true;
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INDENT_CONTENT_COMMAND2, (payload) => $handleMultilineIndent(INDENT_CONTENT_COMMAND2), COMMAND_PRIORITY_LOW2), editor.registerCommand(OUTDENT_CONTENT_COMMAND2, (payload) => $handleMultilineIndent(OUTDENT_CONTENT_COMMAND2), COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_UP_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const {
        anchor
      } = selection;
      const anchorNode = anchor.getNode();
      if (!$isSelectionInCode(selection)) {
        return false;
      }
      if (selection.isCollapsed() && anchor.offset === 0 && anchorNode.getPreviousSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {
        event.preventDefault();
        return true;
      }
      return $handleShiftLines(KEY_ARROW_UP_COMMAND2, event);
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const {
        anchor
      } = selection;
      const anchorNode = anchor.getNode();
      if (!$isSelectionInCode(selection)) {
        return false;
      }
      if (selection.isCollapsed() && anchor.offset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {
        event.preventDefault();
        return true;
      }
      return $handleShiftLines(KEY_ARROW_DOWN_COMMAND2, event);
    }, COMMAND_PRIORITY_LOW2), editor.registerCommand(MOVE_TO_START2, (event) => $handleMoveTo(MOVE_TO_START2, event), COMMAND_PRIORITY_LOW2), editor.registerCommand(MOVE_TO_END2, (event) => $handleMoveTo(MOVE_TO_END2, event), COMMAND_PRIORITY_LOW2));
    return mergeRegister2(...registrations);
  }
  var getFirstCodeNodeOfLine = $getFirstCodeNodeOfLine;
  var getLastCodeNodeOfLine = $getLastCodeNodeOfLine;
  var getEndOfCodeInLine = $getEndOfCodeInLine;
  var getStartOfCodeInLine = $getStartOfCodeInLine;

  // node_modules/@lexical/code/LexicalCode.prod.mjs
  var import_prismjs2 = __toESM(require_prism(), 1);
  function R(e2, n2) {
    for (const r2 of e2.childNodes) {
      if (isHTMLElement3(r2) && r2.tagName === n2) return true;
      R(r2, n2);
    }
    return false;
  }
  var K = "data-language";
  var $ = "data-highlight-language";
  var W = "data-theme";
  var q = class _q extends ElementNode2 {
    __language;
    __theme;
    __isSyntaxHighlightSupported;
    static getType() {
      return "code";
    }
    static clone(t2) {
      return new _q(t2.__language, t2.__key);
    }
    constructor(t2, e2) {
      super(e2), this.__language = t2 || void 0, this.__isSyntaxHighlightSupported = false, this.__theme = void 0;
    }
    afterCloneFrom(t2) {
      super.afterCloneFrom(t2), this.__language = t2.__language, this.__theme = t2.__theme, this.__isSyntaxHighlightSupported = t2.__isSyntaxHighlightSupported;
    }
    createDOM(t2) {
      const n2 = document.createElement("code");
      addClassNamesToElement2(n2, t2.theme.code), n2.setAttribute("spellcheck", "false");
      const r2 = this.getLanguage();
      r2 && (n2.setAttribute(K, r2), this.getIsSyntaxHighlightSupported() && n2.setAttribute($, r2));
      const i2 = this.getTheme();
      i2 && n2.setAttribute(W, i2);
      const o2 = this.getStyle();
      return o2 && n2.setAttribute("style", o2), n2;
    }
    updateDOM(t2, e2, n2) {
      const r2 = this.__language, i2 = t2.__language;
      r2 ? r2 !== i2 && e2.setAttribute(K, r2) : i2 && e2.removeAttribute(K);
      const o2 = this.__isSyntaxHighlightSupported;
      t2.__isSyntaxHighlightSupported && i2 ? o2 && r2 ? r2 !== i2 && e2.setAttribute($, r2) : e2.removeAttribute($) : o2 && r2 && e2.setAttribute($, r2);
      const s2 = this.__theme, l4 = t2.__theme;
      s2 ? s2 !== l4 && e2.setAttribute(W, s2) : l4 && e2.removeAttribute(W);
      const u2 = this.__style, c2 = t2.__style;
      return u2 ? u2 !== c2 && e2.setAttribute("style", u2) : c2 && e2.removeAttribute("style"), false;
    }
    exportDOM(t2) {
      const n2 = document.createElement("pre");
      addClassNamesToElement2(n2, t2._config.theme.code), n2.setAttribute("spellcheck", "false");
      const r2 = this.getLanguage();
      r2 && (n2.setAttribute(K, r2), this.getIsSyntaxHighlightSupported() && n2.setAttribute($, r2));
      const i2 = this.getTheme();
      i2 && n2.setAttribute(W, i2);
      const o2 = this.getStyle();
      return o2 && n2.setAttribute("style", o2), { element: n2 };
    }
    static importDOM() {
      return { code: (t2) => null != t2.textContent && (/\r?\n/.test(t2.textContent) || R(t2, "BR")) ? { conversion: Q, priority: 1 } : null, div: () => ({ conversion: G, priority: 1 }), pre: () => ({ conversion: Q, priority: 0 }), table: (t2) => tt(t2) ? { conversion: V, priority: 3 } : null, td: (t2) => {
        const e2 = t2, n2 = e2.closest("table");
        return e2.classList.contains("js-file-line") || n2 && tt(n2) ? { conversion: Y, priority: 3 } : null;
      }, tr: (t2) => {
        const e2 = t2.closest("table");
        return e2 && tt(e2) ? { conversion: Y, priority: 3 } : null;
      } };
    }
    static importJSON(t2) {
      return U().updateFromJSON(t2);
    }
    updateFromJSON(t2) {
      return super.updateFromJSON(t2).setLanguage(t2.language).setTheme(t2.theme);
    }
    exportJSON() {
      return { ...super.exportJSON(), language: this.getLanguage(), theme: this.getTheme() };
    }
    insertNewAfter(t2, e2 = true) {
      const n2 = this.getChildren(), r2 = n2.length;
      if (r2 >= 2 && "\n" === n2[r2 - 1].getTextContent() && "\n" === n2[r2 - 2].getTextContent() && t2.isCollapsed() && t2.anchor.key === this.__key && t2.anchor.offset === r2) {
        n2[r2 - 1].remove(), n2[r2 - 2].remove();
        const t3 = $createParagraphNode2();
        return this.insertAfter(t3, e2), t3;
      }
      const { anchor: i2, focus: o2 } = t2, a2 = (i2.isBefore(o2) ? i2 : o2).getNode();
      if ($isTextNode2(a2)) {
        let t3 = st(a2);
        const e3 = [];
        for (; ; ) if ($isTabNode2(t3)) e3.push($createTabNode2()), t3 = t3.getNextSibling();
        else {
          if (!it(t3)) break;
          {
            let n4 = 0;
            const r4 = t3.getTextContent(), i3 = t3.getTextContentSize();
            for (; n4 < i3 && " " === r4[n4]; ) n4++;
            if (0 !== n4 && e3.push(rt(" ".repeat(n4))), n4 !== i3) break;
            t3 = t3.getNextSibling();
          }
        }
        const n3 = a2.splitText(i2.offset)[0], r3 = 0 === i2.offset ? 0 : 1, o3 = n3.getIndexWithinParent() + r3, s2 = a2.getParentOrThrow(), l4 = [$createLineBreakNode2(), ...e3];
        s2.splice(o3, 0, l4);
        const f2 = e3[e3.length - 1];
        f2 ? f2.select() : 0 === i2.offset ? n3.selectPrevious() : n3.getNextSibling().selectNext(0, 0);
      }
      if (X(a2)) {
        const { offset: e3 } = t2.anchor;
        a2.splice(e3, 0, [$createLineBreakNode2()]), a2.select(e3 + 1, e3 + 1);
      }
      return null;
    }
    canIndent() {
      return false;
    }
    collapseAtStart() {
      const t2 = $createParagraphNode2();
      return this.getChildren().forEach((e2) => t2.append(e2)), this.replace(t2), true;
    }
    setLanguage(t2) {
      const e2 = this.getWritable();
      return e2.__language = t2 || void 0, e2;
    }
    getLanguage() {
      return this.getLatest().__language;
    }
    setIsSyntaxHighlightSupported(t2) {
      const e2 = this.getWritable();
      return e2.__isSyntaxHighlightSupported = t2, e2;
    }
    getIsSyntaxHighlightSupported() {
      return this.getLatest().__isSyntaxHighlightSupported;
    }
    setTheme(t2) {
      const e2 = this.getWritable();
      return e2.__theme = t2 || void 0, e2;
    }
    getTheme() {
      return this.getLatest().__theme;
    }
  };
  function U(t2, e2) {
    return $create2(q).setLanguage(t2).setTheme(e2);
  }
  function X(t2) {
    return t2 instanceof q;
  }
  function Q(t2) {
    return { node: U(t2.getAttribute(K)) };
  }
  function G(t2) {
    const e2 = t2, n2 = Z(e2);
    return n2 || function(t3) {
      let e3 = t3.parentElement;
      for (; null !== e3; ) {
        if (Z(e3)) return true;
        e3 = e3.parentElement;
      }
      return false;
    }(e2) ? { node: n2 ? U() : null } : { node: null };
  }
  function V() {
    return { node: U() };
  }
  function Y() {
    return { node: null };
  }
  function Z(t2) {
    return null !== t2.style.fontFamily.match("monospace");
  }
  function tt(t2) {
    return t2.classList.contains("js-file-line-container");
  }
  var et = class _et extends TextNode2 {
    __highlightType;
    constructor(t2 = "", e2, n2) {
      super(t2, n2), this.__highlightType = e2;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(t2) {
      return new _et(t2.__text, t2.__highlightType || void 0, t2.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    setHighlightType(t2) {
      const e2 = this.getWritable();
      return e2.__highlightType = t2 || void 0, e2;
    }
    canHaveFormat() {
      return false;
    }
    createDOM(t2) {
      const n2 = super.createDOM(t2), r2 = nt(t2.theme, this.__highlightType);
      return addClassNamesToElement2(n2, r2), n2;
    }
    updateDOM(t2, r2, i2) {
      const o2 = super.updateDOM(t2, r2, i2), s2 = nt(i2.theme, t2.__highlightType), l4 = nt(i2.theme, this.__highlightType);
      return s2 !== l4 && (s2 && removeClassNamesFromElement2(r2, s2), l4 && addClassNamesToElement2(r2, l4)), o2;
    }
    static importJSON(t2) {
      return rt().updateFromJSON(t2);
    }
    updateFromJSON(t2) {
      return super.updateFromJSON(t2).setHighlightType(t2.highlightType);
    }
    exportJSON() {
      return { ...super.exportJSON(), highlightType: this.getHighlightType() };
    }
    setFormat(t2) {
      return this;
    }
    isParentRequired() {
      return true;
    }
    createParentElementNode() {
      return U();
    }
  };
  function nt(t2, e2) {
    return e2 && t2 && t2.codeHighlight && t2.codeHighlight[e2];
  }
  function rt(t2 = "", e2) {
    return $applyNodeReplacement2(new et(t2, e2));
  }
  function it(t2) {
    return t2 instanceof et;
  }
  function ot(t2, e2) {
    let n2 = t2;
    for (let i2 = $getSiblingCaret2(t2, e2); i2 && (it(i2.origin) || $isTabNode2(i2.origin)); i2 = $getAdjacentCaret2(i2)) n2 = i2.origin;
    return n2;
  }
  function st(t2) {
    return ot(t2, "previous");
  }
  var at = defineExtension2({ name: "@lexical/code", nodes: [q, et] });
  !function(t2) {
    t2.languages.diff = { coord: [/^(?:\*{3}|-{3}|\+{3}).*$/m, /^@@.*@@$/m, /^\d.*$/m] };
    var e2 = { "deleted-sign": "-", "deleted-arrow": "<", "inserted-sign": "+", "inserted-arrow": ">", unchanged: " ", diff: "!" };
    Object.keys(e2).forEach(function(n2) {
      var r2 = e2[n2], i2 = [];
      /^\w+$/.test(n2) || i2.push(/\w+/.exec(n2)[0]), "diff" === n2 && i2.push("bold"), t2.languages.diff[n2] = { pattern: RegExp("^(?:[" + r2 + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"), alias: i2, inside: { line: { pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/, lookbehind: true }, prefix: { pattern: /[\s\S]/, alias: /\w+/.exec(n2)[0] } } };
    }), Object.defineProperty(t2.languages.diff, "PREFIXES", { value: e2 });
  }(Prism);
  var ft = globalThis.Prism || window.Prism;

  // node_modules/@lexical/code/LexicalCode.mjs
  var mod10 = true ? LexicalCode_dev_exports : LexicalCode_prod_exports;
  var $createCodeHighlightNode2 = mod10.$createCodeHighlightNode;
  var $createCodeNode2 = mod10.$createCodeNode;
  var $getCodeLineDirection2 = mod10.$getCodeLineDirection;
  var $getEndOfCodeInLine2 = mod10.$getEndOfCodeInLine;
  var $getFirstCodeNodeOfLine2 = mod10.$getFirstCodeNodeOfLine;
  var $getLastCodeNodeOfLine2 = mod10.$getLastCodeNodeOfLine;
  var $getStartOfCodeInLine2 = mod10.$getStartOfCodeInLine;
  var $isCodeHighlightNode2 = mod10.$isCodeHighlightNode;
  var $isCodeNode2 = mod10.$isCodeNode;
  var CODE_LANGUAGE_FRIENDLY_NAME_MAP2 = mod10.CODE_LANGUAGE_FRIENDLY_NAME_MAP;
  var CODE_LANGUAGE_MAP2 = mod10.CODE_LANGUAGE_MAP;
  var CodeExtension2 = mod10.CodeExtension;
  var CodeHighlightNode2 = mod10.CodeHighlightNode;
  var CodeNode2 = mod10.CodeNode;
  var DEFAULT_CODE_LANGUAGE2 = mod10.DEFAULT_CODE_LANGUAGE;
  var PrismTokenizer2 = mod10.PrismTokenizer;
  var getCodeLanguageOptions2 = mod10.getCodeLanguageOptions;
  var getCodeLanguages2 = mod10.getCodeLanguages;
  var getCodeThemeOptions2 = mod10.getCodeThemeOptions;
  var getDefaultCodeLanguage2 = mod10.getDefaultCodeLanguage;
  var getEndOfCodeInLine2 = mod10.getEndOfCodeInLine;
  var getFirstCodeNodeOfLine2 = mod10.getFirstCodeNodeOfLine;
  var getLanguageFriendlyName2 = mod10.getLanguageFriendlyName;
  var getLastCodeNodeOfLine2 = mod10.getLastCodeNodeOfLine;
  var getStartOfCodeInLine2 = mod10.getStartOfCodeInLine;
  var normalizeCodeLang2 = mod10.normalizeCodeLang;
  var normalizeCodeLanguage = mod10.normalizeCodeLanguage;
  var registerCodeHighlighting2 = mod10.registerCodeHighlighting;

  // node_modules/@lexical/link/LexicalLink.dev.mjs
  var LexicalLink_dev_exports = {};
  __export(LexicalLink_dev_exports, {
    $createAutoLinkNode: () => $createAutoLinkNode,
    $createLinkNode: () => $createLinkNode,
    $isAutoLinkNode: () => $isAutoLinkNode,
    $isLinkNode: () => $isLinkNode,
    $toggleLink: () => $toggleLink,
    AutoLinkExtension: () => AutoLinkExtension,
    AutoLinkNode: () => AutoLinkNode,
    ClickableLinkExtension: () => ClickableLinkExtension,
    LinkExtension: () => LinkExtension,
    LinkNode: () => LinkNode,
    TOGGLE_LINK_COMMAND: () => TOGGLE_LINK_COMMAND,
    createLinkMatcherWithRegExp: () => createLinkMatcherWithRegExp,
    formatUrl: () => formatUrl,
    registerAutoLink: () => registerAutoLink,
    registerClickableLink: () => registerClickableLink,
    registerLink: () => registerLink,
    toggleLink: () => toggleLink
  });
  function formatDevErrorMessage8(message) {
    throw new Error(message);
  }
  var SUPPORTED_URL_PROTOCOLS = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  var LinkNode = class _LinkNode extends ElementNode2 {
    /** @internal */
    __url;
    /** @internal */
    __target;
    /** @internal */
    __rel;
    /** @internal */
    __title;
    static getType() {
      return "link";
    }
    static clone(node) {
      return new _LinkNode(node.__url, {
        rel: node.__rel,
        target: node.__target,
        title: node.__title
      }, node.__key);
    }
    constructor(url = "", attributes = {}, key) {
      super(key);
      const {
        target = null,
        rel = null,
        title = null
      } = attributes;
      this.__url = url;
      this.__target = target;
      this.__rel = rel;
      this.__title = title;
    }
    createDOM(config) {
      const element = document.createElement("a");
      this.updateLinkDOM(null, element, config);
      addClassNamesToElement2(element, config.theme.link);
      return element;
    }
    updateLinkDOM(prevNode, anchor, config) {
      if (isHTMLAnchorElement3(anchor)) {
        if (!prevNode || prevNode.__url !== this.__url) {
          anchor.href = this.sanitizeUrl(this.__url);
        }
        for (const attr of ["target", "rel", "title"]) {
          const key = `__${attr}`;
          const value = this[key];
          if (!prevNode || prevNode[key] !== value) {
            if (value) {
              anchor[attr] = value;
            } else {
              anchor.removeAttribute(attr);
            }
          }
        }
      }
    }
    updateDOM(prevNode, anchor, config) {
      this.updateLinkDOM(prevNode, anchor, config);
      return false;
    }
    static importDOM() {
      return {
        a: (node) => ({
          conversion: $convertAnchorElement,
          priority: 1
        })
      };
    }
    static importJSON(serializedNode) {
      return $createLinkNode().updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);
    }
    sanitizeUrl(url) {
      url = formatUrl(url);
      try {
        const parsedUrl = new URL(formatUrl(url));
        if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {
          return "about:blank";
        }
      } catch (_unused) {
        return url;
      }
      return url;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        rel: this.getRel(),
        target: this.getTarget(),
        title: this.getTitle(),
        url: this.getURL()
      };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(url) {
      const writable = this.getWritable();
      writable.__url = url;
      return writable;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(target) {
      const writable = this.getWritable();
      writable.__target = target;
      return writable;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(rel) {
      const writable = this.getWritable();
      writable.__rel = rel;
      return writable;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(title) {
      const writable = this.getWritable();
      writable.__title = title;
      return writable;
    }
    insertNewAfter(_3, restoreSelection = true) {
      const linkNode = $createLinkNode(this.__url, {
        rel: this.__rel,
        target: this.__target,
        title: this.__title
      });
      this.insertAfter(linkNode, restoreSelection);
      return linkNode;
    }
    canInsertTextBefore() {
      return false;
    }
    canInsertTextAfter() {
      return false;
    }
    canBeEmpty() {
      return false;
    }
    isInline() {
      return true;
    }
    extractWithChild(child, selection, destination) {
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;
    }
    isEmailURI() {
      return this.__url.startsWith("mailto:");
    }
    isWebSiteURI() {
      return this.__url.startsWith("https://") || this.__url.startsWith("http://");
    }
  };
  function $convertAnchorElement(domNode) {
    let node = null;
    if (isHTMLAnchorElement3(domNode)) {
      const content = domNode.textContent;
      if (content !== null && content !== "" || domNode.children.length > 0) {
        node = $createLinkNode(domNode.getAttribute("href") || "", {
          rel: domNode.getAttribute("rel"),
          target: domNode.getAttribute("target"),
          title: domNode.getAttribute("title")
        });
      }
    }
    return {
      node
    };
  }
  function $createLinkNode(url = "", attributes) {
    return $applyNodeReplacement2(new LinkNode(url, attributes));
  }
  function $isLinkNode(node) {
    return node instanceof LinkNode;
  }
  var AutoLinkNode = class _AutoLinkNode extends LinkNode {
    /** @internal */
    /** Indicates whether the autolink was ever unlinked. **/
    __isUnlinked;
    constructor(url = "", attributes = {}, key) {
      super(url, attributes, key);
      this.__isUnlinked = attributes.isUnlinked !== void 0 && attributes.isUnlinked !== null ? attributes.isUnlinked : false;
    }
    static getType() {
      return "autolink";
    }
    static clone(node) {
      return new _AutoLinkNode(node.__url, {
        isUnlinked: node.__isUnlinked,
        rel: node.__rel,
        target: node.__target,
        title: node.__title
      }, node.__key);
    }
    getIsUnlinked() {
      return this.__isUnlinked;
    }
    setIsUnlinked(value) {
      const self2 = this.getWritable();
      self2.__isUnlinked = value;
      return self2;
    }
    createDOM(config) {
      if (this.__isUnlinked) {
        return document.createElement("span");
      } else {
        return super.createDOM(config);
      }
    }
    updateDOM(prevNode, anchor, config) {
      return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;
    }
    static importJSON(serializedNode) {
      return $createAutoLinkNode().updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        isUnlinked: this.__isUnlinked
      };
    }
    insertNewAfter(selection, restoreSelection = true) {
      const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);
      if ($isElementNode2(element)) {
        const linkNode = $createAutoLinkNode(this.__url, {
          isUnlinked: this.__isUnlinked,
          rel: this.__rel,
          target: this.__target,
          title: this.__title
        });
        element.append(linkNode);
        return linkNode;
      }
      return null;
    }
  };
  function $createAutoLinkNode(url = "", attributes) {
    return $applyNodeReplacement2(new AutoLinkNode(url, attributes));
  }
  function $isAutoLinkNode(node) {
    return node instanceof AutoLinkNode;
  }
  var TOGGLE_LINK_COMMAND = createCommand2("TOGGLE_LINK_COMMAND");
  function $getPointNode(point, offset) {
    if (point.type === "element") {
      const node = point.getNode();
      if (!$isElementNode2(node)) {
        formatDevErrorMessage8(`$getPointNode: element point is not an ElementNode`);
      }
      const childNode = node.getChildren()[point.offset + offset];
      return childNode || null;
    }
    return null;
  }
  function $withSelectedNodes($fn) {
    const initialSelection = $getSelection2();
    if (!$isRangeSelection2(initialSelection)) {
      return $fn();
    }
    const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);
    const isBackwards = normalized.isBackward();
    const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);
    const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);
    const rval = $fn();
    if (anchorNode || focusNode) {
      const updatedSelection = $getSelection2();
      if ($isRangeSelection2(updatedSelection)) {
        const finalSelection = updatedSelection.clone();
        if (anchorNode) {
          const anchorParent = anchorNode.getParent();
          if (anchorParent) {
            finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), "element");
          }
        }
        if (focusNode) {
          const focusParent = focusNode.getParent();
          if (focusParent) {
            finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), "element");
          }
        }
        $setSelection2($normalizeSelection__EXPERIMENTAL(finalSelection));
      }
    }
    return rval;
  }
  function $splitLinkAtSelection(parentLink, extractedNodes) {
    const extractedKeys = new Set(extractedNodes.filter((n2) => parentLink.isParentOf(n2)).map((n2) => n2.getKey()));
    const allChildren = parentLink.getChildren();
    const extractedChildren = allChildren.filter((child) => extractedKeys.has(child.getKey()));
    if (extractedChildren.length === allChildren.length) {
      allChildren.forEach((child) => parentLink.insertBefore(child));
      parentLink.remove();
      return;
    }
    const firstExtractedIndex = allChildren.findIndex((child) => extractedKeys.has(child.getKey()));
    const lastExtractedIndex = allChildren.findLastIndex((child) => extractedKeys.has(child.getKey()));
    const isAtStart = firstExtractedIndex === 0;
    const isAtEnd = lastExtractedIndex === allChildren.length - 1;
    if (isAtStart) {
      extractedChildren.forEach((child) => parentLink.insertBefore(child));
    } else if (isAtEnd) {
      for (let i2 = extractedChildren.length - 1; i2 >= 0; i2--) {
        parentLink.insertAfter(extractedChildren[i2]);
      }
    } else {
      for (let i2 = extractedChildren.length - 1; i2 >= 0; i2--) {
        parentLink.insertAfter(extractedChildren[i2]);
      }
      const trailingChildren = allChildren.slice(lastExtractedIndex + 1);
      if (trailingChildren.length > 0) {
        const newLink = $createLinkNode(parentLink.getURL(), {
          rel: parentLink.getRel(),
          target: parentLink.getTarget(),
          title: parentLink.getTitle()
        });
        extractedChildren[extractedChildren.length - 1].insertAfter(newLink);
        trailingChildren.forEach((child) => newLink.append(child));
      }
    }
  }
  function $toggleLink(urlOrAttributes, attributes = {}) {
    let url;
    if (urlOrAttributes && typeof urlOrAttributes === "object") {
      const {
        url: urlProp,
        ...rest
      } = urlOrAttributes;
      url = urlProp;
      attributes = {
        ...rest,
        ...attributes
      };
    } else {
      url = urlOrAttributes;
    }
    const {
      target,
      title
    } = attributes;
    const rel = attributes.rel === void 0 ? "noreferrer" : attributes.rel;
    const selection = $getSelection2();
    if (selection === null || !$isRangeSelection2(selection) && !$isNodeSelection2(selection)) {
      return;
    }
    if ($isNodeSelection2(selection)) {
      const nodes2 = selection.getNodes();
      if (nodes2.length === 0) {
        return;
      }
      nodes2.forEach((node) => {
        if (url === null) {
          const linkParent = $findMatchingParent3(node, (parent) => !$isAutoLinkNode(parent) && $isLinkNode(parent));
          if (linkParent) {
            linkParent.insertBefore(node);
            if (linkParent.getChildren().length === 0) {
              linkParent.remove();
            }
          }
        } else {
          const existingLink = $findMatchingParent3(node, (parent) => !$isAutoLinkNode(parent) && $isLinkNode(parent));
          if (existingLink) {
            existingLink.setURL(url);
            if (target !== void 0) {
              existingLink.setTarget(target);
            }
            if (rel !== void 0) {
              existingLink.setRel(rel);
            }
          } else {
            const linkNode = $createLinkNode(url, {
              rel,
              target
            });
            node.insertBefore(linkNode);
            linkNode.append(node);
          }
        }
      });
      return;
    }
    const nodes = selection.extract();
    if (url === null) {
      const processedLinks = /* @__PURE__ */ new Set();
      nodes.forEach((node) => {
        const parentLink = node.getParent();
        if ($isLinkNode(parentLink) && !$isAutoLinkNode(parentLink)) {
          const linkKey = parentLink.getKey();
          if (processedLinks.has(linkKey)) {
            return;
          }
          $splitLinkAtSelection(parentLink, nodes);
          processedLinks.add(linkKey);
        }
      });
      return;
    }
    const updatedNodes = /* @__PURE__ */ new Set();
    const updateLinkNode = (linkNode) => {
      if (updatedNodes.has(linkNode.getKey())) {
        return;
      }
      updatedNodes.add(linkNode.getKey());
      linkNode.setURL(url);
      if (target !== void 0) {
        linkNode.setTarget(target);
      }
      if (rel !== void 0) {
        linkNode.setRel(rel);
      }
      if (title !== void 0) {
        linkNode.setTitle(title);
      }
    };
    if (nodes.length === 1) {
      const firstNode = nodes[0];
      const linkNode = $findMatchingParent3(firstNode, $isLinkNode);
      if (linkNode !== null) {
        return updateLinkNode(linkNode);
      }
    }
    $withSelectedNodes(() => {
      let linkNode = null;
      for (const node of nodes) {
        if (!node.isAttached()) {
          continue;
        }
        const parentLinkNode = $findMatchingParent3(node, $isLinkNode);
        if (parentLinkNode) {
          updateLinkNode(parentLinkNode);
          continue;
        }
        if ($isElementNode2(node)) {
          if (!node.isInline()) {
            continue;
          }
          if ($isLinkNode(node)) {
            if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {
              updateLinkNode(node);
              linkNode = node;
              continue;
            }
            for (const child of node.getChildren()) {
              node.insertBefore(child);
            }
            node.remove();
            continue;
          }
        }
        const prevLinkNode = node.getPreviousSibling();
        if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {
          prevLinkNode.append(node);
          continue;
        }
        linkNode = $createLinkNode(url, {
          rel,
          target,
          title
        });
        node.insertAfter(linkNode);
        linkNode.append(node);
      }
    });
  }
  var PHONE_NUMBER_REGEX = /^\+?[0-9\s()-]{5,}$/;
  function formatUrl(url) {
    if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {
      return url;
    } else if (url.match(/^[/#.]/)) {
      return url;
    } else if (url.includes("@")) {
      return `mailto:${url}`;
    } else if (PHONE_NUMBER_REGEX.test(url)) {
      return `tel:${url}`;
    }
    return `https://${url}`;
  }
  var defaultProps = {
    attributes: void 0,
    validateUrl: void 0
  };
  function registerLink(editor, stores2) {
    return mergeRegister2(effect3(() => editor.registerCommand(TOGGLE_LINK_COMMAND, (payload) => {
      const validateUrl = stores2.validateUrl.peek();
      const attributes = stores2.attributes.peek();
      if (payload === null) {
        $toggleLink(null);
        return true;
      } else if (typeof payload === "string") {
        if (validateUrl === void 0 || validateUrl(payload)) {
          $toggleLink(payload, attributes);
          return true;
        }
        return false;
      } else {
        const {
          url,
          target,
          rel,
          title
        } = payload;
        $toggleLink(url, {
          ...attributes,
          rel,
          target,
          title
        });
        return true;
      }
    }, COMMAND_PRIORITY_LOW2)), effect3(() => {
      const validateUrl = stores2.validateUrl.value;
      if (!validateUrl) {
        return;
      }
      const attributes = stores2.attributes.value;
      return editor.registerCommand(PASTE_COMMAND2, (event) => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection) || selection.isCollapsed() || !objectKlassEquals2(event, ClipboardEvent)) {
          return false;
        }
        if (event.clipboardData === null) {
          return false;
        }
        const clipboardText = event.clipboardData.getData("text");
        if (!validateUrl(clipboardText)) {
          return false;
        }
        if (!selection.getNodes().some((node) => $isElementNode2(node))) {
          editor.dispatchCommand(TOGGLE_LINK_COMMAND, {
            ...attributes,
            url: clipboardText
          });
          event.preventDefault();
          return true;
        }
        return false;
      }, COMMAND_PRIORITY_LOW2);
    }));
  }
  var LinkExtension = defineExtension2({
    build(editor, config, state) {
      return namedSignals2(config);
    },
    config: defaultProps,
    mergeConfig(config, overrides2) {
      const merged = shallowMergeConfig2(config, overrides2);
      if (config.attributes) {
        merged.attributes = shallowMergeConfig2(config.attributes, merged.attributes);
      }
      return merged;
    },
    name: "@lexical/link/Link",
    nodes: [LinkNode],
    register(editor, config, state) {
      return registerLink(editor, state.getOutput());
    }
  });
  function findMatchingDOM(startNode, predicate) {
    let node = startNode;
    while (node != null) {
      if (predicate(node)) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  }
  function registerClickableLink(editor, stores2, eventOptions = {}) {
    const onClick2 = (event) => {
      const target = event.target;
      if (!isDOMNode2(target)) {
        return;
      }
      const nearestEditor = getNearestEditorFromDOMNode2(target);
      if (nearestEditor === null) {
        return;
      }
      let url = null;
      let urlTarget = null;
      nearestEditor.update(() => {
        const clickedNode = $getNearestNodeFromDOMNode2(target);
        if (clickedNode !== null) {
          const maybeLinkNode = $findMatchingParent3(clickedNode, $isElementNode2);
          if (!stores2.disabled.peek()) {
            if ($isLinkNode(maybeLinkNode)) {
              url = maybeLinkNode.sanitizeUrl(maybeLinkNode.getURL());
              urlTarget = maybeLinkNode.getTarget();
            } else {
              const a2 = findMatchingDOM(target, isHTMLAnchorElement3);
              if (a2 !== null) {
                url = a2.href;
                urlTarget = a2.target;
              }
            }
          }
        }
      });
      if (url === null || url === "") {
        return;
      }
      const selection = editor.getEditorState().read($getSelection2);
      if ($isRangeSelection2(selection) && !selection.isCollapsed()) {
        event.preventDefault();
        return;
      }
      const isMiddle = event.type === "auxclick" && event.button === 1;
      window.open(url, stores2.newTab.peek() || isMiddle || event.metaKey || event.ctrlKey || urlTarget === "_blank" ? "_blank" : "_self");
      event.preventDefault();
    };
    const onMouseUp = (event) => {
      if (event.button === 1) {
        onClick2(event);
      }
    };
    return editor.registerRootListener((rootElement, prevRootElement) => {
      if (prevRootElement !== null) {
        prevRootElement.removeEventListener("click", onClick2);
        prevRootElement.removeEventListener("mouseup", onMouseUp);
      }
      if (rootElement !== null) {
        rootElement.addEventListener("click", onClick2, eventOptions);
        rootElement.addEventListener("mouseup", onMouseUp, eventOptions);
      }
    });
  }
  var ClickableLinkExtension = defineExtension2({
    build(editor, config, state) {
      return namedSignals2(config);
    },
    config: safeCast2({
      disabled: false,
      newTab: false
    }),
    dependencies: [LinkExtension],
    name: "@lexical/link/ClickableLink",
    register(editor, config, state) {
      return registerClickableLink(editor, state.getOutput());
    }
  });
  function createLinkMatcherWithRegExp(regExp, urlTransformer = (text2) => text2) {
    return (text2) => {
      const match = regExp.exec(text2);
      if (match === null) {
        return null;
      }
      return {
        index: match.index,
        length: match[0].length,
        text: match[0],
        url: urlTransformer(match[0])
      };
    };
  }
  function findFirstMatch(text2, matchers) {
    for (let i2 = 0; i2 < matchers.length; i2++) {
      const match = matchers[i2](text2);
      if (match) {
        return match;
      }
    }
    return null;
  }
  var PUNCTUATION_OR_SPACE = /[.,;\s]/;
  function isSeparator(char) {
    return PUNCTUATION_OR_SPACE.test(char);
  }
  function endsWithSeparator(textContent) {
    return isSeparator(textContent[textContent.length - 1]);
  }
  function startsWithSeparator(textContent) {
    return isSeparator(textContent[0]);
  }
  function startsWithTLD(textContent, isEmail) {
    if (isEmail) {
      return /^\.[a-zA-Z]{2,}/.test(textContent);
    } else {
      return /^\.[a-zA-Z0-9]{1,}/.test(textContent);
    }
  }
  function isPreviousNodeValid(node) {
    let previousNode = node.getPreviousSibling();
    if ($isElementNode2(previousNode)) {
      previousNode = previousNode.getLastDescendant();
    }
    return previousNode === null || $isLineBreakNode2(previousNode) || $isTextNode2(previousNode) && endsWithSeparator(previousNode.getTextContent());
  }
  function isNextNodeValid(node) {
    let nextNode = node.getNextSibling();
    if ($isElementNode2(nextNode)) {
      nextNode = nextNode.getFirstDescendant();
    }
    return nextNode === null || $isLineBreakNode2(nextNode) || $isTextNode2(nextNode) && startsWithSeparator(nextNode.getTextContent());
  }
  function isContentAroundIsValid(matchStart, matchEnd, text2, nodes) {
    const contentBeforeIsValid = matchStart > 0 ? isSeparator(text2[matchStart - 1]) : isPreviousNodeValid(nodes[0]);
    if (!contentBeforeIsValid) {
      return false;
    }
    const contentAfterIsValid = matchEnd < text2.length ? isSeparator(text2[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);
    return contentAfterIsValid;
  }
  function extractMatchingNodes(nodes, startIndex, endIndex) {
    const unmodifiedBeforeNodes = [];
    const matchingNodes = [];
    const unmodifiedAfterNodes = [];
    let matchingOffset = 0;
    let currentOffset = 0;
    const currentNodes = [...nodes];
    while (currentNodes.length > 0) {
      const currentNode = currentNodes[0];
      const currentNodeText = currentNode.getTextContent();
      const currentNodeLength = currentNodeText.length;
      const currentNodeStart = currentOffset;
      const currentNodeEnd = currentOffset + currentNodeLength;
      if (currentNodeEnd <= startIndex) {
        unmodifiedBeforeNodes.push(currentNode);
        matchingOffset += currentNodeLength;
      } else if (currentNodeStart >= endIndex) {
        unmodifiedAfterNodes.push(currentNode);
      } else {
        matchingNodes.push(currentNode);
      }
      currentOffset += currentNodeLength;
      currentNodes.shift();
    }
    return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];
  }
  function $createAutoLinkNode_(nodes, startIndex, endIndex, match) {
    const linkNode = $createAutoLinkNode(match.url, match.attributes);
    if (nodes.length === 1) {
      let remainingTextNode = nodes[0];
      let linkTextNode;
      if (startIndex === 0) {
        [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);
      } else {
        [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);
      }
      const textNode = $createTextNode2(match.text);
      textNode.setFormat(linkTextNode.getFormat());
      textNode.setDetail(linkTextNode.getDetail());
      textNode.setStyle(linkTextNode.getStyle());
      linkNode.append(textNode);
      linkTextNode.replace(linkNode);
      return remainingTextNode;
    } else if (nodes.length > 1) {
      const firstTextNode = nodes[0];
      let offset = firstTextNode.getTextContent().length;
      let firstLinkTextNode;
      if (startIndex === 0) {
        firstLinkTextNode = firstTextNode;
      } else {
        [, firstLinkTextNode] = firstTextNode.splitText(startIndex);
      }
      const linkNodes = [];
      let remainingTextNode;
      for (let i2 = 1; i2 < nodes.length; i2++) {
        const currentNode = nodes[i2];
        const currentNodeText = currentNode.getTextContent();
        const currentNodeLength = currentNodeText.length;
        const currentNodeStart = offset;
        const currentNodeEnd = offset + currentNodeLength;
        if (currentNodeStart < endIndex) {
          if (currentNodeEnd <= endIndex) {
            linkNodes.push(currentNode);
          } else {
            const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);
            linkNodes.push(linkTextNode);
            remainingTextNode = endNode;
          }
        }
        offset += currentNodeLength;
      }
      const selection = $getSelection2();
      const selectedTextNode = selection ? selection.getNodes().find($isTextNode2) : void 0;
      const textNode = $createTextNode2(firstLinkTextNode.getTextContent());
      textNode.setFormat(firstLinkTextNode.getFormat());
      textNode.setDetail(firstLinkTextNode.getDetail());
      textNode.setStyle(firstLinkTextNode.getStyle());
      linkNode.append(textNode, ...linkNodes);
      if (selectedTextNode && selectedTextNode === firstLinkTextNode) {
        if ($isRangeSelection2(selection)) {
          textNode.select(selection.anchor.offset, selection.focus.offset);
        } else if ($isNodeSelection2(selection)) {
          textNode.select(0, textNode.getTextContent().length);
        }
      }
      firstLinkTextNode.replace(linkNode);
      return remainingTextNode;
    }
    return void 0;
  }
  function $handleLinkCreation(nodes, matchers, onChange) {
    let currentNodes = [...nodes];
    const initialText = currentNodes.map((node) => node.getTextContent()).join("");
    let text2 = initialText;
    let match;
    let invalidMatchEnd = 0;
    while ((match = findFirstMatch(text2, matchers)) && match !== null) {
      const matchStart = match.index;
      const matchLength = match.length;
      const matchEnd = matchStart + matchLength;
      const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, initialText, currentNodes);
      if (isValid) {
        const [matchingOffset, , matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);
        const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;
        const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;
        const remainingTextNode = $createAutoLinkNode_(matchingNodes, actualMatchStart, actualMatchEnd, match);
        currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;
        onChange(match.url, null);
        invalidMatchEnd = 0;
      } else {
        invalidMatchEnd += matchEnd;
      }
      text2 = text2.substring(matchEnd);
    }
  }
  function handleLinkEdit(linkNode, matchers, onChange) {
    const children = linkNode.getChildren();
    const childrenLength = children.length;
    for (let i2 = 0; i2 < childrenLength; i2++) {
      const child = children[i2];
      if (!$isTextNode2(child) || !child.isSimpleText()) {
        replaceWithChildren(linkNode);
        onChange(null, linkNode.getURL());
        return;
      }
    }
    const text2 = linkNode.getTextContent();
    const match = findFirstMatch(text2, matchers);
    if (match === null || match.text !== text2) {
      replaceWithChildren(linkNode);
      onChange(null, linkNode.getURL());
      return;
    }
    if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {
      replaceWithChildren(linkNode);
      onChange(null, linkNode.getURL());
      return;
    }
    const url = linkNode.getURL();
    if (url !== match.url) {
      linkNode.setURL(match.url);
      onChange(match.url, url);
    }
    if (match.attributes) {
      const rel = linkNode.getRel();
      if (rel !== match.attributes.rel) {
        linkNode.setRel(match.attributes.rel || null);
        onChange(match.attributes.rel || null, rel);
      }
      const target = linkNode.getTarget();
      if (target !== match.attributes.target) {
        linkNode.setTarget(match.attributes.target || null);
        onChange(match.attributes.target || null, target);
      }
    }
  }
  function handleBadNeighbors(textNode, matchers, onChange) {
    const previousSibling = textNode.getPreviousSibling();
    const nextSibling = textNode.getNextSibling();
    const text2 = textNode.getTextContent();
    if ($isAutoLinkNode(previousSibling) && !previousSibling.getIsUnlinked() && (!startsWithSeparator(text2) || startsWithTLD(text2, previousSibling.isEmailURI()))) {
      previousSibling.append(textNode);
      handleLinkEdit(previousSibling, matchers, onChange);
      onChange(null, previousSibling.getURL());
    }
    if ($isAutoLinkNode(nextSibling) && !nextSibling.getIsUnlinked() && !endsWithSeparator(text2)) {
      replaceWithChildren(nextSibling);
      handleLinkEdit(nextSibling, matchers, onChange);
      onChange(null, nextSibling.getURL());
    }
  }
  function replaceWithChildren(node) {
    const children = node.getChildren();
    const childrenLength = children.length;
    for (let j2 = childrenLength - 1; j2 >= 0; j2--) {
      node.insertAfter(children[j2]);
    }
    node.remove();
    return children.map((child) => child.getLatest());
  }
  function getTextNodesToMatch(textNode) {
    const textNodesToMatch = [textNode];
    let nextSibling = textNode.getNextSibling();
    while (nextSibling !== null && $isTextNode2(nextSibling) && nextSibling.isSimpleText()) {
      textNodesToMatch.push(nextSibling);
      if (/[\s]/.test(nextSibling.getTextContent())) {
        break;
      }
      nextSibling = nextSibling.getNextSibling();
    }
    return textNodesToMatch;
  }
  var defaultConfig = {
    changeHandlers: [],
    matchers: []
  };
  function registerAutoLink(editor, config = defaultConfig) {
    const {
      matchers,
      changeHandlers
    } = config;
    const onChange = (url, prevUrl) => {
      for (const handler4 of changeHandlers) {
        handler4(url, prevUrl);
      }
    };
    return mergeRegister2(editor.registerNodeTransform(TextNode2, (textNode) => {
      const parent = textNode.getParentOrThrow();
      const previous = textNode.getPreviousSibling();
      if ($isAutoLinkNode(parent) && !parent.getIsUnlinked()) {
        handleLinkEdit(parent, matchers, onChange);
      } else if (!$isLinkNode(parent)) {
        if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))) {
          const textNodesToMatch = getTextNodesToMatch(textNode);
          $handleLinkCreation(textNodesToMatch, matchers, onChange);
        }
        handleBadNeighbors(textNode, matchers, onChange);
      }
    }), editor.registerCommand(TOGGLE_LINK_COMMAND, (payload) => {
      const selection = $getSelection2();
      if (payload !== null || !$isRangeSelection2(selection)) {
        return false;
      }
      const nodes = selection.extract();
      nodes.forEach((node) => {
        const parent = node.getParent();
        if ($isAutoLinkNode(parent)) {
          parent.setIsUnlinked(!parent.getIsUnlinked());
          parent.markDirty();
        }
      });
      return false;
    }, COMMAND_PRIORITY_LOW2));
  }
  var AutoLinkExtension = defineExtension2({
    config: defaultConfig,
    dependencies: [LinkExtension],
    mergeConfig(config, overrides2) {
      const merged = shallowMergeConfig2(config, overrides2);
      for (const k2 of ["matchers", "changeHandlers"]) {
        const v3 = overrides2[k2];
        if (Array.isArray(v3)) {
          merged[k2] = [...config[k2], ...v3];
        }
      }
      return merged;
    },
    name: "@lexical/link/AutoLink",
    register: registerAutoLink
  });
  var toggleLink = $toggleLink;

  // node_modules/@lexical/link/LexicalLink.mjs
  var mod11 = true ? LexicalLink_dev_exports : LexicalLink_prod_exports;
  var $createAutoLinkNode2 = mod11.$createAutoLinkNode;
  var $createLinkNode2 = mod11.$createLinkNode;
  var $isAutoLinkNode2 = mod11.$isAutoLinkNode;
  var $isLinkNode2 = mod11.$isLinkNode;
  var $toggleLink2 = mod11.$toggleLink;
  var AutoLinkExtension2 = mod11.AutoLinkExtension;
  var AutoLinkNode2 = mod11.AutoLinkNode;
  var ClickableLinkExtension2 = mod11.ClickableLinkExtension;
  var LinkExtension2 = mod11.LinkExtension;
  var LinkNode2 = mod11.LinkNode;
  var TOGGLE_LINK_COMMAND2 = mod11.TOGGLE_LINK_COMMAND;
  var createLinkMatcherWithRegExp2 = mod11.createLinkMatcherWithRegExp;
  var formatUrl2 = mod11.formatUrl;
  var registerAutoLink2 = mod11.registerAutoLink;
  var registerClickableLink2 = mod11.registerClickableLink;
  var registerLink2 = mod11.registerLink;
  var toggleLink2 = mod11.toggleLink;

  // node_modules/@lexical/table/LexicalTable.dev.mjs
  var LexicalTable_dev_exports = {};
  __export(LexicalTable_dev_exports, {
    $computeTableMap: () => $computeTableMap,
    $computeTableMapSkipCellCheck: () => $computeTableMapSkipCellCheck,
    $createTableCellNode: () => $createTableCellNode,
    $createTableNode: () => $createTableNode,
    $createTableNodeWithDimensions: () => $createTableNodeWithDimensions,
    $createTableRowNode: () => $createTableRowNode,
    $createTableSelection: () => $createTableSelection,
    $createTableSelectionFrom: () => $createTableSelectionFrom,
    $deleteTableColumn: () => $deleteTableColumn,
    $deleteTableColumnAtSelection: () => $deleteTableColumnAtSelection,
    $deleteTableColumn__EXPERIMENTAL: () => $deleteTableColumn__EXPERIMENTAL,
    $deleteTableRowAtSelection: () => $deleteTableRowAtSelection,
    $deleteTableRow__EXPERIMENTAL: () => $deleteTableRow__EXPERIMENTAL,
    $findCellNode: () => $findCellNode,
    $findTableNode: () => $findTableNode,
    $getElementForTableNode: () => $getElementForTableNode,
    $getNodeTriplet: () => $getNodeTriplet,
    $getTableAndElementByKey: () => $getTableAndElementByKey,
    $getTableCellNodeFromLexicalNode: () => $getTableCellNodeFromLexicalNode,
    $getTableCellNodeRect: () => $getTableCellNodeRect,
    $getTableColumnIndexFromTableCellNode: () => $getTableColumnIndexFromTableCellNode,
    $getTableNodeFromLexicalNodeOrThrow: () => $getTableNodeFromLexicalNodeOrThrow,
    $getTableRowIndexFromTableCellNode: () => $getTableRowIndexFromTableCellNode,
    $getTableRowNodeFromTableCellNodeOrThrow: () => $getTableRowNodeFromTableCellNodeOrThrow,
    $insertTableColumn: () => $insertTableColumn,
    $insertTableColumnAtSelection: () => $insertTableColumnAtSelection,
    $insertTableColumn__EXPERIMENTAL: () => $insertTableColumn__EXPERIMENTAL,
    $insertTableRow: () => $insertTableRow,
    $insertTableRowAtSelection: () => $insertTableRowAtSelection,
    $insertTableRow__EXPERIMENTAL: () => $insertTableRow__EXPERIMENTAL,
    $isScrollableTablesActive: () => $isScrollableTablesActive,
    $isTableCellNode: () => $isTableCellNode,
    $isTableNode: () => $isTableNode,
    $isTableRowNode: () => $isTableRowNode,
    $isTableSelection: () => $isTableSelection,
    $mergeCells: () => $mergeCells,
    $removeTableRowAtIndex: () => $removeTableRowAtIndex,
    $unmergeCell: () => $unmergeCell,
    INSERT_TABLE_COMMAND: () => INSERT_TABLE_COMMAND,
    TableCellHeaderStates: () => TableCellHeaderStates,
    TableCellNode: () => TableCellNode,
    TableExtension: () => TableExtension,
    TableNode: () => TableNode,
    TableObserver: () => TableObserver,
    TableRowNode: () => TableRowNode,
    applyTableHandlers: () => applyTableHandlers,
    getDOMCellFromTarget: () => getDOMCellFromTarget,
    getTableElement: () => getTableElement,
    getTableObserverFromTableElement: () => getTableObserverFromTableElement,
    registerTableCellUnmergeTransform: () => registerTableCellUnmergeTransform,
    registerTablePlugin: () => registerTablePlugin,
    registerTableSelectionObserver: () => registerTableSelectionObserver,
    setScrollableTablesActive: () => setScrollableTablesActive
  });
  var PIXEL_VALUE_REG_EXP = /^(\d+(?:\.\d+)?)px$/;
  var COLUMN_WIDTH = 75;
  var TableCellHeaderStates = {
    BOTH: 3,
    COLUMN: 2,
    NO_STATUS: 0,
    ROW: 1
  };
  var TableCellNode = class _TableCellNode extends ElementNode2 {
    /** @internal */
    __colSpan;
    /** @internal */
    __rowSpan;
    /** @internal */
    __headerState;
    /** @internal */
    __width;
    /** @internal */
    __backgroundColor;
    /** @internal */
    __verticalAlign;
    static getType() {
      return "tablecell";
    }
    static clone(node) {
      return new _TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);
    }
    afterCloneFrom(node) {
      super.afterCloneFrom(node);
      this.__rowSpan = node.__rowSpan;
      this.__backgroundColor = node.__backgroundColor;
      this.__verticalAlign = node.__verticalAlign;
    }
    static importDOM() {
      return {
        td: (node) => ({
          conversion: $convertTableCellNodeElement,
          priority: 0
        }),
        th: (node) => ({
          conversion: $convertTableCellNodeElement,
          priority: 0
        })
      };
    }
    static importJSON(serializedNode) {
      return $createTableCellNode().updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || void 0).setBackgroundColor(serializedNode.backgroundColor || null).setVerticalAlign(serializedNode.verticalAlign || void 0);
    }
    constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {
      super(key);
      this.__colSpan = colSpan;
      this.__rowSpan = 1;
      this.__headerState = headerState;
      this.__width = width;
      this.__backgroundColor = null;
      this.__verticalAlign = void 0;
    }
    createDOM(config) {
      const element = document.createElement(this.getTag());
      if (this.__width) {
        element.style.width = `${this.__width}px`;
      }
      if (this.__colSpan > 1) {
        element.colSpan = this.__colSpan;
      }
      if (this.__rowSpan > 1) {
        element.rowSpan = this.__rowSpan;
      }
      if (this.__backgroundColor !== null) {
        element.style.backgroundColor = this.__backgroundColor;
      }
      if (isValidVerticalAlign(this.__verticalAlign)) {
        element.style.verticalAlign = this.__verticalAlign;
      }
      addClassNamesToElement2(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);
      return element;
    }
    exportDOM(editor) {
      const output = super.exportDOM(editor);
      if (isHTMLElement2(output.element)) {
        const element = output.element;
        element.setAttribute("data-temporary-table-cell-lexical-key", this.getKey());
        element.style.border = "1px solid black";
        if (this.__colSpan > 1) {
          element.colSpan = this.__colSpan;
        }
        if (this.__rowSpan > 1) {
          element.rowSpan = this.__rowSpan;
        }
        element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;
        element.style.verticalAlign = this.getVerticalAlign() || "top";
        element.style.textAlign = "start";
        if (this.__backgroundColor === null && this.hasHeader()) {
          element.style.backgroundColor = "#f2f3f5";
        }
      }
      return output;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        ...isValidVerticalAlign(this.__verticalAlign) && {
          verticalAlign: this.__verticalAlign
        },
        backgroundColor: this.getBackgroundColor(),
        colSpan: this.__colSpan,
        headerState: this.__headerState,
        rowSpan: this.__rowSpan,
        width: this.getWidth()
      };
    }
    getColSpan() {
      return this.getLatest().__colSpan;
    }
    setColSpan(colSpan) {
      const self2 = this.getWritable();
      self2.__colSpan = colSpan;
      return self2;
    }
    getRowSpan() {
      return this.getLatest().__rowSpan;
    }
    setRowSpan(rowSpan) {
      const self2 = this.getWritable();
      self2.__rowSpan = rowSpan;
      return self2;
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {
      const self2 = this.getWritable();
      self2.__headerState = headerState & mask | self2.__headerState & ~mask;
      return self2;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(width) {
      const self2 = this.getWritable();
      self2.__width = width;
      return self2;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(newBackgroundColor) {
      const self2 = this.getWritable();
      self2.__backgroundColor = newBackgroundColor;
      return self2;
    }
    getVerticalAlign() {
      return this.getLatest().__verticalAlign;
    }
    setVerticalAlign(newVerticalAlign) {
      const self2 = this.getWritable();
      self2.__verticalAlign = newVerticalAlign || void 0;
      return self2;
    }
    toggleHeaderStyle(headerStateToToggle) {
      const self2 = this.getWritable();
      if ((self2.__headerState & headerStateToToggle) === headerStateToToggle) {
        self2.__headerState -= headerStateToToggle;
      } else {
        self2.__headerState += headerStateToToggle;
      }
      return self2;
    }
    hasHeaderState(headerState) {
      return (this.getHeaderStyles() & headerState) === headerState;
    }
    hasHeader() {
      return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;
    }
    updateDOM(prevNode) {
      return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor || prevNode.__verticalAlign !== this.__verticalAlign;
    }
    isShadowRoot() {
      return true;
    }
    collapseAtStart() {
      return true;
    }
    canBeEmpty() {
      return false;
    }
    canIndent() {
      return false;
    }
  };
  function isValidVerticalAlign(verticalAlign) {
    return verticalAlign === "middle" || verticalAlign === "bottom";
  }
  function $convertTableCellNodeElement(domNode) {
    const domNode_ = domNode;
    const nodeName = domNode.nodeName.toLowerCase();
    let width = void 0;
    if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {
      width = parseFloat(domNode_.style.width);
    }
    const tableCellNode = $createTableCellNode(nodeName === "th" ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);
    tableCellNode.__rowSpan = domNode_.rowSpan;
    const backgroundColor = domNode_.style.backgroundColor;
    if (backgroundColor !== "") {
      tableCellNode.__backgroundColor = backgroundColor;
    }
    const verticalAlign = domNode_.style.verticalAlign;
    if (isValidVerticalAlign(verticalAlign)) {
      tableCellNode.__verticalAlign = verticalAlign;
    }
    const style = domNode_.style;
    const textDecoration = (style && style.textDecoration || "").split(" ");
    const hasBoldFontWeight = style.fontWeight === "700" || style.fontWeight === "bold";
    const hasLinethroughTextDecoration = textDecoration.includes("line-through");
    const hasItalicFontStyle = style.fontStyle === "italic";
    const hasUnderlineTextDecoration = textDecoration.includes("underline");
    return {
      after: (childLexicalNodes) => {
        const result = [];
        let paragraphNode = null;
        const removeSingleLineBreakNode = () => {
          if (paragraphNode) {
            const firstChild = paragraphNode.getFirstChild();
            if ($isLineBreakNode2(firstChild) && paragraphNode.getChildrenSize() === 1) {
              firstChild.remove();
            }
          }
        };
        for (const child of childLexicalNodes) {
          if ($isInlineElementOrDecoratorNode2(child) || $isTextNode2(child) || $isLineBreakNode2(child)) {
            if ($isTextNode2(child)) {
              if (hasBoldFontWeight) {
                child.toggleFormat("bold");
              }
              if (hasLinethroughTextDecoration) {
                child.toggleFormat("strikethrough");
              }
              if (hasItalicFontStyle) {
                child.toggleFormat("italic");
              }
              if (hasUnderlineTextDecoration) {
                child.toggleFormat("underline");
              }
            }
            if (paragraphNode) {
              paragraphNode.append(child);
            } else {
              paragraphNode = $createParagraphNode2().append(child);
              result.push(paragraphNode);
            }
          } else {
            result.push(child);
            removeSingleLineBreakNode();
            paragraphNode = null;
          }
        }
        removeSingleLineBreakNode();
        if (result.length === 0) {
          result.push($createParagraphNode2());
        }
        return result;
      },
      node: tableCellNode
    };
  }
  function $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {
    return $applyNodeReplacement2(new TableCellNode(headerState, colSpan, width));
  }
  function $isTableCellNode(node) {
    return node instanceof TableCellNode;
  }
  var INSERT_TABLE_COMMAND = createCommand2("INSERT_TABLE_COMMAND");
  function formatDevErrorMessage9(message) {
    throw new Error(message);
  }
  var TableRowNode = class _TableRowNode extends ElementNode2 {
    /** @internal */
    __height;
    static getType() {
      return "tablerow";
    }
    static clone(node) {
      return new _TableRowNode(node.__height, node.__key);
    }
    static importDOM() {
      return {
        tr: (node) => ({
          conversion: $convertTableRowElement,
          priority: 0
        })
      };
    }
    static importJSON(serializedNode) {
      return $createTableRowNode().updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);
    }
    constructor(height, key) {
      super(key);
      this.__height = height;
    }
    exportJSON() {
      const height = this.getHeight();
      return {
        ...super.exportJSON(),
        ...height === void 0 ? void 0 : {
          height
        }
      };
    }
    createDOM(config) {
      const element = document.createElement("tr");
      if (this.__height) {
        element.style.height = `${this.__height}px`;
      }
      addClassNamesToElement2(element, config.theme.tableRow);
      return element;
    }
    extractWithChild(child, selection, destination) {
      return destination === "html";
    }
    isShadowRoot() {
      return true;
    }
    setHeight(height) {
      const self2 = this.getWritable();
      self2.__height = height;
      return self2;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(prevNode) {
      return prevNode.__height !== this.__height;
    }
    canBeEmpty() {
      return false;
    }
    canIndent() {
      return false;
    }
  };
  function $convertTableRowElement(domNode) {
    const domNode_ = domNode;
    let height = void 0;
    if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {
      height = parseFloat(domNode_.style.height);
    }
    return {
      after: (children) => $descendantsMatching2(children, $isTableCellNode),
      node: $createTableRowNode(height)
    };
  }
  function $createTableRowNode(height) {
    return $applyNodeReplacement2(new TableRowNode(height));
  }
  function $isTableRowNode(node) {
    return node instanceof TableRowNode;
  }
  var CAN_USE_DOM5 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  var documentMode4 = CAN_USE_DOM5 && "documentMode" in document ? document.documentMode : null;
  var IS_FIREFOX4 = CAN_USE_DOM5 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
  CAN_USE_DOM5 && "InputEvent" in window && !documentMode4 ? "getTargetRanges" in new window.InputEvent("input") : false;
  function $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {
    const tableNode = $createTableNode();
    for (let iRow = 0; iRow < rowCount; iRow++) {
      const tableRowNode = $createTableRowNode();
      for (let iColumn = 0; iColumn < columnCount; iColumn++) {
        let headerState = TableCellHeaderStates.NO_STATUS;
        if (typeof includeHeaders === "object") {
          if (iRow === 0 && includeHeaders.rows) {
            headerState |= TableCellHeaderStates.ROW;
          }
          if (iColumn === 0 && includeHeaders.columns) {
            headerState |= TableCellHeaderStates.COLUMN;
          }
        } else if (includeHeaders) {
          if (iRow === 0) {
            headerState |= TableCellHeaderStates.ROW;
          }
          if (iColumn === 0) {
            headerState |= TableCellHeaderStates.COLUMN;
          }
        }
        const tableCellNode = $createTableCellNode(headerState);
        const paragraphNode = $createParagraphNode2();
        paragraphNode.append($createTextNode2());
        tableCellNode.append(paragraphNode);
        tableRowNode.append(tableCellNode);
      }
      tableNode.append(tableRowNode);
    }
    return tableNode;
  }
  function $getTableCellNodeFromLexicalNode(startingNode) {
    const node = $findMatchingParent3(startingNode, (n2) => $isTableCellNode(n2));
    if ($isTableCellNode(node)) {
      return node;
    }
    return null;
  }
  function $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {
    const node = $findMatchingParent3(startingNode, (n2) => $isTableRowNode(n2));
    if ($isTableRowNode(node)) {
      return node;
    }
    throw new Error("Expected table cell to be inside of table row.");
  }
  function $getTableNodeFromLexicalNodeOrThrow(startingNode) {
    const node = $findMatchingParent3(startingNode, (n2) => $isTableNode(n2));
    if ($isTableNode(node)) {
      return node;
    }
    throw new Error("Expected table cell to be inside of table.");
  }
  function $getTableRowIndexFromTableCellNode(tableCellNode) {
    const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);
    const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);
    return tableNode.getChildren().findIndex((n2) => n2.is(tableRowNode));
  }
  function $getTableColumnIndexFromTableCellNode(tableCellNode) {
    const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);
    return tableRowNode.getChildren().findIndex((n2) => n2.is(tableCellNode));
  }
  function $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {
    const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);
    const {
      x: x2,
      y: y3
    } = tableNode.getCordsFromCellNode(tableCellNode, table);
    return {
      above: tableNode.getCellNodeFromCords(x2, y3 - 1, table),
      below: tableNode.getCellNodeFromCords(x2, y3 + 1, table),
      left: tableNode.getCellNodeFromCords(x2 - 1, y3, table),
      right: tableNode.getCellNodeFromCords(x2 + 1, y3, table)
    };
  }
  function $removeTableRowAtIndex(tableNode, indexToDelete) {
    const tableRows = tableNode.getChildren();
    if (indexToDelete >= tableRows.length || indexToDelete < 0) {
      throw new Error("Expected table cell to be inside of table row.");
    }
    const targetRowNode = tableRows[indexToDelete];
    targetRowNode.remove();
    return tableNode;
  }
  function $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {
    const tableRows = tableNode.getChildren();
    if (targetIndex >= tableRows.length || targetIndex < 0) {
      throw new Error("Table row target index out of range");
    }
    const targetRowNode = tableRows[targetIndex];
    if ($isTableRowNode(targetRowNode)) {
      for (let r2 = 0; r2 < rowCount; r2++) {
        const tableRowCells = targetRowNode.getChildren();
        const tableColumnCount = tableRowCells.length;
        const newTableRowNode = $createTableRowNode();
        for (let c2 = 0; c2 < tableColumnCount; c2++) {
          const tableCellFromTargetRow = tableRowCells[c2];
          if (!$isTableCellNode(tableCellFromTargetRow)) {
            formatDevErrorMessage9(`Expected table cell`);
          }
          const {
            above,
            below
          } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);
          let headerState = TableCellHeaderStates.NO_STATUS;
          const width = above && above.getWidth() || below && below.getWidth() || void 0;
          if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {
            headerState |= TableCellHeaderStates.COLUMN;
          }
          const tableCellNode = $createTableCellNode(headerState, 1, width);
          tableCellNode.append($createParagraphNode2());
          newTableRowNode.append(tableCellNode);
        }
        if (shouldInsertAfter) {
          targetRowNode.insertAfter(newTableRowNode);
        } else {
          targetRowNode.insertBefore(newTableRowNode);
        }
      }
    } else {
      throw new Error("Row before insertion index does not exist.");
    }
    return tableNode;
  }
  var getHeaderState = (currentState, possibleState) => {
    if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {
      return possibleState;
    }
    return TableCellHeaderStates.NO_STATUS;
  };
  function $insertTableRowAtSelection(insertAfter = true) {
    const selection = $getSelection2();
    if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
      formatDevErrorMessage9(`Expected a RangeSelection or TableSelection`);
    }
    const anchor = selection.anchor.getNode();
    const focus = selection.focus.getNode();
    const [anchorCell] = $getNodeTriplet(anchor);
    const [focusCell, , grid] = $getNodeTriplet(focus);
    const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);
    const {
      startRow: anchorStartRow
    } = anchorCellMap;
    const {
      startRow: focusStartRow
    } = focusCellMap;
    if (insertAfter) {
      return $insertTableRowAtNode(anchorStartRow + anchorCell.__rowSpan > focusStartRow + focusCell.__rowSpan ? anchorCell : focusCell, true);
    } else {
      return $insertTableRowAtNode(focusStartRow < anchorStartRow ? focusCell : anchorCell, false);
    }
  }
  var $insertTableRow__EXPERIMENTAL = $insertTableRowAtSelection;
  function $insertTableRowAtNode(cellNode, insertAfter = true) {
    const [, , grid] = $getNodeTriplet(cellNode);
    const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);
    const columnCount = gridMap[0].length;
    const {
      startRow: cellStartRow
    } = cellMap;
    let insertedRow = null;
    if (insertAfter) {
      const insertAfterEndRow = cellStartRow + cellNode.__rowSpan - 1;
      const insertAfterEndRowMap = gridMap[insertAfterEndRow];
      const newRow = $createTableRowNode();
      for (let i2 = 0; i2 < columnCount; i2++) {
        const {
          cell,
          startRow
        } = insertAfterEndRowMap[i2];
        if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {
          const currentCell = insertAfterEndRowMap[i2].cell;
          const currentCellHeaderState = currentCell.__headerState;
          const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);
          newRow.append($createTableCellNode(headerState).append($createParagraphNode2()));
        } else {
          cell.setRowSpan(cell.__rowSpan + 1);
        }
      }
      const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);
      if (!$isTableRowNode(insertAfterEndRowNode)) {
        formatDevErrorMessage9(`insertAfterEndRow is not a TableRowNode`);
      }
      insertAfterEndRowNode.insertAfter(newRow);
      insertedRow = newRow;
    } else {
      const insertBeforeStartRow = cellStartRow;
      const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];
      const newRow = $createTableRowNode();
      for (let i2 = 0; i2 < columnCount; i2++) {
        const {
          cell,
          startRow
        } = insertBeforeStartRowMap[i2];
        if (startRow === insertBeforeStartRow) {
          const currentCell = insertBeforeStartRowMap[i2].cell;
          const currentCellHeaderState = currentCell.__headerState;
          const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);
          newRow.append($createTableCellNode(headerState).append($createParagraphNode2()));
        } else {
          cell.setRowSpan(cell.__rowSpan + 1);
        }
      }
      const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);
      if (!$isTableRowNode(insertBeforeStartRowNode)) {
        formatDevErrorMessage9(`insertBeforeStartRow is not a TableRowNode`);
      }
      insertBeforeStartRowNode.insertBefore(newRow);
      insertedRow = newRow;
    }
    return insertedRow;
  }
  function $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {
    const tableRows = tableNode.getChildren();
    const tableCellsToBeInserted = [];
    for (let r2 = 0; r2 < tableRows.length; r2++) {
      const currentTableRowNode = tableRows[r2];
      if ($isTableRowNode(currentTableRowNode)) {
        for (let c2 = 0; c2 < columnCount; c2++) {
          const tableRowChildren = currentTableRowNode.getChildren();
          if (targetIndex >= tableRowChildren.length || targetIndex < 0) {
            throw new Error("Table column target index out of range");
          }
          const targetCell = tableRowChildren[targetIndex];
          if (!$isTableCellNode(targetCell)) {
            formatDevErrorMessage9(`Expected table cell`);
          }
          const {
            left,
            right
          } = $getTableCellSiblingsFromTableCellNode(targetCell, table);
          let headerState = TableCellHeaderStates.NO_STATUS;
          if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {
            headerState |= TableCellHeaderStates.ROW;
          }
          const newTableCell = $createTableCellNode(headerState);
          newTableCell.append($createParagraphNode2());
          tableCellsToBeInserted.push({
            newTableCell,
            targetCell
          });
        }
      }
    }
    tableCellsToBeInserted.forEach(({
      newTableCell,
      targetCell
    }) => {
      if (shouldInsertAfter) {
        targetCell.insertAfter(newTableCell);
      } else {
        targetCell.insertBefore(newTableCell);
      }
    });
    return tableNode;
  }
  function $insertTableColumnAtSelection(insertAfter = true) {
    const selection = $getSelection2();
    if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
      formatDevErrorMessage9(`Expected a RangeSelection or TableSelection`);
    }
    const anchor = selection.anchor.getNode();
    const focus = selection.focus.getNode();
    const [anchorCell] = $getNodeTriplet(anchor);
    const [focusCell, , grid] = $getNodeTriplet(focus);
    const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);
    const {
      startColumn: anchorStartColumn
    } = anchorCellMap;
    const {
      startColumn: focusStartColumn
    } = focusCellMap;
    if (insertAfter) {
      return $insertTableColumnAtNode(anchorStartColumn + anchorCell.__colSpan > focusStartColumn + focusCell.__colSpan ? anchorCell : focusCell, true);
    } else {
      return $insertTableColumnAtNode(focusStartColumn < anchorStartColumn ? focusCell : anchorCell, false);
    }
  }
  var $insertTableColumn__EXPERIMENTAL = $insertTableColumnAtSelection;
  function $insertTableColumnAtNode(cellNode, insertAfter = true, shouldSetSelection = true) {
    const [, , grid] = $getNodeTriplet(cellNode);
    const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);
    const rowCount = gridMap.length;
    const {
      startColumn
    } = cellMap;
    const insertAfterColumn = insertAfter ? startColumn + cellNode.__colSpan - 1 : startColumn - 1;
    const gridFirstChild = grid.getFirstChild();
    if (!$isTableRowNode(gridFirstChild)) {
      formatDevErrorMessage9(`Expected firstTable child to be a row`);
    }
    let firstInsertedCell = null;
    function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {
      const cell = $createTableCellNode(headerState).append($createParagraphNode2());
      if (firstInsertedCell === null) {
        firstInsertedCell = cell;
      }
      return cell;
    }
    let loopRow = gridFirstChild;
    rowLoop: for (let i2 = 0; i2 < rowCount; i2++) {
      if (i2 !== 0) {
        const currentRow = loopRow.getNextSibling();
        if (!$isTableRowNode(currentRow)) {
          formatDevErrorMessage9(`Expected row nextSibling to be a row`);
        }
        loopRow = currentRow;
      }
      const rowMap = gridMap[i2];
      const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;
      const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);
      if (insertAfterColumn < 0) {
        $insertFirst3(loopRow, $createTableCellNodeForInsertTableColumn(headerState));
        continue;
      }
      const {
        cell: currentCell,
        startColumn: currentStartColumn,
        startRow: currentStartRow
      } = rowMap[insertAfterColumn];
      if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {
        let insertAfterCell = currentCell;
        let insertAfterCellRowStart = currentStartRow;
        let prevCellIndex = insertAfterColumn;
        while (insertAfterCellRowStart !== i2 && insertAfterCell.__rowSpan > 1) {
          prevCellIndex -= currentCell.__colSpan;
          if (prevCellIndex >= 0) {
            const {
              cell: cell_,
              startRow: startRow_
            } = rowMap[prevCellIndex];
            insertAfterCell = cell_;
            insertAfterCellRowStart = startRow_;
          } else {
            loopRow.append($createTableCellNodeForInsertTableColumn(headerState));
            continue rowLoop;
          }
        }
        insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));
      } else {
        currentCell.setColSpan(currentCell.__colSpan + 1);
      }
    }
    if (firstInsertedCell !== null && shouldSetSelection) {
      $moveSelectionToCell(firstInsertedCell);
    }
    const colWidths = grid.getColWidths();
    if (colWidths) {
      const newColWidths = [...colWidths];
      const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;
      const newWidth = newColWidths[columnIndex];
      newColWidths.splice(columnIndex, 0, newWidth);
      grid.setColWidths(newColWidths);
    }
    return firstInsertedCell;
  }
  function $deleteTableColumn(tableNode, targetIndex) {
    const tableRows = tableNode.getChildren();
    for (let i2 = 0; i2 < tableRows.length; i2++) {
      const currentTableRowNode = tableRows[i2];
      if ($isTableRowNode(currentTableRowNode)) {
        const tableRowChildren = currentTableRowNode.getChildren();
        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {
          throw new Error("Table column target index out of range");
        }
        tableRowChildren[targetIndex].remove();
      }
    }
    return tableNode;
  }
  function $deleteTableRowAtSelection() {
    const selection = $getSelection2();
    if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
      formatDevErrorMessage9(`Expected a RangeSelection or TableSelection`);
    }
    const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];
    const [anchorCell, , grid] = $getNodeTriplet(anchor);
    const [focusCell] = $getNodeTriplet(focus);
    const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);
    const {
      startRow: anchorStartRow
    } = anchorCellMap;
    const {
      startRow: focusStartRow
    } = focusCellMap;
    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;
    if (gridMap.length === focusEndRow - anchorStartRow + 1) {
      grid.remove();
      return;
    }
    const columnCount = gridMap[0].length;
    const nextRow = gridMap[focusEndRow + 1];
    const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);
    for (let row = focusEndRow; row >= anchorStartRow; row--) {
      for (let column = columnCount - 1; column >= 0; column--) {
        const {
          cell,
          startRow: cellStartRow,
          startColumn: cellStartColumn
        } = gridMap[row][column];
        if (cellStartColumn !== column) {
          continue;
        }
        if (cellStartRow < anchorStartRow || cellStartRow + cell.__rowSpan - 1 > focusEndRow) {
          const intersectionStart = Math.max(cellStartRow, anchorStartRow);
          const intersectionEnd = Math.min(cell.__rowSpan + cellStartRow - 1, focusEndRow);
          const overflowRowsCount = intersectionStart <= intersectionEnd ? intersectionEnd - intersectionStart + 1 : 0;
          cell.setRowSpan(cell.__rowSpan - overflowRowsCount);
        }
        if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow && // Handle overflow only once
        row === focusEndRow) {
          if (!(nextRowNode !== null)) {
            formatDevErrorMessage9(`Expected nextRowNode not to be null`);
          }
          let insertAfterCell = null;
          for (let columnIndex = 0; columnIndex < column; columnIndex++) {
            const currentCellMap = nextRow[columnIndex];
            const currentCell = currentCellMap.cell;
            if (currentCellMap.startRow === row + 1) {
              insertAfterCell = currentCell;
            }
            if (currentCell.__colSpan > 1) {
              columnIndex += currentCell.__colSpan - 1;
            }
          }
          if (insertAfterCell === null) {
            $insertFirst3(nextRowNode, cell);
          } else {
            insertAfterCell.insertAfter(cell);
          }
        }
      }
      const rowNode = grid.getChildAtIndex(row);
      if (!$isTableRowNode(rowNode)) {
        formatDevErrorMessage9(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);
      }
      rowNode.remove();
    }
    if (nextRow !== void 0) {
      const {
        cell
      } = nextRow[0];
      $moveSelectionToCell(cell);
    } else {
      const previousRow = gridMap[anchorStartRow - 1];
      const {
        cell
      } = previousRow[0];
      $moveSelectionToCell(cell);
    }
  }
  var $deleteTableRow__EXPERIMENTAL = $deleteTableRowAtSelection;
  function $deleteTableColumnAtSelection() {
    const selection = $getSelection2();
    if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
      formatDevErrorMessage9(`Expected a RangeSelection or TableSelection`);
    }
    const anchor = selection.anchor.getNode();
    const focus = selection.focus.getNode();
    const [anchorCell, , grid] = $getNodeTriplet(anchor);
    const [focusCell] = $getNodeTriplet(focus);
    const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);
    const {
      startColumn: anchorStartColumn
    } = anchorCellMap;
    const {
      startRow: focusStartRow,
      startColumn: focusStartColumn
    } = focusCellMap;
    const startColumn = Math.min(anchorStartColumn, focusStartColumn);
    const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);
    const selectedColumnCount = endColumn - startColumn + 1;
    const columnCount = gridMap[0].length;
    if (columnCount === endColumn - startColumn + 1) {
      grid.selectPrevious();
      grid.remove();
      return;
    }
    const rowCount = gridMap.length;
    for (let row = 0; row < rowCount; row++) {
      for (let column = startColumn; column <= endColumn; column++) {
        const {
          cell,
          startColumn: cellStartColumn
        } = gridMap[row][column];
        if (cellStartColumn < startColumn) {
          if (column === startColumn) {
            const overflowLeft = startColumn - cellStartColumn;
            cell.setColSpan(cell.__colSpan - // Possible overflow right too
            Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));
          }
        } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {
          if (column === endColumn) {
            const inSelectedArea = endColumn - cellStartColumn + 1;
            cell.setColSpan(cell.__colSpan - inSelectedArea);
          }
        } else {
          cell.remove();
        }
      }
    }
    const focusRowMap = gridMap[focusStartRow];
    const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];
    if (nextColumn !== void 0) {
      const {
        cell
      } = nextColumn;
      $moveSelectionToCell(cell);
    } else {
      const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];
      const {
        cell
      } = previousRow;
      $moveSelectionToCell(cell);
    }
    const colWidths = grid.getColWidths();
    if (colWidths) {
      const newColWidths = [...colWidths];
      newColWidths.splice(startColumn, selectedColumnCount);
      grid.setColWidths(newColWidths);
    }
  }
  var $deleteTableColumn__EXPERIMENTAL = $deleteTableColumnAtSelection;
  function $moveSelectionToCell(cell) {
    const firstDescendant = cell.getFirstDescendant();
    if (firstDescendant == null) {
      cell.selectStart();
    } else {
      firstDescendant.getParentOrThrow().selectStart();
    }
  }
  function $insertFirst3(parent, node) {
    const firstChild = parent.getFirstChild();
    if (firstChild !== null) {
      firstChild.insertBefore(node);
    } else {
      parent.append(node);
    }
  }
  function $mergeCells(cellNodes) {
    if (cellNodes.length === 0) {
      return null;
    }
    const tableNode = $getTableNodeFromLexicalNodeOrThrow(cellNodes[0]);
    const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null);
    let minRow = Infinity;
    let maxRow = -Infinity;
    let minCol = Infinity;
    let maxCol = -Infinity;
    const processedCells = /* @__PURE__ */ new Set();
    for (const row of gridMap) {
      for (const mapCell of row) {
        if (!mapCell || !mapCell.cell) {
          continue;
        }
        const cellKey = mapCell.cell.getKey();
        if (processedCells.has(cellKey)) {
          continue;
        }
        if (cellNodes.some((cell) => cell.is(mapCell.cell))) {
          processedCells.add(cellKey);
          const cellStartRow = mapCell.startRow;
          const cellStartCol = mapCell.startColumn;
          const cellRowSpan = mapCell.cell.__rowSpan || 1;
          const cellColSpan = mapCell.cell.__colSpan || 1;
          minRow = Math.min(minRow, cellStartRow);
          maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1);
          minCol = Math.min(minCol, cellStartCol);
          maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1);
        }
      }
    }
    if (minRow === Infinity || minCol === Infinity) {
      return null;
    }
    const totalRowSpan = maxRow - minRow + 1;
    const totalColSpan = maxCol - minCol + 1;
    const targetCellMap = gridMap[minRow][minCol];
    if (!targetCellMap.cell) {
      return null;
    }
    const targetCell = targetCellMap.cell;
    targetCell.setColSpan(totalColSpan);
    targetCell.setRowSpan(totalRowSpan);
    const seenCells = /* @__PURE__ */ new Set([targetCell.getKey()]);
    for (let row = minRow; row <= maxRow; row++) {
      for (let col = minCol; col <= maxCol; col++) {
        const mapCell = gridMap[row][col];
        if (!mapCell.cell) {
          continue;
        }
        const currentCell = mapCell.cell;
        const key = currentCell.getKey();
        if (!seenCells.has(key)) {
          seenCells.add(key);
          const isEmpty = $cellContainsEmptyParagraph(currentCell);
          if (!isEmpty) {
            targetCell.append(...currentCell.getChildren());
          }
          currentCell.remove();
        }
      }
    }
    if (targetCell.getChildrenSize() === 0) {
      targetCell.append($createParagraphNode2());
    }
    return targetCell;
  }
  function $cellContainsEmptyParagraph(cell) {
    if (cell.getChildrenSize() !== 1) {
      return false;
    }
    const firstChild = cell.getFirstChildOrThrow();
    if (!$isParagraphNode2(firstChild) || !firstChild.isEmpty()) {
      return false;
    }
    return true;
  }
  function $unmergeCell() {
    const selection = $getSelection2();
    if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
      formatDevErrorMessage9(`Expected a RangeSelection or TableSelection`);
    }
    const anchor = selection.anchor.getNode();
    const cellNode = $findMatchingParent3(anchor, $isTableCellNode);
    if (!$isTableCellNode(cellNode)) {
      formatDevErrorMessage9(`Expected to find a parent TableCellNode`);
    }
    return $unmergeCellNode(cellNode);
  }
  function $unmergeCellNode(cellNode) {
    const [cell, row, grid] = $getNodeTriplet(cellNode);
    const colSpan = cell.__colSpan;
    const rowSpan = cell.__rowSpan;
    if (colSpan === 1 && rowSpan === 1) {
      return;
    }
    const [map3, cellMap] = $computeTableMap(grid, cell, cell);
    const {
      startColumn,
      startRow
    } = cellMap;
    const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;
    const colStyles = Array.from({
      length: colSpan
    }, (_v, i2) => {
      let colStyle = baseColStyle;
      for (let rowIdx = 0; colStyle !== 0 && rowIdx < map3.length; rowIdx++) {
        colStyle &= map3[rowIdx][i2 + startColumn].cell.__headerState;
      }
      return colStyle;
    });
    const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;
    const rowStyles = Array.from({
      length: rowSpan
    }, (_v, i2) => {
      let rowStyle = baseRowStyle;
      for (let colIdx = 0; rowStyle !== 0 && colIdx < map3[0].length; colIdx++) {
        rowStyle &= map3[i2 + startRow][colIdx].cell.__headerState;
      }
      return rowStyle;
    });
    if (colSpan > 1) {
      for (let i2 = 1; i2 < colSpan; i2++) {
        cell.insertAfter($createTableCellNode(colStyles[i2] | rowStyles[0]).append($createParagraphNode2()));
      }
      cell.setColSpan(1);
    }
    if (rowSpan > 1) {
      let currentRowNode;
      for (let i2 = 1; i2 < rowSpan; i2++) {
        const currentRow = startRow + i2;
        const currentRowMap = map3[currentRow];
        currentRowNode = (currentRowNode || row).getNextSibling();
        if (!$isTableRowNode(currentRowNode)) {
          formatDevErrorMessage9(`Expected row next sibling to be a row`);
        }
        let insertAfterCell = null;
        for (let column = 0; column < startColumn; column++) {
          const currentCellMap = currentRowMap[column];
          const currentCell = currentCellMap.cell;
          if (currentCellMap.startRow === currentRow) {
            insertAfterCell = currentCell;
          }
          if (currentCell.__colSpan > 1) {
            column += currentCell.__colSpan - 1;
          }
        }
        if (insertAfterCell === null) {
          for (let j2 = colSpan - 1; j2 >= 0; j2--) {
            $insertFirst3(currentRowNode, $createTableCellNode(colStyles[j2] | rowStyles[i2]).append($createParagraphNode2()));
          }
        } else {
          for (let j2 = colSpan - 1; j2 >= 0; j2--) {
            insertAfterCell.insertAfter($createTableCellNode(colStyles[j2] | rowStyles[i2]).append($createParagraphNode2()));
          }
        }
      }
      cell.setRowSpan(1);
    }
  }
  function $computeTableMap(tableNode, cellA, cellB) {
    const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);
    if (!(cellAValue !== null)) {
      formatDevErrorMessage9(`Anchor not found in Table`);
    }
    if (!(cellBValue !== null)) {
      formatDevErrorMessage9(`Focus not found in Table`);
    }
    return [tableMap, cellAValue, cellBValue];
  }
  function $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {
    const tableMap = [];
    let cellAValue = null;
    let cellBValue = null;
    function getMapRow(i2) {
      let row = tableMap[i2];
      if (row === void 0) {
        tableMap[i2] = row = [];
      }
      return row;
    }
    const gridChildren = tableNode.getChildren();
    for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {
      const row = gridChildren[rowIdx];
      if (!$isTableRowNode(row)) {
        formatDevErrorMessage9(`Expected TableNode children to be TableRowNode`);
      }
      const startMapRow = getMapRow(rowIdx);
      for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {
        if (!$isTableCellNode(cell)) {
          formatDevErrorMessage9(`Expected TableRowNode children to be TableCellNode`);
        }
        while (startMapRow[colIdx] !== void 0) {
          colIdx++;
        }
        const value = {
          cell,
          startColumn: colIdx,
          startRow: rowIdx
        };
        const {
          __rowSpan: rowSpan,
          __colSpan: colSpan
        } = cell;
        for (let j2 = 0; j2 < rowSpan; j2++) {
          if (rowIdx + j2 >= gridChildren.length) {
            break;
          }
          const mapRow = getMapRow(rowIdx + j2);
          for (let i2 = 0; i2 < colSpan; i2++) {
            mapRow[colIdx + i2] = value;
          }
        }
        if (cellA !== null && cellAValue === null && cellA.is(cell)) {
          cellAValue = value;
        }
        if (cellB !== null && cellBValue === null && cellB.is(cell)) {
          cellBValue = value;
        }
      }
    }
    return [tableMap, cellAValue, cellBValue];
  }
  function $getNodeTriplet(source) {
    let cell;
    if (source instanceof TableCellNode) {
      cell = source;
    } else if ("__type" in source) {
      const cell_ = $findMatchingParent3(source, $isTableCellNode);
      if (!$isTableCellNode(cell_)) {
        formatDevErrorMessage9(`Expected to find a parent TableCellNode`);
      }
      cell = cell_;
    } else {
      const cell_ = $findMatchingParent3(source.getNode(), $isTableCellNode);
      if (!$isTableCellNode(cell_)) {
        formatDevErrorMessage9(`Expected to find a parent TableCellNode`);
      }
      cell = cell_;
    }
    const row = cell.getParent();
    if (!$isTableRowNode(row)) {
      formatDevErrorMessage9(`Expected TableCellNode to have a parent TableRowNode`);
    }
    const grid = row.getParent();
    if (!$isTableNode(grid)) {
      formatDevErrorMessage9(`Expected TableRowNode to have a parent TableNode`);
    }
    return [cell, row, grid];
  }
  function $computeTableCellRectSpans(map3, boundary) {
    const {
      minColumn,
      maxColumn,
      minRow,
      maxRow
    } = boundary;
    let topSpan = 1;
    let leftSpan = 1;
    let rightSpan = 1;
    let bottomSpan = 1;
    const topRow = map3[minRow];
    const bottomRow = map3[maxRow];
    for (let col = minColumn; col <= maxColumn; col++) {
      topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);
      bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);
    }
    for (let row = minRow; row <= maxRow; row++) {
      leftSpan = Math.max(leftSpan, map3[row][minColumn].cell.__colSpan);
      rightSpan = Math.max(rightSpan, map3[row][maxColumn].cell.__colSpan);
    }
    return {
      bottomSpan,
      leftSpan,
      rightSpan,
      topSpan
    };
  }
  function $computeTableCellRectBoundary(map3, cellAMap, cellBMap) {
    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);
    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);
    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);
    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);
    let hasChanges;
    do {
      hasChanges = false;
      for (let row = 0; row < map3.length; row++) {
        for (let col = 0; col < map3[0].length; col++) {
          const cell = map3[row][col];
          if (!cell) {
            continue;
          }
          const cellEndCol = cell.startColumn + cell.cell.__colSpan - 1;
          const cellEndRow = cell.startRow + cell.cell.__rowSpan - 1;
          const intersectsHorizontally = cell.startColumn <= maxColumn && cellEndCol >= minColumn;
          const intersectsVertically = cell.startRow <= maxRow && cellEndRow >= minRow;
          if (intersectsHorizontally && intersectsVertically) {
            const newMinColumn = Math.min(minColumn, cell.startColumn);
            const newMaxColumn = Math.max(maxColumn, cellEndCol);
            const newMinRow = Math.min(minRow, cell.startRow);
            const newMaxRow = Math.max(maxRow, cellEndRow);
            if (newMinColumn !== minColumn || newMaxColumn !== maxColumn || newMinRow !== minRow || newMaxRow !== maxRow) {
              minColumn = newMinColumn;
              maxColumn = newMaxColumn;
              minRow = newMinRow;
              maxRow = newMaxRow;
              hasChanges = true;
            }
          }
        }
      }
    } while (hasChanges);
    return {
      maxColumn,
      maxRow,
      minColumn,
      minRow
    };
  }
  function $getTableCellNodeRect(tableCellNode) {
    const [cellNode, , gridNode] = $getNodeTriplet(tableCellNode);
    const rows = gridNode.getChildren();
    const rowCount = rows.length;
    const columnCount = rows[0].getChildren().length;
    const cellMatrix = new Array(rowCount);
    for (let i2 = 0; i2 < rowCount; i2++) {
      cellMatrix[i2] = new Array(columnCount);
    }
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
      const row = rows[rowIndex];
      const cells = row.getChildren();
      let columnIndex = 0;
      for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
        while (cellMatrix[rowIndex][columnIndex]) {
          columnIndex++;
        }
        const cell = cells[cellIndex];
        const rowSpan = cell.__rowSpan || 1;
        const colSpan = cell.__colSpan || 1;
        for (let i2 = 0; i2 < rowSpan; i2++) {
          for (let j2 = 0; j2 < colSpan; j2++) {
            cellMatrix[rowIndex + i2][columnIndex + j2] = cell;
          }
        }
        if (cellNode === cell) {
          return {
            colSpan,
            columnIndex,
            rowIndex,
            rowSpan
          };
        }
        columnIndex += colSpan;
      }
    }
    return null;
  }
  function $getCellNodes(tableSelection) {
    const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ["anchor", "focus"].map((k2) => {
      const node = tableSelection[k2].getNode();
      const cellNode = $findMatchingParent3(node, $isTableCellNode);
      if (!$isTableCellNode(cellNode)) {
        formatDevErrorMessage9(`Expected TableSelection ${k2} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);
      }
      const rowNode = cellNode.getParent();
      if (!$isTableRowNode(rowNode)) {
        formatDevErrorMessage9(`Expected TableSelection ${k2} cell parent to be a TableRowNode`);
      }
      const tableNode = rowNode.getParent();
      if (!$isTableNode(tableNode)) {
        formatDevErrorMessage9(`Expected TableSelection ${k2} row parent to be a TableNode`);
      }
      return [node, cellNode, rowNode, tableNode];
    });
    if (!anchorTable.is(focusTable)) {
      formatDevErrorMessage9(`Expected TableSelection anchor and focus to be in the same table`);
    }
    return {
      anchorCell,
      anchorNode,
      anchorRow,
      anchorTable,
      focusCell,
      focusNode,
      focusRow,
      focusTable
    };
  }
  var TableSelection = class _TableSelection {
    tableKey;
    anchor;
    focus;
    _cachedNodes;
    dirty;
    constructor(tableKey, anchor, focus) {
      this.anchor = anchor;
      this.focus = focus;
      anchor._selection = this;
      focus._selection = this;
      this._cachedNodes = null;
      this.dirty = false;
      this.tableKey = tableKey;
    }
    getStartEndPoints() {
      return [this.anchor, this.focus];
    }
    /**
     * {@link $createTableSelection} unfortunately makes it very easy to create
     * nonsense selections, so we have a method to see if the selection probably
     * makes sense.
     *
     * @returns true if the TableSelection is (probably) valid
     */
    isValid() {
      if (this.tableKey === "root" || this.anchor.key === "root" || this.anchor.type !== "element" || this.focus.key === "root" || this.focus.type !== "element") {
        return false;
      }
      const tableNode = $getNodeByKey2(this.tableKey);
      const anchorNode = $getNodeByKey2(this.anchor.key);
      const focusNode = $getNodeByKey2(this.focus.key);
      return tableNode !== null && anchorNode !== null && focusNode !== null;
    }
    /**
     * Returns whether the Selection is "backwards", meaning the focus
     * logically precedes the anchor in the EditorState.
     * @returns true if the Selection is backwards, false otherwise.
     */
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(nodes) {
      this._cachedNodes = nodes;
    }
    is(selection) {
      return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);
    }
    set(tableKey, anchorCellKey, focusCellKey) {
      this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;
      this.tableKey = tableKey;
      this.anchor.key = anchorCellKey;
      this.focus.key = focusCellKey;
      this._cachedNodes = null;
    }
    clone() {
      return new _TableSelection(this.tableKey, $createPoint2(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint2(this.focus.key, this.focus.offset, this.focus.type));
    }
    isCollapsed() {
      return false;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(text2) {
    }
    insertText() {
    }
    /**
     * Returns whether the provided TextFormatType is present on the Selection.
     * This will be true if any paragraph in table cells has the specified format.
     *
     * @param type the TextFormatType to check for.
     * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
     */
    hasFormat(type) {
      let format = 0;
      const cellNodes = this.getNodes().filter($isTableCellNode);
      cellNodes.forEach((cellNode) => {
        const paragraph = cellNode.getFirstChild();
        if ($isParagraphNode2(paragraph)) {
          format |= paragraph.getTextFormat();
        }
      });
      const formatFlag = TEXT_TYPE_TO_FORMAT2[type];
      return (format & formatFlag) !== 0;
    }
    insertNodes(nodes) {
      const focusNode = this.focus.getNode();
      if (!$isElementNode2(focusNode)) {
        formatDevErrorMessage9(`Expected TableSelection focus to be an ElementNode`);
      }
      const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));
      selection.insertNodes(nodes);
    }
    // TODO Deprecate this method. It's confusing when used with colspan|rowspan
    getShape() {
      const {
        anchorCell,
        focusCell
      } = $getCellNodes(this);
      const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);
      if (!(anchorCellNodeRect !== null)) {
        formatDevErrorMessage9(`getCellRect: expected to find AnchorNode`);
      }
      const focusCellNodeRect = $getTableCellNodeRect(focusCell);
      if (!(focusCellNodeRect !== null)) {
        formatDevErrorMessage9(`getCellRect: expected to find focusCellNode`);
      }
      const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);
      const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);
      const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);
      const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);
      return {
        fromX: Math.min(startX, stopX),
        fromY: Math.min(startY, stopY),
        toX: Math.max(startX, stopX),
        toY: Math.max(startY, stopY)
      };
    }
    getNodes() {
      if (!this.isValid()) {
        return [];
      }
      const cachedNodes = this._cachedNodes;
      if (cachedNodes !== null) {
        return cachedNodes;
      }
      const {
        anchorTable: tableNode,
        anchorCell,
        focusCell
      } = $getCellNodes(this);
      const focusCellGrid = focusCell.getParents()[1];
      if (focusCellGrid !== tableNode) {
        if (!tableNode.isParentOf(focusCell)) {
          const gridParent = tableNode.getParent();
          if (!(gridParent != null)) {
            formatDevErrorMessage9(`Expected gridParent to have a parent`);
          }
          this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());
        } else {
          const focusCellParent = focusCellGrid.getParent();
          if (!(focusCellParent != null)) {
            formatDevErrorMessage9(`Expected focusCellParent to have a parent`);
          }
          this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());
        }
        return this.getNodes();
      }
      const [map3, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);
      const {
        minColumn,
        maxColumn,
        minRow,
        maxRow
      } = $computeTableCellRectBoundary(map3, cellAMap, cellBMap);
      const nodeMap = /* @__PURE__ */ new Map([[tableNode.getKey(), tableNode]]);
      let lastRow = null;
      for (let i2 = minRow; i2 <= maxRow; i2++) {
        for (let j2 = minColumn; j2 <= maxColumn; j2++) {
          const {
            cell
          } = map3[i2][j2];
          const currentRow = cell.getParent();
          if (!$isTableRowNode(currentRow)) {
            formatDevErrorMessage9(`Expected TableCellNode parent to be a TableRowNode`);
          }
          if (currentRow !== lastRow) {
            nodeMap.set(currentRow.getKey(), currentRow);
            lastRow = currentRow;
          }
          if (!nodeMap.has(cell.getKey())) {
            $visitRecursively(cell, (childNode) => {
              nodeMap.set(childNode.getKey(), childNode);
            });
          }
        }
      }
      const nodes = Array.from(nodeMap.values());
      if (!isCurrentlyReadOnlyMode2()) {
        this._cachedNodes = nodes;
      }
      return nodes;
    }
    getTextContent() {
      const nodes = this.getNodes().filter((node) => $isTableCellNode(node));
      let textContent = "";
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node = nodes[i2];
        const row = node.__parent;
        const nextRow = (nodes[i2 + 1] || {}).__parent;
        textContent += node.getTextContent() + (nextRow !== row ? "\n" : "	");
      }
      return textContent;
    }
  };
  function $isTableSelection(x2) {
    return x2 instanceof TableSelection;
  }
  function $createTableSelection() {
    const anchor = $createPoint2("root", 0, "element");
    const focus = $createPoint2("root", 0, "element");
    return new TableSelection("root", anchor, focus);
  }
  function $createTableSelectionFrom(tableNode, anchorCell, focusCell) {
    const tableNodeKey = tableNode.getKey();
    const anchorCellKey = anchorCell.getKey();
    const focusCellKey = focusCell.getKey();
    {
      if (!tableNode.isAttached()) {
        formatDevErrorMessage9(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);
      }
      if (!tableNode.is($findTableNode(anchorCell))) {
        formatDevErrorMessage9(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);
      }
      if (!tableNode.is($findTableNode(focusCell))) {
        formatDevErrorMessage9(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);
      }
    }
    const prevSelection = $getSelection2();
    const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();
    nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());
    return nextSelection;
  }
  function $visitRecursively(node, $visit) {
    const stack = [[node]];
    for (let currentArray = stack.at(-1); currentArray !== void 0 && stack.length > 0; currentArray = stack.at(-1)) {
      const currentNode = currentArray.pop();
      if (currentNode === void 0) {
        stack.pop();
      } else if ($visit(currentNode) !== false && $isElementNode2(currentNode)) {
        stack.push(currentNode.getChildren());
      }
    }
  }
  function $getTableAndElementByKey(tableNodeKey, editor = $getEditor2()) {
    const tableNode = $getNodeByKey2(tableNodeKey);
    if (!$isTableNode(tableNode)) {
      formatDevErrorMessage9(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);
    }
    const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));
    if (!(tableElement !== null)) {
      formatDevErrorMessage9(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);
    }
    return {
      tableElement,
      tableNode
    };
  }
  var TableObserver = class {
    focusX;
    focusY;
    listenersToRemove;
    table;
    isHighlightingCells;
    anchorX;
    anchorY;
    tableNodeKey;
    anchorCell;
    focusCell;
    anchorCellNodeKey;
    focusCellNodeKey;
    editor;
    tableSelection;
    hasHijackedSelectionStyles;
    isSelecting;
    pointerType;
    shouldCheckSelection;
    abortController;
    listenerOptions;
    nextFocus;
    constructor(editor, tableNodeKey) {
      this.isHighlightingCells = false;
      this.anchorX = -1;
      this.anchorY = -1;
      this.focusX = -1;
      this.focusY = -1;
      this.listenersToRemove = /* @__PURE__ */ new Set();
      this.tableNodeKey = tableNodeKey;
      this.editor = editor;
      this.table = {
        columns: 0,
        domRows: [],
        rows: 0
      };
      this.tableSelection = null;
      this.anchorCellNodeKey = null;
      this.focusCellNodeKey = null;
      this.anchorCell = null;
      this.focusCell = null;
      this.hasHijackedSelectionStyles = false;
      this.isSelecting = false;
      this.pointerType = null;
      this.shouldCheckSelection = false;
      this.abortController = new AbortController();
      this.listenerOptions = {
        signal: this.abortController.signal
      };
      this.nextFocus = null;
      this.trackTable();
    }
    getTable() {
      return this.table;
    }
    removeListeners() {
      this.abortController.abort("removeListeners");
      Array.from(this.listenersToRemove).forEach((removeListener2) => removeListener2());
      this.listenersToRemove.clear();
    }
    $lookup() {
      return $getTableAndElementByKey(this.tableNodeKey, this.editor);
    }
    trackTable() {
      const observer2 = new MutationObserver((records) => {
        this.editor.getEditorState().read(() => {
          let gridNeedsRedraw = false;
          for (let i2 = 0; i2 < records.length; i2++) {
            const record = records[i2];
            const target = record.target;
            const nodeName = target.nodeName;
            if (nodeName === "TABLE" || nodeName === "TBODY" || nodeName === "THEAD" || nodeName === "TR") {
              gridNeedsRedraw = true;
              break;
            }
          }
          if (!gridNeedsRedraw) {
            return;
          }
          const {
            tableNode,
            tableElement
          } = this.$lookup();
          this.table = getTable(tableNode, tableElement);
        }, {
          editor: this.editor
        });
      });
      this.editor.getEditorState().read(() => {
        const {
          tableNode,
          tableElement
        } = this.$lookup();
        this.table = getTable(tableNode, tableElement);
        observer2.observe(tableElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }, {
        editor: this.editor
      });
    }
    $clearHighlight() {
      const editor = this.editor;
      this.isHighlightingCells = false;
      this.anchorX = -1;
      this.anchorY = -1;
      this.focusX = -1;
      this.focusY = -1;
      this.tableSelection = null;
      this.anchorCellNodeKey = null;
      this.focusCellNodeKey = null;
      this.anchorCell = null;
      this.focusCell = null;
      this.hasHijackedSelectionStyles = false;
      this.$enableHighlightStyle();
      const {
        tableNode,
        tableElement
      } = this.$lookup();
      const grid = getTable(tableNode, tableElement);
      $updateDOMForSelection(editor, grid, null);
      if ($getSelection2() !== null) {
        $setSelection2(null);
        editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
      }
    }
    $enableHighlightStyle() {
      const editor = this.editor;
      const {
        tableElement
      } = this.$lookup();
      removeClassNamesFromElement2(tableElement, editor._config.theme.tableSelection);
      tableElement.classList.remove("disable-selection");
      this.hasHijackedSelectionStyles = false;
    }
    $disableHighlightStyle() {
      const {
        tableElement
      } = this.$lookup();
      addClassNamesToElement2(tableElement, this.editor._config.theme.tableSelection);
      this.hasHijackedSelectionStyles = true;
    }
    $updateTableTableSelection(selection) {
      if (selection !== null) {
        if (!(selection.tableKey === this.tableNodeKey)) {
          formatDevErrorMessage9(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);
        }
        const editor = this.editor;
        this.tableSelection = selection;
        this.isHighlightingCells = true;
        this.$disableHighlightStyle();
        this.updateDOMSelection();
        $updateDOMForSelection(editor, this.table, this.tableSelection);
      } else {
        this.$clearHighlight();
      }
    }
    /**
     * @internal
     * Firefox has a strange behavior where pressing the down arrow key from
     * above the table will move the caret after the table and then lexical
     * will select the last cell instead of the first.
     * We do still want to let the browser handle caret movement but we will
     * use this property to "tag" the update so that we can recheck the
     * selection after the event is processed.
     */
    setShouldCheckSelection() {
      this.shouldCheckSelection = true;
    }
    /**
     * @internal
     */
    getAndClearShouldCheckSelection() {
      if (this.shouldCheckSelection) {
        this.shouldCheckSelection = false;
        return true;
      }
      return false;
    }
    /**
     * @internal
     * When handling mousemove events we track what the focus cell should be, but
     * the DOM selection may end up somewhere else entirely. We don't have an elegant
     * way to handle this after the DOM selection has been resolved in a
     * SELECTION_CHANGE_COMMAND callback.
     */
    setNextFocus(nextFocus) {
      this.nextFocus = nextFocus;
    }
    /** @internal */
    getAndClearNextFocus() {
      const {
        nextFocus
      } = this;
      if (nextFocus !== null) {
        this.nextFocus = null;
      }
      return nextFocus;
    }
    /** @internal */
    updateDOMSelection() {
      if (this.anchorCell !== null && this.focusCell !== null) {
        const domSelection = getDOMSelection2(this.editor._window);
        if (domSelection && domSelection.rangeCount > 0) {
          domSelection.removeAllRanges();
        }
      }
    }
    $setFocusCellForSelection(cell, ignoreStart = false) {
      const editor = this.editor;
      const {
        tableNode
      } = this.$lookup();
      const cellX = cell.x;
      const cellY = cell.y;
      this.focusCell = cell;
      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {
        this.isHighlightingCells = true;
        this.$disableHighlightStyle();
      } else if (cellX === this.focusX && cellY === this.focusY) {
        return false;
      }
      this.focusX = cellX;
      this.focusY = cellY;
      if (this.isHighlightingCells) {
        const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);
        if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {
          this.focusCellNodeKey = focusTableCellNode.getKey();
          this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);
          $setSelection2(this.tableSelection);
          editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
          $updateDOMForSelection(editor, this.table, this.tableSelection);
          return true;
        }
      }
      return false;
    }
    $getAnchorTableCell() {
      return this.anchorCellNodeKey ? $getNodeByKey2(this.anchorCellNodeKey) : null;
    }
    $getAnchorTableCellOrThrow() {
      const anchorTableCell = this.$getAnchorTableCell();
      if (!(anchorTableCell !== null)) {
        formatDevErrorMessage9(`TableObserver anchorTableCell is null`);
      }
      return anchorTableCell;
    }
    $getFocusTableCell() {
      return this.focusCellNodeKey ? $getNodeByKey2(this.focusCellNodeKey) : null;
    }
    $getFocusTableCellOrThrow() {
      const focusTableCell = this.$getFocusTableCell();
      if (!(focusTableCell !== null)) {
        formatDevErrorMessage9(`TableObserver focusTableCell is null`);
      }
      return focusTableCell;
    }
    $setAnchorCellForSelection(cell) {
      this.isHighlightingCells = false;
      this.anchorCell = cell;
      this.anchorX = cell.x;
      this.anchorY = cell.y;
      const {
        tableNode
      } = this.$lookup();
      const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);
      if (anchorTableCellNode !== null) {
        const anchorNodeKey = anchorTableCellNode.getKey();
        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();
        this.anchorCellNodeKey = anchorNodeKey;
      }
    }
    $formatCells(type) {
      const selection = $getSelection2();
      if (!$isTableSelection(selection)) {
        formatDevErrorMessage9(`Expected Table selection`);
      }
      const formatSelection = $createRangeSelection2();
      const anchor = formatSelection.anchor;
      const focus = formatSelection.focus;
      const cellNodes = selection.getNodes().filter($isTableCellNode);
      if (!(cellNodes.length > 0)) {
        formatDevErrorMessage9(`No table cells present`);
      }
      const paragraph = cellNodes[0].getFirstChild();
      const alignFormatWith = $isParagraphNode2(paragraph) ? paragraph.getFormatFlags(type, null) : null;
      cellNodes.forEach((cellNode) => {
        anchor.set(cellNode.getKey(), 0, "element");
        focus.set(cellNode.getKey(), cellNode.getChildrenSize(), "element");
        formatSelection.formatText(type, alignFormatWith);
      });
      $setSelection2(selection);
      this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
    }
    $clearText() {
      const {
        editor
      } = this;
      const tableNode = $getNodeByKey2(this.tableNodeKey);
      if (!$isTableNode(tableNode)) {
        throw new Error("Expected TableNode.");
      }
      const selection = $getSelection2();
      if (!$isTableSelection(selection)) {
        formatDevErrorMessage9(`Expected TableSelection`);
      }
      const selectedNodes = selection.getNodes().filter($isTableCellNode);
      const firstRow = tableNode.getFirstChild();
      const lastRow = tableNode.getLastChild();
      const isEntireTableSelected = selectedNodes.length > 0 && firstRow !== null && lastRow !== null && $isTableRowNode(firstRow) && $isTableRowNode(lastRow) && selectedNodes[0] === firstRow.getFirstChild() && selectedNodes[selectedNodes.length - 1] === lastRow.getLastChild();
      if (isEntireTableSelected) {
        tableNode.selectPrevious();
        const parent = tableNode.getParent();
        tableNode.remove();
        if ($isRootNode2(parent) && parent.isEmpty()) {
          editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND2, void 0);
        }
        return;
      }
      selectedNodes.forEach((cellNode) => {
        if ($isElementNode2(cellNode)) {
          const paragraphNode = $createParagraphNode2();
          const textNode = $createTextNode2();
          paragraphNode.append(textNode);
          cellNode.append(paragraphNode);
          cellNode.getChildren().forEach((child) => {
            if (child !== paragraphNode) {
              child.remove();
            }
          });
        }
      });
      $updateDOMForSelection(editor, this.table, null);
      $setSelection2(null);
      editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
    }
  };
  var LEXICAL_ELEMENT_KEY = "__lexicalTableSelection";
  var isPointerDownOnEvent = (event) => {
    return (event.buttons & 1) === 1;
  };
  function isHTMLTableElement(el) {
    return isHTMLElement2(el) && el.nodeName === "TABLE";
  }
  function getTableElement(tableNode, dom) {
    if (!dom) {
      return dom;
    }
    const element = isHTMLTableElement(dom) ? dom : tableNode.getDOMSlot(dom).element;
    if (!(element.nodeName === "TABLE")) {
      formatDevErrorMessage9(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);
    }
    return element;
  }
  function getEditorWindow(editor) {
    return editor._window;
  }
  function $findParentTableCellNodeInTable(tableNode, node) {
    for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {
      if (tableNode.is(currentNode)) {
        return lastTableCellNode;
      } else if ($isTableCellNode(currentNode)) {
        lastTableCellNode = currentNode;
      }
    }
    return null;
  }
  var ARROW_KEY_COMMANDS_WITH_DIRECTION = [[KEY_ARROW_DOWN_COMMAND2, "down"], [KEY_ARROW_UP_COMMAND2, "up"], [KEY_ARROW_LEFT_COMMAND2, "backward"], [KEY_ARROW_RIGHT_COMMAND2, "forward"]];
  var DELETE_TEXT_COMMANDS = [DELETE_WORD_COMMAND2, DELETE_LINE_COMMAND2, DELETE_CHARACTER_COMMAND2];
  var DELETE_KEY_COMMANDS = [KEY_BACKSPACE_COMMAND2, KEY_DELETE_COMMAND2];
  function applyTableHandlers(tableNode, element, editor, hasTabHandler) {
    const rootElement = editor.getRootElement();
    const editorWindow = getEditorWindow(editor);
    if (!(rootElement !== null && editorWindow !== null)) {
      formatDevErrorMessage9(`applyTableHandlers: editor has no root element set`);
    }
    const tableObserver = new TableObserver(editor, tableNode.getKey());
    const tableElement = getTableElement(tableNode, element);
    attachTableObserverToTableElement(tableElement, tableObserver);
    tableObserver.listenersToRemove.add(() => detachTableObserverFromTableElement(tableElement, tableObserver));
    const createPointerHandlers = () => {
      if (tableObserver.isSelecting) {
        return;
      }
      const onPointerUp = () => {
        tableObserver.isSelecting = false;
        editorWindow.removeEventListener("pointerup", onPointerUp);
        editorWindow.removeEventListener("pointermove", onPointerMove);
      };
      const onPointerMove = (moveEvent) => {
        if (!isPointerDownOnEvent(moveEvent) && tableObserver.isSelecting) {
          tableObserver.isSelecting = false;
          editorWindow.removeEventListener("pointerup", onPointerUp);
          editorWindow.removeEventListener("pointermove", onPointerMove);
          return;
        }
        if (!isDOMNode2(moveEvent.target)) {
          return;
        }
        let focusCell = null;
        const override = !(IS_FIREFOX4 || tableElement.contains(moveEvent.target));
        if (override) {
          focusCell = getDOMCellInTableFromTarget(tableElement, moveEvent.target);
        } else {
          for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {
            focusCell = getDOMCellInTableFromTarget(tableElement, el);
            if (focusCell) {
              break;
            }
          }
        }
        if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {
          tableObserver.setNextFocus({
            focusCell,
            override
          });
          editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
        }
      };
      tableObserver.isSelecting = true;
      editorWindow.addEventListener("pointerup", onPointerUp, tableObserver.listenerOptions);
      editorWindow.addEventListener("pointermove", onPointerMove, tableObserver.listenerOptions);
    };
    const onPointerDown2 = (event) => {
      tableObserver.pointerType = event.pointerType;
      if (event.button !== 0 || !isDOMNode2(event.target) || !editorWindow) {
        return;
      }
      const targetCell = getDOMCellFromTarget(event.target);
      if (targetCell !== null) {
        editor.update(() => {
          const prevSelection = $getPreviousSelection2();
          if (IS_FIREFOX4 && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ($isRangeSelection2(prevSelection) || $isTableSelection(prevSelection))) {
            const prevAnchorNode = prevSelection.anchor.getNode();
            const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());
            if (prevAnchorCell) {
              tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));
              tableObserver.$setFocusCellForSelection(targetCell);
              stopEvent(event);
            } else {
              const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();
              newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);
            }
          } else {
            if (event.pointerType !== "touch") {
              tableObserver.$setAnchorCellForSelection(targetCell);
            }
          }
        });
      }
      createPointerHandlers();
    };
    tableElement.addEventListener("pointerdown", onPointerDown2, tableObserver.listenerOptions);
    tableObserver.listenersToRemove.add(() => {
      tableElement.removeEventListener("pointerdown", onPointerDown2);
    });
    const onTripleClick = (event) => {
      if (event.detail >= 3 && isDOMNode2(event.target)) {
        const targetCell = getDOMCellFromTarget(event.target);
        if (targetCell !== null) {
          event.preventDefault();
        }
      }
    };
    tableElement.addEventListener("mousedown", onTripleClick, tableObserver.listenerOptions);
    tableObserver.listenersToRemove.add(() => {
      tableElement.removeEventListener("mousedown", onTripleClick);
    });
    const pointerDownCallback = (event) => {
      const target = event.target;
      if (event.button !== 0 || !isDOMNode2(target)) {
        return;
      }
      editor.update(() => {
        const selection = $getSelection2();
        if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {
          tableObserver.$clearHighlight();
        }
      });
    };
    editorWindow.addEventListener("pointerdown", pointerDownCallback, tableObserver.listenerOptions);
    tableObserver.listenersToRemove.add(() => {
      editorWindow.removeEventListener("pointerdown", pointerDownCallback);
    });
    for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {
      tableObserver.listenersToRemove.add(editor.registerCommand(command, (event) => $handleArrowKey(editor, event, direction, tableNode, tableObserver), COMMAND_PRIORITY_HIGH2));
    }
    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND2, (event) => {
      const selection = $getSelection2();
      if ($isTableSelection(selection)) {
        const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());
        if (focusCellNode !== null) {
          stopEvent(event);
          focusCellNode.selectEnd();
          return true;
        }
      }
      return false;
    }, COMMAND_PRIORITY_HIGH2));
    const deleteTextHandler = (command) => () => {
      const selection = $getSelection2();
      if (!$isSelectionInTable(selection, tableNode)) {
        return false;
      }
      if ($isTableSelection(selection)) {
        tableObserver.$clearText();
        return true;
      } else if ($isRangeSelection2(selection)) {
        const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());
        if (!$isTableCellNode(tableCellNode)) {
          return false;
        }
        const anchorNode = selection.anchor.getNode();
        const focusNode = selection.focus.getNode();
        const isAnchorInside = tableNode.isParentOf(anchorNode);
        const isFocusInside = tableNode.isParentOf(focusNode);
        const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;
        if (selectionContainsPartialTable) {
          tableObserver.$clearText();
          return true;
        }
        const nearestElementNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isElementNode2(n2));
        const topLevelCellElementNode = nearestElementNode && $findMatchingParent3(nearestElementNode, (n2) => $isElementNode2(n2) && $isTableCellNode(n2.getParent()));
        if (!$isElementNode2(topLevelCellElementNode) || !$isElementNode2(nearestElementNode)) {
          return false;
        }
        if (command === DELETE_LINE_COMMAND2 && topLevelCellElementNode.getPreviousSibling() === null) {
          return true;
        }
      }
      return false;
    };
    for (const command of DELETE_TEXT_COMMANDS) {
      tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_HIGH2));
    }
    const $deleteCellHandler = (event) => {
      const selection = $getSelection2();
      if (!($isTableSelection(selection) || $isRangeSelection2(selection))) {
        return false;
      }
      const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());
      const isFocusInside = tableNode.isParentOf(selection.focus.getNode());
      if (isAnchorInside !== isFocusInside) {
        const tablePoint = isAnchorInside ? "anchor" : "focus";
        const outerPoint = isAnchorInside ? "focus" : "anchor";
        const {
          key,
          offset,
          type
        } = selection[outerPoint];
        const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? "selectPrevious" : "selectNext"]();
        newSelection[outerPoint].set(key, offset, type);
        return false;
      }
      if (!$isSelectionInTable(selection, tableNode)) {
        return false;
      }
      if ($isTableSelection(selection)) {
        if (event) {
          event.preventDefault();
          event.stopPropagation();
        }
        tableObserver.$clearText();
        return true;
      }
      return false;
    };
    for (const command of DELETE_KEY_COMMANDS) {
      tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, COMMAND_PRIORITY_HIGH2));
    }
    tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (selection) {
        if (!($isTableSelection(selection) || $isRangeSelection2(selection))) {
          return false;
        }
        void copyToClipboard2(editor, objectKlassEquals2(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection2(selection));
        const intercepted = $deleteCellHandler(event);
        if ($isRangeSelection2(selection)) {
          selection.removeText();
          return true;
        }
        return intercepted;
      }
      return false;
    }, COMMAND_PRIORITY_HIGH2));
    tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND2, (payload) => {
      const selection = $getSelection2();
      if (!$isSelectionInTable(selection, tableNode)) {
        return false;
      }
      if ($isTableSelection(selection)) {
        tableObserver.$formatCells(payload);
        return true;
      } else if ($isRangeSelection2(selection)) {
        const tableCellNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2));
        if (!$isTableCellNode(tableCellNode)) {
          return false;
        }
      }
      return false;
    }, COMMAND_PRIORITY_HIGH2));
    tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND2, (formatType) => {
      const selection = $getSelection2();
      if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {
        return false;
      }
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {
        return false;
      }
      if ($isFullTableSelection(selection, tableNode)) {
        tableNode.setFormat(formatType);
        return true;
      }
      const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);
      const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);
      const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);
      const minRow = Math.min(anchorCell.startRow, focusCell.startRow);
      const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);
      const visited = /* @__PURE__ */ new Set();
      for (let i2 = minRow; i2 <= maxRow; i2++) {
        for (let j2 = minColumn; j2 <= maxColumn; j2++) {
          const cell = tableMap[i2][j2].cell;
          if (visited.has(cell)) {
            continue;
          }
          visited.add(cell);
          cell.setFormat(formatType);
          const cellChildren = cell.getChildren();
          for (let k2 = 0; k2 < cellChildren.length; k2++) {
            const child = cellChildren[k2];
            if ($isElementNode2(child) && !child.isInline()) {
              child.setFormat(formatType);
            }
          }
        }
      }
      return true;
    }, COMMAND_PRIORITY_HIGH2));
    tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (payload) => {
      const selection = $getSelection2();
      if (!$isSelectionInTable(selection, tableNode)) {
        return false;
      }
      if ($isTableSelection(selection)) {
        tableObserver.$clearHighlight();
        return false;
      } else if ($isRangeSelection2(selection)) {
        const tableCellNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2));
        if (!$isTableCellNode(tableCellNode)) {
          return false;
        }
        if (typeof payload === "string") {
          const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);
          if (edgePosition) {
            $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode2(payload)]);
            return true;
          }
        }
      }
      return false;
    }, COMMAND_PRIORITY_HIGH2));
    if (hasTabHandler) {
      tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND2, (event) => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {
          return false;
        }
        const tableCellNode = $findCellNode(selection.anchor.getNode());
        if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {
          return false;
        }
        stopEvent(event);
        $selectAdjacentCell(tableCellNode, event.shiftKey ? "previous" : "next");
        return true;
      }, COMMAND_PRIORITY_HIGH2));
    }
    tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND2, (payload) => {
      return tableNode.isSelected();
    }, COMMAND_PRIORITY_HIGH2));
    tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, (selectionPayload, dispatchEditor) => {
      if (editor !== dispatchEditor) {
        return false;
      }
      const {
        nodes,
        selection
      } = selectionPayload;
      const anchorAndFocus = selection.getStartEndPoints();
      const isTableSelection = $isTableSelection(selection);
      const isRangeSelection = $isRangeSelection2(selection);
      const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2)) !== null && $findMatchingParent3(selection.focus.getNode(), (n2) => $isTableCellNode(n2)) !== null || isTableSelection;
      if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {
        return false;
      }
      const [anchor, focus] = anchorAndFocus;
      const [anchorCellNode, anchorRowNode, gridNode] = $getNodeTriplet(anchor);
      const focusCellNode = $findMatchingParent3(focus.getNode(), (n2) => $isTableCellNode(n2));
      if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableRowNode(anchorRowNode) || !$isTableNode(gridNode)) {
        return false;
      }
      const templateGrid = nodes[0];
      const [initialGridMap, anchorCellMap, focusCellMap] = $computeTableMap(gridNode, anchorCellNode, focusCellNode);
      const [templateGridMap] = $computeTableMapSkipCellCheck(templateGrid, null, null);
      const initialRowCount = initialGridMap.length;
      const initialColCount = initialRowCount > 0 ? initialGridMap[0].length : 0;
      let startRow = anchorCellMap.startRow;
      let startCol = anchorCellMap.startColumn;
      let affectedRowCount = templateGridMap.length;
      let affectedColCount = affectedRowCount > 0 ? templateGridMap[0].length : 0;
      if (isTableSelection) {
        const selectionBoundary = $computeTableCellRectBoundary(initialGridMap, anchorCellMap, focusCellMap);
        const selectionRowCount = selectionBoundary.maxRow - selectionBoundary.minRow + 1;
        const selectionColCount = selectionBoundary.maxColumn - selectionBoundary.minColumn + 1;
        startRow = selectionBoundary.minRow;
        startCol = selectionBoundary.minColumn;
        affectedRowCount = Math.min(affectedRowCount, selectionRowCount);
        affectedColCount = Math.min(affectedColCount, selectionColCount);
      }
      let didPerformMergeOperations = false;
      const lastRowForUnmerge = Math.min(initialRowCount, startRow + affectedRowCount) - 1;
      const lastColForUnmerge = Math.min(initialColCount, startCol + affectedColCount) - 1;
      const unmergedKeys = /* @__PURE__ */ new Set();
      for (let row = startRow; row <= lastRowForUnmerge; row++) {
        for (let col = startCol; col <= lastColForUnmerge; col++) {
          const cellMap = initialGridMap[row][col];
          if (unmergedKeys.has(cellMap.cell.getKey())) {
            continue;
          }
          if (cellMap.cell.__rowSpan === 1 && cellMap.cell.__colSpan === 1) {
            continue;
          }
          $unmergeCellNode(cellMap.cell);
          unmergedKeys.add(cellMap.cell.getKey());
          didPerformMergeOperations = true;
        }
      }
      let [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);
      const rowsToInsert = affectedRowCount - initialRowCount + startRow;
      for (let i2 = 0; i2 < rowsToInsert; i2++) {
        const cellMap = interimGridMap[initialRowCount - 1][0];
        $insertTableRowAtNode(cellMap.cell);
      }
      const colsToInsert = affectedColCount - initialColCount + startCol;
      for (let i2 = 0; i2 < colsToInsert; i2++) {
        const cellMap = interimGridMap[0][initialColCount - 1];
        $insertTableColumnAtNode(cellMap.cell, true, false);
      }
      [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);
      for (let row = startRow; row < startRow + affectedRowCount; row++) {
        for (let col = startCol; col < startCol + affectedColCount; col++) {
          const templateRow = row - startRow;
          const templateCol = col - startCol;
          const templateCellMap = templateGridMap[templateRow][templateCol];
          if (templateCellMap.startRow !== templateRow || templateCellMap.startColumn !== templateCol) {
            continue;
          }
          const templateCell = templateCellMap.cell;
          if (templateCell.__rowSpan !== 1 || templateCell.__colSpan !== 1) {
            const cellsToMerge = [];
            const lastRowForMerge = Math.min(row + templateCell.__rowSpan, startRow + affectedRowCount) - 1;
            const lastColForMerge = Math.min(col + templateCell.__colSpan, startCol + affectedColCount) - 1;
            for (let r2 = row; r2 <= lastRowForMerge; r2++) {
              for (let c2 = col; c2 <= lastColForMerge; c2++) {
                const cellMap = interimGridMap[r2][c2];
                cellsToMerge.push(cellMap.cell);
              }
            }
            $mergeCells(cellsToMerge);
            didPerformMergeOperations = true;
          }
          const {
            cell
          } = interimGridMap[row][col];
          const originalChildren = cell.getChildren();
          templateCell.getChildren().forEach((child) => {
            if ($isTextNode2(child)) {
              const paragraphNode = $createParagraphNode2();
              paragraphNode.append(child);
              cell.append(child);
            } else {
              cell.append(child);
            }
          });
          originalChildren.forEach((n2) => n2.remove());
        }
      }
      if (isTableSelection && didPerformMergeOperations) {
        const [finalGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);
        const newAnchorCellMap = finalGridMap[anchorCellMap.startRow][anchorCellMap.startColumn];
        newAnchorCellMap.cell.selectEnd();
      }
      return true;
    }, COMMAND_PRIORITY_HIGH2));
    tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND2, () => {
      const selection = $getSelection2();
      const prevSelection = $getPreviousSelection2();
      const nextFocus = tableObserver.getAndClearNextFocus();
      if (nextFocus !== null) {
        const {
          focusCell
        } = nextFocus;
        if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {
          if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {
            return false;
          } else {
            tableObserver.$setFocusCellForSelection(focusCell);
            return true;
          }
        } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {
          tableObserver.$setFocusCellForSelection(focusCell);
          return true;
        }
      }
      const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();
      if (shouldCheckSelection && $isRangeSelection2(prevSelection) && $isRangeSelection2(selection) && selection.isCollapsed()) {
        const anchor = selection.anchor.getNode();
        const firstRow = tableNode.getFirstChild();
        const anchorCell = $findCellNode(anchor);
        if (anchorCell !== null && $isTableRowNode(firstRow)) {
          const firstCell = firstRow.getFirstChild();
          if ($isTableCellNode(firstCell) && tableNode.is($findMatchingParent3(anchorCell, (node) => node.is(tableNode) || node.is(firstCell)))) {
            firstCell.selectStart();
            return true;
          }
        }
      }
      if ($isRangeSelection2(selection)) {
        const {
          anchor,
          focus
        } = selection;
        const anchorNode = anchor.getNode();
        const focusNode = focus.getNode();
        const anchorCellNode = $findCellNode(anchorNode);
        const focusCellNode = $findCellNode(focusNode);
        const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));
        const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));
        const isPartiallyWithinTable = isAnchorInside !== isFocusInside;
        const isWithinTable = isAnchorInside && isFocusInside;
        const isBackward = selection.isBackward();
        if (isPartiallyWithinTable) {
          const newSelection = selection.clone();
          if (isFocusInside) {
            const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);
            const firstCell = tableMap[0][0].cell;
            const lastCell = tableMap[tableMap.length - 1].at(-1).cell;
            newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), "element");
          } else if (isAnchorInside) {
            const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);
            const firstCell = tableMap[0][0].cell;
            const lastCell = tableMap[tableMap.length - 1].at(-1).cell;
            newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, "element");
          }
          $setSelection2(newSelection);
          $addHighlightStyleToTable(editor, tableObserver);
        } else if (isWithinTable) {
          if (!anchorCellNode.is(focusCellNode)) {
            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));
            tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);
          }
          if (tableObserver.pointerType === "touch" && tableObserver.isSelecting && selection.isCollapsed() && $isRangeSelection2(prevSelection) && prevSelection.isCollapsed()) {
            const prevAnchorCellNode = $findCellNode(prevSelection.anchor.getNode());
            if (prevAnchorCellNode && !prevAnchorCellNode.is(focusCellNode)) {
              tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCellNode));
              tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);
              tableObserver.pointerType = null;
            }
          }
        }
      } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {
        const domSelection = getDOMSelection2(editorWindow);
        if (domSelection && domSelection.anchorNode && domSelection.focusNode) {
          const focusNode = $getNearestNodeFromDOMNode2(domSelection.focusNode);
          const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);
          const anchorNode = $getNearestNodeFromDOMNode2(domSelection.anchorNode);
          const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);
          if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {
            const newSelection = $createRangeSelectionFromDom2(domSelection, editor);
            if (newSelection) {
              newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, "element");
              domSelection.removeAllRanges();
              $setSelection2(newSelection);
            }
          }
        }
      }
      if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {
        if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {
          tableObserver.$updateTableTableSelection(selection);
        } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {
          tableObserver.$updateTableTableSelection(null);
        }
        return false;
      }
      if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {
        $removeHighlightStyleToTable(editor, tableObserver);
      } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {
        $addHighlightStyleToTable(editor, tableObserver);
      }
      return false;
    }, COMMAND_PRIORITY_HIGH2));
    tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {
        return false;
      }
      const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);
      if (edgePosition) {
        $insertParagraphAtTableEdge(edgePosition, tableNode);
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_HIGH2));
    return tableObserver;
  }
  function detachTableObserverFromTableElement(tableElement, tableObserver) {
    if (getTableObserverFromTableElement(tableElement) === tableObserver) {
      delete tableElement[LEXICAL_ELEMENT_KEY];
    }
  }
  function attachTableObserverToTableElement(tableElement, tableObserver) {
    if (!(getTableObserverFromTableElement(tableElement) === null)) {
      formatDevErrorMessage9(`tableElement already has an attached TableObserver`);
    }
    tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;
  }
  function getTableObserverFromTableElement(tableElement) {
    return tableElement[LEXICAL_ELEMENT_KEY] || null;
  }
  function getDOMCellFromTarget(node) {
    let currentNode = node;
    while (currentNode != null) {
      const nodeName = currentNode.nodeName;
      if (nodeName === "TD" || nodeName === "TH") {
        const cell = currentNode._cell;
        if (cell === void 0) {
          return null;
        }
        return cell;
      }
      currentNode = currentNode.parentNode;
    }
    return null;
  }
  function getDOMCellInTableFromTarget(table, node) {
    if (!table.contains(node)) {
      return null;
    }
    let cell = null;
    for (let currentNode = node; currentNode != null; currentNode = currentNode.parentNode) {
      if (currentNode === table) {
        return cell;
      }
      const nodeName = currentNode.nodeName;
      if (nodeName === "TD" || nodeName === "TH") {
        cell = currentNode._cell || null;
      }
    }
    return null;
  }
  function getTable(tableNode, dom) {
    const tableElement = getTableElement(tableNode, dom);
    const domRows = [];
    const grid = {
      columns: 0,
      domRows,
      rows: 0
    };
    let currentNode = tableElement.querySelector("tr");
    let x2 = 0;
    let y3 = 0;
    domRows.length = 0;
    while (currentNode != null) {
      const nodeMame = currentNode.nodeName;
      if (nodeMame === "TD" || nodeMame === "TH") {
        const elem = currentNode;
        const cell = {
          elem,
          hasBackgroundColor: elem.style.backgroundColor !== "",
          highlighted: false,
          x: x2,
          y: y3
        };
        currentNode._cell = cell;
        let row = domRows[y3];
        if (row === void 0) {
          row = domRows[y3] = [];
        }
        row[x2] = cell;
      } else {
        const child = currentNode.firstChild;
        if (child != null) {
          currentNode = child;
          continue;
        }
      }
      const sibling = currentNode.nextSibling;
      if (sibling != null) {
        x2++;
        currentNode = sibling;
        continue;
      }
      const parent = currentNode.parentNode;
      if (parent != null) {
        const parentSibling = parent.nextSibling;
        if (parentSibling == null) {
          break;
        }
        y3++;
        x2 = 0;
        currentNode = parentSibling;
      }
    }
    grid.columns = x2 + 1;
    grid.rows = y3 + 1;
    return grid;
  }
  function $updateDOMForSelection(editor, table, selection) {
    const selectedCellNodes = new Set(selection ? selection.getNodes() : []);
    $forEachTableCell(table, (cell, lexicalNode) => {
      const elem = cell.elem;
      if (selectedCellNodes.has(lexicalNode)) {
        cell.highlighted = true;
        $addHighlightToDOM(editor, cell);
      } else {
        cell.highlighted = false;
        $removeHighlightFromDOM(editor, cell);
        if (!elem.getAttribute("style")) {
          elem.removeAttribute("style");
        }
      }
    });
  }
  function $forEachTableCell(grid, cb) {
    const {
      domRows
    } = grid;
    for (let y3 = 0; y3 < domRows.length; y3++) {
      const row = domRows[y3];
      if (!row) {
        continue;
      }
      for (let x2 = 0; x2 < row.length; x2++) {
        const cell = row[x2];
        if (!cell) {
          continue;
        }
        const lexicalNode = $getNearestNodeFromDOMNode2(cell.elem);
        if (lexicalNode !== null) {
          cb(cell, lexicalNode, {
            x: x2,
            y: y3
          });
        }
      }
    }
  }
  function $addHighlightStyleToTable(editor, tableSelection) {
    tableSelection.$disableHighlightStyle();
    $forEachTableCell(tableSelection.table, (cell) => {
      cell.highlighted = true;
      $addHighlightToDOM(editor, cell);
    });
  }
  function $removeHighlightStyleToTable(editor, tableObserver) {
    tableObserver.$enableHighlightStyle();
    $forEachTableCell(tableObserver.table, (cell) => {
      const elem = cell.elem;
      cell.highlighted = false;
      $removeHighlightFromDOM(editor, cell);
      if (!elem.getAttribute("style")) {
        elem.removeAttribute("style");
      }
    });
  }
  function $selectAdjacentCell(tableCellNode, direction) {
    const siblingMethod = direction === "next" ? "getNextSibling" : "getPreviousSibling";
    const childMethod = direction === "next" ? "getFirstChild" : "getLastChild";
    const sibling = tableCellNode[siblingMethod]();
    if ($isElementNode2(sibling)) {
      return sibling.selectEnd();
    }
    const parentRow = $findMatchingParent3(tableCellNode, $isTableRowNode);
    if (!(parentRow !== null)) {
      formatDevErrorMessage9(`selectAdjacentCell: Cell not in table row`);
    }
    for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {
      const child = nextRow[childMethod]();
      if ($isElementNode2(child)) {
        return child.selectEnd();
      }
    }
    const parentTable = $findMatchingParent3(parentRow, $isTableNode);
    if (!(parentTable !== null)) {
      formatDevErrorMessage9(`selectAdjacentCell: Row not in table`);
    }
    return direction === "next" ? parentTable.selectNext() : parentTable.selectPrevious();
  }
  var selectTableNodeInDirection = (tableObserver, tableNode, x2, y3, direction) => {
    const isForward = direction === "forward";
    switch (direction) {
      case "backward":
      case "forward":
        if (x2 !== (isForward ? tableObserver.table.columns - 1 : 0)) {
          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x2 + (isForward ? 1 : -1), y3, tableObserver.table), isForward);
        } else {
          if (y3 !== (isForward ? tableObserver.table.rows - 1 : 0)) {
            selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y3 + (isForward ? 1 : -1), tableObserver.table), isForward);
          } else if (!isForward) {
            tableNode.selectPrevious();
          } else {
            tableNode.selectNext();
          }
        }
        return true;
      case "up":
        if (y3 !== 0) {
          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x2, y3 - 1, tableObserver.table), false);
        } else {
          tableNode.selectPrevious();
        }
        return true;
      case "down":
        if (y3 !== tableObserver.table.rows - 1) {
          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x2, y3 + 1, tableObserver.table), true);
        } else {
          tableNode.selectNext();
        }
        return true;
      default:
        return false;
    }
  };
  function getCorner(rect, cellValue) {
    let colName;
    let rowName;
    if (cellValue.startColumn === rect.minColumn) {
      colName = "minColumn";
    } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {
      colName = "maxColumn";
    } else {
      return null;
    }
    if (cellValue.startRow === rect.minRow) {
      rowName = "minRow";
    } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {
      rowName = "maxRow";
    } else {
      return null;
    }
    return [colName, rowName];
  }
  function getCornerOrThrow(rect, cellValue) {
    const corner = getCorner(rect, cellValue);
    if (!(corner !== null)) {
      formatDevErrorMessage9(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);
    }
    return corner;
  }
  function oppositeCorner([colName, rowName]) {
    return [colName === "minColumn" ? "maxColumn" : "minColumn", rowName === "minRow" ? "maxRow" : "minRow"];
  }
  function cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {
    const rowNum = rect[rowName];
    const rowMap = tableMap[rowNum];
    if (!(rowMap !== void 0)) {
      formatDevErrorMessage9(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);
    }
    const colNum = rect[colName];
    const cell = rowMap[colNum];
    if (!(cell !== void 0)) {
      formatDevErrorMessage9(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);
    }
    return cell;
  }
  function $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {
    const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);
    const anchorCorner = getCorner(rect, anchorCellValue);
    if (anchorCorner) {
      return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];
    }
    const newFocusCorner = getCorner(rect, newFocusCellValue);
    if (newFocusCorner) {
      return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];
    }
    const newAnchorCorner = ["minColumn", "minRow"];
    return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];
  }
  function $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {
    const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);
    const spans = $computeTableCellRectSpans(tableMap, rect);
    const {
      topSpan,
      leftSpan,
      bottomSpan,
      rightSpan
    } = spans;
    const anchorCorner = getCornerOrThrow(rect, anchorCellValue);
    const [focusColumn, focusRow] = oppositeCorner(anchorCorner);
    let fCol = rect[focusColumn];
    let fRow = rect[focusRow];
    if (direction === "forward") {
      fCol += focusColumn === "maxColumn" ? 1 : leftSpan;
    } else if (direction === "backward") {
      fCol -= focusColumn === "minColumn" ? 1 : rightSpan;
    } else if (direction === "down") {
      fRow += focusRow === "maxRow" ? 1 : topSpan;
    } else if (direction === "up") {
      fRow -= focusRow === "minRow" ? 1 : bottomSpan;
    }
    const targetRowMap = tableMap[fRow];
    if (targetRowMap === void 0) {
      return false;
    }
    const newFocusCellValue = targetRowMap[fCol];
    if (newFocusCellValue === void 0) {
      return false;
    }
    const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);
    const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);
    const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);
    tableObserver.$setAnchorCellForSelection(anchorDOM);
    tableObserver.$setFocusCellForSelection(focusDOM, true);
    return true;
  }
  function $isSelectionInTable(selection, tableNode) {
    if ($isRangeSelection2(selection) || $isTableSelection(selection)) {
      const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());
      const isFocusInside = tableNode.isParentOf(selection.focus.getNode());
      return isAnchorInside && isFocusInside;
    }
    return false;
  }
  function $isFullTableSelection(selection, tableNode) {
    if ($isTableSelection(selection)) {
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      if (tableNode && anchorNode && focusNode) {
        const [map3] = $computeTableMap(tableNode, anchorNode, focusNode);
        return anchorNode.getKey() === map3[0][0].cell.getKey() && focusNode.getKey() === map3[map3.length - 1].at(-1).cell.getKey();
      }
    }
    return false;
  }
  function selectTableCellNode(tableCell, fromStart) {
    if (fromStart) {
      tableCell.selectStart();
    } else {
      tableCell.selectEnd();
    }
  }
  function $addHighlightToDOM(editor, cell) {
    const element = cell.elem;
    const editorThemeClasses = editor._config.theme;
    const node = $getNearestNodeFromDOMNode2(element);
    if (!$isTableCellNode(node)) {
      formatDevErrorMessage9(`Expected to find LexicalNode from Table Cell DOMNode`);
    }
    addClassNamesToElement2(element, editorThemeClasses.tableCellSelected);
  }
  function $removeHighlightFromDOM(editor, cell) {
    const element = cell.elem;
    const node = $getNearestNodeFromDOMNode2(element);
    if (!$isTableCellNode(node)) {
      formatDevErrorMessage9(`Expected to find LexicalNode from Table Cell DOMNode`);
    }
    const editorThemeClasses = editor._config.theme;
    removeClassNamesFromElement2(element, editorThemeClasses.tableCellSelected);
  }
  function $findCellNode(node) {
    const cellNode = $findMatchingParent3(node, $isTableCellNode);
    return $isTableCellNode(cellNode) ? cellNode : null;
  }
  function $findTableNode(node) {
    const tableNode = $findMatchingParent3(node, $isTableNode);
    return $isTableNode(tableNode) ? tableNode : null;
  }
  function $getBlockParentIfFirstNode(node) {
    for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {
      if ($isElementNode2(currentNode)) {
        if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {
          return null;
        } else if (!currentNode.isInline()) {
          return currentNode;
        }
      }
    }
    return null;
  }
  function $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, isBackward, tableNode, tableObserver) {
    const initialFocus = $caretFromPoint2(selection.focus, isBackward ? "previous" : "next");
    if ($isExtendableTextPointCaret2(initialFocus)) {
      return false;
    }
    let lastCaret = initialFocus;
    for (const nextCaret of $extendCaretToRange2(initialFocus).iterNodeCarets("shadowRoot")) {
      if (!($isSiblingCaret2(nextCaret) && $isElementNode2(nextCaret.origin))) {
        return false;
      }
      lastCaret = nextCaret;
    }
    const lastCaretParent = lastCaret.getParentAtCaret();
    if (!$isTableCellNode(lastCaretParent)) {
      return false;
    }
    const anchorCell = lastCaretParent;
    const focusCaret = $findNextTableCell($getSiblingCaret2(anchorCell, lastCaret.direction));
    const anchorCellTable = $findMatchingParent3(anchorCell, $isTableNode);
    if (!(anchorCellTable && anchorCellTable.is(tableNode))) {
      return false;
    }
    const anchorCellDOM = editor.getElementByKey(anchorCell.getKey());
    const anchorDOMCell = getDOMCellFromTarget(anchorCellDOM);
    if (!anchorCellDOM || !anchorDOMCell) {
      return false;
    }
    const anchorCellTableElement = $getElementForTableNode(editor, anchorCellTable);
    tableObserver.table = anchorCellTableElement;
    if (!focusCaret) {
      if (alter === "extend") {
        tableObserver.$setAnchorCellForSelection(anchorDOMCell);
        tableObserver.$setFocusCellForSelection(anchorDOMCell, true);
      } else {
        const outerFocusCaret = $getTableExitCaret($getSiblingCaret2(anchorCellTable, initialFocus.direction));
        $setPointFromCaret2(selection.anchor, outerFocusCaret);
        $setPointFromCaret2(selection.focus, outerFocusCaret);
      }
    } else if (alter === "extend") {
      const focusDOMCell = getDOMCellFromTarget(editor.getElementByKey(focusCaret.origin.getKey()));
      if (!focusDOMCell) {
        return false;
      }
      tableObserver.$setAnchorCellForSelection(anchorDOMCell);
      tableObserver.$setFocusCellForSelection(focusDOMCell, true);
    } else {
      const innerFocusCaret = $normalizeCaret2(focusCaret);
      $setPointFromCaret2(selection.anchor, innerFocusCaret);
      $setPointFromCaret2(selection.focus, innerFocusCaret);
    }
    stopEvent(event);
    return true;
  }
  function $getTableExitCaret(initialCaret) {
    const adjacent = $getAdjacentChildCaret2(initialCaret);
    return $isChildCaret2(adjacent) ? $normalizeCaret2(adjacent) : initialCaret;
  }
  function $findNextTableCell(initialCaret) {
    for (const nextCaret of $extendCaretToRange2(initialCaret).iterNodeCarets("root")) {
      const {
        origin
      } = nextCaret;
      if ($isTableCellNode(origin)) {
        if ($isChildCaret2(nextCaret)) {
          return $getChildCaret2(origin, initialCaret.direction);
        }
      } else if (!$isTableRowNode(origin)) {
        break;
      }
    }
    return null;
  }
  function $handleArrowKey(editor, event, direction, tableNode, tableObserver) {
    if ((direction === "up" || direction === "down") && isTypeaheadMenuInView(editor)) {
      return false;
    }
    const selection = $getSelection2();
    if (!$isSelectionInTable(selection, tableNode)) {
      if ($isRangeSelection2(selection)) {
        if (direction === "backward") {
          if (selection.focus.offset > 0) {
            return false;
          }
          const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());
          if (!parentNode) {
            return false;
          }
          const siblingNode = parentNode.getPreviousSibling();
          if (!$isTableNode(siblingNode)) {
            return false;
          }
          stopEvent(event);
          if (event.shiftKey) {
            selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), "element");
          } else {
            siblingNode.selectEnd();
          }
          return true;
        } else if (event.shiftKey && (direction === "up" || direction === "down")) {
          const focusNode = selection.focus.getNode();
          const isTableUnselect = !selection.isCollapsed() && (direction === "up" && !selection.isBackward() || direction === "down" && selection.isBackward());
          if (isTableUnselect) {
            let focusParentNode = $findMatchingParent3(focusNode, (n2) => $isTableNode(n2));
            if ($isTableCellNode(focusParentNode)) {
              focusParentNode = $findMatchingParent3(focusParentNode, $isTableNode);
            }
            if (focusParentNode !== tableNode) {
              return false;
            }
            if (!focusParentNode) {
              return false;
            }
            const sibling = direction === "down" ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();
            if (!sibling) {
              return false;
            }
            let newOffset = 0;
            if (direction === "up") {
              if ($isElementNode2(sibling)) {
                newOffset = sibling.getChildrenSize();
              }
            }
            let newFocusNode = sibling;
            if (direction === "up") {
              if ($isElementNode2(sibling)) {
                const lastCell = sibling.getLastChild();
                newFocusNode = lastCell ? lastCell : sibling;
                newOffset = $isTextNode2(newFocusNode) ? newFocusNode.getTextContentSize() : 0;
              }
            }
            const newSelection = selection.clone();
            newSelection.focus.set(newFocusNode.getKey(), newOffset, $isTextNode2(newFocusNode) ? "text" : "element");
            $setSelection2(newSelection);
            stopEvent(event);
            return true;
          } else if ($isRootOrShadowRoot2(focusNode)) {
            const selectedNode = direction === "up" ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];
            if (selectedNode) {
              const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);
              if (tableCellNode !== null) {
                const firstDescendant = tableNode.getFirstDescendant();
                const lastDescendant = tableNode.getLastDescendant();
                if (!firstDescendant || !lastDescendant) {
                  return false;
                }
                const [firstCellNode] = $getNodeTriplet(firstDescendant);
                const [lastCellNode] = $getNodeTriplet(lastDescendant);
                const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);
                const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);
                const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);
                const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);
                tableObserver.$setAnchorCellForSelection(firstCellDOM);
                tableObserver.$setFocusCellForSelection(lastCellDOM, true);
                return true;
              }
            }
            return false;
          } else {
            let focusParentNode = $findMatchingParent3(focusNode, (n2) => $isElementNode2(n2) && !n2.isInline());
            if ($isTableCellNode(focusParentNode)) {
              focusParentNode = $findMatchingParent3(focusParentNode, $isTableNode);
            }
            if (!focusParentNode) {
              return false;
            }
            const sibling = direction === "down" ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();
            if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {
              const firstDescendant = sibling.getFirstDescendant();
              const lastDescendant = sibling.getLastDescendant();
              if (!firstDescendant || !lastDescendant) {
                return false;
              }
              const [firstCellNode] = $getNodeTriplet(firstDescendant);
              const [lastCellNode] = $getNodeTriplet(lastDescendant);
              const newSelection = selection.clone();
              newSelection.focus.set((direction === "up" ? firstCellNode : lastCellNode).getKey(), direction === "up" ? 0 : lastCellNode.getChildrenSize(), "element");
              stopEvent(event);
              $setSelection2(newSelection);
              return true;
            }
          }
        }
      }
      if (direction === "down" && $isScrollableTablesActive(editor)) {
        tableObserver.setShouldCheckSelection();
      }
      return false;
    }
    if ($isRangeSelection2(selection)) {
      if (direction === "backward" || direction === "forward") {
        const alter = event.shiftKey ? "extend" : "move";
        return $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, direction === "backward", tableNode, tableObserver);
      }
      if (selection.isCollapsed()) {
        const {
          anchor,
          focus
        } = selection;
        const anchorCellNode = $findMatchingParent3(anchor.getNode(), $isTableCellNode);
        const focusCellNode = $findMatchingParent3(focus.getNode(), $isTableCellNode);
        if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {
          return false;
        }
        const anchorCellTable = $findTableNode(anchorCellNode);
        if (anchorCellTable !== tableNode && anchorCellTable != null) {
          const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));
          if (anchorCellTableElement != null) {
            tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);
            return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);
          }
        }
        const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);
        const anchorDOM = editor.getElementByKey(anchor.key);
        if (anchorDOM == null || anchorCellDom == null) {
          return false;
        }
        let edgeSelectionRect;
        if (anchor.type === "element") {
          edgeSelectionRect = anchorDOM.getBoundingClientRect();
        } else {
          const domSelection = getDOMSelection2(getEditorWindow(editor));
          if (domSelection === null || domSelection.rangeCount === 0) {
            return false;
          }
          const range2 = domSelection.getRangeAt(0);
          edgeSelectionRect = range2.getBoundingClientRect();
        }
        const edgeChild = direction === "up" ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();
        if (edgeChild == null) {
          return false;
        }
        const edgeChildDOM = editor.getElementByKey(edgeChild.__key);
        if (edgeChildDOM == null) {
          return false;
        }
        const edgeRect = edgeChildDOM.getBoundingClientRect();
        const isExiting = direction === "up" ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;
        if (isExiting) {
          stopEvent(event);
          const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);
          if (event.shiftKey) {
            const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);
            tableObserver.$setAnchorCellForSelection(cell);
            tableObserver.$setFocusCellForSelection(cell, true);
          } else {
            return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);
          }
          return true;
        }
      }
    } else if ($isTableSelection(selection)) {
      const {
        anchor,
        focus
      } = selection;
      const anchorCellNode = $findMatchingParent3(anchor.getNode(), $isTableCellNode);
      const focusCellNode = $findMatchingParent3(focus.getNode(), $isTableCellNode);
      const [tableNodeFromSelection] = selection.getNodes();
      if (!$isTableNode(tableNodeFromSelection)) {
        formatDevErrorMessage9(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);
      }
      const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));
      if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {
        return false;
      }
      tableObserver.$updateTableTableSelection(selection);
      const grid = getTable(tableNodeFromSelection, tableElement);
      const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);
      const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);
      tableObserver.$setAnchorCellForSelection(anchorCell);
      stopEvent(event);
      if (event.shiftKey) {
        const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);
        return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);
      } else {
        focusCellNode.selectEnd();
      }
      return true;
    }
    return false;
  }
  function stopEvent(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    event.stopPropagation();
  }
  function isTypeaheadMenuInView(editor) {
    const root = editor.getRootElement();
    if (!root) {
      return false;
    }
    return root.hasAttribute("aria-controls") && root.getAttribute("aria-controls") === "typeahead-menu";
  }
  function $insertParagraphAtTableEdge(edgePosition, tableNode, children) {
    const paragraphNode = $createParagraphNode2();
    if (edgePosition === "first") {
      tableNode.insertBefore(paragraphNode);
    } else {
      tableNode.insertAfter(paragraphNode);
    }
    paragraphNode.append(...children || []);
    paragraphNode.selectEnd();
  }
  function $getTableEdgeCursorPosition(editor, selection, tableNode) {
    const tableNodeParent = tableNode.getParent();
    if (!tableNodeParent) {
      return void 0;
    }
    const domSelection = getDOMSelection2(getEditorWindow(editor));
    if (!domSelection) {
      return void 0;
    }
    const domAnchorNode = domSelection.anchorNode;
    const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());
    const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));
    if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {
      return void 0;
    }
    const anchorCellNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2));
    if (!anchorCellNode) {
      return void 0;
    }
    const parentTable = $findMatchingParent3(anchorCellNode, (n2) => $isTableNode(n2));
    if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {
      return void 0;
    }
    const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);
    const firstCell = tableMap[0][0];
    const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];
    const {
      startRow,
      startColumn
    } = cellValue;
    const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;
    const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;
    if (isAtFirstCell) {
      return "first";
    } else if (isAtLastCell) {
      return "last";
    } else {
      return void 0;
    }
  }
  function $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {
    const {
      tableNode
    } = tableObserver.$lookup();
    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);
    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);
  }
  function $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {
    return $findParentTableCellNodeInTable(tableNode, $getNearestNodeFromDOMNode2(startingDOM, editorState));
  }
  function isHTMLDivElement(element) {
    return isHTMLElement3(element) && element.nodeName === "DIV";
  }
  function updateColgroup(dom, config, colCount, colWidths) {
    const colGroup = dom.querySelector("colgroup");
    if (!colGroup) {
      return;
    }
    const cols = [];
    for (let i2 = 0; i2 < colCount; i2++) {
      const col = document.createElement("col");
      const width = colWidths && colWidths[i2];
      if (width) {
        col.style.width = `${width}px`;
      }
      cols.push(col);
    }
    colGroup.replaceChildren(...cols);
  }
  function setRowStriping(dom, config, rowStriping) {
    if (rowStriping) {
      addClassNamesToElement2(dom, config.theme.tableRowStriping);
      dom.setAttribute("data-lexical-row-striping", "true");
    } else {
      removeClassNamesFromElement2(dom, config.theme.tableRowStriping);
      dom.removeAttribute("data-lexical-row-striping");
    }
  }
  function setFrozenColumns(dom, tableElement, config, frozenColumnCount) {
    if (frozenColumnCount > 0) {
      addClassNamesToElement2(dom, config.theme.tableFrozenColumn);
      tableElement.setAttribute("data-lexical-frozen-column", "true");
    } else {
      removeClassNamesFromElement2(dom, config.theme.tableFrozenColumn);
      tableElement.removeAttribute("data-lexical-frozen-column");
    }
  }
  function setFrozenRows(dom, tableElement, config, frozenRowCount) {
    if (frozenRowCount > 0) {
      addClassNamesToElement2(dom, config.theme.tableFrozenRow);
      tableElement.setAttribute("data-lexical-frozen-row", "true");
    } else {
      removeClassNamesFromElement2(dom, config.theme.tableFrozenRow);
      tableElement.removeAttribute("data-lexical-frozen-row");
    }
  }
  function alignTableElement(dom, config, formatType) {
    if (!config.theme.tableAlignment) {
      return;
    }
    const removeClasses = [];
    const addClasses = [];
    for (const format of ["center", "right"]) {
      const classes = config.theme.tableAlignment[format];
      if (!classes) {
        continue;
      }
      (format === formatType ? addClasses : removeClasses).push(classes);
    }
    removeClassNamesFromElement2(dom, ...removeClasses);
    addClassNamesToElement2(dom, ...addClasses);
  }
  var scrollableEditors = /* @__PURE__ */ new WeakSet();
  function $isScrollableTablesActive(editor = $getEditor2()) {
    return scrollableEditors.has(editor);
  }
  function setScrollableTablesActive(editor, active) {
    if (active) {
      if (!editor._config.theme.tableScrollableWrapper) {
        console.warn("TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.");
      }
      scrollableEditors.add(editor);
    } else {
      scrollableEditors.delete(editor);
    }
  }
  var TableNode = class _TableNode extends ElementNode2 {
    /** @internal */
    __rowStriping;
    __frozenColumnCount;
    __frozenRowCount;
    __colWidths;
    static getType() {
      return "table";
    }
    getColWidths() {
      const self2 = this.getLatest();
      return self2.__colWidths;
    }
    setColWidths(colWidths) {
      const self2 = this.getWritable();
      self2.__colWidths = colWidths !== void 0 && true ? Object.freeze(colWidths) : colWidths;
      return self2;
    }
    static clone(node) {
      return new _TableNode(node.__key);
    }
    afterCloneFrom(prevNode) {
      super.afterCloneFrom(prevNode);
      this.__colWidths = prevNode.__colWidths;
      this.__rowStriping = prevNode.__rowStriping;
      this.__frozenColumnCount = prevNode.__frozenColumnCount;
      this.__frozenRowCount = prevNode.__frozenRowCount;
    }
    static importDOM() {
      return {
        table: (_node) => ({
          conversion: $convertTableElement2,
          priority: 1
        })
      };
    }
    static importJSON(serializedNode) {
      return $createTableNode().updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
      return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setFrozenColumns(serializedNode.frozenColumnCount || 0).setFrozenRows(serializedNode.frozenRowCount || 0).setColWidths(serializedNode.colWidths);
    }
    constructor(key) {
      super(key);
      this.__rowStriping = false;
      this.__frozenColumnCount = 0;
      this.__frozenRowCount = 0;
      this.__colWidths = void 0;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        colWidths: this.getColWidths(),
        frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : void 0,
        frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : void 0,
        rowStriping: this.__rowStriping ? this.__rowStriping : void 0
      };
    }
    extractWithChild(child, selection, destination) {
      return destination === "html";
    }
    getDOMSlot(element) {
      const tableElement = !isHTMLTableElement(element) ? element.querySelector("table") : element;
      if (!isHTMLTableElement(tableElement)) {
        formatDevErrorMessage9(`TableNode.getDOMSlot: createDOM() did not return a table`);
      }
      return super.getDOMSlot(element).withElement(tableElement).withAfter(tableElement.querySelector("colgroup"));
    }
    createDOM(config, editor) {
      const tableElement = document.createElement("table");
      if (this.__style) {
        tableElement.style.cssText = this.__style;
      }
      const colGroup = document.createElement("colgroup");
      tableElement.appendChild(colGroup);
      setDOMUnmanaged2(colGroup);
      addClassNamesToElement2(tableElement, config.theme.table);
      this.updateTableElement(null, tableElement, config);
      if ($isScrollableTablesActive(editor)) {
        const wrapperElement = document.createElement("div");
        const classes = config.theme.tableScrollableWrapper;
        if (classes) {
          addClassNamesToElement2(wrapperElement, classes);
        } else {
          wrapperElement.style.cssText = "overflow-x: auto;";
        }
        wrapperElement.appendChild(tableElement);
        this.updateTableWrapper(null, wrapperElement, tableElement, config);
        return wrapperElement;
      }
      return tableElement;
    }
    updateTableWrapper(prevNode, tableWrapper, tableElement, config) {
      if (this.__frozenColumnCount !== (prevNode ? prevNode.__frozenColumnCount : 0)) {
        setFrozenColumns(tableWrapper, tableElement, config, this.__frozenColumnCount);
      }
      if (this.__frozenRowCount !== (prevNode ? prevNode.__frozenRowCount : 0)) {
        setFrozenRows(tableWrapper, tableElement, config, this.__frozenRowCount);
      }
    }
    updateTableElement(prevNode, tableElement, config) {
      if (this.__style !== (prevNode ? prevNode.__style : "")) {
        tableElement.style.cssText = this.__style;
      }
      if (this.__rowStriping !== (prevNode ? prevNode.__rowStriping : false)) {
        setRowStriping(tableElement, config, this.__rowStriping);
      }
      updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());
      alignTableElement(tableElement, config, this.getFormatType());
    }
    updateDOM(prevNode, dom, config) {
      const slot = this.getDOMSlot(dom);
      const tableElement = slot.element;
      if (dom === tableElement === $isScrollableTablesActive()) {
        return true;
      }
      if (isHTMLDivElement(dom)) {
        this.updateTableWrapper(prevNode, dom, tableElement, config);
      }
      this.updateTableElement(prevNode, tableElement, config);
      return false;
    }
    exportDOM(editor) {
      const superExport = super.exportDOM(editor);
      const {
        element
      } = superExport;
      return {
        after: (tableElement) => {
          if (superExport.after) {
            tableElement = superExport.after(tableElement);
          }
          if (!isHTMLTableElement(tableElement) && isHTMLElement3(tableElement)) {
            tableElement = tableElement.querySelector("table");
          }
          if (!isHTMLTableElement(tableElement)) {
            return null;
          }
          alignTableElement(tableElement, editor._config, this.getFormatType());
          const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);
          const cellValues = /* @__PURE__ */ new Map();
          for (const mapRow of tableMap) {
            for (const mapValue of mapRow) {
              const key = mapValue.cell.getKey();
              if (!cellValues.has(key)) {
                cellValues.set(key, {
                  colSpan: mapValue.cell.getColSpan(),
                  startColumn: mapValue.startColumn
                });
              }
            }
          }
          const knownColumns = /* @__PURE__ */ new Set();
          for (const cellDOM of tableElement.querySelectorAll(":scope > tr > [data-temporary-table-cell-lexical-key]")) {
            const key = cellDOM.getAttribute("data-temporary-table-cell-lexical-key");
            if (key) {
              const cellSpan = cellValues.get(key);
              cellDOM.removeAttribute("data-temporary-table-cell-lexical-key");
              if (cellSpan) {
                cellValues.delete(key);
                for (let i2 = 0; i2 < cellSpan.colSpan; i2++) {
                  knownColumns.add(i2 + cellSpan.startColumn);
                }
              }
            }
          }
          const colGroup = tableElement.querySelector(":scope > colgroup");
          if (colGroup) {
            const cols = Array.from(tableElement.querySelectorAll(":scope > colgroup > col")).filter((dom, i2) => knownColumns.has(i2));
            colGroup.replaceChildren(...cols);
          }
          const rows = tableElement.querySelectorAll(":scope > tr");
          if (rows.length > 0) {
            const tBody = document.createElement("tbody");
            for (const row of rows) {
              tBody.appendChild(row);
            }
            tableElement.append(tBody);
          }
          return tableElement;
        },
        element: !isHTMLTableElement(element) && isHTMLElement3(element) ? element.querySelector("table") : element
      };
    }
    canBeEmpty() {
      return false;
    }
    isShadowRoot() {
      return true;
    }
    getCordsFromCellNode(tableCellNode, table) {
      const {
        rows,
        domRows
      } = table;
      for (let y3 = 0; y3 < rows; y3++) {
        const row = domRows[y3];
        if (row == null) {
          continue;
        }
        for (let x2 = 0; x2 < row.length; x2++) {
          const cell = row[x2];
          if (cell == null) {
            continue;
          }
          const {
            elem
          } = cell;
          const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);
          if (cellNode !== null && tableCellNode.is(cellNode)) {
            return {
              x: x2,
              y: y3
            };
          }
        }
      }
      throw new Error("Cell not found in table.");
    }
    getDOMCellFromCords(x2, y3, table) {
      const {
        domRows
      } = table;
      const row = domRows[y3];
      if (row == null) {
        return null;
      }
      const index2 = x2 < row.length ? x2 : row.length - 1;
      const cell = row[index2];
      if (cell == null) {
        return null;
      }
      return cell;
    }
    getDOMCellFromCordsOrThrow(x2, y3, table) {
      const cell = this.getDOMCellFromCords(x2, y3, table);
      if (!cell) {
        throw new Error("Cell not found at cords.");
      }
      return cell;
    }
    getCellNodeFromCords(x2, y3, table) {
      const cell = this.getDOMCellFromCords(x2, y3, table);
      if (cell == null) {
        return null;
      }
      const node = $getNearestNodeFromDOMNode2(cell.elem);
      if ($isTableCellNode(node)) {
        return node;
      }
      return null;
    }
    getCellNodeFromCordsOrThrow(x2, y3, table) {
      const node = this.getCellNodeFromCords(x2, y3, table);
      if (!node) {
        throw new Error("Node at cords not TableCellNode.");
      }
      return node;
    }
    getRowStriping() {
      return Boolean(this.getLatest().__rowStriping);
    }
    setRowStriping(newRowStriping) {
      const self2 = this.getWritable();
      self2.__rowStriping = newRowStriping;
      return self2;
    }
    setFrozenColumns(columnCount) {
      const self2 = this.getWritable();
      self2.__frozenColumnCount = columnCount;
      return self2;
    }
    getFrozenColumns() {
      return this.getLatest().__frozenColumnCount;
    }
    setFrozenRows(rowCount) {
      const self2 = this.getWritable();
      self2.__frozenRowCount = rowCount;
      return self2;
    }
    getFrozenRows() {
      return this.getLatest().__frozenRowCount;
    }
    canSelectBefore() {
      return true;
    }
    canIndent() {
      return false;
    }
    getColumnCount() {
      const firstRow = this.getFirstChild();
      if (!firstRow) {
        return 0;
      }
      let columnCount = 0;
      firstRow.getChildren().forEach((cell) => {
        if ($isTableCellNode(cell)) {
          columnCount += cell.getColSpan();
        }
      });
      return columnCount;
    }
  };
  function $getElementForTableNode(editor, tableNode) {
    const tableElement = editor.getElementByKey(tableNode.getKey());
    if (!(tableElement !== null)) {
      formatDevErrorMessage9(`$getElementForTableNode: Table Element Not Found`);
    }
    return getTable(tableNode, tableElement);
  }
  function $convertTableElement2(domNode) {
    const tableNode = $createTableNode();
    if (domNode.hasAttribute("data-lexical-row-striping")) {
      tableNode.setRowStriping(true);
    }
    if (domNode.hasAttribute("data-lexical-frozen-column")) {
      tableNode.setFrozenColumns(1);
    }
    if (domNode.hasAttribute("data-lexical-frozen-row")) {
      tableNode.setFrozenRows(1);
    }
    const colGroup = domNode.querySelector(":scope > colgroup");
    if (colGroup) {
      let columns = [];
      for (const col of colGroup.querySelectorAll(":scope > col")) {
        let width = col.style.width || "";
        if (!PIXEL_VALUE_REG_EXP.test(width)) {
          width = col.getAttribute("width") || "";
          if (!/^\d+$/.test(width)) {
            columns = void 0;
            break;
          }
        }
        columns.push(parseFloat(width));
      }
      if (columns) {
        tableNode.setColWidths(columns);
      }
    }
    return {
      after: (children) => $descendantsMatching2(children, $isTableRowNode),
      node: tableNode
    };
  }
  function $createTableNode() {
    return $applyNodeReplacement2(new TableNode());
  }
  function $isTableNode(node) {
    return node instanceof TableNode;
  }
  function $insertTableCommandListener({
    rows,
    columns,
    includeHeaders
  }) {
    const selection = $getSelection2() || $getPreviousSelection2();
    if (!selection || !$isRangeSelection2(selection)) {
      return false;
    }
    if ($findTableNode(selection.anchor.getNode())) {
      return false;
    }
    const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);
    $insertNodeToNearestRoot2(tableNode);
    const firstDescendant = tableNode.getFirstDescendant();
    if ($isTextNode2(firstDescendant)) {
      firstDescendant.select();
    }
    return true;
  }
  function $tableCellTransform(node) {
    if (!$isTableRowNode(node.getParent())) {
      node.remove();
    } else if (node.isEmpty()) {
      node.append($createParagraphNode2());
    }
  }
  function $tableRowTransform(node) {
    if (!$isTableNode(node.getParent())) {
      node.remove();
    } else {
      $unwrapAndFilterDescendants2(node, $isTableCellNode);
    }
  }
  function $tableTransform(node) {
    $unwrapAndFilterDescendants2(node, $isTableRowNode);
    const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);
    const maxRowLength = gridMap.reduce((curLength, row) => {
      return Math.max(curLength, row.length);
    }, 0);
    const rowNodes = node.getChildren();
    for (let i2 = 0; i2 < gridMap.length; ++i2) {
      const rowNode = rowNodes[i2];
      if (!rowNode) {
        continue;
      }
      if (!$isTableRowNode(rowNode)) {
        formatDevErrorMessage9(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);
      }
      const rowLength = gridMap[i2].reduce((acc, cell) => cell ? 1 + acc : acc, 0);
      if (rowLength === maxRowLength) {
        continue;
      }
      for (let j2 = rowLength; j2 < maxRowLength; ++j2) {
        const newCell = $createTableCellNode();
        newCell.append($createParagraphNode2());
        rowNode.append(newCell);
      }
    }
  }
  function $tableClickCommand(event) {
    if (event.detail < 3 || !isDOMNode2(event.target)) {
      return false;
    }
    const startNode = $getNearestNodeFromDOMNode2(event.target);
    if (startNode === null) {
      return false;
    }
    const blockNode = $findMatchingParent3(startNode, (node) => $isElementNode2(node) && !node.isInline());
    if (blockNode === null) {
      return false;
    }
    const rootNode = blockNode.getParent();
    if (!$isTableCellNode(rootNode)) {
      return false;
    }
    blockNode.select(0);
    return true;
  }
  function registerTableCellUnmergeTransform(editor) {
    return editor.registerNodeTransform(TableCellNode, (node) => {
      if (node.getColSpan() > 1 || node.getRowSpan() > 1) {
        const [, , gridNode] = $getNodeTriplet(node);
        const [gridMap] = $computeTableMap(gridNode, node, node);
        const rowsCount = gridMap.length;
        const columnsCount = gridMap[0].length;
        let row = gridNode.getFirstChild();
        if (!$isTableRowNode(row)) {
          formatDevErrorMessage9(`Expected TableNode first child to be a RowNode`);
        }
        const unmerged = [];
        for (let i2 = 0; i2 < rowsCount; i2++) {
          if (i2 !== 0) {
            row = row.getNextSibling();
            if (!$isTableRowNode(row)) {
              formatDevErrorMessage9(`Expected TableNode first child to be a RowNode`);
            }
          }
          let lastRowCell = null;
          for (let j2 = 0; j2 < columnsCount; j2++) {
            const cellMap = gridMap[i2][j2];
            const cell = cellMap.cell;
            if (cellMap.startRow === i2 && cellMap.startColumn === j2) {
              lastRowCell = cell;
              unmerged.push(cell);
            } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {
              if (!$isTableCellNode(cell)) {
                formatDevErrorMessage9(`Expected TableNode cell to be a TableCellNode`);
              }
              const newCell = $createTableCellNode(cell.__headerState);
              if (lastRowCell !== null) {
                lastRowCell.insertAfter(newCell);
              } else {
                $insertFirst2(row, newCell);
              }
            }
          }
        }
        for (const cell of unmerged) {
          cell.setColSpan(1);
          cell.setRowSpan(1);
        }
      }
    });
  }
  function registerTableSelectionObserver(editor, hasTabHandler = true) {
    const tableSelections = /* @__PURE__ */ new Map();
    const initializeTableNode = (tableNode, nodeKey, dom) => {
      const tableElement = getTableElement(tableNode, dom);
      const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);
      tableSelections.set(nodeKey, [tableSelection, tableElement]);
    };
    const unregisterMutationListener = editor.registerMutationListener(TableNode, (nodeMutations) => {
      editor.getEditorState().read(() => {
        for (const [nodeKey, mutation] of nodeMutations) {
          const tableSelection = tableSelections.get(nodeKey);
          if (mutation === "created" || mutation === "updated") {
            const {
              tableNode,
              tableElement
            } = $getTableAndElementByKey(nodeKey);
            if (tableSelection === void 0) {
              initializeTableNode(tableNode, nodeKey, tableElement);
            } else if (tableElement !== tableSelection[1]) {
              tableSelection[0].removeListeners();
              tableSelections.delete(nodeKey);
              initializeTableNode(tableNode, nodeKey, tableElement);
            }
          } else if (mutation === "destroyed") {
            if (tableSelection !== void 0) {
              tableSelection[0].removeListeners();
              tableSelections.delete(nodeKey);
            }
          }
        }
      }, {
        editor
      });
    }, {
      skipInitialization: false
    });
    return () => {
      unregisterMutationListener();
      for (const [, [tableSelection]] of tableSelections) {
        tableSelection.removeListeners();
      }
    };
  }
  function registerTablePlugin(editor) {
    if (!editor.hasNodes([TableNode])) {
      {
        formatDevErrorMessage9(`TablePlugin: TableNode is not registered on editor`);
      }
    }
    return mergeRegister2(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, ({
      nodes,
      selection
    }, dispatchEditor) => {
      if (editor !== dispatchEditor || !$isRangeSelection2(selection)) {
        return false;
      }
      const isInsideTableCell = $findTableNode(selection.anchor.getNode()) !== null;
      return isInsideTableCell && nodes.some($isTableNode);
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CLICK_COMMAND2, $tableClickCommand, COMMAND_PRIORITY_EDITOR2), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));
  }
  var TableExtension = defineExtension2({
    build(editor, config, state) {
      return namedSignals2(config);
    },
    config: safeCast2({
      hasCellBackgroundColor: true,
      hasCellMerge: true,
      hasHorizontalScroll: true,
      hasTabHandler: true
    }),
    name: "@lexical/table/Table",
    nodes: [TableNode, TableRowNode, TableCellNode],
    register(editor, config, state) {
      const stores2 = state.getOutput();
      return mergeRegister2(effect3(() => {
        const hasHorizontalScroll = stores2.hasHorizontalScroll.value;
        const hadHorizontalScroll = $isScrollableTablesActive(editor);
        if (hadHorizontalScroll !== hasHorizontalScroll) {
          setScrollableTablesActive(editor, hasHorizontalScroll);
          editor.registerNodeTransform(TableNode, () => {
          })();
        }
      }), registerTablePlugin(editor), effect3(() => registerTableSelectionObserver(editor, stores2.hasTabHandler.value)), effect3(() => stores2.hasCellMerge.value ? void 0 : registerTableCellUnmergeTransform(editor)), effect3(() => stores2.hasCellBackgroundColor.value ? void 0 : editor.registerNodeTransform(TableCellNode, (node) => {
        if (node.getBackgroundColor() !== null) {
          node.setBackgroundColor(null);
        }
      })));
    }
  });

  // node_modules/@lexical/table/LexicalTable.mjs
  var mod12 = true ? LexicalTable_dev_exports : LexicalTable_prod_exports;
  var $computeTableMap2 = mod12.$computeTableMap;
  var $computeTableMapSkipCellCheck2 = mod12.$computeTableMapSkipCellCheck;
  var $createTableCellNode2 = mod12.$createTableCellNode;
  var $createTableNode2 = mod12.$createTableNode;
  var $createTableNodeWithDimensions2 = mod12.$createTableNodeWithDimensions;
  var $createTableRowNode2 = mod12.$createTableRowNode;
  var $createTableSelection2 = mod12.$createTableSelection;
  var $createTableSelectionFrom2 = mod12.$createTableSelectionFrom;
  var $deleteTableColumn2 = mod12.$deleteTableColumn;
  var $deleteTableColumnAtSelection2 = mod12.$deleteTableColumnAtSelection;
  var $deleteTableColumn__EXPERIMENTAL2 = mod12.$deleteTableColumn__EXPERIMENTAL;
  var $deleteTableRowAtSelection2 = mod12.$deleteTableRowAtSelection;
  var $deleteTableRow__EXPERIMENTAL2 = mod12.$deleteTableRow__EXPERIMENTAL;
  var $findCellNode2 = mod12.$findCellNode;
  var $findTableNode2 = mod12.$findTableNode;
  var $getElementForTableNode2 = mod12.$getElementForTableNode;
  var $getNodeTriplet2 = mod12.$getNodeTriplet;
  var $getTableAndElementByKey2 = mod12.$getTableAndElementByKey;
  var $getTableCellNodeFromLexicalNode2 = mod12.$getTableCellNodeFromLexicalNode;
  var $getTableCellNodeRect2 = mod12.$getTableCellNodeRect;
  var $getTableColumnIndexFromTableCellNode2 = mod12.$getTableColumnIndexFromTableCellNode;
  var $getTableNodeFromLexicalNodeOrThrow2 = mod12.$getTableNodeFromLexicalNodeOrThrow;
  var $getTableRowIndexFromTableCellNode2 = mod12.$getTableRowIndexFromTableCellNode;
  var $getTableRowNodeFromTableCellNodeOrThrow2 = mod12.$getTableRowNodeFromTableCellNodeOrThrow;
  var $insertTableColumn2 = mod12.$insertTableColumn;
  var $insertTableColumnAtSelection2 = mod12.$insertTableColumnAtSelection;
  var $insertTableColumn__EXPERIMENTAL2 = mod12.$insertTableColumn__EXPERIMENTAL;
  var $insertTableRow2 = mod12.$insertTableRow;
  var $insertTableRowAtSelection2 = mod12.$insertTableRowAtSelection;
  var $insertTableRow__EXPERIMENTAL2 = mod12.$insertTableRow__EXPERIMENTAL;
  var $isScrollableTablesActive2 = mod12.$isScrollableTablesActive;
  var $isTableCellNode2 = mod12.$isTableCellNode;
  var $isTableNode2 = mod12.$isTableNode;
  var $isTableRowNode2 = mod12.$isTableRowNode;
  var $isTableSelection2 = mod12.$isTableSelection;
  var $mergeCells2 = mod12.$mergeCells;
  var $removeTableRowAtIndex2 = mod12.$removeTableRowAtIndex;
  var $unmergeCell2 = mod12.$unmergeCell;
  var INSERT_TABLE_COMMAND2 = mod12.INSERT_TABLE_COMMAND;
  var TableCellHeaderStates2 = mod12.TableCellHeaderStates;
  var TableCellNode2 = mod12.TableCellNode;
  var TableExtension2 = mod12.TableExtension;
  var TableNode2 = mod12.TableNode;
  var TableObserver2 = mod12.TableObserver;
  var TableRowNode2 = mod12.TableRowNode;
  var applyTableHandlers2 = mod12.applyTableHandlers;
  var getDOMCellFromTarget2 = mod12.getDOMCellFromTarget;
  var getTableElement2 = mod12.getTableElement;
  var getTableObserverFromTableElement2 = mod12.getTableObserverFromTableElement;
  var registerTableCellUnmergeTransform2 = mod12.registerTableCellUnmergeTransform;
  var registerTablePlugin2 = mod12.registerTablePlugin;
  var registerTableSelectionObserver2 = mod12.registerTableSelectionObserver;
  var setScrollableTablesActive2 = mod12.setScrollableTablesActive;

  // node_modules/@37signals/lexxy/dist/lexxy_helpers.esm.js
  var import_prismjs3 = __toESM(require_prism(), 1);
  function createElement(name, properties, content = "") {
    const element = document.createElement(name);
    for (const [key, value] of Object.entries(properties || {})) {
      if (key in element) {
        element[key] = value;
      } else if (value !== null && value !== void 0) {
        element.setAttribute(key, value);
      }
    }
    if (content) {
      element.innerHTML = content;
    }
    return element;
  }
  function parseHtml(html2) {
    const parser = new DOMParser();
    return parser.parseFromString(html2, "text/html");
  }
  function createAttachmentFigure(contentType, isPreviewable, fileName) {
    const extension = fileName ? fileName.split(".").pop().toLowerCase() : "unknown";
    return createElement("figure", {
      className: `attachment attachment--${isPreviewable ? "preview" : "file"} attachment--${extension}`,
      "data-content-type": contentType
    });
  }
  function isPreviewableImage(contentType) {
    return contentType.startsWith("image/") && !contentType.includes("svg");
  }
  function dispatchCustomEvent(element, name, detail) {
    const event = new CustomEvent(name, {
      detail,
      bubbles: true
    });
    element.dispatchEvent(event);
  }
  function dispatch2(element, eventName, detail = null, cancelable = false) {
    return element.dispatchEvent(new CustomEvent(eventName, { bubbles: true, detail, cancelable }));
  }
  function generateDomId(prefix2) {
    const randomPart = Math.random().toString(36).slice(2, 10);
    return `${prefix2}-${randomPart}`;
  }

  // node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs
  var LexicalPlainText_dev_exports = {};
  __export(LexicalPlainText_dev_exports, {
    PlainTextExtension: () => PlainTextExtension,
    registerPlainText: () => registerPlainText
  });
  var CAN_USE_DOM6 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  var documentMode5 = CAN_USE_DOM6 && "documentMode" in document ? document.documentMode : null;
  var IS_APPLE5 = CAN_USE_DOM6 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
  var CAN_USE_BEFORE_INPUT5 = CAN_USE_DOM6 && "InputEvent" in window && !documentMode5 ? "getTargetRanges" in new window.InputEvent("input") : false;
  var IS_SAFARI5 = CAN_USE_DOM6 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
  var IS_IOS5 = CAN_USE_DOM6 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  var IS_CHROME5 = CAN_USE_DOM6 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
  var IS_APPLE_WEBKIT5 = CAN_USE_DOM6 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && IS_APPLE5 && !IS_CHROME5;
  function onCopyForPlainText(event, editor) {
    editor.update(() => {
      if (event !== null) {
        const clipboardData = objectKlassEquals2(event, KeyboardEvent) ? null : event.clipboardData;
        const selection = $getSelection2();
        if (selection !== null && !selection.isCollapsed() && clipboardData != null) {
          event.preventDefault();
          const htmlString = $getHtmlContent2(editor);
          if (htmlString !== null) {
            clipboardData.setData("text/html", htmlString);
          }
          clipboardData.setData("text/plain", selection.getTextContent());
        }
      }
    });
  }
  function onPasteForPlainText(event, editor) {
    event.preventDefault();
    editor.update(() => {
      const selection = $getSelection2();
      const clipboardData = objectKlassEquals2(event, ClipboardEvent) ? event.clipboardData : null;
      if (clipboardData != null && $isRangeSelection2(selection)) {
        $insertDataTransferForPlainText2(clipboardData, selection);
      }
    }, {
      tag: PASTE_TAG2
    });
  }
  function onCutForPlainText(event, editor) {
    onCopyForPlainText(event, editor);
    editor.update(() => {
      const selection = $getSelection2();
      if ($isRangeSelection2(selection)) {
        selection.removeText();
      }
    });
  }
  function registerPlainText(editor) {
    const removeListener2 = mergeRegister2(editor.registerCommand(DELETE_CHARACTER_COMMAND2, (isBackward) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.deleteCharacter(isBackward);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_WORD_COMMAND2, (isBackward) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.deleteWord(isBackward);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_LINE_COMMAND2, (isBackward) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.deleteLine(isBackward);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (eventOrText) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      if (typeof eventOrText === "string") {
        selection.insertText(eventOrText);
      } else {
        const dataTransfer = eventOrText.dataTransfer;
        if (dataTransfer != null) {
          $insertDataTransferForPlainText2(dataTransfer, selection);
        } else {
          const data2 = eventOrText.data;
          if (data2) {
            selection.insertText(data2);
          }
        }
      }
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(REMOVE_TEXT_COMMAND2, () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.removeText();
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_LINE_BREAK_COMMAND2, (selectStart) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.insertLineBreak(selectStart);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      selection.insertLineBreak();
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_LEFT_COMMAND2, (payload) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const event = payload;
      const isHoldingShift = event.shiftKey;
      if ($shouldOverrideDefaultCharacterSelection2(selection, true)) {
        event.preventDefault();
        $moveCharacter2(selection, isHoldingShift, true);
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND2, (payload) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const event = payload;
      const isHoldingShift = event.shiftKey;
      if ($shouldOverrideDefaultCharacterSelection2(selection, false)) {
        event.preventDefault();
        $moveCharacter2(selection, isHoldingShift, false);
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_BACKSPACE_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      if (IS_IOS5 && navigator.language === "ko-KR") {
        return false;
      }
      event.preventDefault();
      return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, true);
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_DELETE_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      event.preventDefault();
      return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, false);
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ENTER_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      if (event !== null) {
        if ((IS_IOS5 || IS_SAFARI5 || IS_APPLE_WEBKIT5) && CAN_USE_BEFORE_INPUT5) {
          return false;
        }
        event.preventDefault();
      }
      return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND2, false);
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(SELECT_ALL_COMMAND2, () => {
      $selectAll2();
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(COPY_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      onCopyForPlainText(event, editor);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CUT_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      onCutForPlainText(event, editor);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(PASTE_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      onPasteForPlainText(event, editor);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DROP_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      event.preventDefault();
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DRAGSTART_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      event.preventDefault();
      return true;
    }, COMMAND_PRIORITY_EDITOR2));
    return removeListener2;
  }
  var PlainTextExtension = defineExtension2({
    conflictsWith: ["@lexical/rich-text"],
    dependencies: [DragonExtension2],
    name: "@lexical/plain-text",
    register: registerPlainText
  });

  // node_modules/@lexical/plain-text/LexicalPlainText.mjs
  var mod13 = true ? LexicalPlainText_dev_exports : LexicalPlainText_prod_exports;
  var PlainTextExtension2 = mod13.PlainTextExtension;
  var registerPlainText2 = mod13.registerPlainText;

  // node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs
  var LexicalMarkdown_dev_exports = {};
  __export(LexicalMarkdown_dev_exports, {
    $convertFromMarkdownString: () => $convertFromMarkdownString,
    $convertToMarkdownString: () => $convertToMarkdownString,
    BOLD_ITALIC_STAR: () => BOLD_ITALIC_STAR,
    BOLD_ITALIC_UNDERSCORE: () => BOLD_ITALIC_UNDERSCORE,
    BOLD_STAR: () => BOLD_STAR,
    BOLD_UNDERSCORE: () => BOLD_UNDERSCORE,
    CHECK_LIST: () => CHECK_LIST,
    CODE: () => CODE,
    ELEMENT_TRANSFORMERS: () => ELEMENT_TRANSFORMERS,
    HEADING: () => HEADING,
    HIGHLIGHT: () => HIGHLIGHT,
    INLINE_CODE: () => INLINE_CODE,
    ITALIC_STAR: () => ITALIC_STAR,
    ITALIC_UNDERSCORE: () => ITALIC_UNDERSCORE,
    LINK: () => LINK,
    MULTILINE_ELEMENT_TRANSFORMERS: () => MULTILINE_ELEMENT_TRANSFORMERS,
    ORDERED_LIST: () => ORDERED_LIST,
    QUOTE: () => QUOTE,
    STRIKETHROUGH: () => STRIKETHROUGH,
    TEXT_FORMAT_TRANSFORMERS: () => TEXT_FORMAT_TRANSFORMERS,
    TEXT_MATCH_TRANSFORMERS: () => TEXT_MATCH_TRANSFORMERS,
    TRANSFORMERS: () => TRANSFORMERS,
    UNORDERED_LIST: () => UNORDERED_LIST,
    registerMarkdownShortcuts: () => registerMarkdownShortcuts
  });
  function indexBy(list, callback2) {
    const index2 = {};
    for (const item of list) {
      const key = callback2(item);
      if (!key) {
        continue;
      }
      if (index2[key]) {
        index2[key].push(item);
      } else {
        index2[key] = [item];
      }
    }
    return index2;
  }
  function transformersByType(transformers) {
    const byType = indexBy(transformers, (t2) => t2.type);
    return {
      element: byType.element || [],
      multilineElement: byType["multiline-element"] || [],
      textFormat: byType["text-format"] || [],
      textMatch: byType["text-match"] || []
    };
  }
  var PUNCTUATION_OR_SPACE2 = /[!-/:-@[-`{-~\s]/;
  var MARKDOWN_EMPTY_LINE_REG_EXP = /^\s{0,3}$/;
  function isEmptyParagraph(node) {
    if (!$isParagraphNode2(node)) {
      return false;
    }
    const firstChild = node.getFirstChild();
    return firstChild == null || node.getChildrenSize() === 1 && $isTextNode2(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());
  }
  function createMarkdownExport(transformers, shouldPreserveNewLines = false) {
    const byType = transformersByType(transformers);
    const elementTransformers = [...byType.multilineElement, ...byType.element];
    const isNewlineDelimited = !shouldPreserveNewLines;
    const textFormatTransformers = byType.textFormat.filter((transformer) => transformer.format.length === 1).sort((a2, b3) => {
      return Number(a2.format.includes("code")) - Number(b3.format.includes("code"));
    });
    return (node) => {
      const output = [];
      const children = (node || $getRoot2()).getChildren();
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        const result = exportTopLevelElements(child, elementTransformers, textFormatTransformers, byType.textMatch);
        if (result != null) {
          output.push(
            // separate consecutive group of texts with a line break: eg. ["hello", "world"] -> ["hello", "/nworld"]
            isNewlineDelimited && i2 > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i2 - 1]) ? "\n".concat(result) : result
          );
        }
      }
      return output.join("\n");
    };
  }
  function exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {
    for (const transformer of elementTransformers) {
      if (!transformer.export) {
        continue;
      }
      const result = transformer.export(node, (_node) => exportChildren(_node, textTransformersIndex, textMatchTransformers));
      if (result != null) {
        return result;
      }
    }
    if ($isElementNode2(node)) {
      return exportChildren(node, textTransformersIndex, textMatchTransformers);
    } else if ($isDecoratorNode2(node)) {
      return node.getTextContent();
    } else {
      return null;
    }
  }
  function exportChildren(node, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags) {
    const output = [];
    const children = node.getChildren();
    if (!unclosedTags) {
      unclosedTags = [];
    }
    if (!unclosableTags) {
      unclosableTags = [];
    }
    mainLoop: for (const child of children) {
      for (const transformer of textMatchTransformers) {
        if (!transformer.export) {
          continue;
        }
        const result = transformer.export(child, (parentNode) => exportChildren(
          parentNode,
          textTransformersIndex,
          textMatchTransformers,
          unclosedTags,
          // Add current unclosed tags to the list of unclosable tags - we don't want nested tags from
          // textmatch transformers to close the outer ones, as that may result in invalid markdown.
          // E.g. **text [text**](https://lexical.io)
          // is invalid markdown, as the closing ** is inside the link.
          //
          [...unclosableTags, ...unclosedTags]
        ), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex, unclosedTags, unclosableTags));
        if (result != null) {
          output.push(result);
          continue mainLoop;
        }
      }
      if ($isLineBreakNode2(child)) {
        output.push("\n");
      } else if ($isTextNode2(child)) {
        output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex, unclosedTags, unclosableTags));
      } else if ($isElementNode2(child)) {
        output.push(exportChildren(child, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags));
      } else if ($isDecoratorNode2(child)) {
        output.push(child.getTextContent());
      }
    }
    return output.join("");
  }
  function exportTextFormat(node, textContent, textTransformers, unclosedTags, unclosableTags) {
    let output = node.getFormat() === 0 ? textContent : escapeLeadingAndTrailingWhitespaces(textContent);
    if (!node.hasFormat("code")) {
      output = output.replace(/([*_`~\\])/g, "\\$1");
    }
    let openingTags = "";
    let closingTagsBefore = "";
    let closingTagsAfter = "";
    const prevNode = getTextSibling(node, true);
    const nextNode = getTextSibling(node, false);
    const applied = /* @__PURE__ */ new Set();
    for (const transformer of textTransformers) {
      const format = transformer.format[0];
      const tag = transformer.tag;
      if (hasFormat(node, format) && !applied.has(format)) {
        applied.add(format);
        if (!hasFormat(prevNode, format) || !unclosedTags.find((element) => element.tag === tag)) {
          unclosedTags.push({
            format,
            tag
          });
          openingTags += tag;
        }
      }
    }
    for (let i2 = 0; i2 < unclosedTags.length; i2++) {
      const nodeHasFormat = hasFormat(node, unclosedTags[i2].format);
      const nextNodeHasFormat = hasFormat(nextNode, unclosedTags[i2].format);
      if (nodeHasFormat && nextNodeHasFormat) {
        continue;
      }
      const unhandledUnclosedTags = [...unclosedTags];
      while (unhandledUnclosedTags.length > i2) {
        const unclosedTag = unhandledUnclosedTags.pop();
        if (unclosableTags && unclosedTag && unclosableTags.find((element) => element.tag === unclosedTag.tag)) {
          continue;
        }
        if (unclosedTag && typeof unclosedTag.tag === "string") {
          if (!nodeHasFormat) {
            closingTagsBefore += unclosedTag.tag;
          } else if (!nextNodeHasFormat) {
            closingTagsAfter += unclosedTag.tag;
          }
        }
        unclosedTags.pop();
      }
      break;
    }
    output = openingTags + output + closingTagsAfter;
    return closingTagsBefore + output;
  }
  function getTextSibling(node, backward) {
    let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();
    if (!sibling) {
      const parent = node.getParentOrThrow();
      if (parent.isInline()) {
        sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();
      }
    }
    while (sibling) {
      if ($isElementNode2(sibling)) {
        if (!sibling.isInline()) {
          break;
        }
        const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();
        if ($isTextNode2(descendant)) {
          return descendant;
        } else {
          sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();
        }
      }
      if ($isTextNode2(sibling)) {
        return sibling;
      }
      if (!$isElementNode2(sibling)) {
        return null;
      }
    }
    return null;
  }
  function hasFormat(node, format) {
    return $isTextNode2(node) && node.hasFormat(format);
  }
  function escapeLeadingAndTrailingWhitespaces(textContent) {
    return textContent.replace(/^\s+|\s+$/g, (match) => {
      return [...match].map((char) => "&#" + char.codePointAt(0) + ";").join("");
    });
  }
  function findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex) {
    const textContent = textNode.getTextContent();
    const match = findOutermostMatch(textContent, textFormatTransformersIndex);
    if (!match) {
      return null;
    }
    const textFormatMatchStart = match.index || 0;
    const textFormatMatchEnd = textFormatMatchStart + match[0].length;
    const transformer = textFormatTransformersIndex.transformersByTag[match[1]];
    return {
      endIndex: textFormatMatchEnd,
      match,
      startIndex: textFormatMatchStart,
      transformer
    };
  }
  function findOutermostMatch(textContent, textTransformersIndex) {
    const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);
    if (openTagsMatch == null) {
      return null;
    }
    for (const match of openTagsMatch) {
      const tag = match.replace(/^\s/, "");
      const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];
      if (fullMatchRegExp == null) {
        continue;
      }
      const fullMatch = textContent.match(fullMatchRegExp);
      const transformer = textTransformersIndex.transformersByTag[tag];
      if (fullMatch != null && transformer != null) {
        if (transformer.intraword !== false) {
          return fullMatch;
        }
        const {
          index: index2 = 0
        } = fullMatch;
        const beforeChar = textContent[index2 - 1];
        const afterChar = textContent[index2 + fullMatch[0].length];
        if ((!beforeChar || PUNCTUATION_OR_SPACE2.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE2.test(afterChar))) {
          return fullMatch;
        }
      }
    }
    return null;
  }
  function importTextFormatTransformer(textNode, startIndex, endIndex, transformer, match) {
    const textContent = textNode.getTextContent();
    let transformedNode, nodeAfter, nodeBefore;
    if (match[0] === textContent) {
      transformedNode = textNode;
    } else {
      if (startIndex === 0) {
        [transformedNode, nodeAfter] = textNode.splitText(endIndex);
      } else {
        [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);
      }
    }
    transformedNode.setTextContent(match[2]);
    if (transformer) {
      for (const format of transformer.format) {
        if (!transformedNode.hasFormat(format)) {
          transformedNode.toggleFormat(format);
        }
      }
    }
    return {
      nodeAfter,
      nodeBefore,
      transformedNode
    };
  }
  function findOutermostTextMatchTransformer(textNode_, textMatchTransformers) {
    const textNode = textNode_;
    let foundMatchStartIndex = void 0;
    let foundMatchEndIndex = void 0;
    let foundMatchTransformer = void 0;
    let foundMatch = void 0;
    for (const transformer of textMatchTransformers) {
      if (!transformer.replace || !transformer.importRegExp) {
        continue;
      }
      const match = textNode.getTextContent().match(transformer.importRegExp);
      if (!match) {
        continue;
      }
      const startIndex = match.index || 0;
      const endIndex = transformer.getEndIndex ? transformer.getEndIndex(textNode, match) : startIndex + match[0].length;
      if (endIndex === false) {
        continue;
      }
      if (foundMatchStartIndex === void 0 || foundMatchEndIndex === void 0 || // Wraps previous match or is strictly before it.
      startIndex < foundMatchStartIndex && (endIndex > foundMatchEndIndex || endIndex <= foundMatchStartIndex)) {
        foundMatchStartIndex = startIndex;
        foundMatchEndIndex = endIndex;
        foundMatchTransformer = transformer;
        foundMatch = match;
      }
    }
    if (foundMatchStartIndex === void 0 || foundMatchEndIndex === void 0 || foundMatchTransformer === void 0 || foundMatch === void 0) {
      return null;
    }
    return {
      endIndex: foundMatchEndIndex,
      match: foundMatch,
      startIndex: foundMatchStartIndex,
      transformer: foundMatchTransformer
    };
  }
  function importFoundTextMatchTransformer(textNode, startIndex, endIndex, transformer, match) {
    let transformedNode, nodeAfter, nodeBefore;
    if (startIndex === 0) {
      [transformedNode, nodeAfter] = textNode.splitText(endIndex);
    } else {
      [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);
    }
    if (!transformer.replace) {
      return null;
    }
    const potentialTransformedNode = transformer.replace(transformedNode, match);
    return {
      nodeAfter,
      nodeBefore,
      transformedNode: potentialTransformedNode || void 0
    };
  }
  function canContainTransformableMarkdown(node) {
    return $isTextNode2(node) && !node.hasFormat("code");
  }
  function importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {
    let foundTextFormat = findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex);
    let foundTextMatch = findOutermostTextMatchTransformer(textNode, textMatchTransformers);
    if (foundTextFormat && foundTextMatch) {
      if (foundTextFormat.startIndex <= foundTextMatch.startIndex && foundTextFormat.endIndex >= foundTextMatch.endIndex || // foundTextMatch is not contained within foundTextFormat
      foundTextMatch.startIndex > foundTextFormat.endIndex) {
        foundTextMatch = null;
      } else {
        foundTextFormat = null;
      }
    }
    if (foundTextFormat) {
      const result = importTextFormatTransformer(textNode, foundTextFormat.startIndex, foundTextFormat.endIndex, foundTextFormat.transformer, foundTextFormat.match);
      if (canContainTransformableMarkdown(result.nodeAfter)) {
        importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);
      }
      if (canContainTransformableMarkdown(result.nodeBefore)) {
        importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);
      }
      if (canContainTransformableMarkdown(result.transformedNode)) {
        importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);
      }
    } else if (foundTextMatch) {
      const result = importFoundTextMatchTransformer(textNode, foundTextMatch.startIndex, foundTextMatch.endIndex, foundTextMatch.transformer, foundTextMatch.match);
      if (!result) {
        return;
      }
      if (canContainTransformableMarkdown(result.nodeAfter)) {
        importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);
      }
      if (canContainTransformableMarkdown(result.nodeBefore)) {
        importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);
      }
      if (canContainTransformableMarkdown(result.transformedNode)) {
        importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);
      }
    }
    const textContent = textNode.getTextContent();
    const escapedText = textContent.replace(/\\([*_`~\\])/g, "$1").replace(/&#(\d+);/g, (_3, codePoint) => {
      return String.fromCodePoint(codePoint);
    });
    textNode.setTextContent(escapedText);
  }
  function createMarkdownImport(transformers, shouldPreserveNewLines = false) {
    const byType = transformersByType(transformers);
    const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);
    return (markdownString, node) => {
      const lines = markdownString.split("\n");
      const linesLength = lines.length;
      const root = node || $getRoot2();
      root.clear();
      for (let i2 = 0; i2 < linesLength; i2++) {
        const lineText = lines[i2];
        const [imported, shiftedIndex] = $importMultiline(lines, i2, byType.multilineElement, root);
        if (imported) {
          i2 = shiftedIndex;
          continue;
        }
        $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch, shouldPreserveNewLines);
      }
      const children = root.getChildren();
      for (const child of children) {
        if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {
          child.remove();
        }
      }
      if ($getSelection2() !== null) {
        root.selectStart();
      }
    };
  }
  function $importMultiline(lines, startLineIndex, multilineElementTransformers, rootNode) {
    for (const transformer of multilineElementTransformers) {
      const {
        handleImportAfterStartMatch,
        regExpEnd,
        regExpStart,
        replace
      } = transformer;
      const startMatch = lines[startLineIndex].match(regExpStart);
      if (!startMatch) {
        continue;
      }
      if (handleImportAfterStartMatch) {
        const result = handleImportAfterStartMatch({
          lines,
          rootNode,
          startLineIndex,
          startMatch,
          transformer
        });
        if (result === null) {
          continue;
        } else if (result) {
          return result;
        }
      }
      const regexpEndRegex = typeof regExpEnd === "object" && "regExp" in regExpEnd ? regExpEnd.regExp : regExpEnd;
      const isEndOptional = regExpEnd && typeof regExpEnd === "object" && "optional" in regExpEnd ? regExpEnd.optional : !regExpEnd;
      let endLineIndex = startLineIndex;
      const linesLength = lines.length;
      while (endLineIndex < linesLength) {
        const endMatch = regexpEndRegex ? lines[endLineIndex].match(regexpEndRegex) : null;
        if (!endMatch) {
          if (!isEndOptional || isEndOptional && endLineIndex < linesLength - 1) {
            endLineIndex++;
            continue;
          }
        }
        if (endMatch && startLineIndex === endLineIndex && endMatch.index === startMatch.index) {
          endLineIndex++;
          continue;
        }
        const linesInBetween = [];
        if (endMatch && startLineIndex === endLineIndex) {
          linesInBetween.push(lines[startLineIndex].slice(startMatch[0].length, -endMatch[0].length));
        } else {
          for (let i2 = startLineIndex; i2 <= endLineIndex; i2++) {
            if (i2 === startLineIndex) {
              const text2 = lines[i2].slice(startMatch[0].length);
              linesInBetween.push(text2);
            } else if (i2 === endLineIndex && endMatch) {
              const text2 = lines[i2].slice(0, -endMatch[0].length);
              linesInBetween.push(text2);
            } else {
              linesInBetween.push(lines[i2]);
            }
          }
        }
        if (replace(rootNode, null, startMatch, endMatch, linesInBetween, true) !== false) {
          return [true, endLineIndex];
        }
        break;
      }
    }
    return [false, startLineIndex];
  }
  function $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers, shouldPreserveNewLines) {
    const textNode = $createTextNode2(lineText);
    const elementNode = $createParagraphNode2();
    elementNode.append(textNode);
    rootNode.append(elementNode);
    for (const {
      regExp,
      replace
    } of elementTransformers) {
      const match = lineText.match(regExp);
      if (match) {
        textNode.setTextContent(lineText.slice(match[0].length));
        if (replace(elementNode, [textNode], match, true) !== false) {
          break;
        }
      }
    }
    importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);
    if (elementNode.isAttached() && lineText.length > 0) {
      const previousNode = elementNode.getPreviousSibling();
      if (!shouldPreserveNewLines && // Only append if we're not preserving newlines
      ($isParagraphNode2(previousNode) || $isQuoteNode2(previousNode) || $isListNode2(previousNode))) {
        let targetNode = previousNode;
        if ($isListNode2(previousNode)) {
          const lastDescendant = previousNode.getLastDescendant();
          if (lastDescendant == null) {
            targetNode = null;
          } else {
            targetNode = $findMatchingParent3(lastDescendant, $isListItemNode2);
          }
        }
        if (targetNode != null && targetNode.getTextContentSize() > 0) {
          targetNode.splice(targetNode.getChildrenSize(), 0, [$createLineBreakNode2(), ...elementNode.getChildren()]);
          elementNode.remove();
        }
      }
    }
  }
  function createTextFormatTransformersIndex(textTransformers) {
    const transformersByTag = {};
    const fullMatchRegExpByTag = {};
    const openTagsRegExp = [];
    const escapeRegExp = `(?<![\\\\])`;
    for (const transformer of textTransformers) {
      const {
        tag
      } = transformer;
      transformersByTag[tag] = transformer;
      const tagRegExp = tag.replace(/(\*|\^|\+)/g, "\\$1");
      openTagsRegExp.push(tagRegExp);
      if (tag.length === 1) {
        if (tag === "`") {
          fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\`])(\`)((?:\\\\\`|[^\`])+?)(\`)(?!\`)`);
        } else {
          fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\${tagRegExp}])(${tagRegExp})((\\\\${tagRegExp})?.*?[^${tagRegExp}\\s](\\\\${tagRegExp})?)((?<!\\\\)|(?<=\\\\\\\\))(${tagRegExp})(?![\\\\${tagRegExp}])`);
        }
      } else {
        fullMatchRegExpByTag[tag] = new RegExp(`(?<!\\\\)(${tagRegExp})((\\\\${tagRegExp})?.*?[^\\s](\\\\${tagRegExp})?)((?<!\\\\)|(?<=\\\\\\\\))(${tagRegExp})(?!\\\\)`);
      }
    }
    return {
      // Reg exp to find open tag + content + close tag
      fullMatchRegExpByTag,
      // Regexp to locate *any* potential opening tag (longest first).
      openTagsRegExp: new RegExp(`${escapeRegExp}(${openTagsRegExp.join("|")})`, "g"),
      transformersByTag
    };
  }
  function formatDevErrorMessage10(message) {
    throw new Error(message);
  }
  var ORDERED_LIST_REGEX = /^(\s*)(\d{1,})\.\s/;
  var UNORDERED_LIST_REGEX = /^(\s*)[-*+]\s/;
  var CHECK_LIST_REGEX = /^(\s*)(?:[-*+]\s)?\s?(\[(\s|x)?\])\s/i;
  var HEADING_REGEX = /^(#{1,6})\s/;
  var QUOTE_REGEX = /^>\s/;
  var CODE_START_REGEX = /^[ \t]*```([\w-]+)?/;
  var CODE_END_REGEX = /[ \t]*```$/;
  var CODE_SINGLE_LINE_REGEX = /^[ \t]*```[^`]+(?:(?:`{1,2}|`{4,})[^`]+)*```(?:[^`]|$)/;
  var TABLE_ROW_REG_EXP = /^(?:\|)(.+)(?:\|)\s?$/;
  var TABLE_ROW_DIVIDER_REG_EXP = /^(\| ?:?-*:? ?)+\|\s?$/;
  var TAG_START_REGEX = /^<[a-z_][\w-]*(?:\s[^<>]*)?\/?>/i;
  var TAG_END_REGEX = /^<\/[a-z_][\w-]*\s*>/i;
  var ENDS_WITH = (regex) => new RegExp(`(?:${regex.source})$`, regex.flags);
  var listMarkerState = createState2("mdListMarker", {
    parse: (v3) => typeof v3 === "string" && /^[-*+]$/.test(v3) ? v3 : "-"
  });
  var createBlockNode = (createNode) => {
    return (parentNode, children, match, isImport) => {
      const node = createNode(match);
      node.append(...children);
      parentNode.replace(node);
      if (!isImport) {
        node.select(0, 0);
      }
    };
  };
  var LIST_INDENT_SIZE = 4;
  function getIndent(whitespaces) {
    const tabs = whitespaces.match(/\t/g);
    const spaces = whitespaces.match(/ /g);
    let indent = 0;
    if (tabs) {
      indent += tabs.length;
    }
    if (spaces) {
      indent += Math.floor(spaces.length / LIST_INDENT_SIZE);
    }
    return indent;
  }
  var listReplace = (listType) => {
    return (parentNode, children, match, isImport) => {
      const previousNode = parentNode.getPreviousSibling();
      const nextNode = parentNode.getNextSibling();
      const listItem = $createListItemNode2(listType === "check" ? match[3] === "x" : void 0);
      const firstMatchChar = match[0].trim()[0];
      const listMarker = (listType === "bullet" || listType === "check") && firstMatchChar === listMarkerState.parse(firstMatchChar) ? firstMatchChar : void 0;
      if ($isListNode2(nextNode) && nextNode.getListType() === listType) {
        if (listMarker) {
          $setState2(nextNode, listMarkerState, listMarker);
        }
        const firstChild = nextNode.getFirstChild();
        if (firstChild !== null) {
          firstChild.insertBefore(listItem);
        } else {
          nextNode.append(listItem);
        }
        parentNode.remove();
      } else if ($isListNode2(previousNode) && previousNode.getListType() === listType) {
        if (listMarker) {
          $setState2(previousNode, listMarkerState, listMarker);
        }
        previousNode.append(listItem);
        parentNode.remove();
      } else {
        const list = $createListNode2(listType, listType === "number" ? Number(match[2]) : void 0);
        if (listMarker) {
          $setState2(list, listMarkerState, listMarker);
        }
        list.append(listItem);
        parentNode.replace(list);
      }
      listItem.append(...children);
      if (!isImport) {
        listItem.select(0, 0);
      }
      const indent = getIndent(match[1]);
      if (indent) {
        listItem.setIndent(indent);
      }
    };
  };
  var $listExport = (listNode, exportChildren2, depth) => {
    const output = [];
    const children = listNode.getChildren();
    let index2 = 0;
    for (const listItemNode of children) {
      if ($isListItemNode2(listItemNode)) {
        if (listItemNode.getChildrenSize() === 1) {
          const firstChild = listItemNode.getFirstChild();
          if ($isListNode2(firstChild)) {
            output.push($listExport(firstChild, exportChildren2, depth + 1));
            continue;
          }
        }
        const indent = " ".repeat(depth * LIST_INDENT_SIZE);
        const listType = listNode.getListType();
        const listMarker = $getState2(listNode, listMarkerState);
        const prefix2 = listType === "number" ? `${listNode.getStart() + index2}. ` : listType === "check" ? `${listMarker} [${listItemNode.getChecked() ? "x" : " "}] ` : listMarker + " ";
        output.push(indent + prefix2 + exportChildren2(listItemNode));
        index2++;
      }
    }
    return output.join("\n");
  };
  var HEADING = {
    dependencies: [HeadingNode2],
    export: (node, exportChildren2) => {
      if (!$isHeadingNode2(node)) {
        return null;
      }
      const level = Number(node.getTag().slice(1));
      return "#".repeat(level) + " " + exportChildren2(node);
    },
    regExp: HEADING_REGEX,
    replace: createBlockNode((match) => {
      const tag = "h" + match[1].length;
      return $createHeadingNode2(tag);
    }),
    type: "element"
  };
  var QUOTE = {
    dependencies: [QuoteNode2],
    export: (node, exportChildren2) => {
      if (!$isQuoteNode2(node)) {
        return null;
      }
      const lines = exportChildren2(node).split("\n");
      const output = [];
      for (const line of lines) {
        output.push("> " + line);
      }
      return output.join("\n");
    },
    regExp: QUOTE_REGEX,
    replace: (parentNode, children, _match, isImport) => {
      if (isImport) {
        const previousNode = parentNode.getPreviousSibling();
        if ($isQuoteNode2(previousNode)) {
          previousNode.splice(previousNode.getChildrenSize(), 0, [$createLineBreakNode2(), ...children]);
          parentNode.remove();
          return;
        }
      }
      const node = $createQuoteNode2();
      node.append(...children);
      parentNode.replace(node);
      if (!isImport) {
        node.select(0, 0);
      }
    },
    type: "element"
  };
  var CODE = {
    dependencies: [CodeNode2],
    export: (node) => {
      if (!$isCodeNode2(node)) {
        return null;
      }
      const textContent = node.getTextContent();
      return "```" + (node.getLanguage() || "") + (textContent ? "\n" + textContent : "") + "\n```";
    },
    regExpEnd: {
      optional: true,
      regExp: CODE_END_REGEX
    },
    regExpStart: CODE_START_REGEX,
    replace: (rootNode, children, startMatch, endMatch, linesInBetween, isImport) => {
      let codeBlockNode;
      let code;
      if (!children && linesInBetween) {
        if (linesInBetween.length === 1) {
          if (endMatch) {
            codeBlockNode = $createCodeNode2();
            code = startMatch[1] + linesInBetween[0];
          } else {
            codeBlockNode = $createCodeNode2(startMatch[1]);
            code = linesInBetween[0].startsWith(" ") ? linesInBetween[0].slice(1) : linesInBetween[0];
          }
        } else {
          codeBlockNode = $createCodeNode2(startMatch[1]);
          if (linesInBetween[0].trim().length === 0) {
            while (linesInBetween.length > 0 && !linesInBetween[0].length) {
              linesInBetween.shift();
            }
          } else {
            linesInBetween[0] = linesInBetween[0].startsWith(" ") ? linesInBetween[0].slice(1) : linesInBetween[0];
          }
          while (linesInBetween.length > 0 && !linesInBetween[linesInBetween.length - 1].length) {
            linesInBetween.pop();
          }
          code = linesInBetween.join("\n");
        }
        const textNode = $createTextNode2(code);
        codeBlockNode.append(textNode);
        rootNode.append(codeBlockNode);
      } else if (children) {
        createBlockNode((match) => {
          return $createCodeNode2(match ? match[1] : void 0);
        })(rootNode, children, startMatch, isImport);
      }
    },
    type: "multiline-element"
  };
  var UNORDERED_LIST = {
    dependencies: [ListNode2, ListItemNode2],
    export: (node, exportChildren2) => {
      return $isListNode2(node) ? $listExport(node, exportChildren2, 0) : null;
    },
    regExp: UNORDERED_LIST_REGEX,
    replace: listReplace("bullet"),
    type: "element"
  };
  var CHECK_LIST = {
    dependencies: [ListNode2, ListItemNode2],
    export: (node, exportChildren2) => {
      return $isListNode2(node) ? $listExport(node, exportChildren2, 0) : null;
    },
    regExp: CHECK_LIST_REGEX,
    replace: listReplace("check"),
    type: "element"
  };
  var ORDERED_LIST = {
    dependencies: [ListNode2, ListItemNode2],
    export: (node, exportChildren2) => {
      return $isListNode2(node) ? $listExport(node, exportChildren2, 0) : null;
    },
    regExp: ORDERED_LIST_REGEX,
    replace: listReplace("number"),
    type: "element"
  };
  var INLINE_CODE = {
    format: ["code"],
    tag: "`",
    type: "text-format"
  };
  var HIGHLIGHT = {
    format: ["highlight"],
    tag: "==",
    type: "text-format"
  };
  var BOLD_ITALIC_STAR = {
    format: ["bold", "italic"],
    tag: "***",
    type: "text-format"
  };
  var BOLD_ITALIC_UNDERSCORE = {
    format: ["bold", "italic"],
    intraword: false,
    tag: "___",
    type: "text-format"
  };
  var BOLD_STAR = {
    format: ["bold"],
    tag: "**",
    type: "text-format"
  };
  var BOLD_UNDERSCORE = {
    format: ["bold"],
    intraword: false,
    tag: "__",
    type: "text-format"
  };
  var STRIKETHROUGH = {
    format: ["strikethrough"],
    tag: "~~",
    type: "text-format"
  };
  var ITALIC_STAR = {
    format: ["italic"],
    tag: "*",
    type: "text-format"
  };
  var ITALIC_UNDERSCORE = {
    format: ["italic"],
    intraword: false,
    tag: "_",
    type: "text-format"
  };
  var LINK = {
    dependencies: [LinkNode2],
    export: (node, exportChildren2, exportFormat) => {
      if (!$isLinkNode2(node) || $isAutoLinkNode2(node)) {
        return null;
      }
      const title = node.getTitle();
      const textContent = exportChildren2(node);
      const linkContent = title ? `[${textContent}](${node.getURL()} "${title}")` : `[${textContent}](${node.getURL()})`;
      return linkContent;
    },
    importRegExp: /(?:\[(.+?)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))/,
    regExp: /(?:\[(.+?)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))$/,
    replace: (textNode, match) => {
      const [, linkText, linkUrl, linkTitle] = match;
      const linkNode = $createLinkNode2(linkUrl, {
        title: linkTitle
      });
      const openBracketAmount = linkText.split("[").length - 1;
      const closeBracketAmount = linkText.split("]").length - 1;
      let parsedLinkText = linkText;
      let outsideLinkText = "";
      if (openBracketAmount < closeBracketAmount) {
        return;
      } else if (openBracketAmount > closeBracketAmount) {
        const linkTextParts = linkText.split("[");
        outsideLinkText = "[" + linkTextParts[0];
        parsedLinkText = linkTextParts.slice(1).join("[");
      }
      const linkTextNode = $createTextNode2(parsedLinkText);
      linkTextNode.setFormat(textNode.getFormat());
      linkNode.append(linkTextNode);
      textNode.replace(linkNode);
      if (outsideLinkText) {
        linkNode.insertBefore($createTextNode2(outsideLinkText));
      }
      return linkTextNode;
    },
    trigger: ")",
    type: "text-match"
  };
  var ELEMENT_TRANSFORMERS = [HEADING, QUOTE, UNORDERED_LIST, ORDERED_LIST];
  var MULTILINE_ELEMENT_TRANSFORMERS = [CODE];
  var TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];
  var TEXT_MATCH_TRANSFORMERS = [LINK];
  var TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...MULTILINE_ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];
  function normalizeMarkdown(input, shouldMergeAdjacentLines = false) {
    const lines = input.split("\n");
    let inCodeBlock = false;
    const sanitizedLines = [];
    for (let i2 = 0; i2 < lines.length; i2++) {
      const line = lines[i2].trimEnd();
      const lastLine = sanitizedLines[sanitizedLines.length - 1];
      if (CODE_SINGLE_LINE_REGEX.test(line)) {
        sanitizedLines.push(line);
        continue;
      }
      if (CODE_START_REGEX.test(line) || CODE_END_REGEX.test(line)) {
        inCodeBlock = !inCodeBlock;
        sanitizedLines.push(line);
        continue;
      }
      if (inCodeBlock) {
        sanitizedLines.push(line);
        continue;
      }
      if (line === "" || lastLine === "" || !lastLine || HEADING_REGEX.test(lastLine) || HEADING_REGEX.test(line) || QUOTE_REGEX.test(line) || ORDERED_LIST_REGEX.test(line) || UNORDERED_LIST_REGEX.test(line) || CHECK_LIST_REGEX.test(line) || TABLE_ROW_REG_EXP.test(line) || TABLE_ROW_DIVIDER_REG_EXP.test(line) || !shouldMergeAdjacentLines || TAG_START_REGEX.test(line) || TAG_END_REGEX.test(line) || ENDS_WITH(TAG_END_REGEX).test(lastLine) || ENDS_WITH(TAG_START_REGEX).test(lastLine) || CODE_END_REGEX.test(lastLine)) {
        sanitizedLines.push(line);
      } else {
        sanitizedLines[sanitizedLines.length - 1] = lastLine + " " + line.trimStart();
      }
    }
    return sanitizedLines.join("\n");
  }
  function runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {
    const grandParentNode = parentNode.getParent();
    if (!$isRootOrShadowRoot2(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {
      return false;
    }
    const textContent = anchorNode.getTextContent();
    if (textContent[anchorOffset - 1] !== " ") {
      return false;
    }
    for (const {
      regExp,
      replace
    } of elementTransformers) {
      const match = textContent.match(regExp);
      if (match && match[0].length === (match[0].endsWith(" ") ? anchorOffset : anchorOffset - 1)) {
        const nextSiblings = anchorNode.getNextSiblings();
        const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);
        const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;
        if (replace(parentNode, siblings, match, false) !== false) {
          leadingNode.remove();
          return true;
        }
      }
    }
    return false;
  }
  function runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {
    const grandParentNode = parentNode.getParent();
    if (!$isRootOrShadowRoot2(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {
      return false;
    }
    const textContent = anchorNode.getTextContent();
    if (textContent[anchorOffset - 1] !== " ") {
      return false;
    }
    for (const {
      regExpStart,
      replace,
      regExpEnd
    } of elementTransformers) {
      if (regExpEnd && !("optional" in regExpEnd) || regExpEnd && "optional" in regExpEnd && !regExpEnd.optional) {
        continue;
      }
      const match = textContent.match(regExpStart);
      if (match && match[0].length === (match[0].endsWith(" ") ? anchorOffset : anchorOffset - 1)) {
        const nextSiblings = anchorNode.getNextSiblings();
        const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);
        const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;
        if (replace(parentNode, siblings, match, null, null, false) !== false) {
          leadingNode.remove();
          return true;
        }
      }
    }
    return false;
  }
  function runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {
    let textContent = anchorNode.getTextContent();
    const lastChar = textContent[anchorOffset - 1];
    const transformers = transformersByTrigger[lastChar];
    if (transformers == null) {
      return false;
    }
    if (anchorOffset < textContent.length) {
      textContent = textContent.slice(0, anchorOffset);
    }
    for (const transformer of transformers) {
      if (!transformer.replace || !transformer.regExp) {
        continue;
      }
      const match = textContent.match(transformer.regExp);
      if (match === null) {
        continue;
      }
      const startIndex = match.index || 0;
      const endIndex = startIndex + match[0].length;
      let replaceNode;
      if (startIndex === 0) {
        [replaceNode] = anchorNode.splitText(endIndex);
      } else {
        [, replaceNode] = anchorNode.splitText(startIndex, endIndex);
      }
      replaceNode.selectNext(0, 0);
      transformer.replace(replaceNode, match);
      return true;
    }
    return false;
  }
  function $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {
    const textContent = anchorNode.getTextContent();
    const closeTagEndIndex = anchorOffset - 1;
    const closeChar = textContent[closeTagEndIndex];
    const matchers = textFormatTransformers[closeChar];
    if (!matchers) {
      return false;
    }
    for (const matcher of matchers) {
      const {
        tag
      } = matcher;
      const tagLength = tag.length;
      const closeTagStartIndex = closeTagEndIndex - tagLength + 1;
      if (tagLength > 1) {
        if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {
          continue;
        }
      }
      if (textContent[closeTagStartIndex - 1] === " ") {
        continue;
      }
      const afterCloseTagChar = textContent[closeTagEndIndex + 1];
      if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE2.test(afterCloseTagChar)) {
        continue;
      }
      const closeNode = anchorNode;
      let openNode = closeNode;
      let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);
      let sibling = openNode;
      while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {
        if ($isLineBreakNode2(sibling)) {
          break;
        }
        if ($isTextNode2(sibling)) {
          if (sibling.hasFormat("code")) {
            continue;
          }
          const siblingTextContent = sibling.getTextContent();
          openNode = sibling;
          openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);
        }
      }
      if (openTagStartIndex < 0) {
        continue;
      }
      if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {
        continue;
      }
      const prevOpenNodeText = openNode.getTextContent();
      if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {
        continue;
      }
      const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];
      if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE2.test(beforeOpenTagChar)) {
        continue;
      }
      const prevCloseNodeText = closeNode.getTextContent();
      const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);
      closeNode.setTextContent(closeNodeText);
      const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;
      openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));
      const selection = $getSelection2();
      const nextSelection = $createRangeSelection2();
      $setSelection2(nextSelection);
      const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;
      nextSelection.anchor.set(openNode.__key, openTagStartIndex, "text");
      nextSelection.focus.set(closeNode.__key, newOffset, "text");
      for (const format of matcher.format) {
        if (!nextSelection.hasFormat(format)) {
          nextSelection.formatText(format);
        }
      }
      nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);
      for (const format of matcher.format) {
        if (nextSelection.hasFormat(format)) {
          nextSelection.toggleFormat(format);
        }
      }
      if ($isRangeSelection2(selection)) {
        nextSelection.format = selection.format;
      }
      return true;
    }
    return false;
  }
  function getOpenTagStartIndex(string, maxIndex, tag) {
    const tagLength = tag.length;
    for (let i2 = maxIndex; i2 >= tagLength; i2--) {
      const startIndex = i2 - tagLength;
      if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation
      string[startIndex + tagLength] !== " ") {
        return startIndex;
      }
    }
    return -1;
  }
  function isEqualSubString(stringA, aStart, stringB, bStart, length) {
    for (let i2 = 0; i2 < length; i2++) {
      if (stringA[aStart + i2] !== stringB[bStart + i2]) {
        return false;
      }
    }
    return true;
  }
  function registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {
    const byType = transformersByType(transformers);
    const textFormatTransformersByTrigger = indexBy(byType.textFormat, ({
      tag
    }) => tag[tag.length - 1]);
    const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({
      trigger: trigger2
    }) => trigger2);
    for (const transformer of transformers) {
      const type = transformer.type;
      if (type === "element" || type === "text-match" || type === "multiline-element") {
        const dependencies = transformer.dependencies;
        for (const node of dependencies) {
          if (!editor.hasNode(node)) {
            {
              formatDevErrorMessage10(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);
            }
          }
        }
      }
    }
    const $transform = (parentNode, anchorNode, anchorOffset) => {
      if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {
        return;
      }
      if (runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)) {
        return;
      }
      if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {
        return;
      }
      $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger);
    };
    return editor.registerUpdateListener(({
      tags,
      dirtyLeaves,
      editorState,
      prevEditorState
    }) => {
      if (tags.has(COLLABORATION_TAG2) || tags.has(HISTORIC_TAG2)) {
        return;
      }
      if (editor.isComposing()) {
        return;
      }
      const selection = editorState.read($getSelection2);
      const prevSelection = prevEditorState.read($getSelection2);
      if (!$isRangeSelection2(prevSelection) || !$isRangeSelection2(selection) || !selection.isCollapsed() || selection.is(prevSelection)) {
        return;
      }
      const anchorKey = selection.anchor.key;
      const anchorOffset = selection.anchor.offset;
      const anchorNode = editorState._nodeMap.get(anchorKey);
      if (!$isTextNode2(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {
        return;
      }
      editor.update(() => {
        if (!canContainTransformableMarkdown(anchorNode)) {
          return;
        }
        const parentNode = anchorNode.getParent();
        if (parentNode === null || $isCodeNode2(parentNode)) {
          return;
        }
        $transform(parentNode, anchorNode, selection.anchor.offset);
      });
    });
  }
  function $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false, shouldMergeAdjacentLines = false) {
    const sanitizedMarkdown = shouldPreserveNewLines ? markdown : normalizeMarkdown(markdown, shouldMergeAdjacentLines);
    const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);
    return importMarkdown(sanitizedMarkdown, node);
  }
  function $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {
    const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);
    return exportMarkdown(node);
  }

  // node_modules/@lexical/markdown/LexicalMarkdown.mjs
  var mod14 = true ? LexicalMarkdown_dev_exports : LexicalMarkdown_prod_exports;
  var $convertFromMarkdownString2 = mod14.$convertFromMarkdownString;
  var $convertToMarkdownString2 = mod14.$convertToMarkdownString;
  var BOLD_ITALIC_STAR2 = mod14.BOLD_ITALIC_STAR;
  var BOLD_ITALIC_UNDERSCORE2 = mod14.BOLD_ITALIC_UNDERSCORE;
  var BOLD_STAR2 = mod14.BOLD_STAR;
  var BOLD_UNDERSCORE2 = mod14.BOLD_UNDERSCORE;
  var CHECK_LIST2 = mod14.CHECK_LIST;
  var CODE2 = mod14.CODE;
  var ELEMENT_TRANSFORMERS2 = mod14.ELEMENT_TRANSFORMERS;
  var HEADING2 = mod14.HEADING;
  var HIGHLIGHT2 = mod14.HIGHLIGHT;
  var INLINE_CODE2 = mod14.INLINE_CODE;
  var ITALIC_STAR2 = mod14.ITALIC_STAR;
  var ITALIC_UNDERSCORE2 = mod14.ITALIC_UNDERSCORE;
  var LINK2 = mod14.LINK;
  var MULTILINE_ELEMENT_TRANSFORMERS2 = mod14.MULTILINE_ELEMENT_TRANSFORMERS;
  var ORDERED_LIST2 = mod14.ORDERED_LIST;
  var QUOTE2 = mod14.QUOTE;
  var STRIKETHROUGH2 = mod14.STRIKETHROUGH;
  var TEXT_FORMAT_TRANSFORMERS2 = mod14.TEXT_FORMAT_TRANSFORMERS;
  var TEXT_MATCH_TRANSFORMERS2 = mod14.TEXT_MATCH_TRANSFORMERS;
  var TRANSFORMERS2 = mod14.TRANSFORMERS;
  var UNORDERED_LIST2 = mod14.UNORDERED_LIST;
  var registerMarkdownShortcuts2 = mod14.registerMarkdownShortcuts;

  // node_modules/@lexical/history/LexicalHistory.dev.mjs
  var LexicalHistory_dev_exports = {};
  __export(LexicalHistory_dev_exports, {
    HistoryExtension: () => HistoryExtension,
    SharedHistoryExtension: () => SharedHistoryExtension,
    createEmptyHistoryState: () => createEmptyHistoryState,
    registerHistory: () => registerHistory
  });
  var HISTORY_MERGE = 0;
  var HISTORY_PUSH = 1;
  var DISCARD_HISTORY_CANDIDATE = 2;
  var OTHER = 0;
  var COMPOSING_CHARACTER = 1;
  var INSERT_CHARACTER_AFTER_SELECTION = 2;
  var DELETE_CHARACTER_BEFORE_SELECTION = 3;
  var DELETE_CHARACTER_AFTER_SELECTION = 4;
  function getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {
    const nodeMap = editorState._nodeMap;
    const nodes = [];
    for (const dirtyLeafKey of dirtyLeaves) {
      const dirtyLeaf = nodeMap.get(dirtyLeafKey);
      if (dirtyLeaf !== void 0) {
        nodes.push(dirtyLeaf);
      }
    }
    for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {
      if (!intentionallyMarkedAsDirty) {
        continue;
      }
      const dirtyElement = nodeMap.get(dirtyElementKey);
      if (dirtyElement !== void 0 && !$isRootNode2(dirtyElement)) {
        nodes.push(dirtyElement);
      }
    }
    return nodes;
  }
  function getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {
    if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {
      return OTHER;
    }
    const nextSelection = nextEditorState._selection;
    const prevSelection = prevEditorState._selection;
    if (isComposing) {
      return COMPOSING_CHARACTER;
    }
    if (!$isRangeSelection2(nextSelection) || !$isRangeSelection2(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {
      return OTHER;
    }
    const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);
    if (dirtyNodes.length === 0) {
      return OTHER;
    }
    if (dirtyNodes.length > 1) {
      const nextNodeMap = nextEditorState._nodeMap;
      const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);
      const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);
      if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode2(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {
        return INSERT_CHARACTER_AFTER_SELECTION;
      }
      return OTHER;
    }
    const nextDirtyNode = dirtyNodes[0];
    const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);
    if (!$isTextNode2(prevDirtyNode) || !$isTextNode2(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {
      return OTHER;
    }
    const prevText = prevDirtyNode.__text;
    const nextText = nextDirtyNode.__text;
    if (prevText === nextText) {
      return OTHER;
    }
    const nextAnchor = nextSelection.anchor;
    const prevAnchor = prevSelection.anchor;
    if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== "text") {
      return OTHER;
    }
    const nextAnchorOffset = nextAnchor.offset;
    const prevAnchorOffset = prevAnchor.offset;
    const textDiff = nextText.length - prevText.length;
    if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {
      return INSERT_CHARACTER_AFTER_SELECTION;
    }
    if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {
      return DELETE_CHARACTER_BEFORE_SELECTION;
    }
    if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {
      return DELETE_CHARACTER_AFTER_SELECTION;
    }
    return OTHER;
  }
  function isTextNodeUnchanged(key, prevEditorState, nextEditorState) {
    const prevNode = prevEditorState._nodeMap.get(key);
    const nextNode = nextEditorState._nodeMap.get(key);
    const prevSelection = prevEditorState._selection;
    const nextSelection = nextEditorState._selection;
    const isDeletingLine = $isRangeSelection2(prevSelection) && $isRangeSelection2(nextSelection) && prevSelection.anchor.type === "element" && prevSelection.focus.type === "element" && nextSelection.anchor.type === "text" && nextSelection.focus.type === "text";
    if (!isDeletingLine && $isTextNode2(prevNode) && $isTextNode2(nextNode) && prevNode.__parent === nextNode.__parent) {
      return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));
    }
    return false;
  }
  function createMergeActionGetter(editor, delayOrStore) {
    let prevChangeTime = Date.now();
    let prevChangeType = OTHER;
    return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {
      const changeTime = Date.now();
      if (tags.has(HISTORIC_TAG2)) {
        prevChangeType = OTHER;
        prevChangeTime = changeTime;
        return DISCARD_HISTORY_CANDIDATE;
      }
      const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());
      const mergeAction = (() => {
        const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;
        const shouldPushHistory = tags.has(HISTORY_PUSH_TAG2);
        const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has(HISTORY_MERGE_TAG2);
        if (shouldMergeHistory) {
          return HISTORY_MERGE;
        }
        if (prevEditorState === null) {
          return HISTORY_PUSH;
        }
        const selection = nextEditorState._selection;
        const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;
        if (!hasDirtyNodes) {
          if (selection !== null) {
            return HISTORY_MERGE;
          }
          return DISCARD_HISTORY_CANDIDATE;
        }
        const delay = typeof delayOrStore === "number" ? delayOrStore : delayOrStore.peek();
        if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {
          return HISTORY_MERGE;
        }
        if (dirtyLeaves.size === 1) {
          const dirtyLeafKey = Array.from(dirtyLeaves)[0];
          if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {
            return HISTORY_MERGE;
          }
        }
        return HISTORY_PUSH;
      })();
      prevChangeTime = changeTime;
      prevChangeType = changeType;
      return mergeAction;
    };
  }
  function redo(editor, historyState) {
    const redoStack = historyState.redoStack;
    const undoStack = historyState.undoStack;
    if (redoStack.length !== 0) {
      const current = historyState.current;
      if (current !== null) {
        undoStack.push(current);
        editor.dispatchCommand(CAN_UNDO_COMMAND2, true);
      }
      const historyStateEntry = redoStack.pop();
      if (redoStack.length === 0) {
        editor.dispatchCommand(CAN_REDO_COMMAND2, false);
      }
      historyState.current = historyStateEntry || null;
      if (historyStateEntry) {
        historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {
          tag: HISTORIC_TAG2
        });
      }
    }
  }
  function undo(editor, historyState) {
    const redoStack = historyState.redoStack;
    const undoStack = historyState.undoStack;
    const undoStackLength = undoStack.length;
    if (undoStackLength !== 0) {
      const current = historyState.current;
      const historyStateEntry = undoStack.pop();
      if (current !== null) {
        redoStack.push(current);
        editor.dispatchCommand(CAN_REDO_COMMAND2, true);
      }
      if (undoStack.length === 0) {
        editor.dispatchCommand(CAN_UNDO_COMMAND2, false);
      }
      historyState.current = historyStateEntry || null;
      if (historyStateEntry) {
        historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {
          tag: HISTORIC_TAG2
        });
      }
    }
  }
  function clearHistory(historyState) {
    historyState.undoStack = [];
    historyState.redoStack = [];
    historyState.current = null;
  }
  function registerHistory(editor, historyState, delay) {
    const getMergeAction = createMergeActionGetter(editor, delay);
    const applyChange = ({
      editorState,
      prevEditorState,
      dirtyLeaves,
      dirtyElements,
      tags
    }) => {
      const current = historyState.current;
      const redoStack = historyState.redoStack;
      const undoStack = historyState.undoStack;
      const currentEditorState = current === null ? null : current.editorState;
      if (current !== null && editorState === currentEditorState) {
        return;
      }
      const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);
      if (mergeAction === HISTORY_PUSH) {
        if (redoStack.length !== 0) {
          historyState.redoStack = [];
          editor.dispatchCommand(CAN_REDO_COMMAND2, false);
        }
        if (current !== null) {
          undoStack.push({
            ...current
          });
          editor.dispatchCommand(CAN_UNDO_COMMAND2, true);
        }
      } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {
        return;
      }
      historyState.current = {
        editor,
        editorState
      };
    };
    const unregister = mergeRegister2(editor.registerCommand(UNDO_COMMAND2, () => {
      undo(editor, historyState);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(REDO_COMMAND2, () => {
      redo(editor, historyState);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CLEAR_EDITOR_COMMAND2, () => {
      clearHistory(historyState);
      return false;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CLEAR_HISTORY_COMMAND2, () => {
      clearHistory(historyState);
      editor.dispatchCommand(CAN_REDO_COMMAND2, false);
      editor.dispatchCommand(CAN_UNDO_COMMAND2, false);
      return true;
    }, COMMAND_PRIORITY_EDITOR2), editor.registerUpdateListener(applyChange));
    return unregister;
  }
  function createEmptyHistoryState() {
    return {
      current: null,
      redoStack: [],
      undoStack: []
    };
  }
  var HistoryExtension = defineExtension2({
    build: (editor, {
      delay,
      createInitialHistoryState,
      disabled
    }) => namedSignals2({
      delay,
      disabled,
      historyState: createInitialHistoryState(editor)
    }),
    config: safeCast2({
      createInitialHistoryState: createEmptyHistoryState,
      delay: 300,
      disabled: typeof window === "undefined"
    }),
    name: "@lexical/history/History",
    register: (editor, config, state) => {
      const stores2 = state.getOutput();
      return effect3(() => stores2.disabled.value ? void 0 : registerHistory(editor, stores2.historyState.value, stores2.delay));
    }
  });
  function getHistoryPeer(editor) {
    return editor ? getPeerDependencyFromEditor2(editor, HistoryExtension.name) : null;
  }
  var SharedHistoryExtension = defineExtension2({
    dependencies: [configExtension2(HistoryExtension, {
      createInitialHistoryState: () => {
        throw new Error("SharedHistory did not inherit parent history");
      },
      disabled: true
    })],
    name: "@lexical/history/SharedHistory",
    register(editor, _config, state) {
      const {
        output
      } = state.getDependency(HistoryExtension);
      const parentPeer = getHistoryPeer(editor._parentEditor);
      if (!parentPeer) {
        return () => {
        };
      }
      const parentOutput = parentPeer.output;
      return effect3(() => batch(() => {
        output.delay.value = parentOutput.delay.value;
        output.historyState.value = parentOutput.historyState.value;
        output.disabled.value = parentOutput.disabled.value;
      }));
    }
  });

  // node_modules/@lexical/history/LexicalHistory.mjs
  var mod15 = true ? LexicalHistory_dev_exports : LexicalHistory_prod_exports;
  var HistoryExtension2 = mod15.HistoryExtension;
  var SharedHistoryExtension2 = mod15.SharedHistoryExtension;
  var createEmptyHistoryState2 = mod15.createEmptyHistoryState;
  var registerHistory2 = mod15.registerHistory;

  // node_modules/marked/lib/marked.esm.js
  function L() {
    return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
  }
  var T = L();
  function G2(l4) {
    T = l4;
  }
  var E2 = { exec: () => null };
  function d2(l4, e2 = "") {
    let t2 = typeof l4 == "string" ? l4 : l4.source, n2 = { replace: (r2, i2) => {
      let s2 = typeof i2 == "string" ? i2 : i2.source;
      return s2 = s2.replace(m.caret, "$1"), t2 = t2.replace(r2, s2), n2;
    }, getRegex: () => new RegExp(t2, e2) };
    return n2;
  }
  var be = (() => {
    try {
      return !!new RegExp("(?<=1)(?<!1)");
    } catch {
      return false;
    }
  })();
  var m = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (l4) => new RegExp(`^( {0,3}${l4})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}#`), htmlBeginRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}<(?:[a-z].*>|!--)`, "i") };
  var Re = /^(?:[ \t]*(?:\n|$))+/;
  var Te = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
  var Oe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
  var I = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
  var we = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
  var F = /(?:[*+-]|\d{1,9}[.)])/;
  var ie = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
  var oe = d2(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
  var ye = d2(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
  var j = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  var Pe = /^[^\n]+/;
  var Q2 = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/;
  var Se = d2(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q2).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
  var $e = d2(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, F).getRegex();
  var v2 = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  var U2 = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
  var _e = d2("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", U2).replace("tag", v2).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  var ae = d2(j).replace("hr", I).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v2).getRegex();
  var Le = d2(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", ae).getRegex();
  var K2 = { blockquote: Le, code: Te, def: Se, fences: Oe, heading: we, hr: I, html: _e, lheading: oe, list: $e, newline: Re, paragraph: ae, table: E2, text: Pe };
  var re = d2("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", I).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v2).getRegex();
  var Me = { ...K2, lheading: ye, table: re, paragraph: d2(j).replace("hr", I).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", re).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v2).getRegex() };
  var ze = { ...K2, html: d2(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", U2).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: E2, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: d2(j).replace("hr", I).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", oe).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() };
  var Ae = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
  var Ee = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
  var le = /^( {2,}|\\)\n(?!\s*$)/;
  var Ie = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
  var D = /[\p{P}\p{S}]/u;
  var W2 = /[\s\p{P}\p{S}]/u;
  var ue = /[^\s\p{P}\p{S}]/u;
  var Ce = d2(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, W2).getRegex();
  var pe = /(?!~)[\p{P}\p{S}]/u;
  var Be = /(?!~)[\s\p{P}\p{S}]/u;
  var qe = /(?:[^\s\p{P}\p{S}]|~)/u;
  var ve = d2(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", be ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex();
  var ce = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
  var De = d2(ce, "u").replace(/punct/g, D).getRegex();
  var He = d2(ce, "u").replace(/punct/g, pe).getRegex();
  var he = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
  var Ze = d2(he, "gu").replace(/notPunctSpace/g, ue).replace(/punctSpace/g, W2).replace(/punct/g, D).getRegex();
  var Ge = d2(he, "gu").replace(/notPunctSpace/g, qe).replace(/punctSpace/g, Be).replace(/punct/g, pe).getRegex();
  var Ne = d2("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, ue).replace(/punctSpace/g, W2).replace(/punct/g, D).getRegex();
  var Fe = d2(/\\(punct)/, "gu").replace(/punct/g, D).getRegex();
  var je = d2(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
  var Qe = d2(U2).replace("(?:-->|$)", "-->").getRegex();
  var Ue = d2("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Qe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
  var q2 = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/;
  var Ke = d2(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", q2).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
  var de = d2(/^!?\[(label)\]\[(ref)\]/).replace("label", q2).replace("ref", Q2).getRegex();
  var ke = d2(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q2).getRegex();
  var We = d2("reflink|nolink(?!\\()", "g").replace("reflink", de).replace("nolink", ke).getRegex();
  var se = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/;
  var X2 = { _backpedal: E2, anyPunctuation: Fe, autolink: je, blockSkip: ve, br: le, code: Ee, del: E2, emStrongLDelim: De, emStrongRDelimAst: Ze, emStrongRDelimUnd: Ne, escape: Ae, link: Ke, nolink: ke, punctuation: Ce, reflink: de, reflinkSearch: We, tag: Ue, text: Ie, url: E2 };
  var Xe = { ...X2, link: d2(/^!?\[(label)\]\((.*?)\)/).replace("label", q2).getRegex(), reflink: d2(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", q2).getRegex() };
  var N = { ...X2, emStrongRDelimAst: Ge, emStrongLDelim: He, url: d2(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", se).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: d2(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", se).getRegex() };
  var Je = { ...N, br: d2(le).replace("{2,}", "*").getRegex(), text: d2(N.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() };
  var C = { normal: K2, gfm: Me, pedantic: ze };
  var M = { normal: X2, gfm: N, breaks: Je, pedantic: Xe };
  var Ve = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
  var ge = (l4) => Ve[l4];
  function w2(l4, e2) {
    if (e2) {
      if (m.escapeTest.test(l4)) return l4.replace(m.escapeReplace, ge);
    } else if (m.escapeTestNoEncode.test(l4)) return l4.replace(m.escapeReplaceNoEncode, ge);
    return l4;
  }
  function J(l4) {
    try {
      l4 = encodeURI(l4).replace(m.percentDecode, "%");
    } catch {
      return null;
    }
    return l4;
  }
  function V2(l4, e2) {
    let t2 = l4.replace(m.findPipe, (i2, s2, a2) => {
      let o2 = false, p2 = s2;
      for (; --p2 >= 0 && a2[p2] === "\\"; ) o2 = !o2;
      return o2 ? "|" : " |";
    }), n2 = t2.split(m.splitPipe), r2 = 0;
    if (n2[0].trim() || n2.shift(), n2.length > 0 && !n2.at(-1)?.trim() && n2.pop(), e2) if (n2.length > e2) n2.splice(e2);
    else for (; n2.length < e2; ) n2.push("");
    for (; r2 < n2.length; r2++) n2[r2] = n2[r2].trim().replace(m.slashPipe, "|");
    return n2;
  }
  function z(l4, e2, t2) {
    let n2 = l4.length;
    if (n2 === 0) return "";
    let r2 = 0;
    for (; r2 < n2; ) {
      let i2 = l4.charAt(n2 - r2 - 1);
      if (i2 === e2 && !t2) r2++;
      else if (i2 !== e2 && t2) r2++;
      else break;
    }
    return l4.slice(0, n2 - r2);
  }
  function fe(l4, e2) {
    if (l4.indexOf(e2[1]) === -1) return -1;
    let t2 = 0;
    for (let n2 = 0; n2 < l4.length; n2++) if (l4[n2] === "\\") n2++;
    else if (l4[n2] === e2[0]) t2++;
    else if (l4[n2] === e2[1] && (t2--, t2 < 0)) return n2;
    return t2 > 0 ? -2 : -1;
  }
  function me(l4, e2, t2, n2, r2) {
    let i2 = e2.href, s2 = e2.title || null, a2 = l4[1].replace(r2.other.outputLinkReplace, "$1");
    n2.state.inLink = true;
    let o2 = { type: l4[0].charAt(0) === "!" ? "image" : "link", raw: t2, href: i2, title: s2, text: a2, tokens: n2.inlineTokens(a2) };
    return n2.state.inLink = false, o2;
  }
  function Ye(l4, e2, t2) {
    let n2 = l4.match(t2.other.indentCodeCompensation);
    if (n2 === null) return e2;
    let r2 = n2[1];
    return e2.split(`
`).map((i2) => {
      let s2 = i2.match(t2.other.beginningSpace);
      if (s2 === null) return i2;
      let [a2] = s2;
      return a2.length >= r2.length ? i2.slice(r2.length) : i2;
    }).join(`
`);
  }
  var y2 = class {
    options;
    rules;
    lexer;
    constructor(e2) {
      this.options = e2 || T;
    }
    space(e2) {
      let t2 = this.rules.block.newline.exec(e2);
      if (t2 && t2[0].length > 0) return { type: "space", raw: t2[0] };
    }
    code(e2) {
      let t2 = this.rules.block.code.exec(e2);
      if (t2) {
        let n2 = t2[0].replace(this.rules.other.codeRemoveIndent, "");
        return { type: "code", raw: t2[0], codeBlockStyle: "indented", text: this.options.pedantic ? n2 : z(n2, `
`) };
      }
    }
    fences(e2) {
      let t2 = this.rules.block.fences.exec(e2);
      if (t2) {
        let n2 = t2[0], r2 = Ye(n2, t2[3] || "", this.rules);
        return { type: "code", raw: n2, lang: t2[2] ? t2[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t2[2], text: r2 };
      }
    }
    heading(e2) {
      let t2 = this.rules.block.heading.exec(e2);
      if (t2) {
        let n2 = t2[2].trim();
        if (this.rules.other.endingHash.test(n2)) {
          let r2 = z(n2, "#");
          (this.options.pedantic || !r2 || this.rules.other.endingSpaceChar.test(r2)) && (n2 = r2.trim());
        }
        return { type: "heading", raw: t2[0], depth: t2[1].length, text: n2, tokens: this.lexer.inline(n2) };
      }
    }
    hr(e2) {
      let t2 = this.rules.block.hr.exec(e2);
      if (t2) return { type: "hr", raw: z(t2[0], `
`) };
    }
    blockquote(e2) {
      let t2 = this.rules.block.blockquote.exec(e2);
      if (t2) {
        let n2 = z(t2[0], `
`).split(`
`), r2 = "", i2 = "", s2 = [];
        for (; n2.length > 0; ) {
          let a2 = false, o2 = [], p2;
          for (p2 = 0; p2 < n2.length; p2++) if (this.rules.other.blockquoteStart.test(n2[p2])) o2.push(n2[p2]), a2 = true;
          else if (!a2) o2.push(n2[p2]);
          else break;
          n2 = n2.slice(p2);
          let u2 = o2.join(`
`), c2 = u2.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
          r2 = r2 ? `${r2}
${u2}` : u2, i2 = i2 ? `${i2}
${c2}` : c2;
          let g2 = this.lexer.state.top;
          if (this.lexer.state.top = true, this.lexer.blockTokens(c2, s2, true), this.lexer.state.top = g2, n2.length === 0) break;
          let h3 = s2.at(-1);
          if (h3?.type === "code") break;
          if (h3?.type === "blockquote") {
            let R2 = h3, f2 = R2.raw + `
` + n2.join(`
`), O = this.blockquote(f2);
            s2[s2.length - 1] = O, r2 = r2.substring(0, r2.length - R2.raw.length) + O.raw, i2 = i2.substring(0, i2.length - R2.text.length) + O.text;
            break;
          } else if (h3?.type === "list") {
            let R2 = h3, f2 = R2.raw + `
` + n2.join(`
`), O = this.list(f2);
            s2[s2.length - 1] = O, r2 = r2.substring(0, r2.length - h3.raw.length) + O.raw, i2 = i2.substring(0, i2.length - R2.raw.length) + O.raw, n2 = f2.substring(s2.at(-1).raw.length).split(`
`);
            continue;
          }
        }
        return { type: "blockquote", raw: r2, tokens: s2, text: i2 };
      }
    }
    list(e2) {
      let t2 = this.rules.block.list.exec(e2);
      if (t2) {
        let n2 = t2[1].trim(), r2 = n2.length > 1, i2 = { type: "list", raw: "", ordered: r2, start: r2 ? +n2.slice(0, -1) : "", loose: false, items: [] };
        n2 = r2 ? `\\d{1,9}\\${n2.slice(-1)}` : `\\${n2}`, this.options.pedantic && (n2 = r2 ? n2 : "[*+-]");
        let s2 = this.rules.other.listItemRegex(n2), a2 = false;
        for (; e2; ) {
          let p2 = false, u2 = "", c2 = "";
          if (!(t2 = s2.exec(e2)) || this.rules.block.hr.test(e2)) break;
          u2 = t2[0], e2 = e2.substring(u2.length);
          let g2 = t2[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (H) => " ".repeat(3 * H.length)), h3 = e2.split(`
`, 1)[0], R2 = !g2.trim(), f2 = 0;
          if (this.options.pedantic ? (f2 = 2, c2 = g2.trimStart()) : R2 ? f2 = t2[1].length + 1 : (f2 = t2[2].search(this.rules.other.nonSpaceChar), f2 = f2 > 4 ? 1 : f2, c2 = g2.slice(f2), f2 += t2[1].length), R2 && this.rules.other.blankLine.test(h3) && (u2 += h3 + `
`, e2 = e2.substring(h3.length + 1), p2 = true), !p2) {
            let H = this.rules.other.nextBulletRegex(f2), ee = this.rules.other.hrRegex(f2), te = this.rules.other.fencesBeginRegex(f2), ne = this.rules.other.headingBeginRegex(f2), xe = this.rules.other.htmlBeginRegex(f2);
            for (; e2; ) {
              let Z2 = e2.split(`
`, 1)[0], A;
              if (h3 = Z2, this.options.pedantic ? (h3 = h3.replace(this.rules.other.listReplaceNesting, "  "), A = h3) : A = h3.replace(this.rules.other.tabCharGlobal, "    "), te.test(h3) || ne.test(h3) || xe.test(h3) || H.test(h3) || ee.test(h3)) break;
              if (A.search(this.rules.other.nonSpaceChar) >= f2 || !h3.trim()) c2 += `
` + A.slice(f2);
              else {
                if (R2 || g2.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || te.test(g2) || ne.test(g2) || ee.test(g2)) break;
                c2 += `
` + h3;
              }
              !R2 && !h3.trim() && (R2 = true), u2 += Z2 + `
`, e2 = e2.substring(Z2.length + 1), g2 = A.slice(f2);
            }
          }
          i2.loose || (a2 ? i2.loose = true : this.rules.other.doubleBlankLine.test(u2) && (a2 = true));
          let O = null, Y2;
          this.options.gfm && (O = this.rules.other.listIsTask.exec(c2), O && (Y2 = O[0] !== "[ ] ", c2 = c2.replace(this.rules.other.listReplaceTask, ""))), i2.items.push({ type: "list_item", raw: u2, task: !!O, checked: Y2, loose: false, text: c2, tokens: [] }), i2.raw += u2;
        }
        let o2 = i2.items.at(-1);
        if (o2) o2.raw = o2.raw.trimEnd(), o2.text = o2.text.trimEnd();
        else return;
        i2.raw = i2.raw.trimEnd();
        for (let p2 = 0; p2 < i2.items.length; p2++) if (this.lexer.state.top = false, i2.items[p2].tokens = this.lexer.blockTokens(i2.items[p2].text, []), !i2.loose) {
          let u2 = i2.items[p2].tokens.filter((g2) => g2.type === "space"), c2 = u2.length > 0 && u2.some((g2) => this.rules.other.anyLine.test(g2.raw));
          i2.loose = c2;
        }
        if (i2.loose) for (let p2 = 0; p2 < i2.items.length; p2++) i2.items[p2].loose = true;
        return i2;
      }
    }
    html(e2) {
      let t2 = this.rules.block.html.exec(e2);
      if (t2) return { type: "html", block: true, raw: t2[0], pre: t2[1] === "pre" || t2[1] === "script" || t2[1] === "style", text: t2[0] };
    }
    def(e2) {
      let t2 = this.rules.block.def.exec(e2);
      if (t2) {
        let n2 = t2[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r2 = t2[2] ? t2[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i2 = t2[3] ? t2[3].substring(1, t2[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t2[3];
        return { type: "def", tag: n2, raw: t2[0], href: r2, title: i2 };
      }
    }
    table(e2) {
      let t2 = this.rules.block.table.exec(e2);
      if (!t2 || !this.rules.other.tableDelimiter.test(t2[2])) return;
      let n2 = V2(t2[1]), r2 = t2[2].replace(this.rules.other.tableAlignChars, "").split("|"), i2 = t2[3]?.trim() ? t2[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s2 = { type: "table", raw: t2[0], header: [], align: [], rows: [] };
      if (n2.length === r2.length) {
        for (let a2 of r2) this.rules.other.tableAlignRight.test(a2) ? s2.align.push("right") : this.rules.other.tableAlignCenter.test(a2) ? s2.align.push("center") : this.rules.other.tableAlignLeft.test(a2) ? s2.align.push("left") : s2.align.push(null);
        for (let a2 = 0; a2 < n2.length; a2++) s2.header.push({ text: n2[a2], tokens: this.lexer.inline(n2[a2]), header: true, align: s2.align[a2] });
        for (let a2 of i2) s2.rows.push(V2(a2, s2.header.length).map((o2, p2) => ({ text: o2, tokens: this.lexer.inline(o2), header: false, align: s2.align[p2] })));
        return s2;
      }
    }
    lheading(e2) {
      let t2 = this.rules.block.lheading.exec(e2);
      if (t2) return { type: "heading", raw: t2[0], depth: t2[2].charAt(0) === "=" ? 1 : 2, text: t2[1], tokens: this.lexer.inline(t2[1]) };
    }
    paragraph(e2) {
      let t2 = this.rules.block.paragraph.exec(e2);
      if (t2) {
        let n2 = t2[1].charAt(t2[1].length - 1) === `
` ? t2[1].slice(0, -1) : t2[1];
        return { type: "paragraph", raw: t2[0], text: n2, tokens: this.lexer.inline(n2) };
      }
    }
    text(e2) {
      let t2 = this.rules.block.text.exec(e2);
      if (t2) return { type: "text", raw: t2[0], text: t2[0], tokens: this.lexer.inline(t2[0]) };
    }
    escape(e2) {
      let t2 = this.rules.inline.escape.exec(e2);
      if (t2) return { type: "escape", raw: t2[0], text: t2[1] };
    }
    tag(e2) {
      let t2 = this.rules.inline.tag.exec(e2);
      if (t2) return !this.lexer.state.inLink && this.rules.other.startATag.test(t2[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t2[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t2[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t2[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: t2[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: t2[0] };
    }
    link(e2) {
      let t2 = this.rules.inline.link.exec(e2);
      if (t2) {
        let n2 = t2[2].trim();
        if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n2)) {
          if (!this.rules.other.endAngleBracket.test(n2)) return;
          let s2 = z(n2.slice(0, -1), "\\");
          if ((n2.length - s2.length) % 2 === 0) return;
        } else {
          let s2 = fe(t2[2], "()");
          if (s2 === -2) return;
          if (s2 > -1) {
            let o2 = (t2[0].indexOf("!") === 0 ? 5 : 4) + t2[1].length + s2;
            t2[2] = t2[2].substring(0, s2), t2[0] = t2[0].substring(0, o2).trim(), t2[3] = "";
          }
        }
        let r2 = t2[2], i2 = "";
        if (this.options.pedantic) {
          let s2 = this.rules.other.pedanticHrefTitle.exec(r2);
          s2 && (r2 = s2[1], i2 = s2[3]);
        } else i2 = t2[3] ? t2[3].slice(1, -1) : "";
        return r2 = r2.trim(), this.rules.other.startAngleBracket.test(r2) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n2) ? r2 = r2.slice(1) : r2 = r2.slice(1, -1)), me(t2, { href: r2 && r2.replace(this.rules.inline.anyPunctuation, "$1"), title: i2 && i2.replace(this.rules.inline.anyPunctuation, "$1") }, t2[0], this.lexer, this.rules);
      }
    }
    reflink(e2, t2) {
      let n2;
      if ((n2 = this.rules.inline.reflink.exec(e2)) || (n2 = this.rules.inline.nolink.exec(e2))) {
        let r2 = (n2[2] || n2[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i2 = t2[r2.toLowerCase()];
        if (!i2) {
          let s2 = n2[0].charAt(0);
          return { type: "text", raw: s2, text: s2 };
        }
        return me(n2, i2, n2[0], this.lexer, this.rules);
      }
    }
    emStrong(e2, t2, n2 = "") {
      let r2 = this.rules.inline.emStrongLDelim.exec(e2);
      if (!r2 || r2[3] && n2.match(this.rules.other.unicodeAlphaNumeric)) return;
      if (!(r2[1] || r2[2] || "") || !n2 || this.rules.inline.punctuation.exec(n2)) {
        let s2 = [...r2[0]].length - 1, a2, o2, p2 = s2, u2 = 0, c2 = r2[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        for (c2.lastIndex = 0, t2 = t2.slice(-1 * e2.length + s2); (r2 = c2.exec(t2)) != null; ) {
          if (a2 = r2[1] || r2[2] || r2[3] || r2[4] || r2[5] || r2[6], !a2) continue;
          if (o2 = [...a2].length, r2[3] || r2[4]) {
            p2 += o2;
            continue;
          } else if ((r2[5] || r2[6]) && s2 % 3 && !((s2 + o2) % 3)) {
            u2 += o2;
            continue;
          }
          if (p2 -= o2, p2 > 0) continue;
          o2 = Math.min(o2, o2 + p2 + u2);
          let g2 = [...r2[0]][0].length, h3 = e2.slice(0, s2 + r2.index + g2 + o2);
          if (Math.min(s2, o2) % 2) {
            let f2 = h3.slice(1, -1);
            return { type: "em", raw: h3, text: f2, tokens: this.lexer.inlineTokens(f2) };
          }
          let R2 = h3.slice(2, -2);
          return { type: "strong", raw: h3, text: R2, tokens: this.lexer.inlineTokens(R2) };
        }
      }
    }
    codespan(e2) {
      let t2 = this.rules.inline.code.exec(e2);
      if (t2) {
        let n2 = t2[2].replace(this.rules.other.newLineCharGlobal, " "), r2 = this.rules.other.nonSpaceChar.test(n2), i2 = this.rules.other.startingSpaceChar.test(n2) && this.rules.other.endingSpaceChar.test(n2);
        return r2 && i2 && (n2 = n2.substring(1, n2.length - 1)), { type: "codespan", raw: t2[0], text: n2 };
      }
    }
    br(e2) {
      let t2 = this.rules.inline.br.exec(e2);
      if (t2) return { type: "br", raw: t2[0] };
    }
    del(e2) {
      let t2 = this.rules.inline.del.exec(e2);
      if (t2) return { type: "del", raw: t2[0], text: t2[2], tokens: this.lexer.inlineTokens(t2[2]) };
    }
    autolink(e2) {
      let t2 = this.rules.inline.autolink.exec(e2);
      if (t2) {
        let n2, r2;
        return t2[2] === "@" ? (n2 = t2[1], r2 = "mailto:" + n2) : (n2 = t2[1], r2 = n2), { type: "link", raw: t2[0], text: n2, href: r2, tokens: [{ type: "text", raw: n2, text: n2 }] };
      }
    }
    url(e2) {
      let t2;
      if (t2 = this.rules.inline.url.exec(e2)) {
        let n2, r2;
        if (t2[2] === "@") n2 = t2[0], r2 = "mailto:" + n2;
        else {
          let i2;
          do
            i2 = t2[0], t2[0] = this.rules.inline._backpedal.exec(t2[0])?.[0] ?? "";
          while (i2 !== t2[0]);
          n2 = t2[0], t2[1] === "www." ? r2 = "http://" + t2[0] : r2 = t2[0];
        }
        return { type: "link", raw: t2[0], text: n2, href: r2, tokens: [{ type: "text", raw: n2, text: n2 }] };
      }
    }
    inlineText(e2) {
      let t2 = this.rules.inline.text.exec(e2);
      if (t2) {
        let n2 = this.lexer.state.inRawBlock;
        return { type: "text", raw: t2[0], text: t2[0], escaped: n2 };
      }
    }
  };
  var x = class l2 {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(e2) {
      this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e2 || T, this.options.tokenizer = this.options.tokenizer || new y2(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
      let t2 = { other: m, block: C.normal, inline: M.normal };
      this.options.pedantic ? (t2.block = C.pedantic, t2.inline = M.pedantic) : this.options.gfm && (t2.block = C.gfm, this.options.breaks ? t2.inline = M.breaks : t2.inline = M.gfm), this.tokenizer.rules = t2;
    }
    static get rules() {
      return { block: C, inline: M };
    }
    static lex(e2, t2) {
      return new l2(t2).lex(e2);
    }
    static lexInline(e2, t2) {
      return new l2(t2).inlineTokens(e2);
    }
    lex(e2) {
      e2 = e2.replace(m.carriageReturn, `
`), this.blockTokens(e2, this.tokens);
      for (let t2 = 0; t2 < this.inlineQueue.length; t2++) {
        let n2 = this.inlineQueue[t2];
        this.inlineTokens(n2.src, n2.tokens);
      }
      return this.inlineQueue = [], this.tokens;
    }
    blockTokens(e2, t2 = [], n2 = false) {
      for (this.options.pedantic && (e2 = e2.replace(m.tabCharGlobal, "    ").replace(m.spaceLine, "")); e2; ) {
        let r2;
        if (this.options.extensions?.block?.some((s2) => (r2 = s2.call({ lexer: this }, e2, t2)) ? (e2 = e2.substring(r2.raw.length), t2.push(r2), true) : false)) continue;
        if (r2 = this.tokenizer.space(e2)) {
          e2 = e2.substring(r2.raw.length);
          let s2 = t2.at(-1);
          r2.raw.length === 1 && s2 !== void 0 ? s2.raw += `
` : t2.push(r2);
          continue;
        }
        if (r2 = this.tokenizer.code(e2)) {
          e2 = e2.substring(r2.raw.length);
          let s2 = t2.at(-1);
          s2?.type === "paragraph" || s2?.type === "text" ? (s2.raw += (s2.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s2.text += `
` + r2.text, this.inlineQueue.at(-1).src = s2.text) : t2.push(r2);
          continue;
        }
        if (r2 = this.tokenizer.fences(e2)) {
          e2 = e2.substring(r2.raw.length), t2.push(r2);
          continue;
        }
        if (r2 = this.tokenizer.heading(e2)) {
          e2 = e2.substring(r2.raw.length), t2.push(r2);
          continue;
        }
        if (r2 = this.tokenizer.hr(e2)) {
          e2 = e2.substring(r2.raw.length), t2.push(r2);
          continue;
        }
        if (r2 = this.tokenizer.blockquote(e2)) {
          e2 = e2.substring(r2.raw.length), t2.push(r2);
          continue;
        }
        if (r2 = this.tokenizer.list(e2)) {
          e2 = e2.substring(r2.raw.length), t2.push(r2);
          continue;
        }
        if (r2 = this.tokenizer.html(e2)) {
          e2 = e2.substring(r2.raw.length), t2.push(r2);
          continue;
        }
        if (r2 = this.tokenizer.def(e2)) {
          e2 = e2.substring(r2.raw.length);
          let s2 = t2.at(-1);
          s2?.type === "paragraph" || s2?.type === "text" ? (s2.raw += (s2.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s2.text += `
` + r2.raw, this.inlineQueue.at(-1).src = s2.text) : this.tokens.links[r2.tag] || (this.tokens.links[r2.tag] = { href: r2.href, title: r2.title }, t2.push(r2));
          continue;
        }
        if (r2 = this.tokenizer.table(e2)) {
          e2 = e2.substring(r2.raw.length), t2.push(r2);
          continue;
        }
        if (r2 = this.tokenizer.lheading(e2)) {
          e2 = e2.substring(r2.raw.length), t2.push(r2);
          continue;
        }
        let i2 = e2;
        if (this.options.extensions?.startBlock) {
          let s2 = 1 / 0, a2 = e2.slice(1), o2;
          this.options.extensions.startBlock.forEach((p2) => {
            o2 = p2.call({ lexer: this }, a2), typeof o2 == "number" && o2 >= 0 && (s2 = Math.min(s2, o2));
          }), s2 < 1 / 0 && s2 >= 0 && (i2 = e2.substring(0, s2 + 1));
        }
        if (this.state.top && (r2 = this.tokenizer.paragraph(i2))) {
          let s2 = t2.at(-1);
          n2 && s2?.type === "paragraph" ? (s2.raw += (s2.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s2.text += `
` + r2.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s2.text) : t2.push(r2), n2 = i2.length !== e2.length, e2 = e2.substring(r2.raw.length);
          continue;
        }
        if (r2 = this.tokenizer.text(e2)) {
          e2 = e2.substring(r2.raw.length);
          let s2 = t2.at(-1);
          s2?.type === "text" ? (s2.raw += (s2.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s2.text += `
` + r2.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s2.text) : t2.push(r2);
          continue;
        }
        if (e2) {
          let s2 = "Infinite loop on byte: " + e2.charCodeAt(0);
          if (this.options.silent) {
            console.error(s2);
            break;
          } else throw new Error(s2);
        }
      }
      return this.state.top = true, t2;
    }
    inline(e2, t2 = []) {
      return this.inlineQueue.push({ src: e2, tokens: t2 }), t2;
    }
    inlineTokens(e2, t2 = []) {
      let n2 = e2, r2 = null;
      if (this.tokens.links) {
        let o2 = Object.keys(this.tokens.links);
        if (o2.length > 0) for (; (r2 = this.tokenizer.rules.inline.reflinkSearch.exec(n2)) != null; ) o2.includes(r2[0].slice(r2[0].lastIndexOf("[") + 1, -1)) && (n2 = n2.slice(0, r2.index) + "[" + "a".repeat(r2[0].length - 2) + "]" + n2.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
      }
      for (; (r2 = this.tokenizer.rules.inline.anyPunctuation.exec(n2)) != null; ) n2 = n2.slice(0, r2.index) + "++" + n2.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      let i2;
      for (; (r2 = this.tokenizer.rules.inline.blockSkip.exec(n2)) != null; ) i2 = r2[2] ? r2[2].length : 0, n2 = n2.slice(0, r2.index + i2) + "[" + "a".repeat(r2[0].length - i2 - 2) + "]" + n2.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      n2 = this.options.hooks?.emStrongMask?.call({ lexer: this }, n2) ?? n2;
      let s2 = false, a2 = "";
      for (; e2; ) {
        s2 || (a2 = ""), s2 = false;
        let o2;
        if (this.options.extensions?.inline?.some((u2) => (o2 = u2.call({ lexer: this }, e2, t2)) ? (e2 = e2.substring(o2.raw.length), t2.push(o2), true) : false)) continue;
        if (o2 = this.tokenizer.escape(e2)) {
          e2 = e2.substring(o2.raw.length), t2.push(o2);
          continue;
        }
        if (o2 = this.tokenizer.tag(e2)) {
          e2 = e2.substring(o2.raw.length), t2.push(o2);
          continue;
        }
        if (o2 = this.tokenizer.link(e2)) {
          e2 = e2.substring(o2.raw.length), t2.push(o2);
          continue;
        }
        if (o2 = this.tokenizer.reflink(e2, this.tokens.links)) {
          e2 = e2.substring(o2.raw.length);
          let u2 = t2.at(-1);
          o2.type === "text" && u2?.type === "text" ? (u2.raw += o2.raw, u2.text += o2.text) : t2.push(o2);
          continue;
        }
        if (o2 = this.tokenizer.emStrong(e2, n2, a2)) {
          e2 = e2.substring(o2.raw.length), t2.push(o2);
          continue;
        }
        if (o2 = this.tokenizer.codespan(e2)) {
          e2 = e2.substring(o2.raw.length), t2.push(o2);
          continue;
        }
        if (o2 = this.tokenizer.br(e2)) {
          e2 = e2.substring(o2.raw.length), t2.push(o2);
          continue;
        }
        if (o2 = this.tokenizer.del(e2)) {
          e2 = e2.substring(o2.raw.length), t2.push(o2);
          continue;
        }
        if (o2 = this.tokenizer.autolink(e2)) {
          e2 = e2.substring(o2.raw.length), t2.push(o2);
          continue;
        }
        if (!this.state.inLink && (o2 = this.tokenizer.url(e2))) {
          e2 = e2.substring(o2.raw.length), t2.push(o2);
          continue;
        }
        let p2 = e2;
        if (this.options.extensions?.startInline) {
          let u2 = 1 / 0, c2 = e2.slice(1), g2;
          this.options.extensions.startInline.forEach((h3) => {
            g2 = h3.call({ lexer: this }, c2), typeof g2 == "number" && g2 >= 0 && (u2 = Math.min(u2, g2));
          }), u2 < 1 / 0 && u2 >= 0 && (p2 = e2.substring(0, u2 + 1));
        }
        if (o2 = this.tokenizer.inlineText(p2)) {
          e2 = e2.substring(o2.raw.length), o2.raw.slice(-1) !== "_" && (a2 = o2.raw.slice(-1)), s2 = true;
          let u2 = t2.at(-1);
          u2?.type === "text" ? (u2.raw += o2.raw, u2.text += o2.text) : t2.push(o2);
          continue;
        }
        if (e2) {
          let u2 = "Infinite loop on byte: " + e2.charCodeAt(0);
          if (this.options.silent) {
            console.error(u2);
            break;
          } else throw new Error(u2);
        }
      }
      return t2;
    }
  };
  var P = class {
    options;
    parser;
    constructor(e2) {
      this.options = e2 || T;
    }
    space(e2) {
      return "";
    }
    code({ text: e2, lang: t2, escaped: n2 }) {
      let r2 = (t2 || "").match(m.notSpaceStart)?.[0], i2 = e2.replace(m.endingNewline, "") + `
`;
      return r2 ? '<pre><code class="language-' + w2(r2) + '">' + (n2 ? i2 : w2(i2, true)) + `</code></pre>
` : "<pre><code>" + (n2 ? i2 : w2(i2, true)) + `</code></pre>
`;
    }
    blockquote({ tokens: e2 }) {
      return `<blockquote>
${this.parser.parse(e2)}</blockquote>
`;
    }
    html({ text: e2 }) {
      return e2;
    }
    def(e2) {
      return "";
    }
    heading({ tokens: e2, depth: t2 }) {
      return `<h${t2}>${this.parser.parseInline(e2)}</h${t2}>
`;
    }
    hr(e2) {
      return `<hr>
`;
    }
    list(e2) {
      let t2 = e2.ordered, n2 = e2.start, r2 = "";
      for (let a2 = 0; a2 < e2.items.length; a2++) {
        let o2 = e2.items[a2];
        r2 += this.listitem(o2);
      }
      let i2 = t2 ? "ol" : "ul", s2 = t2 && n2 !== 1 ? ' start="' + n2 + '"' : "";
      return "<" + i2 + s2 + `>
` + r2 + "</" + i2 + `>
`;
    }
    listitem(e2) {
      let t2 = "";
      if (e2.task) {
        let n2 = this.checkbox({ checked: !!e2.checked });
        e2.loose ? e2.tokens[0]?.type === "paragraph" ? (e2.tokens[0].text = n2 + " " + e2.tokens[0].text, e2.tokens[0].tokens && e2.tokens[0].tokens.length > 0 && e2.tokens[0].tokens[0].type === "text" && (e2.tokens[0].tokens[0].text = n2 + " " + w2(e2.tokens[0].tokens[0].text), e2.tokens[0].tokens[0].escaped = true)) : e2.tokens.unshift({ type: "text", raw: n2 + " ", text: n2 + " ", escaped: true }) : t2 += n2 + " ";
      }
      return t2 += this.parser.parse(e2.tokens, !!e2.loose), `<li>${t2}</li>
`;
    }
    checkbox({ checked: e2 }) {
      return "<input " + (e2 ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens: e2 }) {
      return `<p>${this.parser.parseInline(e2)}</p>
`;
    }
    table(e2) {
      let t2 = "", n2 = "";
      for (let i2 = 0; i2 < e2.header.length; i2++) n2 += this.tablecell(e2.header[i2]);
      t2 += this.tablerow({ text: n2 });
      let r2 = "";
      for (let i2 = 0; i2 < e2.rows.length; i2++) {
        let s2 = e2.rows[i2];
        n2 = "";
        for (let a2 = 0; a2 < s2.length; a2++) n2 += this.tablecell(s2[a2]);
        r2 += this.tablerow({ text: n2 });
      }
      return r2 && (r2 = `<tbody>${r2}</tbody>`), `<table>
<thead>
` + t2 + `</thead>
` + r2 + `</table>
`;
    }
    tablerow({ text: e2 }) {
      return `<tr>
${e2}</tr>
`;
    }
    tablecell(e2) {
      let t2 = this.parser.parseInline(e2.tokens), n2 = e2.header ? "th" : "td";
      return (e2.align ? `<${n2} align="${e2.align}">` : `<${n2}>`) + t2 + `</${n2}>
`;
    }
    strong({ tokens: e2 }) {
      return `<strong>${this.parser.parseInline(e2)}</strong>`;
    }
    em({ tokens: e2 }) {
      return `<em>${this.parser.parseInline(e2)}</em>`;
    }
    codespan({ text: e2 }) {
      return `<code>${w2(e2, true)}</code>`;
    }
    br(e2) {
      return "<br>";
    }
    del({ tokens: e2 }) {
      return `<del>${this.parser.parseInline(e2)}</del>`;
    }
    link({ href: e2, title: t2, tokens: n2 }) {
      let r2 = this.parser.parseInline(n2), i2 = J(e2);
      if (i2 === null) return r2;
      e2 = i2;
      let s2 = '<a href="' + e2 + '"';
      return t2 && (s2 += ' title="' + w2(t2) + '"'), s2 += ">" + r2 + "</a>", s2;
    }
    image({ href: e2, title: t2, text: n2, tokens: r2 }) {
      r2 && (n2 = this.parser.parseInline(r2, this.parser.textRenderer));
      let i2 = J(e2);
      if (i2 === null) return w2(n2);
      e2 = i2;
      let s2 = `<img src="${e2}" alt="${n2}"`;
      return t2 && (s2 += ` title="${w2(t2)}"`), s2 += ">", s2;
    }
    text(e2) {
      return "tokens" in e2 && e2.tokens ? this.parser.parseInline(e2.tokens) : "escaped" in e2 && e2.escaped ? e2.text : w2(e2.text);
    }
  };
  var $2 = class {
    strong({ text: e2 }) {
      return e2;
    }
    em({ text: e2 }) {
      return e2;
    }
    codespan({ text: e2 }) {
      return e2;
    }
    del({ text: e2 }) {
      return e2;
    }
    html({ text: e2 }) {
      return e2;
    }
    text({ text: e2 }) {
      return e2;
    }
    link({ text: e2 }) {
      return "" + e2;
    }
    image({ text: e2 }) {
      return "" + e2;
    }
    br() {
      return "";
    }
  };
  var b2 = class l3 {
    options;
    renderer;
    textRenderer;
    constructor(e2) {
      this.options = e2 || T, this.options.renderer = this.options.renderer || new P(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new $2();
    }
    static parse(e2, t2) {
      return new l3(t2).parse(e2);
    }
    static parseInline(e2, t2) {
      return new l3(t2).parseInline(e2);
    }
    parse(e2, t2 = true) {
      let n2 = "";
      for (let r2 = 0; r2 < e2.length; r2++) {
        let i2 = e2[r2];
        if (this.options.extensions?.renderers?.[i2.type]) {
          let a2 = i2, o2 = this.options.extensions.renderers[a2.type].call({ parser: this }, a2);
          if (o2 !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(a2.type)) {
            n2 += o2 || "";
            continue;
          }
        }
        let s2 = i2;
        switch (s2.type) {
          case "space": {
            n2 += this.renderer.space(s2);
            continue;
          }
          case "hr": {
            n2 += this.renderer.hr(s2);
            continue;
          }
          case "heading": {
            n2 += this.renderer.heading(s2);
            continue;
          }
          case "code": {
            n2 += this.renderer.code(s2);
            continue;
          }
          case "table": {
            n2 += this.renderer.table(s2);
            continue;
          }
          case "blockquote": {
            n2 += this.renderer.blockquote(s2);
            continue;
          }
          case "list": {
            n2 += this.renderer.list(s2);
            continue;
          }
          case "html": {
            n2 += this.renderer.html(s2);
            continue;
          }
          case "def": {
            n2 += this.renderer.def(s2);
            continue;
          }
          case "paragraph": {
            n2 += this.renderer.paragraph(s2);
            continue;
          }
          case "text": {
            let a2 = s2, o2 = this.renderer.text(a2);
            for (; r2 + 1 < e2.length && e2[r2 + 1].type === "text"; ) a2 = e2[++r2], o2 += `
` + this.renderer.text(a2);
            t2 ? n2 += this.renderer.paragraph({ type: "paragraph", raw: o2, text: o2, tokens: [{ type: "text", raw: o2, text: o2, escaped: true }] }) : n2 += o2;
            continue;
          }
          default: {
            let a2 = 'Token with "' + s2.type + '" type was not found.';
            if (this.options.silent) return console.error(a2), "";
            throw new Error(a2);
          }
        }
      }
      return n2;
    }
    parseInline(e2, t2 = this.renderer) {
      let n2 = "";
      for (let r2 = 0; r2 < e2.length; r2++) {
        let i2 = e2[r2];
        if (this.options.extensions?.renderers?.[i2.type]) {
          let a2 = this.options.extensions.renderers[i2.type].call({ parser: this }, i2);
          if (a2 !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i2.type)) {
            n2 += a2 || "";
            continue;
          }
        }
        let s2 = i2;
        switch (s2.type) {
          case "escape": {
            n2 += t2.text(s2);
            break;
          }
          case "html": {
            n2 += t2.html(s2);
            break;
          }
          case "link": {
            n2 += t2.link(s2);
            break;
          }
          case "image": {
            n2 += t2.image(s2);
            break;
          }
          case "strong": {
            n2 += t2.strong(s2);
            break;
          }
          case "em": {
            n2 += t2.em(s2);
            break;
          }
          case "codespan": {
            n2 += t2.codespan(s2);
            break;
          }
          case "br": {
            n2 += t2.br(s2);
            break;
          }
          case "del": {
            n2 += t2.del(s2);
            break;
          }
          case "text": {
            n2 += t2.text(s2);
            break;
          }
          default: {
            let a2 = 'Token with "' + s2.type + '" type was not found.';
            if (this.options.silent) return console.error(a2), "";
            throw new Error(a2);
          }
        }
      }
      return n2;
    }
  };
  var S = class {
    options;
    block;
    constructor(e2) {
      this.options = e2 || T;
    }
    static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
    static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
    preprocess(e2) {
      return e2;
    }
    postprocess(e2) {
      return e2;
    }
    processAllTokens(e2) {
      return e2;
    }
    emStrongMask(e2) {
      return e2;
    }
    provideLexer() {
      return this.block ? x.lex : x.lexInline;
    }
    provideParser() {
      return this.block ? b2.parse : b2.parseInline;
    }
  };
  var B = class {
    defaults = L();
    options = this.setOptions;
    parse = this.parseMarkdown(true);
    parseInline = this.parseMarkdown(false);
    Parser = b2;
    Renderer = P;
    TextRenderer = $2;
    Lexer = x;
    Tokenizer = y2;
    Hooks = S;
    constructor(...e2) {
      this.use(...e2);
    }
    walkTokens(e2, t2) {
      let n2 = [];
      for (let r2 of e2) switch (n2 = n2.concat(t2.call(this, r2)), r2.type) {
        case "table": {
          let i2 = r2;
          for (let s2 of i2.header) n2 = n2.concat(this.walkTokens(s2.tokens, t2));
          for (let s2 of i2.rows) for (let a2 of s2) n2 = n2.concat(this.walkTokens(a2.tokens, t2));
          break;
        }
        case "list": {
          let i2 = r2;
          n2 = n2.concat(this.walkTokens(i2.items, t2));
          break;
        }
        default: {
          let i2 = r2;
          this.defaults.extensions?.childTokens?.[i2.type] ? this.defaults.extensions.childTokens[i2.type].forEach((s2) => {
            let a2 = i2[s2].flat(1 / 0);
            n2 = n2.concat(this.walkTokens(a2, t2));
          }) : i2.tokens && (n2 = n2.concat(this.walkTokens(i2.tokens, t2)));
        }
      }
      return n2;
    }
    use(...e2) {
      let t2 = this.defaults.extensions || { renderers: {}, childTokens: {} };
      return e2.forEach((n2) => {
        let r2 = { ...n2 };
        if (r2.async = this.defaults.async || r2.async || false, n2.extensions && (n2.extensions.forEach((i2) => {
          if (!i2.name) throw new Error("extension name required");
          if ("renderer" in i2) {
            let s2 = t2.renderers[i2.name];
            s2 ? t2.renderers[i2.name] = function(...a2) {
              let o2 = i2.renderer.apply(this, a2);
              return o2 === false && (o2 = s2.apply(this, a2)), o2;
            } : t2.renderers[i2.name] = i2.renderer;
          }
          if ("tokenizer" in i2) {
            if (!i2.level || i2.level !== "block" && i2.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
            let s2 = t2[i2.level];
            s2 ? s2.unshift(i2.tokenizer) : t2[i2.level] = [i2.tokenizer], i2.start && (i2.level === "block" ? t2.startBlock ? t2.startBlock.push(i2.start) : t2.startBlock = [i2.start] : i2.level === "inline" && (t2.startInline ? t2.startInline.push(i2.start) : t2.startInline = [i2.start]));
          }
          "childTokens" in i2 && i2.childTokens && (t2.childTokens[i2.name] = i2.childTokens);
        }), r2.extensions = t2), n2.renderer) {
          let i2 = this.defaults.renderer || new P(this.defaults);
          for (let s2 in n2.renderer) {
            if (!(s2 in i2)) throw new Error(`renderer '${s2}' does not exist`);
            if (["options", "parser"].includes(s2)) continue;
            let a2 = s2, o2 = n2.renderer[a2], p2 = i2[a2];
            i2[a2] = (...u2) => {
              let c2 = o2.apply(i2, u2);
              return c2 === false && (c2 = p2.apply(i2, u2)), c2 || "";
            };
          }
          r2.renderer = i2;
        }
        if (n2.tokenizer) {
          let i2 = this.defaults.tokenizer || new y2(this.defaults);
          for (let s2 in n2.tokenizer) {
            if (!(s2 in i2)) throw new Error(`tokenizer '${s2}' does not exist`);
            if (["options", "rules", "lexer"].includes(s2)) continue;
            let a2 = s2, o2 = n2.tokenizer[a2], p2 = i2[a2];
            i2[a2] = (...u2) => {
              let c2 = o2.apply(i2, u2);
              return c2 === false && (c2 = p2.apply(i2, u2)), c2;
            };
          }
          r2.tokenizer = i2;
        }
        if (n2.hooks) {
          let i2 = this.defaults.hooks || new S();
          for (let s2 in n2.hooks) {
            if (!(s2 in i2)) throw new Error(`hook '${s2}' does not exist`);
            if (["options", "block"].includes(s2)) continue;
            let a2 = s2, o2 = n2.hooks[a2], p2 = i2[a2];
            S.passThroughHooks.has(s2) ? i2[a2] = (u2) => {
              if (this.defaults.async && S.passThroughHooksRespectAsync.has(s2)) return (async () => {
                let g2 = await o2.call(i2, u2);
                return p2.call(i2, g2);
              })();
              let c2 = o2.call(i2, u2);
              return p2.call(i2, c2);
            } : i2[a2] = (...u2) => {
              if (this.defaults.async) return (async () => {
                let g2 = await o2.apply(i2, u2);
                return g2 === false && (g2 = await p2.apply(i2, u2)), g2;
              })();
              let c2 = o2.apply(i2, u2);
              return c2 === false && (c2 = p2.apply(i2, u2)), c2;
            };
          }
          r2.hooks = i2;
        }
        if (n2.walkTokens) {
          let i2 = this.defaults.walkTokens, s2 = n2.walkTokens;
          r2.walkTokens = function(a2) {
            let o2 = [];
            return o2.push(s2.call(this, a2)), i2 && (o2 = o2.concat(i2.call(this, a2))), o2;
          };
        }
        this.defaults = { ...this.defaults, ...r2 };
      }), this;
    }
    setOptions(e2) {
      return this.defaults = { ...this.defaults, ...e2 }, this;
    }
    lexer(e2, t2) {
      return x.lex(e2, t2 ?? this.defaults);
    }
    parser(e2, t2) {
      return b2.parse(e2, t2 ?? this.defaults);
    }
    parseMarkdown(e2) {
      return (n2, r2) => {
        let i2 = { ...r2 }, s2 = { ...this.defaults, ...i2 }, a2 = this.onError(!!s2.silent, !!s2.async);
        if (this.defaults.async === true && i2.async === false) return a2(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        if (typeof n2 > "u" || n2 === null) return a2(new Error("marked(): input parameter is undefined or null"));
        if (typeof n2 != "string") return a2(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n2) + ", string expected"));
        if (s2.hooks && (s2.hooks.options = s2, s2.hooks.block = e2), s2.async) return (async () => {
          let o2 = s2.hooks ? await s2.hooks.preprocess(n2) : n2, u2 = await (s2.hooks ? await s2.hooks.provideLexer() : e2 ? x.lex : x.lexInline)(o2, s2), c2 = s2.hooks ? await s2.hooks.processAllTokens(u2) : u2;
          s2.walkTokens && await Promise.all(this.walkTokens(c2, s2.walkTokens));
          let h3 = await (s2.hooks ? await s2.hooks.provideParser() : e2 ? b2.parse : b2.parseInline)(c2, s2);
          return s2.hooks ? await s2.hooks.postprocess(h3) : h3;
        })().catch(a2);
        try {
          s2.hooks && (n2 = s2.hooks.preprocess(n2));
          let p2 = (s2.hooks ? s2.hooks.provideLexer() : e2 ? x.lex : x.lexInline)(n2, s2);
          s2.hooks && (p2 = s2.hooks.processAllTokens(p2)), s2.walkTokens && this.walkTokens(p2, s2.walkTokens);
          let c2 = (s2.hooks ? s2.hooks.provideParser() : e2 ? b2.parse : b2.parseInline)(p2, s2);
          return s2.hooks && (c2 = s2.hooks.postprocess(c2)), c2;
        } catch (o2) {
          return a2(o2);
        }
      };
    }
    onError(e2, t2) {
      return (n2) => {
        if (n2.message += `
Please report this to https://github.com/markedjs/marked.`, e2) {
          let r2 = "<p>An error occurred:</p><pre>" + w2(n2.message + "", true) + "</pre>";
          return t2 ? Promise.resolve(r2) : r2;
        }
        if (t2) return Promise.reject(n2);
        throw n2;
      };
    }
  };
  var _2 = new B();
  function k(l4, e2) {
    return _2.parse(l4, e2);
  }
  k.options = k.setOptions = function(l4) {
    return _2.setOptions(l4), k.defaults = _2.defaults, G2(k.defaults), k;
  };
  k.getDefaults = L;
  k.defaults = T;
  k.use = function(...l4) {
    return _2.use(...l4), k.defaults = _2.defaults, G2(k.defaults), k;
  };
  k.walkTokens = function(l4, e2) {
    return _2.walkTokens(l4, e2);
  };
  k.parseInline = _2.parseInline;
  k.Parser = b2;
  k.parser = b2.parse;
  k.Renderer = P;
  k.TextRenderer = $2;
  k.Lexer = x;
  k.lexer = x.lex;
  k.Tokenizer = y2;
  k.Hooks = S;
  k.parse = k;
  var Zt = k.options;
  var Gt = k.setOptions;
  var Nt = k.use;
  var Ft = k.walkTokens;
  var jt = k.parseInline;
  var Ut = b2.parse;
  var Kt = x.lex;

  // node_modules/@37signals/lexxy/dist/lexxy.esm.js
  window.Prism = window.Prism || {};
  window.Prism.manual = true;
  function deepMerge(target, source) {
    const result = { ...target, ...source };
    for (const [key, value] of Object.entries(source)) {
      if (arePlainHashes(target[key], value)) {
        result[key] = deepMerge(target[key], value);
      }
    }
    return result;
  }
  function arePlainHashes(...values) {
    return values.every((value) => value && value.constructor == Object);
  }
  var Configuration = class {
    #tree = {};
    constructor(...configs) {
      this.merge(...configs);
    }
    merge(...configs) {
      return this.#tree = configs.reduce(deepMerge, this.#tree);
    }
    get(path) {
      const keys = path.split(".");
      return keys.reduce((node, key) => node[key], this.#tree);
    }
  };
  function range(from2, to2) {
    return [...Array(1 + to2 - from2).keys()].map((i2) => i2 + from2);
  }
  var global2 = new Configuration({
    attachmentTagName: "action-text-attachment",
    attachmentContentTypeNamespace: "actiontext",
    authenticatedUploads: false,
    extensions: []
  });
  var presets = new Configuration({
    default: {
      attachments: true,
      markdown: true,
      multiLine: true,
      richText: true,
      toolbar: true,
      highlight: {
        buttons: {
          color: range(1, 9).map((n2) => `var(--highlight-${n2})`),
          "background-color": range(1, 9).map((n2) => `var(--highlight-bg-${n2})`)
        },
        permit: {
          color: [],
          "background-color": []
        }
      }
    }
  });
  var Lexxy = {
    global: global2,
    presets,
    configure({ global: newGlobal, ...newPresets }) {
      if (newGlobal) {
        global2.merge(newGlobal);
      }
      presets.merge(newPresets);
    }
  };
  var ALLOWED_HTML_TAGS = [
    "a",
    "b",
    "blockquote",
    "br",
    "code",
    "em",
    "figcaption",
    "figure",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    "li",
    "mark",
    "ol",
    "p",
    "pre",
    "q",
    "s",
    "strong",
    "ul",
    "table",
    "tbody",
    "tr",
    "th",
    "td"
  ];
  var ALLOWED_HTML_ATTRIBUTES = [
    "alt",
    "caption",
    "class",
    "content",
    "content-type",
    "contenteditable",
    "data-direct-upload-id",
    "data-sgid",
    "filename",
    "filesize",
    "height",
    "href",
    "presentation",
    "previewable",
    "sgid",
    "src",
    "style",
    "title",
    "url",
    "width"
  ];
  var ALLOWED_STYLE_PROPERTIES = ["color", "background-color"];
  function styleFilterHook(_currentNode, hookEvent) {
    if (hookEvent.attrName === "style" && hookEvent.attrValue) {
      const styles = { ...getStyleObjectFromCSS2(hookEvent.attrValue) };
      const sanitizedStyles = {};
      for (const property in styles) {
        if (ALLOWED_STYLE_PROPERTIES.includes(property)) {
          sanitizedStyles[property] = styles[property];
        }
      }
      if (Object.keys(sanitizedStyles).length) {
        hookEvent.attrValue = getCSSFromStyleObject2(sanitizedStyles);
      } else {
        hookEvent.keepAttr = false;
      }
    }
  }
  purify.addHook("uponSanitizeAttribute", styleFilterHook);
  purify.addHook("uponSanitizeElement", (node, data2) => {
    if (data2.tagName === "strong" || data2.tagName === "em") {
      node.removeAttribute("class");
    }
  });
  function buildConfig() {
    return {
      ALLOWED_TAGS: ALLOWED_HTML_TAGS.concat(Lexxy.global.get("attachmentTagName")),
      ALLOWED_ATTR: ALLOWED_HTML_ATTRIBUTES,
      ADD_URI_SAFE_ATTR: ["caption", "filename"],
      SAFE_FOR_XML: false
      // So that it does not strip attributes that contains serialized HTML (like content)
    };
  }
  function getNonce() {
    const element = document.head.querySelector("meta[name=csp-nonce]");
    return element?.content;
  }
  function getNearestListItemNode(node) {
    let current = node;
    while (current !== null) {
      if ($isListItemNode2(current)) return current;
      current = current.getParent();
    }
    return null;
  }
  function getListType(node) {
    let current = node;
    while (current) {
      if ($isListNode2(current)) {
        return current.getListType();
      }
      current = current.getParent();
    }
    return null;
  }
  function isPrintableCharacter(event) {
    if (event.ctrlKey || event.metaKey || event.altKey) return false;
    if (event.key.length > 1 && event.key !== "Enter" && event.key !== "Space") return false;
    return event.key.length === 1;
  }
  function extendTextNodeConversion(conversionName, ...callbacks) {
    return extendConversion(TextNode2, conversionName, (conversionOutput, element) => ({
      ...conversionOutput,
      forChild: (lexicalNode, parentNode) => {
        const originalForChild = conversionOutput?.forChild ?? ((x2) => x2);
        let childNode = originalForChild(lexicalNode, parentNode);
        if ($isTextNode2(childNode)) {
          childNode = callbacks.reduce(
            (childNode2, callback2) => callback2(childNode2, element) ?? childNode2,
            childNode
          );
          return childNode;
        }
      }
    }));
  }
  function extendConversion(nodeKlass, conversionName, callback2 = (output) => output) {
    return (element) => {
      const converter = nodeKlass.importDOM()?.[conversionName]?.(element);
      if (!converter) return null;
      const conversionOutput = converter.conversion(element);
      if (!conversionOutput) return conversionOutput;
      return callback2(conversionOutput, element) ?? conversionOutput;
    };
  }
  function isSelectionHighlighted(selection) {
    if (!$isRangeSelection2(selection)) return false;
    if (selection.isCollapsed()) {
      return hasHighlightStyles(selection.style);
    } else {
      return selection.hasFormat("highlight");
    }
  }
  function hasHighlightStyles(cssOrStyles) {
    const styles = typeof cssOrStyles === "string" ? getStyleObjectFromCSS2(cssOrStyles) : cssOrStyles;
    return !!(styles.color || styles["background-color"]);
  }
  var StyleCanonicalizer = class {
    constructor(property, allowedValues = []) {
      this._property = property;
      this._allowedValues = allowedValues;
      this._canonicalValues = this.#allowedValuesIdentityObject;
    }
    applyCanonicalization(css) {
      const styles = { ...getStyleObjectFromCSS2(css) };
      styles[this._property] = this.getCanonicalAllowedValue(styles[this._property]);
      if (!styles[this._property]) {
        delete styles[this._property];
      }
      return getCSSFromStyleObject2(styles);
    }
    getCanonicalAllowedValue(value) {
      return this._canonicalValues[value] ||= this.#resolveCannonicalValue(value);
    }
    // Private
    get #allowedValuesIdentityObject() {
      return this._allowedValues.reduce((object, value) => ({ ...object, [value]: value }), {});
    }
    #resolveCannonicalValue(value) {
      let index2 = this.#computedAllowedValues.indexOf(value);
      index2 ||= this.#computedAllowedValues.indexOf(getComputedStyleForProperty(this._property, value));
      return index2 === -1 ? null : this._allowedValues[index2];
    }
    get #computedAllowedValues() {
      return this._computedAllowedValues ||= this._allowedValues.map(
        (value) => getComputedStyleForProperty(this._property, value)
      );
    }
  };
  function getComputedStyleForProperty(property, value) {
    const style = `${property}: ${value};`;
    const element = document.body.appendChild(createElement("span", { style: "display: none;" + style }));
    const computedStyle = window.getComputedStyle(element).getPropertyValue(property);
    element.remove();
    return computedStyle;
  }
  function handleRollingTabIndex(elements2, event) {
    const previousActiveElement = document.activeElement;
    if (elements2.includes(previousActiveElement)) {
      const finder = new NextElementFinder(elements2, event.key);
      if (finder.selectNext(previousActiveElement)) {
        event.preventDefault();
      }
    }
  }
  var NextElementFinder = class {
    constructor(elements2, key) {
      this.elements = elements2;
      this.key = key;
    }
    selectNext(fromElement) {
      const nextElement = this.#findNextElement(fromElement);
      if (nextElement) {
        const inactiveElements = this.elements.filter((element) => element !== nextElement);
        this.#unsetTabIndex(inactiveElements);
        this.#focusWithActiveTabIndex(nextElement);
        return true;
      }
      return false;
    }
    #findNextElement(fromElement) {
      switch (this.key) {
        case "ArrowRight":
        case "ArrowDown":
          return this.#findNextSibling(fromElement);
        case "ArrowLeft":
        case "ArrowUp":
          return this.#findPreviousSibling(fromElement);
        case "Home":
          return this.#findFirst();
        case "End":
          return this.#findLast();
      }
    }
    #findFirst(elements2 = this.elements) {
      return elements2.find(isActiveAndVisible);
    }
    #findLast(elements2 = this.elements) {
      return elements2.findLast(isActiveAndVisible);
    }
    #findNextSibling(element) {
      const afterElements = this.elements.slice(this.#indexOf(element) + 1);
      return this.#findFirst(afterElements);
    }
    #findPreviousSibling(element) {
      const beforeElements = this.elements.slice(0, this.#indexOf(element));
      return this.#findLast(beforeElements);
    }
    #indexOf(element) {
      return this.elements.indexOf(element);
    }
    #focusWithActiveTabIndex(element) {
      if (isActiveAndVisible(element)) {
        element.tabIndex = 0;
        element.focus();
      }
    }
    #unsetTabIndex(elements2) {
      elements2.forEach((element) => element.tabIndex = -1);
    }
  };
  function isActiveAndVisible(element) {
    return element && !element.disabled && element.checkVisibility();
  }
  var LexicalToolbarElement = class extends HTMLElement {
    static observedAttributes = ["connected"];
    constructor() {
      super();
      this.internals = this.attachInternals();
      this.internals.role = "toolbar";
      this.#createEditorPromise();
    }
    connectedCallback() {
      requestAnimationFrame(() => this.#refreshToolbarOverflow());
      this.setAttribute("role", "toolbar");
      this.#installResizeObserver();
    }
    disconnectedCallback() {
      this.#uninstallResizeObserver();
      this.#unbindHotkeys();
      this.#unbindFocusListeners();
    }
    attributeChangedCallback(name, oldValue, newValue) {
      if (name === "connected" && this.isConnected && oldValue != null && oldValue !== newValue) {
        requestAnimationFrame(() => this.#reconnect());
      }
    }
    setEditor(editorElement) {
      this.editorElement = editorElement;
      this.editor = editorElement.editor;
      this.#bindButtons();
      this.#bindHotkeys();
      this.#resetTabIndexValues();
      this.#setItemPositionValues();
      this.#monitorSelectionChanges();
      this.#monitorHistoryChanges();
      this.#refreshToolbarOverflow();
      this.#bindFocusListeners();
      this.resolveEditorPromise(editorElement);
      this.toggleAttribute("connected", true);
    }
    async getEditorElement() {
      return this.editorElement || await this.editorPromise;
    }
    #reconnect() {
      this.disconnectedCallback();
      this.connectedCallback();
    }
    #createEditorPromise() {
      this.editorPromise = new Promise((resolve2) => {
        this.resolveEditorPromise = resolve2;
      });
    }
    #installResizeObserver() {
      this.resizeObserver = new ResizeObserver(() => this.#refreshToolbarOverflow());
      this.resizeObserver.observe(this);
    }
    #uninstallResizeObserver() {
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
        this.resizeObserver = null;
      }
    }
    #bindButtons() {
      this.addEventListener("click", this.#handleButtonClicked.bind(this));
    }
    #handleButtonClicked(event) {
      this.#handleTargetClicked(event, "[data-command]", this.#dispatchButtonCommand.bind(this));
    }
    #handleTargetClicked(event, selector, callback2) {
      const button = event.target.closest(selector);
      if (button) {
        callback2(event, button);
      }
    }
    #dispatchButtonCommand(event, { dataset: { command, payload } }) {
      const isKeyboard = event instanceof PointerEvent && event.pointerId === -1;
      this.editor.update(() => {
        this.editor.dispatchCommand(command, payload);
      }, { tag: isKeyboard ? SKIP_DOM_SELECTION_TAG2 : void 0 });
    }
    #bindHotkeys() {
      this.editorElement.addEventListener("keydown", this.#handleHotkey);
    }
    #unbindHotkeys() {
      this.editorElement?.removeEventListener("keydown", this.#handleHotkey);
    }
    #handleHotkey = (event) => {
      const buttons = this.querySelectorAll("[data-hotkey]");
      buttons.forEach((button) => {
        const hotkeys = button.dataset.hotkey.toLowerCase().split(/\s+/);
        if (hotkeys.includes(this.#keyCombinationFor(event))) {
          event.preventDefault();
          event.stopPropagation();
          button.click();
        }
      });
    };
    #keyCombinationFor(event) {
      const pressedKey = event.key.toLowerCase();
      const modifiers = [
        event.ctrlKey ? "ctrl" : null,
        event.metaKey ? "cmd" : null,
        event.altKey ? "alt" : null,
        event.shiftKey ? "shift" : null
      ].filter(Boolean);
      return [...modifiers, pressedKey].join("+");
    }
    #bindFocusListeners() {
      this.editorElement.addEventListener("lexxy:focus", this.#handleEditorFocus);
      this.editorElement.addEventListener("lexxy:blur", this.#handleEditorBlur);
      this.addEventListener("keydown", this.#handleKeydown);
    }
    #unbindFocusListeners() {
      this.editorElement.removeEventListener("lexxy:focus", this.#handleEditorFocus);
      this.editorElement.removeEventListener("lexxy:blur", this.#handleEditorBlur);
      this.removeEventListener("keydown", this.#handleKeydown);
    }
    #handleEditorFocus = () => {
      this.#focusableItems[0].tabIndex = 0;
    };
    #handleEditorBlur = () => {
      this.#resetTabIndexValues();
      this.#closeDropdowns();
    };
    #handleKeydown = (event) => {
      handleRollingTabIndex(this.#focusableItems, event);
    };
    #resetTabIndexValues() {
      this.#focusableItems.forEach((button) => {
        button.tabIndex = -1;
      });
    }
    #monitorSelectionChanges() {
      this.editor.registerCommand(
        SELECTION_CHANGE_COMMAND2,
        () => {
          this.#closeDropdowns();
          this.#updateButtonStates();
          return false;
        },
        COMMAND_PRIORITY_HIGH2
      );
    }
    #monitorHistoryChanges() {
      this.editor.registerUpdateListener(() => {
        this.#updateUndoRedoButtonStates();
      });
    }
    #updateUndoRedoButtonStates() {
      this.editor.getEditorState().read(() => {
        const historyState = this.editorElement.historyState;
        if (historyState) {
          this.#setButtonDisabled("undo", historyState.undoStack.length === 0);
          this.#setButtonDisabled("redo", historyState.redoStack.length === 0);
        }
      });
    }
    #updateButtonStates() {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) return;
      const anchorNode = selection.anchor.getNode();
      if (!anchorNode.getParent()) {
        return;
      }
      const topLevelElement = anchorNode.getTopLevelElementOrThrow();
      const isBold2 = selection.hasFormat("bold");
      const isItalic2 = selection.hasFormat("italic");
      const isStrikethrough = selection.hasFormat("strikethrough");
      const isHighlight = isSelectionHighlighted(selection);
      const isInLink = this.#isInLink(anchorNode);
      const isInQuote = $isQuoteNode2(topLevelElement);
      const isInHeading = $isHeadingNode2(topLevelElement);
      const isInCode = $isCodeNode2(topLevelElement) || selection.hasFormat("code");
      const isInList = this.#isInList(anchorNode);
      const listType = getListType(anchorNode);
      const isInTable = $getTableCellNodeFromLexicalNode2(anchorNode) !== null;
      this.#setButtonPressed("bold", isBold2);
      this.#setButtonPressed("italic", isItalic2);
      this.#setButtonPressed("strikethrough", isStrikethrough);
      this.#setButtonPressed("highlight", isHighlight);
      this.#setButtonPressed("link", isInLink);
      this.#setButtonPressed("quote", isInQuote);
      this.#setButtonPressed("heading", isInHeading);
      this.#setButtonPressed("code", isInCode);
      this.#setButtonPressed("unordered-list", isInList && listType === "bullet");
      this.#setButtonPressed("ordered-list", isInList && listType === "number");
      this.#setButtonPressed("table", isInTable);
      this.#updateUndoRedoButtonStates();
    }
    #isInList(node) {
      let current = node;
      while (current) {
        if ($isListNode2(current) || $isListItemNode2(current)) return true;
        current = current.getParent();
      }
      return false;
    }
    #isInLink(node) {
      let current = node;
      while (current) {
        if ($isLinkNode2(current)) return true;
        current = current.getParent();
      }
      return false;
    }
    #setButtonPressed(name, isPressed) {
      const button = this.querySelector(`[name="${name}"]`);
      if (button) {
        button.setAttribute("aria-pressed", isPressed.toString());
      }
    }
    #setButtonDisabled(name, isDisabled) {
      const button = this.querySelector(`[name="${name}"]`);
      if (button) {
        button.disabled = isDisabled;
        button.setAttribute("aria-disabled", isDisabled.toString());
      }
    }
    #toolbarIsOverflowing() {
      return this.scrollWidth - this.#overflow.clientWidth > this.clientWidth + 1;
    }
    #refreshToolbarOverflow = () => {
      this.#resetToolbarOverflow();
      this.#compactMenu();
      this.#overflow.style.display = this.#overflowMenu.children.length ? "block" : "none";
      this.#overflow.setAttribute("nonce", getNonce());
      const isOverflowing = this.#overflowMenu.children.length > 0;
      this.toggleAttribute("overflowing", isOverflowing);
      this.#overflowMenu.toggleAttribute("disabled", !isOverflowing);
    };
    #compactMenu() {
      const buttons = this.#buttons.reverse();
      let movedToOverflow = false;
      for (const button of buttons) {
        if (this.#toolbarIsOverflowing()) {
          this.#overflowMenu.prepend(button);
          movedToOverflow = true;
        } else {
          if (movedToOverflow) this.#overflowMenu.prepend(button);
          break;
        }
      }
    }
    #resetToolbarOverflow() {
      const items = Array.from(this.#overflowMenu.children);
      items.sort((a2, b3) => this.#itemPosition(b3) - this.#itemPosition(a2));
      items.forEach((item) => {
        const nextItem = this.querySelector(`[data-position="${this.#itemPosition(item) + 1}"]`) ?? this.#overflow;
        this.insertBefore(item, nextItem);
      });
    }
    #itemPosition(item) {
      return parseInt(item.dataset.position ?? "999");
    }
    #setItemPositionValues() {
      this.#toolbarItems.forEach((item, index2) => {
        if (item.dataset.position === void 0) {
          item.dataset.position = index2;
        }
      });
    }
    #closeDropdowns() {
      this.#dropdowns.forEach((details) => {
        details.open = false;
      });
    }
    get #dropdowns() {
      return this.querySelectorAll("details");
    }
    get #overflow() {
      return this.querySelector(".lexxy-editor__toolbar-overflow");
    }
    get #overflowMenu() {
      return this.querySelector(".lexxy-editor__toolbar-overflow-menu");
    }
    get #buttons() {
      return Array.from(this.querySelectorAll(":scope > button"));
    }
    get #focusableItems() {
      return Array.from(this.querySelectorAll(":scope button, :scope > details > summary"));
    }
    get #toolbarItems() {
      return Array.from(this.querySelectorAll(":scope > *:not(.lexxy-editor__toolbar-overflow)"));
    }
    static get defaultTemplate() {
      return `
      <button class="lexxy-editor__toolbar-button" type="button" name="bold" data-command="bold" title="Bold">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5 22V2h8.183c1.764 0 3.174.435 4.228 1.304 1.055.87 1.582 2.076 1.582 3.62 0 .8-.148 1.503-.445 2.109a3.94 3.94 0 01-1.194 1.465 4.866 4.866 0 01-1.726.806v.176c.786.078 1.51.312 2.172.703a4.293 4.293 0 011.596 1.627c.403.693.604 1.543.604 2.549 0 1.192-.292 2.207-.877 3.048-.585.84-1.39 1.484-2.416 1.934-1.026.44-2.206.659-3.538.659H5zM8.854 4.974v5.348h2.56c.873 0 1.582-.107 2.129-.322.556-.215.963-.523 1.222-.923.269-.41.403-.904.403-1.48 0-.82-.254-1.46-.762-1.92-.499-.468-1.204-.703-2.115-.703H8.854zm0 8.103v5.949h2.877c1.534 0 2.636-.245 3.307-.733.671-.498 1.007-1.221 1.007-2.168 0-.635-.134-1.178-.403-1.627-.268-.459-.666-.81-1.193-1.055-.518-.244-1.156-.366-1.913-.366H8.854z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="italic" data-command="italic" title="Italic">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.1 4h-1.5l-3.2 16h1.5l-.4 2h-7l.4-2h1.5l3.2-16h-1.5l.4-2h7l-.4 2z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="strikethrough" data-command="strikethrough" title="Strikethrough">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path fill-rule="evenodd" clip-rule="evenodd" d="M4.70588 16.1591C4.81459 19.7901 7.48035 22 11.6668 22C15.9854 22 18.724 19.6296 18.724 15.8779C18.724 15.5007 18.6993 15.1427 18.6474 14.8066H14.3721C14.8637 15.2085 15.0799 15.7037 15.0799 16.3471C15.0799 17.7668 13.7532 18.7984 11.8113 18.7984C9.88053 18.7984 8.38582 17.7531 8.21659 16.1591H4.70588ZM5.23953 9.31962H9.88794C9.10723 8.88889 8.75888 8.33882 8.75888 7.57339C8.75888 6.13992 9.96576 5.18793 11.7631 5.18793C13.5852 5.18793 14.8761 6.1797 14.9959 7.81344H18.4102C18.3485 4.31824 15.8038 2 11.752 2C7.867 2 5.09129 4.35802 5.09129 7.92044C5.09129 8.41838 5.14071 8.88477 5.23953 9.31962ZM2.23529 10.6914C1.90767 10.6914 1.59347 10.8359 1.36181 11.0931C1.13015 11.3504 1 11.6993 1 12.0631C1 12.4269 1.13015 12.7758 1.36181 13.0331C1.59347 13.2903 1.90767 13.4348 2.23529 13.4348H20.7647C21.0923 13.4348 21.4065 13.2903 21.6382 13.0331C21.8699 12.7758 22 12.4269 22 12.0631C22 11.6993 21.8699 11.3504 21.6382 11.0931C21.4065 10.8359 21.0923 10.6914 20.7647 10.6914H2.23529Z"/>
        </svg>
      </button>

      <details class="lexxy-editor__toolbar-dropdown" name="lexxy-dropdown">
        <summary class="lexxy-editor__toolbar-button" name="highlight" title="Color highlight">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.65422 0.711575C7.1856 0.242951 6.42579 0.242951 5.95717 0.711575C5.48853 1.18021 5.48853 1.94 5.95717 2.40864L8.70864 5.16011L2.85422 11.0145C1.44834 12.4204 1.44833 14.6998 2.85422 16.1057L7.86011 21.1115C9.26599 22.5174 11.5454 22.5174 12.9513 21.1115L19.6542 14.4087C20.1228 13.94 20.1228 13.1802 19.6542 12.7115L11.8544 4.91171L11.2542 4.31158L7.65422 0.711575ZM4.55127 12.7115L10.4057 6.85716L17.1087 13.56H4.19981C4.19981 13.253 4.31696 12.9459 4.55127 12.7115ZM23.6057 20.76C23.6057 22.0856 22.5311 23.16 21.2057 23.16C19.8802 23.16 18.8057 22.0856 18.8057 20.76C18.8057 19.5408 19.8212 18.5339 20.918 17.4462C21.0135 17.3516 21.1096 17.2563 21.2057 17.16C21.3018 17.2563 21.398 17.3516 21.4935 17.4462C22.5903 18.5339 23.6057 19.5408 23.6057 20.76Z"/></svg>
        </summary>
        <lexxy-highlight-dropdown class="lexxy-editor__toolbar-dropdown-content">
          <div class="lexxy-highlight-colors"></div>
          <button data-command="removeHighlight" class="lexxy-editor__toolbar-button lexxy-editor__toolbar-dropdown-reset">Remove all coloring</button>
        </lexxy-highlight-dropdown>
      </details>

      <details class="lexxy-editor__toolbar-dropdown" name="lexxy-dropdown">
        <summary class="lexxy-editor__toolbar-button" name="link" title="Link" data-hotkey="cmd+k ctrl+k">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.111 9.546a1.5 1.5 0 012.121 0 5.5 5.5 0 010 7.778l-2.828 2.828a5.5 5.5 0 01-7.778 0 5.498 5.498 0 010-7.777l2.828-2.83a1.5 1.5 0 01.355-.262 6.52 6.52 0 00.351 3.799l-1.413 1.414a2.499 2.499 0 000 3.535 2.499 2.499 0 003.535 0l2.83-2.828a2.5 2.5 0 000-3.536 1.5 1.5 0 010-2.121z"/><path d="M12.111 3.89a5.5 5.5 0 117.778 7.777l-2.828 2.829a1.496 1.496 0 01-.355.262 6.522 6.522 0 00-.351-3.8l1.413-1.412a2.5 2.5 0 10-3.536-3.535l-2.828 2.828a2.5 2.5 0 000 3.536 1.5 1.5 0 01-2.122 2.12 5.5 5.5 0 010-7.777l2.83-2.829z"/></svg>
        </summary>
        <lexxy-link-dropdown class="lexxy-editor__toolbar-dropdown-content">
          <form method="dialog">
            <input type="url" placeholder="Enter a URL\u2026" class="input">
            <div class="lexxy-editor__toolbar-dropdown-actions">
              <button type="submit" class="lexxy-editor__toolbar-button" value="link">Link</button>
              <button type="button" class="lexxy-editor__toolbar-button" value="unlink">Unlink</button>
            </div>
          </form>
        </lexxy-link-dropdown>
      </details>

      <button class="lexxy-editor__toolbar-button" type="button" name="quote" data-command="insertQuoteBlock" title="Quote">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6.5 5C8.985 5 11 7.09 11 9.667c0 2.694-.962 5.005-2.187 6.644-.613.82-1.3 1.481-1.978 1.943-.668.454-1.375.746-2.022.746a.563.563 0 01-.52-.36.602.602 0 01.067-.57l.055-.066.009-.009.041-.048a4.25 4.25 0 00.168-.21c.143-.188.336-.47.53-.84a6.743 6.743 0 00.75-2.605C3.705 13.994 2 12.038 2 9.667 2 7.089 4.015 5 6.5 5zM17.5 5C19.985 5 22 7.09 22 9.667c0 2.694-.962 5.005-2.187 6.644-.613.82-1.3 1.481-1.978 1.943-.668.454-1.375.746-2.023.746a.563.563 0 01-.52-.36.602.602 0 01.068-.57l.055-.066.009-.009.041-.048c.039-.045.097-.115.168-.21a6.16 6.16 0 00.53-.84 6.745 6.745 0 00.75-2.605C14.705 13.994 13 12.038 13 9.667 13 7.089 15.015 5 17.5 5z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="heading" data-command="rotateHeadingFormat" title="Heading">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.322 5.315H9.64V22H5.684V5.315H0v-3.31h15.322v3.31z"/><path d="M23.957 11.79H19.92V22h-3.402V11.79H12.48V9.137h11.477v2.653z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="code" data-command="insertCodeBlock" title="Code">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10.121 6l-6 6 6 6-2.12 2.121-7.061-7.06a1.5 1.5 0 010-2.121L8 3.879 10.121 6zM23.06 10.94a1.5 1.5 0 010 2.12L16 20.121 13.88 18l6-6-6-6L16 3.879l7.06 7.06z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="unordered-list" data-command="insertUnorderedList" title="Bullet list">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5 5a2 2 0 11-4 0 2 2 0 014 0zM5 12a2 2 0 11-4 0 2 2 0 014 0zM5 19a2 2 0 11-4 0 2 2 0 014 0zM7 5.25C7 4.56 7.56 4 8.25 4h13.5a1.25 1.25 0 110 2.5H8.25C7.56 6.5 7 5.94 7 5.25zM7 12.25c0-.69.56-1.25 1.25-1.25h13.5a1.25 1.25 0 110 2.5H8.25c-.69 0-1.25-.56-1.25-1.25zM7 19.25c0-.69.56-1.25 1.25-1.25h13.5a1.25 1.25 0 110 2.5H8.25c-.69 0-1.25-.56-1.25-1.25z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="ordered-list" data-command="insertOrderedList" title="Numbered list">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.25C7 4.56 7.56 4 8.25 4h13.5a1.25 1.25 0 110 2.5H8.25C7.56 6.5 7 5.94 7 5.25zM7 12.25c0-.69.56-1.25 1.25-1.25h13.5a1.25 1.25 0 110 2.5H8.25c-.69 0-1.25-.56-1.25-1.25zM7 19.25c0-.69.56-1.25 1.25-1.25h13.5a1.25 1.25 0 110 2.5H8.25c-.69 0-1.25-.56-1.25-1.25zM4.438 8H3.39V3.684H3.34c-.133.093-.267.188-.402.285l-.407.289a129.5 129.5 0 00-.402.285v-.969l.633-.453c.21-.15.42-.302.629-.453h1.046V8zM2.672 11.258h-1v-.051c0-.206.036-.405.11-.598.075-.195.188-.37.34-.527.15-.156.339-.281.566-.375.229-.094.498-.14.808-.14.367 0 .688.065.961.195s.484.308.633.535c.15.224.226.478.226.762 0 .244-.046.463-.14.656-.091.19-.209.368-.352.535-.14.164-.289.332-.445.504L3.168 14.09v.05h2.238V15H1.723v-.656l1.949-2.102c.096-.101.19-.207.281-.316.091-.112.167-.232.227-.36a.953.953 0 00.09-.41.712.712 0 00-.387-.648.845.845 0 00-.41-.098.81.81 0 00-.43.11.75.75 0 00-.277.293.824.824 0 00-.094.386V11.258zM2.852 19.66v-.812h.562a.917.917 0 00.43-.098.742.742 0 00.293-.266.673.673 0 00.101-.379.654.654 0 00-.234-.523.87.87 0 00-.59-.2.987.987 0 00-.336.055.837.837 0 00-.258.149.712.712 0 00-.172.215.66.66 0 00-.066.25h-.98c.007-.209.053-.403.136-.582.084-.18.203-.336.36-.469.156-.135.346-.24.57-.316.227-.076.486-.115.777-.118a2.33 2.33 0 01.965.176c.271.12.48.285.63.496.15.209.227.448.23.719a1.11 1.11 0 01-.16.637 1.28 1.28 0 01-.825.586v.054c.162.016.33.07.504.164.177.094.328.232.453.415.125.18.189.411.192.695a1.37 1.37 0 01-.157.676c-.104.197-.25.365-.437.503-.188.136-.404.24-.649.313-.242.07-.5.105-.777.105-.401 0-.743-.067-1.027-.203a1.608 1.608 0 01-.649-.547 1.46 1.46 0 01-.238-.75h.969c.01.128.057.243.14.344a.885.885 0 00.332.238c.141.058.3.088.477.09.195 0 .366-.034.512-.101a.798.798 0 00.336-.29.744.744 0 00.117-.425.74.74 0 00-.446-.695 1.082 1.082 0 00-.496-.106h-.59z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="upload" data-command="uploadAttachments" title="Upload file">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 8a2 2 0 110 4 2 2 0 010-4z""/><path d="M22 2a1 1 0 011 1v18a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h20zM3 18.714L9 11l5.25 6.75L17 15l4 4V4H3v14.714z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="table" data-command="insertTable" title="Insert a table">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.2041 2.01074C21.2128 2.113 22 2.96435 22 4V20L21.9893 20.2041C21.8938 21.1457 21.1457 21.8938 20.2041 21.9893L20 22H4C2.96435 22 2.113 21.2128 2.01074 20.2041L2 20V4C2 2.89543 2.89543 2 4 2H20L20.2041 2.01074ZM4 13V20H11V13H4ZM13 13V20H20V13H13ZM4 11H11V4H4V11ZM13 11H20V4H13V11Z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="divider" data-command="insertHorizontalDivider" title="Insert a divider">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 12C0 11.4477 0.447715 11 1 11H23C23.5523 11 24 11.4477 24 12C24 12.5523 23.5523 13 23 13H1C0.447716 13 0 12.5523 0 12Z"/><path d="M4 5C4 3.89543 4.89543 3 6 3H18C19.1046 3 20 3.89543 20 5C20 6.10457 19.1046 7 18 7H6C4.89543 7 4 6.10457 4 5Z"/><path d="M4 19C4 17.8954 4.89543 17 6 17H18C19.1046 17 20 17.8954 20 19C20 20.1046 19.1046 21 18 21H6C4.89543 21 4 20.1046 4 19Z"/></svg>
      </button>
 
      <div class="lexxy-editor__toolbar-spacer" role="separator"></div>
 
      <button class="lexxy-editor__toolbar-button" type="button" name="undo" data-command="undo" title="Undo">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5.64648 8.26531C7.93911 6.56386 10.7827 5.77629 13.624 6.05535C16.4655 6.33452 19.1018 7.66079 21.0195 9.77605C22.5839 11.5016 23.5799 13.6516 23.8936 15.9352C24.0115 16.7939 23.2974 17.4997 22.4307 17.4997C21.5641 17.4997 20.8766 16.7915 20.7148 15.9401C20.4295 14.4379 19.7348 13.0321 18.6943 11.8844C17.3 10.3464 15.3835 9.38139 13.3174 9.17839C11.2514 8.97546 9.18359 9.54856 7.5166 10.7858C6.38259 11.6275 5.48981 12.7361 4.90723 13.9997H8.5C9.3283 13.9997 9.99979 14.6714 10 15.4997C10 16.3281 9.32843 16.9997 8.5 16.9997H1.5C0.671573 16.9997 0 16.3281 0 15.4997V8.49968C0.000213656 7.67144 0.671705 6.99968 1.5 6.99968C2.3283 6.99968 2.99979 7.67144 3 8.49968V11.0212C3.7166 9.9704 4.60793 9.03613 5.64648 8.26531Z"/></svg>
      </button>

      <button class="lexxy-editor__toolbar-button" type="button" name="redo" data-command="redo" title="Redo">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.2599 8.26531C15.9672 6.56386 13.1237 5.77629 10.2823 6.05535C7.4408 6.33452 4.80455 7.66079 2.88681 9.77605C1.32245 11.5016 0.326407 13.6516 0.0127834 15.9352C-0.105117 16.7939 0.608975 17.4997 1.47567 17.4997C2.34228 17.4997 3.02969 16.7915 3.19149 15.9401C3.47682 14.4379 4.17156 13.0321 5.212 11.8844C6.60637 10.3464 8.52287 9.38139 10.589 9.17839C12.655 8.97546 14.7227 9.54856 16.3897 10.7858C17.5237 11.6275 18.4165 12.7361 18.9991 13.9997H15.4063C14.578 13.9997 13.9066 14.6714 13.9063 15.4997C13.9063 16.3281 14.5779 16.9997 15.4063 16.9997H22.4063C23.2348 16.9997 23.9063 16.3281 23.9063 15.4997V8.49968C23.9061 7.67144 23.2346 6.99968 22.4063 6.99968C21.578 6.99968 20.9066 7.67144 20.9063 8.49968V11.0212C20.1897 9.9704 19.2984 9.03613 18.2599 8.26531Z"/></svg>
      </button>

      <details class="lexxy-editor__toolbar-dropdown lexxy-editor__toolbar-overflow" name="lexxy-dropdown">
        <summary class="lexxy-editor__toolbar-button" aria-label="Show more toolbar buttons">\u2022\u2022\u2022</summary>
        <div class="lexxy-editor__toolbar-dropdown-content lexxy-editor__toolbar-overflow-menu" aria-label="More toolbar buttons"></div>
      </details>
    `;
    }
  };
  customElements.define("lexxy-toolbar", LexicalToolbarElement);
  var theme = {
    text: {
      bold: "lexxy-content__bold",
      italic: "lexxy-content__italic",
      strikethrough: "lexxy-content__strikethrough",
      underline: "lexxy-content__underline",
      highlight: "lexxy-content__highlight"
    },
    tableCellHeader: "lexxy-content__table-cell--header",
    tableCellSelected: "lexxy-content__table-cell--selected",
    tableSelection: "lexxy-content__table--selection",
    tableScrollableWrapper: "lexxy-content__table-wrapper",
    tableCellHighlight: "lexxy-content__table-cell--highlight",
    tableCellFocus: "lexxy-content__table-cell--focus",
    list: {
      nested: {
        listitem: "lexxy-nested-listitem"
      }
    },
    codeHighlight: {
      addition: "code-token__selector",
      atrule: "code-token__attr",
      attr: "code-token__attr",
      "attr-name": "code-token__attr",
      "attr-value": "code-token__selector",
      boolean: "code-token__property",
      bold: "code-token__variable",
      builtin: "code-token__selector",
      cdata: "code-token__comment",
      char: "code-token__selector",
      class: "code-token__function",
      "class-name": "code-token__function",
      color: "code-token__property",
      comment: "code-token__comment",
      constant: "code-token__property",
      coord: "code-token__comment",
      decorator: "code-token__function",
      deleted: "code-token__operator",
      deletion: "code-token__operator",
      directive: "code-token__attr",
      "directive-hash": "code-token__property",
      doctype: "code-token__comment",
      entity: "code-token__operator",
      function: "code-token__function",
      hexcode: "code-token__property",
      important: "code-token__function",
      inserted: "code-token__selector",
      italic: "code-token__comment",
      keyword: "code-token__attr",
      line: "code-token__selector",
      namespace: "code-token__variable",
      number: "code-token__property",
      macro: "code-token__function",
      operator: "code-token__operator",
      parameter: "code-token__variable",
      prolog: "code-token__comment",
      property: "code-token__property",
      punctuation: "code-token__punctuation",
      "raw-string": "code-token__operator",
      regex: "code-token__variable",
      script: "code-token__function",
      selector: "code-token__selector",
      string: "code-token__selector",
      style: "code-token__function",
      symbol: "code-token__property",
      tag: "code-token__property",
      title: "code-token__function",
      "type-definition": "code-token__function",
      url: "code-token__operator",
      variable: "code-token__variable"
    }
  };
  function bytesToHumanSize(bytes) {
    if (bytes === 0) return "0 B";
    const sizes = ["B", "KB", "MB", "GB", "TB", "PB"];
    const i2 = Math.floor(Math.log(bytes) / Math.log(1024));
    const value = bytes / Math.pow(1024, i2);
    return `${value.toFixed(2)} ${sizes[i2]}`;
  }
  var ActionTextAttachmentNode = class _ActionTextAttachmentNode extends DecoratorNode2 {
    static getType() {
      return "action_text_attachment";
    }
    static clone(node) {
      return new _ActionTextAttachmentNode({ ...node }, node.__key);
    }
    static importJSON(serializedNode) {
      return new _ActionTextAttachmentNode({ ...serializedNode });
    }
    static importDOM() {
      return {
        [this.TAG_NAME]: () => {
          return {
            conversion: (attachment) => ({
              node: new _ActionTextAttachmentNode({
                sgid: attachment.getAttribute("sgid"),
                src: attachment.getAttribute("url"),
                previewable: attachment.getAttribute("previewable"),
                altText: attachment.getAttribute("alt"),
                caption: attachment.getAttribute("caption"),
                contentType: attachment.getAttribute("content-type"),
                fileName: attachment.getAttribute("filename"),
                fileSize: attachment.getAttribute("filesize"),
                width: attachment.getAttribute("width"),
                height: attachment.getAttribute("height")
              })
            }),
            priority: 1
          };
        },
        "img": () => {
          return {
            conversion: (img) => ({
              node: new _ActionTextAttachmentNode({
                src: img.getAttribute("src"),
                caption: img.getAttribute("alt") || "",
                contentType: "image/*",
                width: img.getAttribute("width"),
                height: img.getAttribute("height")
              })
            }),
            priority: 1
          };
        },
        "video": () => {
          return {
            conversion: (video) => {
              const videoSource = video.getAttribute("src") || video.querySelector("source")?.src;
              const fileName = videoSource?.split("/")?.pop();
              const contentType = video.querySelector("source")?.getAttribute("content-type") || "video/*";
              return {
                node: new _ActionTextAttachmentNode({
                  src: videoSource,
                  fileName,
                  contentType
                })
              };
            },
            priority: 1
          };
        }
      };
    }
    static get TAG_NAME() {
      return Lexxy.global.get("attachmentTagName");
    }
    constructor({ tagName, sgid, src, previewable, altText, caption, contentType, fileName, fileSize, width, height }, key) {
      super(key);
      this.tagName = tagName || _ActionTextAttachmentNode.TAG_NAME;
      this.sgid = sgid;
      this.src = src;
      this.previewable = previewable;
      this.altText = altText || "";
      this.caption = caption || "";
      this.contentType = contentType || "";
      this.fileName = fileName || "";
      this.fileSize = fileSize;
      this.width = width;
      this.height = height;
    }
    createDOM() {
      const figure = this.createAttachmentFigure();
      figure.addEventListener("click", () => {
        this.#select(figure);
      });
      if (this.isPreviewableAttachment) {
        figure.appendChild(this.#createDOMForImage());
        figure.appendChild(this.#createEditableCaption());
      } else {
        figure.appendChild(this.#createDOMForFile());
        figure.appendChild(this.#createDOMForNotImage());
      }
      return figure;
    }
    updateDOM() {
      return true;
    }
    getTextContent() {
      return `[${this.caption || this.fileName}]

`;
    }
    isInline() {
      return false;
    }
    exportDOM() {
      const attachment = createElement(this.tagName, {
        sgid: this.sgid,
        previewable: this.previewable || null,
        url: this.src,
        alt: this.altText,
        caption: this.caption,
        "content-type": this.contentType,
        filename: this.fileName,
        filesize: this.fileSize,
        width: this.width,
        height: this.height,
        presentation: "gallery"
      });
      return { element: attachment };
    }
    exportJSON() {
      return {
        type: "action_text_attachment",
        version: 1,
        tagName: this.tagName,
        sgid: this.sgid,
        src: this.src,
        previewable: this.previewable,
        altText: this.altText,
        caption: this.caption,
        contentType: this.contentType,
        fileName: this.fileName,
        fileSize: this.fileSize,
        width: this.width,
        height: this.height
      };
    }
    decorate() {
      return null;
    }
    createAttachmentFigure() {
      return createAttachmentFigure(this.contentType, this.isPreviewableAttachment, this.fileName);
    }
    get #isPreviewableImage() {
      return isPreviewableImage(this.contentType);
    }
    get isPreviewableAttachment() {
      return this.#isPreviewableImage || this.previewable;
    }
    #createDOMForImage() {
      return createElement("img", { src: this.src, alt: this.altText, ...this.#imageDimensions });
    }
    get #imageDimensions() {
      if (this.width && this.height) {
        return { width: this.width, height: this.height };
      } else {
        return {};
      }
    }
    #createDOMForFile() {
      const extension = this.fileName ? this.fileName.split(".").pop().toLowerCase() : "unknown";
      return createElement("span", { className: "attachment__icon", textContent: `${extension}` });
    }
    #createDOMForNotImage() {
      const figcaption = createElement("figcaption", { className: "attachment__caption" });
      const nameTag = createElement("strong", { className: "attachment__name", textContent: this.caption || this.fileName });
      figcaption.appendChild(nameTag);
      if (this.fileSize) {
        const sizeSpan = createElement("span", { className: "attachment__size", textContent: bytesToHumanSize(this.fileSize) });
        figcaption.appendChild(sizeSpan);
      }
      return figcaption;
    }
    #select(figure) {
      dispatchCustomEvent(figure, "lexxy:internal:select-node", { key: this.getKey() });
    }
    #createEditableCaption() {
      const caption = createElement("figcaption", { className: "attachment__caption" });
      const input = createElement("textarea", {
        value: this.caption,
        placeholder: this.fileName,
        rows: "1"
      });
      input.addEventListener("focusin", () => input.placeholder = "Add caption...");
      input.addEventListener("blur", this.#handleCaptionInputBlurred.bind(this));
      input.addEventListener("keydown", this.#handleCaptionInputKeydown.bind(this));
      caption.appendChild(input);
      return caption;
    }
    #handleCaptionInputBlurred(event) {
      const input = event.target;
      input.placeholder = this.fileName;
      this.#updateCaptionValueFromInput(input);
    }
    #updateCaptionValueFromInput(input) {
      dispatchCustomEvent(input, "lexxy:internal:invalidate-node", { key: this.getKey(), values: { caption: input.value } });
    }
    #handleCaptionInputKeydown(event) {
      if (event.key === "Enter") {
        this.#updateCaptionValueFromInput(event.target);
        dispatchCustomEvent(event.target, "lexxy:internal:move-to-next-line");
        event.preventDefault();
      }
      event.stopPropagation();
    }
  };
  async function loadFileIntoImage(file, image) {
    return new Promise((resolve2) => {
      const reader = new FileReader();
      image.addEventListener("load", () => {
        resolve2(image);
      });
      reader.onload = (event) => {
        image.src = event.target.result || null;
      };
      reader.readAsDataURL(file);
    });
  }
  var ActionTextAttachmentUploadNode = class _ActionTextAttachmentUploadNode extends ActionTextAttachmentNode {
    static getType() {
      return "action_text_attachment_upload";
    }
    static clone(node) {
      return new _ActionTextAttachmentUploadNode({ ...node }, node.__key);
    }
    static importJSON(serializedNode) {
      return new _ActionTextAttachmentUploadNode({ ...serializedNode });
    }
    // Should never run since this is a transient node. Defined to remove console warning.
    static importDOM() {
      return null;
    }
    constructor(node, key) {
      const { file, uploadUrl, blobUrlTemplate, editor, progress } = node;
      super({ ...node, contentType: file.type }, key);
      this.file = file;
      this.uploadUrl = uploadUrl;
      this.blobUrlTemplate = blobUrlTemplate;
      this.src = null;
      this.editor = editor;
      this.progress = progress || 0;
    }
    createDOM() {
      const figure = this.createAttachmentFigure();
      if (this.isPreviewableAttachment) {
        figure.appendChild(this.#createDOMForImage());
      } else {
        figure.appendChild(this.#createDOMForFile());
      }
      figure.appendChild(this.#createCaption());
      const progressBar = createElement("progress", { value: this.progress, max: 100 });
      figure.appendChild(progressBar);
      this.#loadFigure(figure).then(() => this.#startUpload(progressBar, figure));
      return figure;
    }
    exportDOM() {
      const img = document.createElement("img");
      if (this.src) {
        img.src = this.src;
      }
      return { element: img };
    }
    exportJSON() {
      return {
        type: "action_text_attachment_upload",
        version: 1,
        progress: this.progress,
        uploadUrl: this.uploadUrl,
        blobUrlTemplate: this.blobUrlTemplate,
        ...super.exportJSON()
      };
    }
    #createDOMForImage() {
      return createElement("img");
    }
    #createDOMForFile() {
      const extension = this.#getFileExtension();
      const span = createElement("span", { className: "attachment__icon", textContent: extension });
      return span;
    }
    #getFileExtension() {
      return this.file.name.split(".").pop().toLowerCase();
    }
    #createCaption() {
      const figcaption = createElement("figcaption", { className: "attachment__caption" });
      const nameSpan = createElement("span", { className: "attachment__name", textContent: this.file.name || "" });
      const sizeSpan = createElement("span", { className: "attachment__size", textContent: bytesToHumanSize(this.file.size) });
      figcaption.appendChild(nameSpan);
      figcaption.appendChild(sizeSpan);
      return figcaption;
    }
    #loadFigure(figure) {
      const image = figure.querySelector("img");
      if (!image) {
        return Promise.resolve();
      } else {
        return loadFileIntoImage(this.file, image);
      }
    }
    async #startUpload(progressBar, figure) {
      const { DirectUpload: DirectUpload2 } = await Promise.resolve().then(() => (init_activestorage_esm(), activestorage_esm_exports));
      const shouldAuthenticateUploads = Lexxy.global.get("authenticatedUploads");
      const upload = new DirectUpload2(this.file, this.uploadUrl, this);
      upload.delegate = {
        directUploadWillCreateBlobWithXHR: (request) => {
          if (shouldAuthenticateUploads) request.withCredentials = true;
        },
        directUploadWillStoreFileWithXHR: (request) => {
          if (shouldAuthenticateUploads) request.withCredentials = true;
          request.upload.addEventListener("progress", (event) => {
            this.editor.update(() => {
              progressBar.value = Math.round(event.loaded / event.total * 100);
            });
          });
        }
      };
      upload.create((error2, blob) => {
        if (error2) {
          this.#handleUploadError(figure);
        } else {
          this.#loadFigurePreviewFromBlob(blob, figure).then(() => {
            this.#showUploadedAttachment(figure, blob);
          });
        }
      });
    }
    #handleUploadError(figure) {
      figure.innerHTML = "";
      figure.classList.add("attachment--error");
      figure.appendChild(createElement("div", { innerText: `Error uploading ${this.file?.name ?? "image"}` }));
    }
    async #showUploadedAttachment(figure, blob) {
      this.editor.update(() => {
        const image = figure.querySelector("img");
        const src = this.blobUrlTemplate.replace(":signed_id", blob.signed_id).replace(":filename", encodeURIComponent(blob.filename));
        const latest = $getNodeByKey2(this.getKey());
        if (latest) {
          latest.replace(new ActionTextAttachmentNode({
            tagName: this.tagName,
            sgid: blob.attachable_sgid,
            src: blob.previewable ? blob.url : src,
            altText: blob.filename,
            contentType: blob.content_type,
            fileName: blob.filename,
            fileSize: blob.byte_size,
            width: image?.naturalWidth,
            previewable: blob.previewable,
            height: image?.naturalHeight
          }));
        }
      }, { tag: HISTORY_MERGE_TAG2 });
    }
    async #loadFigurePreviewFromBlob(blob, figure) {
      if (blob.previewable) {
        return new Promise((resolve2) => {
          this.editor.update(() => {
            const image = this.#createDOMForImage();
            image.addEventListener("load", () => {
              resolve2();
            });
            image.src = blob.url;
            figure.insertBefore(image, figure.firstChild);
          });
        });
      } else {
        return Promise.resolve();
      }
    }
  };
  var HorizontalDividerNode = class _HorizontalDividerNode extends DecoratorNode2 {
    static getType() {
      return "horizontal_divider";
    }
    static clone(node) {
      return new _HorizontalDividerNode(node.__key);
    }
    static importJSON(serializedNode) {
      return new _HorizontalDividerNode();
    }
    static importDOM() {
      return {
        "hr": (hr) => {
          return {
            conversion: () => ({
              node: new _HorizontalDividerNode()
            }),
            priority: 1
          };
        }
      };
    }
    constructor(key) {
      super(key);
    }
    createDOM() {
      const figure = createElement("figure", { className: "horizontal-divider" });
      const hr = createElement("hr");
      figure.addEventListener("click", (event) => {
        dispatchCustomEvent(figure, "lexxy:internal:select-node", { key: this.getKey() });
      });
      figure.appendChild(hr);
      return figure;
    }
    updateDOM() {
      return true;
    }
    getTextContent() {
      return "\u2504\n\n";
    }
    isInline() {
      return false;
    }
    exportDOM() {
      const hr = createElement("hr");
      return { element: hr };
    }
    exportJSON() {
      return {
        type: "horizontal_divider",
        version: 1
      };
    }
    decorate() {
      return null;
    }
  };
  var COMMANDS = [
    "bold",
    "italic",
    "strikethrough",
    "link",
    "unlink",
    "toggleHighlight",
    "removeHighlight",
    "rotateHeadingFormat",
    "insertUnorderedList",
    "insertOrderedList",
    "insertQuoteBlock",
    "insertCodeBlock",
    "insertHorizontalDivider",
    "uploadAttachments",
    "insertTable",
    "undo",
    "redo"
  ];
  var CommandDispatcher = class _CommandDispatcher {
    static configureFor(editorElement) {
      new _CommandDispatcher(editorElement);
    }
    constructor(editorElement) {
      this.editorElement = editorElement;
      this.editor = editorElement.editor;
      this.selection = editorElement.selection;
      this.contents = editorElement.contents;
      this.clipboard = editorElement.clipboard;
      this.highlighter = editorElement.highlighter;
      this.#registerCommands();
      this.#registerKeyboardCommands();
      this.#registerDragAndDropHandlers();
    }
    dispatchPaste(event) {
      return this.clipboard.paste(event);
    }
    dispatchBold() {
      this.editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "bold");
    }
    dispatchItalic() {
      this.editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "italic");
    }
    dispatchStrikethrough() {
      this.editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "strikethrough");
    }
    dispatchToggleHighlight(styles) {
      this.highlighter.toggle(styles);
    }
    dispatchRemoveHighlight() {
      this.highlighter.remove();
    }
    dispatchLink(url) {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        if (selection.isCollapsed()) {
          const autoLinkNode = $createAutoLinkNode2(url);
          const textNode = $createTextNode2(url);
          autoLinkNode.append(textNode);
          selection.insertNodes([autoLinkNode]);
        } else {
          $toggleLink2(url);
        }
      });
    }
    dispatchUnlink() {
      this.#toggleLink(null);
    }
    dispatchInsertUnorderedList() {
      const selection = $getSelection2();
      if (!selection) return;
      const anchorNode = selection.anchor.getNode();
      if (this.selection.isInsideList && anchorNode && getListType(anchorNode) === "bullet") {
        this.contents.unwrapSelectedListItems();
      } else {
        this.editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND2, void 0);
      }
    }
    dispatchInsertOrderedList() {
      const selection = $getSelection2();
      if (!selection) return;
      const anchorNode = selection.anchor.getNode();
      if (this.selection.isInsideList && anchorNode && getListType(anchorNode) === "number") {
        this.contents.unwrapSelectedListItems();
      } else {
        this.editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND2, void 0);
      }
    }
    dispatchInsertQuoteBlock() {
      this.contents.toggleNodeWrappingAllSelectedNodes((node) => $isQuoteNode2(node), () => $createQuoteNode2());
    }
    dispatchInsertCodeBlock() {
      this.editor.update(() => {
        if (this.selection.hasSelectedWordsInSingleLine) {
          this.editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "code");
        } else {
          this.contents.toggleNodeWrappingAllSelectedLines((node) => $isCodeNode2(node), () => new CodeNode2("plain"));
        }
      });
    }
    dispatchInsertHorizontalDivider() {
      this.contents.insertAtCursorEnsuringLineBelow(new HorizontalDividerNode());
      this.editor.focus();
    }
    dispatchRotateHeadingFormat() {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        if ($isRootOrShadowRoot2(selection.anchor.getNode())) {
          selection.insertNodes([$createHeadingNode2("h2")]);
          return;
        }
        const topLevelElement = selection.anchor.getNode().getTopLevelElementOrThrow();
        let nextTag = "h2";
        if ($isHeadingNode2(topLevelElement)) {
          const currentTag = topLevelElement.getTag();
          if (currentTag === "h2") {
            nextTag = "h3";
          } else if (currentTag === "h3") {
            nextTag = "h4";
          } else if (currentTag === "h4") {
            nextTag = null;
          } else {
            nextTag = "h2";
          }
        }
        if (nextTag) {
          this.contents.insertNodeWrappingEachSelectedLine(() => $createHeadingNode2(nextTag));
        } else {
          this.contents.removeFormattingFromSelectedLines();
        }
      });
    }
    dispatchUploadAttachments() {
      const input = createElement("input", {
        type: "file",
        multiple: true,
        style: "display: none;",
        onchange: ({ target }) => {
          const files = Array.from(target.files);
          if (!files.length) return;
          for (const file of files) {
            this.contents.uploadFile(file);
          }
        }
      });
      this.editorElement.appendChild(input);
      input.click();
      setTimeout(() => input.remove(), 1e3);
    }
    dispatchInsertTable() {
      this.editor.dispatchCommand(INSERT_TABLE_COMMAND2, { "rows": 3, "columns": 3, "includeHeaders": true });
    }
    dispatchUndo() {
      this.editor.dispatchCommand(UNDO_COMMAND2, void 0);
    }
    dispatchRedo() {
      this.editor.dispatchCommand(REDO_COMMAND2, void 0);
    }
    #registerCommands() {
      for (const command of COMMANDS) {
        const methodName = `dispatch${capitalize2(command)}`;
        this.#registerCommandHandler(command, 0, this[methodName].bind(this));
      }
      this.#registerCommandHandler(PASTE_COMMAND2, COMMAND_PRIORITY_LOW2, this.dispatchPaste.bind(this));
    }
    #registerCommandHandler(command, priority, handler4) {
      this.editor.registerCommand(command, handler4, priority);
    }
    #registerKeyboardCommands() {
      this.editor.registerCommand(KEY_TAB_COMMAND2, this.#handleTabKey.bind(this), COMMAND_PRIORITY_NORMAL2);
    }
    #registerDragAndDropHandlers() {
      if (this.editorElement.supportsAttachments) {
        this.dragCounter = 0;
        this.editor.getRootElement().addEventListener("dragover", this.#handleDragOver.bind(this));
        this.editor.getRootElement().addEventListener("drop", this.#handleDrop.bind(this));
        this.editor.getRootElement().addEventListener("dragenter", this.#handleDragEnter.bind(this));
        this.editor.getRootElement().addEventListener("dragleave", this.#handleDragLeave.bind(this));
      }
    }
    #handleDragEnter(event) {
      this.dragCounter++;
      if (this.dragCounter === 1) {
        this.editor.getRootElement().classList.add("lexxy-editor--drag-over");
      }
    }
    #handleDragLeave(event) {
      this.dragCounter--;
      if (this.dragCounter === 0) {
        this.editor.getRootElement().classList.remove("lexxy-editor--drag-over");
      }
    }
    #handleDragOver(event) {
      event.preventDefault();
    }
    #handleDrop(event) {
      event.preventDefault();
      this.dragCounter = 0;
      this.editor.getRootElement().classList.remove("lexxy-editor--drag-over");
      const dataTransfer = event.dataTransfer;
      if (!dataTransfer) return;
      const files = Array.from(dataTransfer.files);
      if (!files.length) return;
      for (const file of files) {
        this.contents.uploadFile(file);
      }
      this.editor.focus();
    }
    #handleTabKey(event) {
      if (this.selection.isInsideList) {
        return this.#handleTabForList(event);
      } else if (this.selection.isInsideCodeBlock) {
        return this.#handleTabForCode();
      }
      return false;
    }
    #handleTabForList(event) {
      if (event.shiftKey && !this.selection.isIndentedList) return false;
      event.preventDefault();
      const command = event.shiftKey ? OUTDENT_CONTENT_COMMAND2 : INDENT_CONTENT_COMMAND2;
      return this.editor.dispatchCommand(command);
    }
    #handleTabForCode() {
      const selection = $getSelection2();
      return $isRangeSelection2(selection) && selection.isCollapsed();
    }
    // Not using TOGGLE_LINK_COMMAND because it's not handled unless you use React/LinkPlugin
    #toggleLink(url) {
      this.editor.update(() => {
        if (url === null) {
          $toggleLink2(null);
        } else {
          $toggleLink2(url);
        }
      });
    }
  };
  function capitalize2(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function debounceAsync(fn, wait) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      return new Promise((resolve2, reject) => {
        timeout = setTimeout(async () => {
          try {
            const result = await fn(...args);
            resolve2(result);
          } catch (err) {
            reject(err);
          }
        }, wait);
      });
    };
  }
  function nextFrame() {
    return new Promise(requestAnimationFrame);
  }
  var Selection = class {
    constructor(editorElement) {
      this.editorElement = editorElement;
      this.editorContentElement = editorElement.editorContentElement;
      this.editor = this.editorElement.editor;
      this.previouslySelectedKeys = /* @__PURE__ */ new Set();
      this.#listenForNodeSelections();
      this.#processSelectionChangeCommands();
      this.#handleInputWhenDecoratorNodesSelected();
      this.#containEditorFocus();
    }
    set current(selection) {
      this.editor.update(() => {
        this.#syncSelectedClasses();
      });
    }
    get hasNodeSelection() {
      let result = false;
      this.editor.getEditorState().read(() => {
        const selection = $getSelection2();
        result = selection !== null && $isNodeSelection2(selection);
      });
      return result;
    }
    get cursorPosition() {
      let position = { x: 0, y: 0 };
      this.editor.getEditorState().read(() => {
        const range2 = this.#getValidSelectionRange();
        if (!range2) return;
        const rect = this.#getReliableRectFromRange(range2);
        if (!rect) return;
        position = this.#calculateCursorPosition(rect, range2);
      });
      return position;
    }
    placeCursorAtTheEnd() {
      this.editor.update(() => {
        const root = $getRoot2();
        const lastDescendant = root.getLastDescendant();
        if (lastDescendant && $isTextNode2(lastDescendant)) {
          lastDescendant.selectEnd();
        } else {
          root.selectEnd();
        }
      });
    }
    selectedNodeWithOffset() {
      const selection = $getSelection2();
      if (!selection) return { node: null, offset: 0 };
      if ($isRangeSelection2(selection)) {
        return {
          node: selection.anchor.getNode(),
          offset: selection.anchor.offset
        };
      } else if ($isNodeSelection2(selection)) {
        const [node] = selection.getNodes();
        return {
          node,
          offset: 0
        };
      }
      return { node: null, offset: 0 };
    }
    preservingSelection(fn) {
      let selectionState = null;
      this.editor.getEditorState().read(() => {
        const selection = $getSelection2();
        if (selection && $isRangeSelection2(selection)) {
          selectionState = {
            anchor: { key: selection.anchor.key, offset: selection.anchor.offset },
            focus: { key: selection.focus.key, offset: selection.focus.offset }
          };
        }
      });
      fn();
      if (selectionState) {
        this.editor.update(() => {
          const selection = $getSelection2();
          if (selection && $isRangeSelection2(selection)) {
            selection.anchor.set(selectionState.anchor.key, selectionState.anchor.offset, "text");
            selection.focus.set(selectionState.focus.key, selectionState.focus.offset, "text");
          }
        });
      }
    }
    get hasSelectedWordsInSingleLine() {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) return false;
      if (selection.isCollapsed()) return false;
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      if (anchorNode.getTopLevelElement() !== focusNode.getTopLevelElement()) {
        return false;
      }
      const anchorElement = anchorNode.getTopLevelElement();
      if (!anchorElement) return false;
      const nodes = selection.getNodes();
      for (const node of nodes) {
        if ($isLineBreakNode2(node)) {
          return false;
        }
      }
      return true;
    }
    get isInsideList() {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) return false;
      const anchorNode = selection.anchor.getNode();
      return getNearestListItemNode(anchorNode) !== null;
    }
    get isIndentedList() {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) return false;
      const nodes = selection.getNodes();
      for (const node of nodes) {
        const closestListNode = $getNearestNodeOfType2(node, ListNode2);
        if (closestListNode && $getListDepth2(closestListNode) > 1) {
          return true;
        }
      }
      return false;
    }
    get isInsideCodeBlock() {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) return false;
      const anchorNode = selection.anchor.getNode();
      return $getNearestNodeOfType2(anchorNode, CodeNode2) !== null;
    }
    get isTableCellSelected() {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) return false;
      const anchorNode = selection.anchor.getNode();
      return $getNearestNodeOfType2(anchorNode, TableCellNode2) !== null;
    }
    get nodeAfterCursor() {
      const { anchorNode, offset } = this.#getCollapsedSelectionData();
      if (!anchorNode) return null;
      if ($isTextNode2(anchorNode)) {
        return this.#getNodeAfterTextNode(anchorNode, offset);
      }
      if ($isElementNode2(anchorNode)) {
        return this.#getNodeAfterElementNode(anchorNode, offset);
      }
      return this.#findNextSiblingUp(anchorNode);
    }
    get topLevelNodeAfterCursor() {
      const { anchorNode, offset } = this.#getCollapsedSelectionData();
      if (!anchorNode) return null;
      if ($isTextNode2(anchorNode)) {
        return this.#getNextNodeFromTextEnd(anchorNode);
      }
      if ($isElementNode2(anchorNode)) {
        return this.#getNodeAfterElementNode(anchorNode, offset);
      }
      return this.#findNextSiblingUp(anchorNode);
    }
    get nodeBeforeCursor() {
      const { anchorNode, offset } = this.#getCollapsedSelectionData();
      if (!anchorNode) return null;
      if ($isTextNode2(anchorNode)) {
        return this.#getNodeBeforeTextNode(anchorNode, offset);
      }
      if ($isElementNode2(anchorNode)) {
        return this.#getNodeBeforeElementNode(anchorNode, offset);
      }
      return this.#findPreviousSiblingUp(anchorNode);
    }
    get topLevelNodeBeforeCursor() {
      const { anchorNode, offset } = this.#getCollapsedSelectionData();
      if (!anchorNode) return null;
      if ($isTextNode2(anchorNode)) {
        return this.#getPreviousNodeFromTextStart(anchorNode);
      }
      if ($isElementNode2(anchorNode)) {
        return this.#getNodeBeforeElementNode(anchorNode, offset);
      }
      return this.#findPreviousSiblingUp(anchorNode);
    }
    get #contents() {
      return this.editorElement.contents;
    }
    get #currentlySelectedKeys() {
      if (this.currentlySelectedKeys) {
        return this.currentlySelectedKeys;
      }
      this.currentlySelectedKeys = /* @__PURE__ */ new Set();
      const selection = $getSelection2();
      if (selection && $isNodeSelection2(selection)) {
        for (const node of selection.getNodes()) {
          this.currentlySelectedKeys.add(node.getKey());
        }
      }
      return this.currentlySelectedKeys;
    }
    #processSelectionChangeCommands() {
      this.editor.registerCommand(KEY_ARROW_LEFT_COMMAND2, this.#selectPreviousNode.bind(this), COMMAND_PRIORITY_LOW2);
      this.editor.registerCommand(KEY_ARROW_RIGHT_COMMAND2, this.#selectNextNode.bind(this), COMMAND_PRIORITY_LOW2);
      this.editor.registerCommand(KEY_ARROW_UP_COMMAND2, this.#selectPreviousTopLevelNode.bind(this), COMMAND_PRIORITY_LOW2);
      this.editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, this.#selectNextTopLevelNode.bind(this), COMMAND_PRIORITY_LOW2);
      this.editor.registerCommand(KEY_DELETE_COMMAND2, this.#deleteSelectedOrNext.bind(this), COMMAND_PRIORITY_LOW2);
      this.editor.registerCommand(KEY_BACKSPACE_COMMAND2, this.#deletePreviousOrNext.bind(this), COMMAND_PRIORITY_LOW2);
      this.editor.registerCommand(SELECTION_CHANGE_COMMAND2, () => {
        this.current = $getSelection2();
      }, COMMAND_PRIORITY_LOW2);
    }
    #listenForNodeSelections() {
      this.editor.getRootElement().addEventListener("lexxy:internal:select-node", async (event) => {
        await nextFrame();
        const { key } = event.detail;
        this.editor.update(() => {
          const node = $getNodeByKey2(key);
          if (node) {
            const selection = $createNodeSelection2();
            selection.add(node.getKey());
            $setSelection2(selection);
          }
          this.editor.focus();
        });
      });
      this.editor.getRootElement().addEventListener("lexxy:internal:move-to-next-line", (event) => {
        this.#selectOrAppendNextLine();
      });
    }
    // In Safari, when the only node in the document is an attachment, it won't let you enter text
    // before/below it. There is probably a better fix here, but this workaround solves the problem until
    // we find it.
    #handleInputWhenDecoratorNodesSelected() {
      this.editor.getRootElement().addEventListener("keydown", (event) => {
        if (isPrintableCharacter(event)) {
          this.editor.update(() => {
            const selection = $getSelection2();
            if ($isRangeSelection2(selection) && selection.isCollapsed()) {
              const anchorNode = selection.anchor.getNode();
              const offset = selection.anchor.offset;
              const nodeBefore = this.#getNodeBeforePosition(anchorNode, offset);
              const nodeAfter = this.#getNodeAfterPosition(anchorNode, offset);
              if (nodeBefore instanceof DecoratorNode2 && !nodeBefore.isInline()) {
                event.preventDefault();
                this.#contents.createParagraphAfterNode(nodeBefore, event.key);
                return;
              } else if (nodeAfter instanceof DecoratorNode2 && !nodeAfter.isInline()) {
                event.preventDefault();
                this.#contents.createParagraphBeforeNode(nodeAfter, event.key);
                return;
              }
            }
          });
        }
      }, true);
    }
    #getNodeBeforePosition(node, offset) {
      if ($isTextNode2(node) && offset === 0) {
        return node.getPreviousSibling();
      }
      if ($isElementNode2(node) && offset > 0) {
        return node.getChildAtIndex(offset - 1);
      }
      return null;
    }
    #getNodeAfterPosition(node, offset) {
      if ($isTextNode2(node) && offset === node.getTextContentSize()) {
        return node.getNextSibling();
      }
      if ($isElementNode2(node)) {
        return node.getChildAtIndex(offset);
      }
      return null;
    }
    #containEditorFocus() {
      this.editorContentElement.addEventListener("keydown", (event) => {
        if (event.key === "ArrowUp") {
          const lexicalCursor = this.editor.getRootElement().querySelector("[data-lexical-cursor]");
          if (lexicalCursor) {
            let currentElement = lexicalCursor.previousElementSibling;
            while (currentElement && currentElement.hasAttribute("data-lexical-cursor")) {
              currentElement = currentElement.previousElementSibling;
            }
            if (!currentElement) {
              event.preventDefault();
            }
          }
        }
        if (event.key === "ArrowDown") {
          const lexicalCursor = this.editor.getRootElement().querySelector("[data-lexical-cursor]");
          if (lexicalCursor) {
            let currentElement = lexicalCursor.nextElementSibling;
            while (currentElement && currentElement.hasAttribute("data-lexical-cursor")) {
              currentElement = currentElement.nextElementSibling;
            }
            if (!currentElement) {
              event.preventDefault();
            }
          }
        }
      }, true);
    }
    #syncSelectedClasses() {
      this.#clearPreviouslyHighlightedItems();
      this.#highlightNewItems();
      this.previouslySelectedKeys = this.#currentlySelectedKeys;
      this.currentlySelectedKeys = null;
    }
    #clearPreviouslyHighlightedItems() {
      for (const key of this.previouslySelectedKeys) {
        if (!this.#currentlySelectedKeys.has(key)) {
          const dom = this.editor.getElementByKey(key);
          if (dom) dom.classList.remove("node--selected");
        }
      }
    }
    #highlightNewItems() {
      for (const key of this.#currentlySelectedKeys) {
        if (!this.previouslySelectedKeys.has(key)) {
          const nodeElement = this.editor.getElementByKey(key);
          if (nodeElement) nodeElement.classList.add("node--selected");
        }
      }
    }
    async #selectPreviousNode() {
      if (this.hasNodeSelection) {
        await this.#withCurrentNode((currentNode) => currentNode.selectPrevious());
      } else {
        this.#selectInLexical(this.nodeBeforeCursor);
      }
    }
    async #selectNextNode() {
      if (this.hasNodeSelection) {
        await this.#withCurrentNode((currentNode) => currentNode.selectNext(0, 0));
      } else {
        this.#selectInLexical(this.nodeAfterCursor);
      }
    }
    async #selectPreviousTopLevelNode() {
      if (this.hasNodeSelection) {
        await this.#withCurrentNode((currentNode) => currentNode.selectPrevious());
      } else {
        this.#selectInLexical(this.topLevelNodeBeforeCursor);
      }
    }
    async #selectNextTopLevelNode() {
      if (this.hasNodeSelection) {
        await this.#withCurrentNode((currentNode) => currentNode.selectNext(0, 0));
      } else {
        this.#selectInLexical(this.topLevelNodeAfterCursor);
      }
    }
    async #withCurrentNode(fn) {
      await nextFrame();
      if (this.hasNodeSelection) {
        this.editor.update(() => {
          fn($getSelection2().getNodes()[0]);
          this.editor.focus();
        });
      }
    }
    async #selectOrAppendNextLine() {
      this.editor.update(() => {
        const topLevelElement = this.#getTopLevelElementFromSelection();
        if (!topLevelElement) return;
        this.#moveToOrCreateNextLine(topLevelElement);
      });
    }
    #getTopLevelElementFromSelection() {
      const selection = $getSelection2();
      if (!selection) return null;
      if ($isNodeSelection2(selection)) {
        return this.#getTopLevelFromNodeSelection(selection);
      }
      if ($isRangeSelection2(selection)) {
        return this.#getTopLevelFromRangeSelection(selection);
      }
      return null;
    }
    #getTopLevelFromNodeSelection(selection) {
      const nodes = selection.getNodes();
      return nodes.length > 0 ? nodes[0].getTopLevelElement() : null;
    }
    #getTopLevelFromRangeSelection(selection) {
      const anchorNode = selection.anchor.getNode();
      return anchorNode.getTopLevelElement();
    }
    #moveToOrCreateNextLine(topLevelElement) {
      const nextSibling = topLevelElement.getNextSibling();
      if (nextSibling) {
        nextSibling.selectStart();
      } else {
        this.#createAndSelectNewParagraph();
      }
    }
    #createAndSelectNewParagraph() {
      const root = $getRoot2();
      const newParagraph = $createParagraphNode2();
      root.append(newParagraph);
      newParagraph.selectStart();
    }
    #selectInLexical(node) {
      if (!node || !(node instanceof DecoratorNode2)) return;
      this.editor.update(() => {
        const selection = $createNodeSelection2();
        selection.add(node.getKey());
        $setSelection2(selection);
      });
    }
    #deleteSelectedOrNext() {
      const node = this.nodeAfterCursor;
      if (node instanceof DecoratorNode2) {
        this.#selectInLexical(node);
        return true;
      } else {
        this.#contents.deleteSelectedNodes();
      }
      return false;
    }
    #deletePreviousOrNext() {
      const node = this.nodeBeforeCursor;
      if (node instanceof DecoratorNode2) {
        this.#selectInLexical(node);
        return true;
      } else {
        this.#contents.deleteSelectedNodes();
      }
      return false;
    }
    #getValidSelectionRange() {
      const lexicalSelection = $getSelection2();
      if (!lexicalSelection || !lexicalSelection.isCollapsed()) return null;
      const nativeSelection = window.getSelection();
      if (!nativeSelection || nativeSelection.rangeCount === 0) return null;
      return nativeSelection.getRangeAt(0);
    }
    #getReliableRectFromRange(range2) {
      let rect = range2.getBoundingClientRect();
      if (this.#isRectUnreliable(rect)) {
        const marker = this.#createAndInsertMarker(range2);
        rect = marker.getBoundingClientRect();
        this.#restoreSelectionAfterMarker(marker);
        marker.remove();
      }
      return rect;
    }
    #isRectUnreliable(rect) {
      return rect.width === 0 && rect.height === 0 || rect.top === 0 && rect.left === 0;
    }
    #createAndInsertMarker(range2) {
      const marker = this.#createMarker();
      range2.insertNode(marker);
      return marker;
    }
    #createMarker() {
      const marker = document.createElement("span");
      marker.textContent = "\u200B";
      marker.style.display = "inline-block";
      marker.style.width = "1px";
      marker.style.height = "1em";
      marker.style.lineHeight = "normal";
      marker.setAttribute("nonce", getNonce());
      return marker;
    }
    #restoreSelectionAfterMarker(marker) {
      const nativeSelection = window.getSelection();
      nativeSelection.removeAllRanges();
      const newRange = document.createRange();
      newRange.setStartAfter(marker);
      newRange.collapse(true);
      nativeSelection.addRange(newRange);
    }
    #calculateCursorPosition(rect, range2) {
      const rootRect = this.editor.getRootElement().getBoundingClientRect();
      const x2 = rect.left - rootRect.left;
      let y3 = rect.top - rootRect.top;
      const fontSize = this.#getFontSizeForCursor(range2);
      if (!isNaN(fontSize)) {
        y3 += fontSize;
      }
      return { x: x2, y: y3, fontSize };
    }
    #getFontSizeForCursor(range2) {
      const nativeSelection = window.getSelection();
      const anchorNode = nativeSelection.anchorNode;
      const parentElement = this.#getElementFromNode(anchorNode);
      if (parentElement instanceof HTMLElement) {
        const computed2 = window.getComputedStyle(parentElement);
        return parseFloat(computed2.fontSize);
      }
      return 0;
    }
    #getElementFromNode(node) {
      return node?.nodeType === Node.TEXT_NODE ? node.parentElement : node;
    }
    #getCollapsedSelectionData() {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) || !selection.isCollapsed()) {
        return { anchorNode: null, offset: 0 };
      }
      const { anchor } = selection;
      return { anchorNode: anchor.getNode(), offset: anchor.offset };
    }
    #getNodeAfterTextNode(anchorNode, offset) {
      if (offset === anchorNode.getTextContentSize()) {
        return this.#getNextNodeFromTextEnd(anchorNode);
      }
      return null;
    }
    #getNextNodeFromTextEnd(anchorNode) {
      if (anchorNode.getNextSibling() instanceof DecoratorNode2) {
        return anchorNode.getNextSibling();
      }
      const parent = anchorNode.getParent();
      return parent ? parent.getNextSibling() : null;
    }
    #getNodeAfterElementNode(anchorNode, offset) {
      if (offset < anchorNode.getChildrenSize()) {
        return anchorNode.getChildAtIndex(offset);
      }
      return this.#findNextSiblingUp(anchorNode);
    }
    #getNodeBeforeTextNode(anchorNode, offset) {
      if (offset === 0) {
        return this.#getPreviousNodeFromTextStart(anchorNode);
      }
      return null;
    }
    #getPreviousNodeFromTextStart(anchorNode) {
      if (anchorNode.getPreviousSibling() instanceof DecoratorNode2) {
        return anchorNode.getPreviousSibling();
      }
      const parent = anchorNode.getParent();
      return parent.getPreviousSibling();
    }
    #getNodeBeforeElementNode(anchorNode, offset) {
      if (offset > 0) {
        return anchorNode.getChildAtIndex(offset - 1);
      }
      return this.#findPreviousSiblingUp(anchorNode);
    }
    #findNextSiblingUp(node) {
      let current = node;
      while (current && current.getNextSibling() == null) {
        current = current.getParent();
      }
      return current ? current.getNextSibling() : null;
    }
    #findPreviousSiblingUp(node) {
      let current = node;
      while (current && current.getPreviousSibling() == null) {
        current = current.getParent();
      }
      return current ? current.getPreviousSibling() : null;
    }
  };
  function sanitize(html2) {
    return purify.sanitize(html2, buildConfig());
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_3, char) => `-${char.toLowerCase()}`);
  }
  function isUrl(string) {
    try {
      new URL(string);
      return true;
    } catch {
      return false;
    }
  }
  function normalizeFilteredText(string) {
    return string.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  }
  function filterMatches(text2, potentialMatch) {
    return normalizeFilteredText(text2).includes(normalizeFilteredText(potentialMatch));
  }
  function upcaseFirst(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  var EditorConfiguration = class {
    #editorElement;
    #config;
    constructor(editorElement) {
      this.#editorElement = editorElement;
      this.#config = new Configuration(
        Lexxy.presets.get("default"),
        Lexxy.presets.get(editorElement.preset),
        this.#overrides
      );
    }
    get(path) {
      return this.#config.get(path);
    }
    get #overrides() {
      const overrides2 = {};
      for (const option of this.#defaultOptions) {
        const attribute = dasherize(option);
        if (this.#editorElement.hasAttribute(attribute)) {
          overrides2[option] = this.#parseAttribute(attribute);
        }
      }
      return overrides2;
    }
    get #defaultOptions() {
      return Object.keys(Lexxy.presets.get("default"));
    }
    #parseAttribute(attribute) {
      const value = this.#editorElement.getAttribute(attribute);
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
  };
  var CustomActionTextAttachmentNode = class _CustomActionTextAttachmentNode extends DecoratorNode2 {
    static getType() {
      return "custom_action_text_attachment";
    }
    static clone(node) {
      return new _CustomActionTextAttachmentNode({ ...node }, node.__key);
    }
    static importJSON(serializedNode) {
      return new _CustomActionTextAttachmentNode({ ...serializedNode });
    }
    static importDOM() {
      return {
        [this.TAG_NAME]: (element) => {
          if (!element.getAttribute("content")) {
            return null;
          }
          return {
            conversion: (attachment) => {
              const nodes = [];
              const previousSibling = attachment.previousSibling;
              if (previousSibling && previousSibling.nodeType === Node.TEXT_NODE && /\s$/.test(previousSibling.textContent)) {
                nodes.push($createTextNode2(" "));
              }
              nodes.push(new _CustomActionTextAttachmentNode({
                sgid: attachment.getAttribute("sgid"),
                innerHtml: JSON.parse(attachment.getAttribute("content")),
                contentType: attachment.getAttribute("content-type")
              }));
              nodes.push($createTextNode2(" "));
              return { node: nodes };
            },
            priority: 2
          };
        }
      };
    }
    static get TAG_NAME() {
      return Lexxy.global.get("attachmentTagName");
    }
    constructor({ tagName, sgid, contentType, innerHtml }, key) {
      super(key);
      const contentTypeNamespace = Lexxy.global.get("attachmentContentTypeNamespace");
      this.tagName = tagName || _CustomActionTextAttachmentNode.TAG_NAME;
      this.sgid = sgid;
      this.contentType = contentType || `application/vnd.${contentTypeNamespace}.unknown`;
      this.innerHtml = innerHtml;
    }
    createDOM() {
      const figure = createElement(this.tagName, { "content-type": this.contentType, "data-lexxy-decorator": true });
      figure.addEventListener("click", (event) => {
        dispatchCustomEvent(figure, "lexxy:internal:select-node", { key: this.getKey() });
      });
      figure.insertAdjacentHTML("beforeend", this.innerHtml);
      return figure;
    }
    updateDOM() {
      return true;
    }
    getTextContent() {
      return this.createDOM().textContent.trim() || `[${this.contentType}]`;
    }
    isInline() {
      return true;
    }
    exportDOM() {
      const attachment = createElement(this.tagName, {
        sgid: this.sgid,
        content: JSON.stringify(this.innerHtml),
        "content-type": this.contentType
      });
      return { element: attachment };
    }
    exportJSON() {
      return {
        type: "custom_action_text_attachment",
        version: 1,
        tagName: this.tagName,
        sgid: this.sgid,
        contentType: this.contentType,
        innerHtml: this.innerHtml
      };
    }
    decorate() {
      return null;
    }
  };
  var FormatEscaper = class {
    constructor(editorElement) {
      this.editorElement = editorElement;
      this.editor = editorElement.editor;
    }
    monitor() {
      this.editor.registerCommand(
        KEY_ENTER_COMMAND2,
        (event) => this.#handleEnterKey(event),
        COMMAND_PRIORITY_HIGH2
      );
    }
    #handleEnterKey(event) {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) return false;
      const anchorNode = selection.anchor.getNode();
      if (!this.#isInsideBlockquote(anchorNode)) return false;
      return this.#handleLists(event, anchorNode) || this.#handleBlockquotes(event, anchorNode);
    }
    #handleLists(event, anchorNode) {
      if (this.#shouldEscapeFromEmptyListItem(anchorNode) || this.#shouldEscapeFromEmptyParagraphInListItem(anchorNode)) {
        event.preventDefault();
        this.#escapeFromList(anchorNode);
        return true;
      }
      return false;
    }
    #handleBlockquotes(event, anchorNode) {
      if (this.#shouldEscapeFromEmptyParagraphInBlockquote(anchorNode)) {
        event.preventDefault();
        this.#escapeFromBlockquote(anchorNode);
        return true;
      }
      return false;
    }
    #isInsideBlockquote(node) {
      let currentNode = node;
      while (currentNode) {
        if ($isQuoteNode2(currentNode)) {
          return true;
        }
        currentNode = currentNode.getParent();
      }
      return false;
    }
    #shouldEscapeFromEmptyListItem(node) {
      const listItem = this.#getListItemNode(node);
      if (!listItem) return false;
      return this.#isNodeEmpty(listItem);
    }
    #shouldEscapeFromEmptyParagraphInListItem(node) {
      const paragraph = this.#getParagraphNode(node);
      if (!paragraph) return false;
      if (!this.#isNodeEmpty(paragraph)) return false;
      const parent = paragraph.getParent();
      return parent && $isListItemNode2(parent);
    }
    #isNodeEmpty(node) {
      if (node.getTextContent().trim() !== "") return false;
      const children = node.getChildren();
      if (children.length === 0) return true;
      return children.every((child) => {
        if ($isLineBreakNode2(child)) return true;
        return this.#isNodeEmpty(child);
      });
    }
    #getListItemNode(node) {
      let currentNode = node;
      while (currentNode) {
        if ($isListItemNode2(currentNode)) {
          return currentNode;
        }
        currentNode = currentNode.getParent();
      }
      return null;
    }
    #escapeFromList(anchorNode) {
      const listItem = this.#getListItemNode(anchorNode);
      if (!listItem) return;
      const parentList = listItem.getParent();
      if (!parentList || !$isListNode2(parentList)) return;
      const blockquote = parentList.getParent();
      const isInBlockquote = blockquote && $isQuoteNode2(blockquote);
      if (isInBlockquote) {
        const listItemsAfter = this.#getListItemSiblingsAfter(listItem);
        const nonEmptyListItems = listItemsAfter.filter((item) => !this.#isNodeEmpty(item));
        if (nonEmptyListItems.length > 0) {
          this.#splitBlockquoteWithList(blockquote, parentList, listItem, nonEmptyListItems);
          return;
        }
      }
      const paragraph = $createParagraphNode2();
      parentList.insertAfter(paragraph);
      listItem.remove();
      paragraph.selectStart();
    }
    #shouldEscapeFromEmptyParagraphInBlockquote(node) {
      const paragraph = this.#getParagraphNode(node);
      if (!paragraph) return false;
      if (!this.#isNodeEmpty(paragraph)) return false;
      const parent = paragraph.getParent();
      return parent && $isQuoteNode2(parent);
    }
    #getParagraphNode(node) {
      let currentNode = node;
      while (currentNode) {
        if ($isParagraphNode2(currentNode)) {
          return currentNode;
        }
        currentNode = currentNode.getParent();
      }
      return null;
    }
    #escapeFromBlockquote(anchorNode) {
      const paragraph = this.#getParagraphNode(anchorNode);
      if (!paragraph) return;
      const blockquote = paragraph.getParent();
      if (!blockquote || !$isQuoteNode2(blockquote)) return;
      const siblingsAfter = this.#getSiblingsAfter(paragraph);
      const nonEmptySiblings = siblingsAfter.filter((sibling) => !this.#isNodeEmpty(sibling));
      if (nonEmptySiblings.length > 0) {
        this.#splitBlockquote(blockquote, paragraph, nonEmptySiblings);
      } else {
        const newParagraph = $createParagraphNode2();
        blockquote.insertAfter(newParagraph);
        paragraph.remove();
        newParagraph.selectStart();
      }
    }
    #getSiblingsAfter(node) {
      const siblings = [];
      let sibling = node.getNextSibling();
      while (sibling) {
        siblings.push(sibling);
        sibling = sibling.getNextSibling();
      }
      return siblings;
    }
    #getListItemSiblingsAfter(listItem) {
      const siblings = [];
      let sibling = listItem.getNextSibling();
      while (sibling) {
        if ($isListItemNode2(sibling)) {
          siblings.push(sibling);
        }
        sibling = sibling.getNextSibling();
      }
      return siblings;
    }
    #splitBlockquoteWithList(blockquote, parentList, emptyListItem, listItemsAfter) {
      const blockquoteSiblingsAfterList = this.#getSiblingsAfter(parentList);
      const nonEmptyBlockquoteSiblings = blockquoteSiblingsAfterList.filter((sibling) => !this.#isNodeEmpty(sibling));
      const middleParagraph = $createParagraphNode2();
      blockquote.insertAfter(middleParagraph);
      const newList = $createListNode2(parentList.getListType());
      const newBlockquote = $createQuoteNode2();
      middleParagraph.insertAfter(newBlockquote);
      newBlockquote.append(newList);
      listItemsAfter.forEach((item) => {
        newList.append(item);
      });
      nonEmptyBlockquoteSiblings.forEach((sibling) => {
        newBlockquote.append(sibling);
      });
      emptyListItem.remove();
      this.#removeTrailingEmptyListItems(parentList);
      this.#removeTrailingEmptyNodes(newBlockquote);
      if (parentList.getChildrenSize() === 0) {
        parentList.remove();
        if (blockquote.getChildrenSize() === 0) {
          blockquote.remove();
        }
      } else {
        this.#removeTrailingEmptyNodes(blockquote);
      }
      middleParagraph.selectStart();
    }
    #removeTrailingEmptyListItems(list) {
      const items = list.getChildren();
      for (let i2 = items.length - 1; i2 >= 0; i2--) {
        const item = items[i2];
        if ($isListItemNode2(item) && this.#isNodeEmpty(item)) {
          item.remove();
        } else {
          break;
        }
      }
    }
    #removeTrailingEmptyNodes(blockquote) {
      const children = blockquote.getChildren();
      for (let i2 = children.length - 1; i2 >= 0; i2--) {
        const child = children[i2];
        if (this.#isNodeEmpty(child)) {
          child.remove();
        } else {
          break;
        }
      }
    }
    #splitBlockquote(blockquote, emptyParagraph, siblingsAfter) {
      const newParagraph = $createParagraphNode2();
      blockquote.insertAfter(newParagraph);
      const newBlockquote = $createQuoteNode2();
      newParagraph.insertAfter(newBlockquote);
      siblingsAfter.forEach((sibling) => {
        newBlockquote.append(sibling);
      });
      emptyParagraph.remove();
      this.#removeTrailingEmptyNodes(blockquote);
      this.#removeTrailingEmptyNodes(newBlockquote);
      newParagraph.selectStart();
    }
  };
  var Contents = class {
    constructor(editorElement) {
      this.editorElement = editorElement;
      this.editor = editorElement.editor;
      new FormatEscaper(editorElement).monitor();
    }
    insertHtml(html2, { tag } = {}) {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        const nodes = $generateNodesFromDOM2(this.editor, parseHtml(html2));
        selection.insertNodes(nodes);
      }, { tag });
    }
    insertAtCursor(node) {
      this.editor.update(() => {
        const selection = $getSelection2();
        const selectedNodes = selection?.getNodes();
        if ($isRangeSelection2(selection)) {
          $insertNodes2([node]);
        } else if ($isNodeSelection2(selection) && selectedNodes && selectedNodes.length > 0) {
          const lastNode = selectedNodes[selectedNodes.length - 1];
          lastNode.insertAfter(node);
        } else {
          const root = $getRoot2();
          root.append(node);
        }
      });
    }
    insertAtCursorEnsuringLineBelow(node) {
      this.insertAtCursor(node);
      this.#insertLineBelowIfLastNode(node);
    }
    insertNodeWrappingEachSelectedLine(newNodeFn) {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        const selectedNodes = selection.extract();
        selectedNodes.forEach((node) => {
          const parent = node.getParent();
          if (!parent) {
            return;
          }
          const topLevelElement = node.getTopLevelElementOrThrow();
          const wrappingNode = newNodeFn();
          wrappingNode.append(...topLevelElement.getChildren());
          topLevelElement.replace(wrappingNode);
        });
      });
    }
    toggleNodeWrappingAllSelectedLines(isFormatAppliedFn, newNodeFn) {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        const topLevelElement = selection.anchor.getNode().getTopLevelElementOrThrow();
        if (isFormatAppliedFn(topLevelElement)) {
          this.removeFormattingFromSelectedLines();
        } else {
          this.#insertNodeWrappingAllSelectedLines(newNodeFn);
        }
      });
    }
    toggleNodeWrappingAllSelectedNodes(isFormatAppliedFn, newNodeFn) {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        const topLevelElement = selection.anchor.getNode().getTopLevelElement();
        if (topLevelElement && isFormatAppliedFn(topLevelElement)) {
          this.#unwrap(topLevelElement);
        } else {
          this.#insertNodeWrappingAllSelectedNodes(newNodeFn);
        }
      });
    }
    removeFormattingFromSelectedLines() {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        const topLevelElement = selection.anchor.getNode().getTopLevelElementOrThrow();
        const paragraph = $createParagraphNode2();
        paragraph.append(...topLevelElement.getChildren());
        topLevelElement.replace(paragraph);
      });
    }
    hasSelectedText() {
      let result = false;
      this.editor.read(() => {
        const selection = $getSelection2();
        result = $isRangeSelection2(selection) && !selection.isCollapsed();
      });
      return result;
    }
    unwrapSelectedListItems() {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        const { listItems, parentLists } = this.#collectSelectedListItems(selection);
        if (listItems.size > 0) {
          const newParagraphs = this.#convertListItemsToParagraphs(listItems);
          this.#removeEmptyParentLists(parentLists);
          this.#selectNewParagraphs(newParagraphs);
        }
      });
    }
    createLink(url) {
      let linkNodeKey = null;
      this.editor.update(() => {
        const textNode = $createTextNode2(url);
        const linkNode = $createLinkNode2(url);
        linkNode.append(textNode);
        const selection = $getSelection2();
        if ($isRangeSelection2(selection)) {
          selection.insertNodes([linkNode]);
          linkNodeKey = linkNode.getKey();
        }
      });
      return linkNodeKey;
    }
    createLinkWithSelectedText(url) {
      if (!this.hasSelectedText()) return;
      this.editor.update(() => {
        $toggleLink2(url);
      });
    }
    textBackUntil(string) {
      let result = "";
      this.editor.getEditorState().read(() => {
        const selection = $getSelection2();
        if (!selection || !selection.isCollapsed()) return;
        const anchor = selection.anchor;
        const anchorNode = anchor.getNode();
        if (!$isTextNode2(anchorNode)) return;
        const fullText = anchorNode.getTextContent();
        const offset = anchor.offset;
        const textBeforeCursor = fullText.slice(0, offset);
        const lastIndex = textBeforeCursor.lastIndexOf(string);
        if (lastIndex !== -1) {
          result = textBeforeCursor.slice(lastIndex + string.length);
        }
      });
      return result;
    }
    containsTextBackUntil(string) {
      let result = false;
      this.editor.getEditorState().read(() => {
        const selection = $getSelection2();
        if (!selection || !selection.isCollapsed()) return;
        const anchor = selection.anchor;
        const anchorNode = anchor.getNode();
        if (!$isTextNode2(anchorNode)) return;
        const fullText = anchorNode.getTextContent();
        const offset = anchor.offset;
        const textBeforeCursor = fullText.slice(0, offset);
        result = textBeforeCursor.includes(string);
      });
      return result;
    }
    replaceTextBackUntil(stringToReplace, replacementNodes) {
      replacementNodes = Array.isArray(replacementNodes) ? replacementNodes : [replacementNodes];
      this.editor.update(() => {
        const { anchorNode, offset } = this.#getTextAnchorData();
        if (!anchorNode) return;
        const lastIndex = this.#findLastIndexBeforeCursor(anchorNode, offset, stringToReplace);
        if (lastIndex === -1) return;
        this.#performTextReplacement(anchorNode, offset, lastIndex, replacementNodes);
      });
    }
    createParagraphAfterNode(node, text2) {
      const newParagraph = $createParagraphNode2();
      node.insertAfter(newParagraph);
      newParagraph.selectStart();
      if (text2) {
        newParagraph.append($createTextNode2(text2));
        newParagraph.select(1, 1);
      }
    }
    createParagraphBeforeNode(node, text2) {
      const newParagraph = $createParagraphNode2();
      node.insertBefore(newParagraph);
      newParagraph.selectStart();
      if (text2) {
        newParagraph.append($createTextNode2(text2));
        newParagraph.select(1, 1);
      }
    }
    uploadFile(file) {
      if (!this.editorElement.supportsAttachments) {
        console.warn("This editor does not supports attachments (it's configured with [attachments=false])");
        return;
      }
      if (!this.#shouldUploadFile(file)) {
        return;
      }
      const uploadUrl = this.editorElement.directUploadUrl;
      const blobUrlTemplate = this.editorElement.blobUrlTemplate;
      this.editor.update(() => {
        const uploadedImageNode = new ActionTextAttachmentUploadNode({ file, uploadUrl, blobUrlTemplate, editor: this.editor });
        this.insertAtCursor(uploadedImageNode);
      }, { tag: HISTORY_MERGE_TAG2 });
    }
    async deleteSelectedNodes() {
      let focusNode = null;
      this.editor.update(() => {
        if (this.#selection.hasNodeSelection) {
          const nodesToRemove = $getSelection2().getNodes();
          if (nodesToRemove.length === 0) return;
          focusNode = this.#findAdjacentNodeTo(nodesToRemove);
          this.#deleteNodes(nodesToRemove);
        }
      });
      await nextFrame();
      this.editor.update(() => {
        this.#selectAfterDeletion(focusNode);
        this.editor.focus();
      });
    }
    replaceNodeWithHTML(nodeKey, html2, options = {}) {
      this.editor.update(() => {
        const node = $getNodeByKey2(nodeKey);
        if (!node) return;
        const selection = $getSelection2();
        let wasSelected = false;
        if ($isRangeSelection2(selection)) {
          const selectedNodes = selection.getNodes();
          wasSelected = selectedNodes.includes(node) || selectedNodes.some((n2) => n2.getParent() === node);
          if (wasSelected) {
            $setSelection2(null);
          }
        }
        const replacementNode = options.attachment ? this.#createCustomAttachmentNodeWithHtml(html2, options.attachment) : this.#createHtmlNodeWith(html2);
        node.replace(replacementNode);
        if (wasSelected) {
          replacementNode.selectEnd();
        }
      });
    }
    insertHTMLBelowNode(nodeKey, html2, options = {}) {
      this.editor.update(() => {
        const node = $getNodeByKey2(nodeKey);
        if (!node) return;
        const previousNode = node.getTopLevelElement() || node;
        const newNode = options.attachment ? this.#createCustomAttachmentNodeWithHtml(html2, options.attachment) : this.#createHtmlNodeWith(html2);
        previousNode.insertAfter(newNode);
      });
    }
    get #selection() {
      return this.editorElement.selection;
    }
    #insertLineBelowIfLastNode(node) {
      this.editor.update(() => {
        const nextSibling = node.getNextSibling();
        if (!nextSibling) {
          const newParagraph = $createParagraphNode2();
          node.insertAfter(newParagraph);
          newParagraph.selectStart();
        }
      });
    }
    #unwrap(node) {
      const children = node.getChildren();
      if (children.length == 0) {
        node.insertBefore($createParagraphNode2());
      } else {
        children.forEach((child) => {
          if ($isTextNode2(child) && child.getTextContent().trim() !== "") {
            const newParagraph = $createParagraphNode2();
            newParagraph.append(child);
            node.insertBefore(newParagraph);
          } else if (!$isLineBreakNode2(child)) {
            node.insertBefore(child);
          }
        });
      }
      node.remove();
    }
    #insertNodeWrappingAllSelectedNodes(newNodeFn) {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        const selectedNodes = selection.extract();
        if (selectedNodes.length === 0) {
          return;
        }
        const topLevelElements = /* @__PURE__ */ new Set();
        selectedNodes.forEach((node) => {
          const topLevel = node.getTopLevelElementOrThrow();
          topLevelElements.add(topLevel);
        });
        const elements2 = this.#withoutTrailingEmptyParagraphs(Array.from(topLevelElements));
        if (elements2.length === 0) {
          this.#removeStandaloneEmptyParagraph();
          this.insertAtCursor(newNodeFn());
          return;
        }
        const wrappingNode = newNodeFn();
        elements2[0].insertBefore(wrappingNode);
        elements2.forEach((element) => {
          wrappingNode.append(element);
        });
      });
    }
    #withoutTrailingEmptyParagraphs(elements2) {
      let lastNonEmptyIndex = elements2.length - 1;
      while (lastNonEmptyIndex >= 0) {
        const element = elements2[lastNonEmptyIndex];
        if (!$isParagraphNode2(element) || !this.#isElementEmpty(element)) {
          break;
        }
        lastNonEmptyIndex--;
      }
      return elements2.slice(0, lastNonEmptyIndex + 1);
    }
    #isElementEmpty(element) {
      if (element.getTextContent().trim() !== "") return false;
      const children = element.getChildren();
      return children.length === 0 || children.every((child) => $isLineBreakNode2(child));
    }
    #removeStandaloneEmptyParagraph() {
      const root = $getRoot2();
      if (root.getChildrenSize() === 1) {
        const firstChild = root.getFirstChild();
        if (firstChild && $isParagraphNode2(firstChild) && this.#isElementEmpty(firstChild)) {
          firstChild.remove();
        }
      }
    }
    #insertNodeWrappingAllSelectedLines(newNodeFn) {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        if (selection.isCollapsed()) {
          this.#wrapCurrentLine(selection, newNodeFn);
        } else {
          this.#wrapMultipleSelectedLines(selection, newNodeFn);
        }
      });
    }
    #wrapCurrentLine(selection, newNodeFn) {
      const anchorNode = selection.anchor.getNode();
      const topLevelElement = anchorNode.getTopLevelElementOrThrow();
      if (topLevelElement.getTextContent()) {
        const wrappingNode = newNodeFn();
        wrappingNode.append(...topLevelElement.getChildren());
        topLevelElement.replace(wrappingNode);
      } else {
        $insertNodes2([newNodeFn()]);
      }
    }
    #wrapMultipleSelectedLines(selection, newNodeFn) {
      const selectedParagraphs = this.#extractSelectedParagraphs(selection);
      if (selectedParagraphs.length === 0) return;
      const { lineSet, nodesToDelete } = this.#extractUniqueLines(selectedParagraphs);
      if (lineSet.size === 0) return;
      const wrappingNode = this.#createWrappingNodeWithLines(newNodeFn, lineSet);
      this.#replaceWithWrappingNode(selection, wrappingNode);
      this.#removeNodes(nodesToDelete);
    }
    #extractSelectedParagraphs(selection) {
      const selectedNodes = selection.extract();
      const selectedParagraphs = selectedNodes.map((node) => this.#getParagraphFromNode(node)).filter(Boolean);
      $setSelection2(null);
      return selectedParagraphs;
    }
    #getParagraphFromNode(node) {
      if ($isParagraphNode2(node)) return node;
      if ($isTextNode2(node) && node.getParent() && $isParagraphNode2(node.getParent())) {
        return node.getParent();
      }
      return null;
    }
    #extractUniqueLines(selectedParagraphs) {
      const lineSet = /* @__PURE__ */ new Set();
      const nodesToDelete = /* @__PURE__ */ new Set();
      selectedParagraphs.forEach((paragraphNode) => {
        const textContent = paragraphNode.getTextContent();
        if (textContent) {
          textContent.split("\n").forEach((line) => {
            if (line.trim()) lineSet.add(line);
          });
        }
        nodesToDelete.add(paragraphNode);
      });
      return { lineSet, nodesToDelete };
    }
    #createWrappingNodeWithLines(newNodeFn, lineSet) {
      const wrappingNode = newNodeFn();
      const lines = Array.from(lineSet);
      lines.forEach((lineText, index2) => {
        wrappingNode.append($createTextNode2(lineText));
        if (index2 < lines.length - 1) {
          wrappingNode.append($createLineBreakNode2());
        }
      });
      return wrappingNode;
    }
    #replaceWithWrappingNode(selection, wrappingNode) {
      const anchorNode = selection.anchor.getNode();
      const parent = anchorNode.getParent();
      if (parent) {
        parent.replace(wrappingNode);
      }
    }
    #removeNodes(nodesToDelete) {
      nodesToDelete.forEach((node) => node.remove());
    }
    #deleteNodes(nodes) {
      nodes.forEach((node) => {
        const parent = node.getParent();
        if (!$isElementNode2(parent)) return;
        const children = parent.getChildren();
        const index2 = children.indexOf(node);
        if (index2 >= 0) {
          parent.splice(index2, 1, []);
        }
      });
    }
    #findAdjacentNodeTo(nodes) {
      const firstNode = nodes[0];
      const lastNode = nodes[nodes.length - 1];
      return firstNode?.getPreviousSibling() || lastNode?.getNextSibling();
    }
    #selectAfterDeletion(focusNode) {
      const root = $getRoot2();
      if (root.getChildrenSize() === 0) {
        const newParagraph = $createParagraphNode2();
        root.append(newParagraph);
        newParagraph.selectStart();
      } else if (focusNode) {
        if ($isTextNode2(focusNode) || $isParagraphNode2(focusNode)) {
          focusNode.selectEnd();
        } else {
          focusNode.selectNext(0, 0);
        }
      }
    }
    #collectSelectedListItems(selection) {
      const nodes = selection.getNodes();
      const listItems = /* @__PURE__ */ new Set();
      const parentLists = /* @__PURE__ */ new Set();
      for (const node of nodes) {
        const listItem = getNearestListItemNode(node);
        if (listItem) {
          listItems.add(listItem);
          const parentList = listItem.getParent();
          if (parentList && $isListNode2(parentList)) {
            parentLists.add(parentList);
          }
        }
      }
      return { listItems, parentLists };
    }
    #convertListItemsToParagraphs(listItems) {
      const newParagraphs = [];
      for (const listItem of listItems) {
        const paragraph = this.#convertListItemToParagraph(listItem);
        if (paragraph) {
          newParagraphs.push(paragraph);
        }
      }
      return newParagraphs;
    }
    #convertListItemToParagraph(listItem) {
      const parentList = listItem.getParent();
      if (!parentList || !$isListNode2(parentList)) return null;
      const paragraph = $createParagraphNode2();
      const sublists = this.#extractSublistsAndContent(listItem, paragraph);
      listItem.insertAfter(paragraph);
      this.#insertSublists(paragraph, sublists);
      listItem.remove();
      return paragraph;
    }
    #extractSublistsAndContent(listItem, paragraph) {
      const sublists = [];
      listItem.getChildren().forEach((child) => {
        if ($isListNode2(child)) {
          sublists.push(child);
        } else {
          paragraph.append(child);
        }
      });
      return sublists;
    }
    #insertSublists(paragraph, sublists) {
      sublists.forEach((sublist) => {
        paragraph.insertAfter(sublist);
      });
    }
    #removeEmptyParentLists(parentLists) {
      for (const parentList of parentLists) {
        if ($isListNode2(parentList) && parentList.getChildrenSize() === 0) {
          parentList.remove();
        }
      }
    }
    #selectNewParagraphs(newParagraphs) {
      if (newParagraphs.length === 0) return;
      const firstParagraph = newParagraphs[0];
      const lastParagraph = newParagraphs[newParagraphs.length - 1];
      if (newParagraphs.length === 1) {
        firstParagraph.selectEnd();
      } else {
        this.#selectParagraphRange(firstParagraph, lastParagraph);
      }
    }
    #selectParagraphRange(firstParagraph, lastParagraph) {
      firstParagraph.selectStart();
      const currentSelection = $getSelection2();
      if (currentSelection && $isRangeSelection2(currentSelection)) {
        currentSelection.anchor.set(firstParagraph.getKey(), 0, "element");
        currentSelection.focus.set(lastParagraph.getKey(), lastParagraph.getChildrenSize(), "element");
      }
    }
    #getTextAnchorData() {
      const selection = $getSelection2();
      if (!selection || !selection.isCollapsed()) return { anchorNode: null, offset: 0 };
      const anchor = selection.anchor;
      const anchorNode = anchor.getNode();
      if (!$isTextNode2(anchorNode)) return { anchorNode: null, offset: 0 };
      return { anchorNode, offset: anchor.offset };
    }
    #findLastIndexBeforeCursor(anchorNode, offset, stringToReplace) {
      const fullText = anchorNode.getTextContent();
      const textBeforeCursor = fullText.slice(0, offset);
      return textBeforeCursor.lastIndexOf(stringToReplace);
    }
    #performTextReplacement(anchorNode, offset, lastIndex, replacementNodes) {
      const fullText = anchorNode.getTextContent();
      const textBeforeString = fullText.slice(0, lastIndex);
      const textAfterCursor = fullText.slice(offset);
      const textNodeBefore = $createTextNode2(textBeforeString);
      const textNodeAfter = $createTextNode2(textAfterCursor || " ");
      anchorNode.replace(textNodeBefore);
      const lastInsertedNode = this.#insertReplacementNodes(textNodeBefore, replacementNodes);
      lastInsertedNode.insertAfter(textNodeAfter);
      this.#appendLineBreakIfNeeded(textNodeAfter.getParentOrThrow());
      const cursorOffset = textAfterCursor ? 0 : 1;
      textNodeAfter.select(cursorOffset, cursorOffset);
    }
    #insertReplacementNodes(startNode, replacementNodes) {
      let previousNode = startNode;
      for (const node of replacementNodes) {
        previousNode.insertAfter(node);
        previousNode = node;
      }
      return previousNode;
    }
    #appendLineBreakIfNeeded(paragraph) {
      if ($isParagraphNode2(paragraph) && this.editorElement.supportsMultiLine) {
        const children = paragraph.getChildren();
        const last = children[children.length - 1];
        const beforeLast = children[children.length - 2];
        if ($isTextNode2(last) && last.getTextContent() === "" && (beforeLast && !$isTextNode2(beforeLast))) {
          paragraph.append($createLineBreakNode2());
        }
      }
    }
    #createCustomAttachmentNodeWithHtml(html2, options = {}) {
      const attachmentConfig = typeof options === "object" ? options : {};
      return new CustomActionTextAttachmentNode({
        sgid: attachmentConfig.sgid || null,
        contentType: "text/html",
        innerHtml: html2
      });
    }
    #createHtmlNodeWith(html2) {
      const htmlNodes = $generateNodesFromDOM2(this.editor, parseHtml(html2));
      return htmlNodes[0] || $createParagraphNode2();
    }
    #shouldUploadFile(file) {
      return dispatch2(this.editorElement, "lexxy:file-accept", { file }, true);
    }
  };
  var Clipboard = class {
    constructor(editorElement) {
      this.editorElement = editorElement;
      this.editor = editorElement.editor;
      this.contents = editorElement.contents;
    }
    paste(event) {
      const clipboardData = event.clipboardData;
      if (!clipboardData) return false;
      if (this.#isPlainTextOrURLPasted(clipboardData) && !this.#isPastingIntoCodeBlock()) {
        this.#pastePlainText(clipboardData);
        event.preventDefault();
        return true;
      }
      this.#handlePastedFiles(clipboardData);
    }
    #isPlainTextOrURLPasted(clipboardData) {
      return this.#isOnlyPlainTextPasted(clipboardData) || this.#isOnlyURLPasted(clipboardData);
    }
    #isOnlyPlainTextPasted(clipboardData) {
      const types = Array.from(clipboardData.types);
      return types.length === 1 && types[0] === "text/plain";
    }
    #isOnlyURLPasted(clipboardData) {
      const types = Array.from(clipboardData.types);
      return types.length === 2 && types.includes("text/uri-list") && types.includes("text/plain");
    }
    #isPastingIntoCodeBlock() {
      let result = false;
      this.editor.getEditorState().read(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        let currentNode = selection.anchor.getNode();
        while (currentNode) {
          if ($isCodeNode2(currentNode)) {
            result = true;
            return;
          }
          currentNode = currentNode.getParent();
        }
      });
      return result;
    }
    #pastePlainText(clipboardData) {
      const item = clipboardData.items[0];
      item.getAsString((text2) => {
        if (isUrl(text2) && this.contents.hasSelectedText()) {
          this.contents.createLinkWithSelectedText(text2);
        } else if (isUrl(text2)) {
          const nodeKey = this.contents.createLink(text2);
          this.#dispatchLinkInsertEvent(nodeKey, { url: text2 });
        } else if (this.editorElement.supportsMarkdown) {
          this.#pasteMarkdown(text2);
        } else {
          this.#pasteRichText(clipboardData);
        }
      });
    }
    #dispatchLinkInsertEvent(nodeKey, payload) {
      const linkManipulationMethods = {
        replaceLinkWith: (html2, options) => this.contents.replaceNodeWithHTML(nodeKey, html2, options),
        insertBelowLink: (html2, options) => this.contents.insertHTMLBelowNode(nodeKey, html2, options)
      };
      dispatch2(this.editorElement, "lexxy:insert-link", {
        ...payload,
        ...linkManipulationMethods
      });
    }
    #pasteMarkdown(text2) {
      const html2 = k(text2);
      this.contents.insertHtml(html2, { tag: [PASTE_TAG2] });
    }
    #pasteRichText(clipboardData) {
      this.editor.update(() => {
        const selection = $getSelection2();
        $insertDataTransferForRichText2(clipboardData, selection, this.editor);
      }, { tag: PASTE_TAG2 });
    }
    #handlePastedFiles(clipboardData) {
      if (!this.editorElement.supportsAttachments) return;
      const html2 = clipboardData.getData("text/html");
      if (html2) return;
      this.#preservingScrollPosition(() => {
        for (const item of clipboardData.items) {
          const file = item.getAsFile();
          if (!file) continue;
          this.contents.uploadFile(file);
        }
      });
    }
    // Deals with an issue in Safari where it scrolls to the tops after pasting attachments
    async #preservingScrollPosition(callback2) {
      const scrollY = window.scrollY;
      const scrollX = window.scrollX;
      callback2();
      await nextFrame();
      window.scrollTo(scrollX, scrollY);
      this.editor.focus();
    }
  };
  var Extensions = class {
    constructor(lexxyElement) {
      this.lexxyElement = lexxyElement;
      this.enabledExtensions = this.#initializeExtensions();
    }
    get lexicalExtensions() {
      return this.enabledExtensions.map((ext) => ext.lexicalExtension).filter(Boolean);
    }
    initializeToolbars() {
      if (this.#lexxyToolbar) {
        this.enabledExtensions.forEach((ext) => ext.initializeToobar(this.#lexxyToolbar));
      }
    }
    get #lexxyToolbar() {
      return this.lexxyElement.toolbar;
    }
    #initializeExtensions() {
      const extensionDefinitions = Lexxy.global.get("extensions");
      return extensionDefinitions.map(
        (extension) => new extension(this.lexxyElement)
      ).filter((extension) => extension.enabled);
    }
  };
  var TOGGLE_HIGHLIGHT_COMMAND = createCommand2();
  var hasPastedStylesState = createState2("hasPastedStyles", {
    parse: (value) => value || false
  });
  var HighlightExtension = defineExtension2({
    dependencies: [RichTextExtension2],
    name: "lexxy/highlight",
    config: {
      color: { buttons: [], permit: [] },
      "background-color": { buttons: [], permit: [] }
    },
    html: {
      import: {
        mark: $markConversion
      }
    },
    register(editor, config) {
      const canonicalizers = buildCanonicalizers(config);
      editor.registerCommand(TOGGLE_HIGHLIGHT_COMMAND, $toggleSelectionStyles, COMMAND_PRIORITY_NORMAL2);
      editor.registerNodeTransform(TextNode2, $syncHighlightWithStyle);
      editor.registerNodeTransform(TextNode2, (textNode) => $canonicalizePastedStyles(textNode, canonicalizers));
    }
  });
  function $applyHighlightStyle(textNode, element) {
    const elementStyles = {
      color: element.style?.color,
      "background-color": element.style?.backgroundColor
    };
    if ($hasUpdateTag2(PASTE_TAG2)) {
      $setPastedStyles(textNode);
    }
    const highlightStyle = getCSSFromStyleObject2(elementStyles);
    if (highlightStyle.length) {
      return textNode.setStyle(textNode.getStyle() + highlightStyle);
    }
  }
  function $markConversion() {
    return {
      conversion: extendTextNodeConversion("mark", $applyHighlightStyle),
      priority: 1
    };
  }
  function buildCanonicalizers(config) {
    return [
      new StyleCanonicalizer("color", [...config.buttons.color, ...config.permit.color]),
      new StyleCanonicalizer("background-color", [...config.buttons["background-color"], ...config.permit["background-color"]])
    ];
  }
  function $toggleSelectionStyles(styles) {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) return;
    const patch = {};
    for (const property in styles) {
      const oldValue = $getSelectionStyleValueForProperty2(selection, property);
      patch[property] = toggleOrReplace(oldValue, styles[property]);
    }
    $patchStyleText2(selection, patch);
  }
  function toggleOrReplace(oldValue, newValue) {
    return oldValue === newValue ? null : newValue;
  }
  function $syncHighlightWithStyle(textNode) {
    if (hasHighlightStyles(textNode.getStyle()) !== textNode.hasFormat("highlight")) {
      textNode.toggleFormat("highlight");
    }
  }
  function $canonicalizePastedStyles(textNode, canonicalizers = []) {
    if ($hasPastedStyles(textNode)) {
      $setPastedStyles(textNode, false);
      const canonicalizedCSS = canonicalizers.reduce((css, canonicalizer) => {
        return canonicalizer.applyCanonicalization(css);
      }, textNode.getStyle());
      textNode.setStyle(canonicalizedCSS);
    }
  }
  function $setPastedStyles(textNode, value = true) {
    $setState2(textNode, hasPastedStylesState, value);
  }
  function $hasPastedStyles(textNode) {
    return $getState2(textNode, hasPastedStylesState);
  }
  var Highlighter = class {
    constructor(editorElement) {
      this.editorElement = editorElement;
    }
    get editor() {
      return this.editorElement.editor;
    }
    get lexicalExtension() {
      return [HighlightExtension, this.editorElement.config.get("highlight")];
    }
    toggle(styles) {
      this.editor.dispatchCommand(TOGGLE_HIGHLIGHT_COMMAND, styles);
    }
    remove() {
      this.toggle({ "color": null, "background-color": null });
    }
  };
  var TRIX_LANGUAGE_ATTR = "language";
  var TrixContentExtension = defineExtension2({
    name: "lexxy/trix-content",
    html: {
      import: {
        em: (element) => onlyStyledElements(element, {
          conversion: extendTextNodeConversion("i", $applyHighlightStyle),
          priority: 1
        }),
        span: (element) => onlyStyledElements(element, {
          conversion: extendTextNodeConversion("mark", $applyHighlightStyle),
          priority: 1
        }),
        strong: (element) => onlyStyledElements(element, {
          conversion: extendTextNodeConversion("b", $applyHighlightStyle),
          priority: 1
        }),
        del: () => ({
          conversion: extendTextNodeConversion("s", $applyStrikethrough, $applyHighlightStyle),
          priority: 1
        }),
        pre: (element) => onlyPreLanguageElements(element, {
          conversion: extendConversion(CodeNode2, "pre", $applyLanguage),
          priority: 1
        })
      }
    }
  });
  function onlyStyledElements(element, conversion) {
    const elementHighlighted = element.style.color !== "" || element.style.backgroundColor !== "";
    return elementHighlighted ? conversion : null;
  }
  function $applyStrikethrough(textNode) {
    if (!textNode.hasFormat("strikethrough")) textNode.toggleFormat("strikethrough");
    return textNode;
  }
  function onlyPreLanguageElements(element, conversion) {
    return element.hasAttribute(TRIX_LANGUAGE_ATTR) ? conversion : null;
  }
  function $applyLanguage(conversionOutput, element) {
    const language = normalizeCodeLang2(element.getAttribute(TRIX_LANGUAGE_ATTR));
    conversionOutput.node.setLanguage(language);
  }
  var WrappedTableNode = class _WrappedTableNode extends TableNode2 {
    static clone(node) {
      return new _WrappedTableNode(node.__key);
    }
    exportDOM(editor) {
      const superExport = super.exportDOM(editor);
      return {
        ...superExport,
        after: (tableElement) => {
          if (superExport.after) {
            tableElement = superExport.after(tableElement);
            const clonedTable = tableElement.cloneNode(true);
            const wrappedTable = createElement("figure", { className: "lexxy-content__table-wrapper" }, clonedTable.outerHTML);
            return wrappedTable;
          }
          return tableElement;
        }
      };
    }
  };
  var TablesLexicalExtension = defineExtension2({
    name: "lexxy/tables",
    nodes: [
      WrappedTableNode,
      {
        replace: TableNode2,
        with: () => new WrappedTableNode()
      },
      TableCellNode2,
      TableRowNode2
    ],
    register(editor) {
      registerTablePlugin2(editor);
      registerTableSelectionObserver2(editor, true);
      setScrollableTablesActive2(editor, true);
      editor.registerNodeTransform(TableCellNode2, (node) => {
        if (node.getBackgroundColor() === null) {
          node.setBackgroundColor("");
        }
      });
      editor.registerNodeTransform(TableCellNode2, (node) => {
        const headerState = node.getHeaderStyles();
        if (headerState !== TableCellHeaderStates2.ROW) return;
        const rowParent = node.getParent();
        const tableNode = rowParent?.getParent();
        if (!tableNode) return;
        const rows = tableNode.getChildren();
        const cellIndex = rowParent.getChildren().indexOf(node);
        const cellsInRow = rowParent.getChildren();
        const isHeaderRow = cellsInRow.every(
          (cell) => cell.getHeaderStyles() !== TableCellHeaderStates2.NO_STATUS
        );
        const isHeaderColumn = rows.every((row) => {
          const cell = row.getChildren()[cellIndex];
          return cell && cell.getHeaderStyles() !== TableCellHeaderStates2.NO_STATUS;
        });
        let newHeaderState = TableCellHeaderStates2.NO_STATUS;
        if (isHeaderRow) {
          newHeaderState |= TableCellHeaderStates2.ROW;
        }
        if (isHeaderColumn) {
          newHeaderState |= TableCellHeaderStates2.COLUMN;
        }
        if (newHeaderState !== headerState) {
          node.setHeaderStyles(newHeaderState, TableCellHeaderStates2.BOTH);
        }
      });
      editor.registerCommand("insertTableRowAfter", () => {
        $insertTableRowAtSelection2(true);
      }, COMMAND_PRIORITY_NORMAL2);
      editor.registerCommand("insertTableRowBefore", () => {
        $insertTableRowAtSelection2(false);
      }, COMMAND_PRIORITY_NORMAL2);
      editor.registerCommand("insertTableColumnAfter", () => {
        $insertTableColumnAtSelection2(true);
      }, COMMAND_PRIORITY_NORMAL2);
      editor.registerCommand("insertTableColumnBefore", () => {
        $insertTableColumnAtSelection2(false);
      }, COMMAND_PRIORITY_NORMAL2);
      editor.registerCommand("deleteTableRow", () => {
        $deleteTableRowAtSelection2();
      }, COMMAND_PRIORITY_NORMAL2);
      editor.registerCommand("deleteTableColumn", () => {
        $deleteTableColumnAtSelection2();
      }, COMMAND_PRIORITY_NORMAL2);
      editor.registerCommand("deleteTable", () => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return false;
        $findTableNode2(selection.anchor.getNode())?.remove();
      }, COMMAND_PRIORITY_NORMAL2);
    }
  });
  var LexicalEditorElement = class _LexicalEditorElement extends HTMLElement {
    static formAssociated = true;
    static debug = false;
    static commands = ["bold", "italic", "strikethrough"];
    static observedAttributes = ["connected", "required"];
    #initialValue = "";
    #validationTextArea = document.createElement("textarea");
    constructor() {
      super();
      this.internals = this.attachInternals();
      this.internals.role = "presentation";
    }
    connectedCallback() {
      this.id ??= generateDomId("lexxy-editor");
      this.config = new EditorConfiguration(this);
      this.extensions = new Extensions(this);
      this.highlighter = new Highlighter(this);
      this.editor = this.#createEditor();
      this.contents = new Contents(this);
      this.selection = new Selection(this);
      this.clipboard = new Clipboard(this);
      CommandDispatcher.configureFor(this);
      this.#initialize();
      requestAnimationFrame(() => dispatch2(this, "lexxy:initialize"));
      this.toggleAttribute("connected", true);
      this.#handleAutofocus();
      this.valueBeforeDisconnect = null;
    }
    disconnectedCallback() {
      this.valueBeforeDisconnect = this.value;
      this.#reset();
    }
    attributeChangedCallback(name, oldValue, newValue) {
      if (name === "connected" && this.isConnected && oldValue != null && oldValue !== newValue) {
        requestAnimationFrame(() => this.#reconnect());
      }
      if (name === "required" && this.isConnected) {
        this.#validationTextArea.required = this.hasAttribute("required");
        this.#setValidity();
      }
    }
    formResetCallback() {
      this.value = this.#initialValue;
      this.editor.dispatchCommand(CLEAR_HISTORY_COMMAND2, void 0);
    }
    toString() {
      if (!this.cachedStringValue) {
        this.editor?.getEditorState().read(() => {
          this.cachedStringValue = $getRoot2().getTextContent();
        });
      }
      return this.cachedStringValue;
    }
    get form() {
      return this.internals.form;
    }
    get name() {
      return this.getAttribute("name");
    }
    get toolbarElement() {
      if (!this.#hasToolbar) return null;
      this.toolbar = this.toolbar || this.#findOrCreateDefaultToolbar();
      return this.toolbar;
    }
    get directUploadUrl() {
      return this.dataset.directUploadUrl;
    }
    get blobUrlTemplate() {
      return this.dataset.blobUrlTemplate;
    }
    get isEmpty() {
      return ["<p><br></p>", "<p></p>", ""].includes(this.value.trim());
    }
    get isBlank() {
      return this.isEmpty || this.toString().match(/^\s*$/g) !== null;
    }
    get hasOpenPrompt() {
      return this.querySelector(".lexxy-prompt-menu.lexxy-prompt-menu--visible") !== null;
    }
    get preset() {
      return this.getAttribute("preset") || "default";
    }
    get supportsAttachments() {
      return this.config.get("attachments");
    }
    get supportsMarkdown() {
      return this.supportsRichText && this.config.get("markdown");
    }
    get supportsMultiLine() {
      return this.config.get("multiLine") && !this.isSingleLineMode;
    }
    get supportsRichText() {
      return this.config.get("richText");
    }
    // TODO: Deprecate `single-line` attribute
    get isSingleLineMode() {
      return this.hasAttribute("single-line");
    }
    get contentTabIndex() {
      return parseInt(this.editorContentElement?.getAttribute("tabindex") ?? "0");
    }
    focus() {
      this.editor.focus(() => this.#onFocus());
    }
    get value() {
      if (!this.cachedValue) {
        this.editor?.getEditorState().read(() => {
          this.cachedValue = sanitize($generateHtmlFromNodes2(this.editor, null));
        });
      }
      return this.cachedValue;
    }
    set value(html2) {
      this.editor.update(() => {
        $addUpdateTag2(SKIP_DOM_SELECTION_TAG2);
        const root = $getRoot2();
        root.clear();
        root.append(...this.#parseHtmlIntoLexicalNodes(html2));
        root.selectEnd();
        this.#toggleEmptyStatus();
        requestAnimationFrame(() => this.editor?.update(() => {
        }));
      });
    }
    #parseHtmlIntoLexicalNodes(html2) {
      if (!html2) html2 = "<p></p>";
      const nodes = $generateNodesFromDOM2(this.editor, parseHtml(`<div>${html2}</div>`));
      if (nodes.length === 0) {
        return [$createParagraphNode2()];
      }
      return nodes.map((node) => {
        if (node.getType() === "paragraph" && node.getChildrenSize() === 1) {
          const child = node.getFirstChild();
          if (child instanceof DecoratorNode2 && !child.isInline()) {
            return child;
          }
        }
        return node;
      });
    }
    #initialize() {
      this.#synchronizeWithChanges();
      this.#registerComponents();
      this.#listenForInvalidatedNodes();
      this.#handleEnter();
      this.#registerFocusEvents();
      this.#attachDebugHooks();
      this.#attachToolbar();
      this.#loadInitialValue();
      this.#resetBeforeTurboCaches();
    }
    #createEditor() {
      this.editorContentElement ||= this.#createEditorContentElement();
      const editor = buildEditorFromExtensions2(
        {
          name: "lexxy/core",
          namespace: "Lexxy",
          theme,
          nodes: this.#lexicalNodes
        },
        ...this.#lexicalExtensions
      );
      editor.setRootElement(this.editorContentElement);
      return editor;
    }
    get #lexicalExtensions() {
      const extensions = [];
      const richTextExtensions = [
        this.highlighter.lexicalExtension,
        TrixContentExtension,
        TablesLexicalExtension
      ];
      if (this.supportsRichText) {
        extensions.push(...richTextExtensions);
      }
      extensions.push(...this.extensions.lexicalExtensions);
      return extensions;
    }
    get #lexicalNodes() {
      const nodes = [CustomActionTextAttachmentNode];
      if (this.supportsRichText) {
        nodes.push(
          QuoteNode2,
          HeadingNode2,
          ListNode2,
          ListItemNode2,
          CodeNode2,
          CodeHighlightNode2,
          LinkNode2,
          AutoLinkNode2,
          HorizontalDividerNode
        );
      }
      if (this.supportsAttachments) {
        nodes.push(ActionTextAttachmentNode, ActionTextAttachmentUploadNode);
      }
      return nodes;
    }
    #createEditorContentElement() {
      const editorContentElement = createElement("div", {
        classList: "lexxy-editor__content",
        contenteditable: true,
        role: "textbox",
        "aria-multiline": true,
        "aria-label": this.#labelText,
        placeholder: this.getAttribute("placeholder")
      });
      editorContentElement.id = `${this.id}-content`;
      this.#ariaAttributes.forEach((attribute) => editorContentElement.setAttribute(attribute.name, attribute.value));
      this.appendChild(editorContentElement);
      if (this.getAttribute("tabindex")) {
        editorContentElement.setAttribute("tabindex", this.getAttribute("tabindex"));
        this.removeAttribute("tabindex");
      } else {
        editorContentElement.setAttribute("tabindex", 0);
      }
      return editorContentElement;
    }
    get #labelText() {
      return Array.from(this.internals.labels).map((label) => label.textContent).join(" ");
    }
    get #ariaAttributes() {
      return Array.from(this.attributes).filter((attribute) => attribute.name.startsWith("aria-"));
    }
    set #internalFormValue(html2) {
      const changed = this.#internalFormValue !== void 0 && this.#internalFormValue !== this.value;
      this.internals.setFormValue(html2);
      this._internalFormValue = html2;
      this.#validationTextArea.value = this.isEmpty ? "" : html2;
      if (changed) {
        dispatch2(this, "lexxy:change");
      }
    }
    get #internalFormValue() {
      return this._internalFormValue;
    }
    #loadInitialValue() {
      const initialHtml = this.valueBeforeDisconnect || this.getAttribute("value") || "<p></p>";
      this.value = this.#initialValue = initialHtml;
    }
    #resetBeforeTurboCaches() {
      document.addEventListener("turbo:before-cache", this.#handleTurboBeforeCache);
    }
    #handleTurboBeforeCache = (event) => {
      this.#reset();
    };
    #synchronizeWithChanges() {
      this.#addUnregisterHandler(this.editor.registerUpdateListener(({ editorState }) => {
        this.#clearCachedValues();
        this.#internalFormValue = this.value;
        this.#toggleEmptyStatus();
        this.#setValidity();
      }));
    }
    #clearCachedValues() {
      this.cachedValue = null;
      this.cachedStringValue = null;
    }
    #addUnregisterHandler(handler4) {
      this.unregisterHandlers = this.unregisterHandlers || [];
      this.unregisterHandlers.push(handler4);
    }
    #unregisterHandlers() {
      this.unregisterHandlers?.forEach((handler4) => {
        handler4();
      });
      this.unregisterHandlers = null;
    }
    #registerComponents() {
      if (this.supportsRichText) {
        registerRichText2(this.editor);
        registerList2(this.editor);
        this.#registerTableComponents();
        this.#registerCodeHiglightingComponents();
        if (this.supportsMarkdown) {
          registerMarkdownShortcuts2(this.editor, TRANSFORMERS2);
        }
      } else {
        registerPlainText2(this.editor);
      }
      this.historyState = createEmptyHistoryState2();
      registerHistory2(this.editor, this.historyState, 20);
    }
    #registerTableComponents() {
      this.tableTools = createElement("lexxy-table-tools");
      this.append(this.tableTools);
    }
    #registerCodeHiglightingComponents() {
      registerCodeHighlighting2(this.editor);
      this.codeLanguagePicker = createElement("lexxy-code-language-picker");
      this.append(this.codeLanguagePicker);
    }
    #listenForInvalidatedNodes() {
      this.editor.getRootElement().addEventListener("lexxy:internal:invalidate-node", (event) => {
        const { key, values } = event.detail;
        this.editor.update(() => {
          const node = $getNodeByKey2(key);
          if (node instanceof ActionTextAttachmentNode) {
            const updatedNode = node.getWritable();
            Object.assign(updatedNode, values);
          }
        });
      });
    }
    #handleEnter() {
      this.editor.registerCommand(
        KEY_ENTER_COMMAND2,
        (event) => {
          if (event.ctrlKey || event.metaKey) {
            event.preventDefault();
            return true;
          }
          if (!this.supportsMultiLine) {
            event.preventDefault();
            return true;
          }
          return false;
        },
        COMMAND_PRIORITY_NORMAL2
      );
    }
    #registerFocusEvents() {
      this.addEventListener("focusin", this.#handleFocusIn);
      this.addEventListener("focusout", this.#handleFocusOut);
    }
    #handleFocusIn(event) {
      if (this.#elementInEditorOrToolbar(event.target) && !this.currentlyFocused) {
        dispatch2(this, "lexxy:focus");
        this.currentlyFocused = true;
      }
    }
    #handleFocusOut(event) {
      if (!this.#elementInEditorOrToolbar(event.relatedTarget)) {
        dispatch2(this, "lexxy:blur");
        this.currentlyFocused = false;
      }
    }
    #elementInEditorOrToolbar(element) {
      return this.contains(element) || this.toolbarElement?.contains(element);
    }
    #onFocus() {
      if (this.isEmpty) {
        this.selection.placeCursorAtTheEnd();
      }
    }
    #handleAutofocus() {
      if (!document.querySelector(":focus")) {
        if (this.hasAttribute("autofocus") && document.querySelector("[autofocus]") === this) {
          this.focus();
        }
      }
    }
    #attachDebugHooks() {
      if (!_LexicalEditorElement.debug) return;
      this.#addUnregisterHandler(this.editor.registerUpdateListener(({ editorState }) => {
        editorState.read(() => {
          console.debug("HTML: ", this.value, "String:", this.toString());
          console.debug("empty", this.isEmpty, "blank", this.isBlank);
        });
      }));
    }
    #attachToolbar() {
      if (this.#hasToolbar) {
        this.toolbarElement.setEditor(this);
      }
    }
    #findOrCreateDefaultToolbar() {
      const toolbarId = this.config.get("toolbar");
      if (toolbarId && toolbarId !== true) {
        return document.getElementById(toolbarId);
      } else {
        return this.#createDefaultToolbar();
      }
    }
    get #hasToolbar() {
      return this.supportsRichText && this.config.get("toolbar");
    }
    #createDefaultToolbar() {
      const toolbar = createElement("lexxy-toolbar");
      toolbar.innerHTML = LexicalToolbarElement.defaultTemplate;
      toolbar.setAttribute("data-attachments", this.supportsAttachments);
      this.prepend(toolbar);
      return toolbar;
    }
    #toggleEmptyStatus() {
      this.classList.toggle("lexxy-editor--empty", this.isEmpty);
    }
    #setValidity() {
      if (this.#validationTextArea.validity.valid) {
        this.internals.setValidity({});
      } else {
        this.internals.setValidity(this.#validationTextArea.validity, this.#validationTextArea.validationMessage, this.editorContentElement);
      }
    }
    #reset() {
      this.#unregisterHandlers();
      if (this.editorContentElement) {
        this.editorContentElement.remove();
        this.editorContentElement = null;
      }
      this.contents = null;
      this.editor = null;
      if (this.toolbar) {
        if (!this.getAttribute("toolbar")) {
          this.toolbar.remove();
        }
        this.toolbar = null;
      }
      if (this.codeLanguagePicker) {
        this.codeLanguagePicker.remove();
        this.codeLanguagePicker = null;
      }
      if (this.tableHandler) {
        this.tableHandler.remove();
        this.tableHandler = null;
      }
      this.selection = null;
      document.removeEventListener("turbo:before-cache", this.#handleTurboBeforeCache);
    }
    #reconnect() {
      this.disconnectedCallback();
      this.valueBeforeDisconnect = null;
      this.connectedCallback();
    }
  };
  customElements.define("lexxy-editor", LexicalEditorElement);
  var ToolbarDropdown = class extends HTMLElement {
    connectedCallback() {
      this.container = this.closest("details");
      this.container.addEventListener("toggle", this.#handleToggle.bind(this));
      this.container.addEventListener("keydown", this.#handleKeyDown.bind(this));
      this.#onToolbarEditor(this.initialize.bind(this));
    }
    disconnectedCallback() {
      this.container.removeEventListener("keydown", this.#handleKeyDown.bind(this));
    }
    get toolbar() {
      return this.closest("lexxy-toolbar");
    }
    get editorElement() {
      return this.toolbar.editorElement;
    }
    get editor() {
      return this.toolbar.editor;
    }
    initialize() {
    }
    close() {
      this.editor.focus();
      this.container.open = false;
    }
    async #onToolbarEditor(callback2) {
      await this.toolbar.editorConnected;
      callback2();
    }
    #handleToggle() {
      if (this.container.open) {
        this.#handleOpen();
      }
    }
    async #handleOpen() {
      this.#interactiveElements[0].focus();
      this.#resetTabIndexValues();
    }
    #handleKeyDown(event) {
      if (event.key === "Escape") {
        event.stopPropagation();
        this.close();
      }
    }
    async #resetTabIndexValues() {
      await nextFrame();
      this.#buttons.forEach((element, index2) => {
        element.setAttribute("tabindex", index2 === 0 ? 0 : "-1");
      });
    }
    get #interactiveElements() {
      return Array.from(this.querySelectorAll("button, input"));
    }
    get #buttons() {
      return Array.from(this.querySelectorAll("button"));
    }
  };
  var LinkDropdown = class extends ToolbarDropdown {
    connectedCallback() {
      super.connectedCallback();
      this.input = this.querySelector("input");
      this.#registerHandlers();
    }
    #registerHandlers() {
      this.container.addEventListener("toggle", this.#handleToggle.bind(this));
      this.addEventListener("submit", this.#handleSubmit.bind(this));
      this.querySelector("[value='unlink']").addEventListener("click", this.#handleUnlink.bind(this));
    }
    #handleToggle({ newState }) {
      this.input.value = this.#selectedLinkUrl;
      this.input.required = newState === "open";
    }
    #handleSubmit(event) {
      const command = event.submitter?.value;
      this.editor.dispatchCommand(command, this.input.value);
      this.close();
    }
    #handleUnlink() {
      this.editor.dispatchCommand("unlink");
      this.close();
    }
    get #selectedLinkUrl() {
      let url = "";
      this.editor.getEditorState().read(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        let node = selection.getNodes()[0];
        while (node && node.getParent()) {
          if ($isLinkNode2(node)) {
            url = node.getURL();
            break;
          }
          node = node.getParent();
        }
      });
      return url;
    }
  };
  customElements.define("lexxy-link-dropdown", LinkDropdown);
  var APPLY_HIGHLIGHT_SELECTOR = "button.lexxy-highlight-button";
  var REMOVE_HIGHLIGHT_SELECTOR = "[data-command='removeHighlight']";
  var NO_STYLE = Symbol("no_style");
  var HighlightDropdown = class extends ToolbarDropdown {
    connectedCallback() {
      super.connectedCallback();
      this.#registerToggleHandler();
    }
    initialize() {
      this.#setUpButtons();
      this.#registerButtonHandlers();
    }
    #registerToggleHandler() {
      this.container.addEventListener("toggle", this.#handleToggle.bind(this));
    }
    #registerButtonHandlers() {
      this.#colorButtons.forEach((button) => button.addEventListener("click", this.#handleColorButtonClick.bind(this)));
      this.querySelector(REMOVE_HIGHLIGHT_SELECTOR).addEventListener("click", this.#handleRemoveHighlightClick.bind(this));
    }
    #setUpButtons() {
      const colorGroups = this.editorElement.config.get("highlight.buttons");
      this.#populateButtonGroup("color", colorGroups.color);
      this.#populateButtonGroup("background-color", colorGroups["background-color"]);
      const maxNumberOfColors = Math.max(colorGroups.color.length, colorGroups["background-color"].length);
      this.style.setProperty("--max-colors", maxNumberOfColors);
    }
    #populateButtonGroup(attribute, values) {
      values.forEach((value, index2) => {
        this.#buttonContainer.appendChild(this.#createButton(attribute, value, index2));
      });
    }
    #createButton(attribute, value, index2) {
      const button = document.createElement("button");
      button.dataset.style = attribute;
      button.style.setProperty(attribute, value);
      button.dataset.value = value;
      button.classList.add("lexxy-editor__toolbar-button", "lexxy-highlight-button");
      button.name = attribute + "-" + index2;
      return button;
    }
    #handleToggle({ newState }) {
      if (newState === "open") {
        this.editor.getEditorState().read(() => {
          this.#updateColorButtonStates($getSelection2());
        });
      }
    }
    #handleColorButtonClick(event) {
      event.preventDefault();
      const button = event.target.closest(APPLY_HIGHLIGHT_SELECTOR);
      if (!button) return;
      const attribute = button.dataset.style;
      const value = button.dataset.value;
      this.editor.dispatchCommand("toggleHighlight", { [attribute]: value });
      this.close();
    }
    #handleRemoveHighlightClick(event) {
      event.preventDefault();
      this.editor.dispatchCommand("removeHighlight");
      this.close();
    }
    #updateColorButtonStates(selection) {
      if (!$isRangeSelection2(selection)) {
        return;
      }
      const textColor = $getSelectionStyleValueForProperty2(selection, "color", NO_STYLE);
      const backgroundColor = $getSelectionStyleValueForProperty2(selection, "background-color", NO_STYLE);
      this.#colorButtons.forEach((button) => {
        const matchesSelection = button.dataset.value === textColor || button.dataset.value === backgroundColor;
        button.setAttribute("aria-pressed", matchesSelection);
      });
      const hasHighlight = textColor !== NO_STYLE || backgroundColor !== NO_STYLE;
      this.querySelector(REMOVE_HIGHLIGHT_SELECTOR).disabled = !hasHighlight;
    }
    get #buttonContainer() {
      return this.querySelector(".lexxy-highlight-colors");
    }
    get #colorButtons() {
      return Array.from(this.querySelectorAll(APPLY_HIGHLIGHT_SELECTOR));
    }
  };
  customElements.define("lexxy-highlight-dropdown", HighlightDropdown);
  var TableController = class {
    constructor(editorElement) {
      this.editor = editorElement.editor;
      this.contents = editorElement.contents;
      this.selection = editorElement.selection;
      this.currentTableNodeKey = null;
      this.currentCellKey = null;
      this.#registerKeyHandlers();
    }
    destroy() {
      this.currentTableNodeKey = null;
      this.currentCellKey = null;
      this.#unregisterKeyHandlers();
    }
    get currentCell() {
      if (!this.currentCellKey) return null;
      return this.editor.getEditorState().read(() => {
        const cell = $getNodeByKey2(this.currentCellKey);
        return cell instanceof TableCellNode2 ? cell : null;
      });
    }
    get currentTableNode() {
      if (!this.currentTableNodeKey) return null;
      return this.editor.getEditorState().read(() => {
        const tableNode = $getNodeByKey2(this.currentTableNodeKey);
        return tableNode instanceof TableNode2 ? tableNode : null;
      });
    }
    get currentRowCells() {
      const currentRowIndex = this.currentRowIndex;
      const rows = this.tableRows;
      if (!rows) return null;
      return this.editor.getEditorState().read(() => {
        return rows[currentRowIndex]?.getChildren() ?? null;
      }) ?? null;
    }
    get currentRowIndex() {
      const currentCell = this.currentCell;
      if (!currentCell) return 0;
      return this.editor.getEditorState().read(() => {
        return $getTableRowIndexFromTableCellNode2(currentCell);
      }) ?? 0;
    }
    get currentColumnCells() {
      const columnIndex = this.currentColumnIndex;
      const rows = this.tableRows;
      if (!rows) return null;
      return this.editor.getEditorState().read(() => {
        return rows.map((row) => row.getChildAtIndex(columnIndex));
      }) ?? null;
    }
    get currentColumnIndex() {
      const currentCell = this.currentCell;
      if (!currentCell) return 0;
      return this.editor.getEditorState().read(() => {
        return $getTableColumnIndexFromTableCellNode2(currentCell);
      }) ?? 0;
    }
    get tableRows() {
      return this.editor.getEditorState().read(() => {
        return this.currentTableNode?.getChildren();
      }) ?? null;
    }
    updateSelectedTable() {
      let cellNode = null;
      let tableNode = null;
      this.editor.getEditorState().read(() => {
        const selection = $getSelection2();
        if (!selection || !this.selection.isTableCellSelected) return;
        const node = selection.getNodes()[0];
        cellNode = $findCellNode2(node);
        tableNode = $findTableNode2(node);
      });
      this.currentCellKey = cellNode?.getKey() ?? null;
      this.currentTableNodeKey = tableNode?.getKey() ?? null;
    }
    executeTableCommand(command, customIndex = null) {
      if (command.action === "delete" && command.childType === "table") {
        this.#deleteTable();
        return;
      }
      if (command.action === "toggle") {
        this.#executeToggleStyle(command);
        return;
      }
      this.#executeCommand(command, customIndex);
    }
    #executeCommand(command, customIndex = null) {
      this.#selectCellAtSelection();
      this.editor.dispatchCommand(this.#commandName(command));
      this.#selectNextBestCell(command, customIndex);
    }
    #executeToggleStyle(command) {
      const childType = command.childType;
      let cells = null;
      let headerState = null;
      if (childType === "row") {
        cells = this.currentRowCells;
        headerState = TableCellHeaderStates2.ROW;
      } else if (childType === "column") {
        cells = this.currentColumnCells;
        headerState = TableCellHeaderStates2.COLUMN;
      }
      if (!cells || cells.length === 0) return;
      this.editor.update(() => {
        const firstCell = $getTableCellNodeFromLexicalNode2(cells[0]);
        if (!firstCell) return;
        const currentStyle = firstCell.getHeaderStyles();
        const newStyle = currentStyle ^ headerState;
        cells.forEach((cell) => {
          this.#setHeaderStyle(cell, newStyle, headerState);
        });
      });
    }
    #deleteTable() {
      this.#selectCellAtSelection();
      this.editor.dispatchCommand("deleteTable");
    }
    #selectCellAtSelection() {
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!selection) return;
        const node = selection.getNodes()[0];
        $findCellNode2(node)?.selectEnd();
      });
    }
    #commandName(command) {
      const { action, childType, direction } = command;
      const childTypeSuffix = upcaseFirst(childType);
      const directionSuffix = action == "insert" ? upcaseFirst(direction) : "";
      return `${action}Table${childTypeSuffix}${directionSuffix}`;
    }
    #setHeaderStyle(cell, newStyle, headerState) {
      const tableCellNode = $getTableCellNodeFromLexicalNode2(cell);
      tableCellNode?.setHeaderStyles(newStyle, headerState);
    }
    async #selectCellAtIndex(rowIndex, columnIndex) {
      await nextFrame();
      if (!this.currentTableNode) return;
      const rows = this.tableRows;
      if (!rows) return;
      const row = rows[rowIndex];
      if (!row) return;
      this.editor.update(() => {
        const cell = $getTableCellNodeFromLexicalNode2(row.getChildAtIndex(columnIndex));
        cell?.selectEnd();
      });
    }
    #selectNextBestCell(command, customIndex = null) {
      const { childType, direction } = command;
      let rowIndex = this.currentRowIndex;
      let columnIndex = customIndex !== null ? customIndex : this.currentColumnIndex;
      const deleteOffset = command.action === "delete" ? -1 : 0;
      const offset = direction === "after" ? 1 : deleteOffset;
      if (childType === "row") {
        rowIndex += offset;
      } else if (childType === "column") {
        columnIndex += offset;
      }
      this.#selectCellAtIndex(rowIndex, columnIndex);
    }
    #selectNextRow() {
      const rows = this.tableRows;
      if (!rows) return;
      const nextRow = rows.at(this.currentRowIndex + 1);
      if (!nextRow) return;
      this.editor.update(() => {
        nextRow.getChildAtIndex(this.currentColumnIndex)?.selectEnd();
      });
    }
    #selectPreviousCell() {
      const cell = this.currentCell;
      if (!cell) return;
      this.editor.update(() => {
        cell.selectPrevious();
      });
    }
    #insertRowAndSelectFirstCell() {
      this.executeTableCommand({ action: "insert", childType: "row", direction: "after" }, 0);
    }
    #deleteRowAndSelectLastCell() {
      this.executeTableCommand({ action: "delete", childType: "row" }, -1);
    }
    #deleteRowAndSelectNextNode() {
      const tableNode = this.currentTableNode;
      this.executeTableCommand({ action: "delete", childType: "row" });
      this.editor.update(() => {
        const next = tableNode?.getNextSibling();
        if ($isParagraphNode2(next)) {
          next.selectStart();
        } else {
          const newParagraph = $createParagraphNode2();
          this.currentTableNode.insertAfter(newParagraph);
          newParagraph.selectStart();
        }
      });
    }
    #isCurrentCellEmpty() {
      if (!this.currentTableNode) return false;
      const cell = this.currentCell;
      if (!cell) return false;
      return cell.getTextContent().trim() === "";
    }
    #isCurrentRowLast() {
      if (!this.currentTableNode) return false;
      const rows = this.tableRows;
      if (!rows) return false;
      return rows.length === this.currentRowIndex + 1;
    }
    #isCurrentRowEmpty() {
      if (!this.currentTableNode) return false;
      const cells = this.currentRowCells;
      if (!cells) return false;
      return cells.every((cell) => cell.getTextContent().trim() === "");
    }
    #isFirstCellInRow() {
      if (!this.currentTableNode) return false;
      const cells = this.currentRowCells;
      if (!cells) return false;
      return cells.indexOf(this.currentCell) === 0;
    }
    #registerKeyHandlers() {
      this.unregisterBackspaceKeyHandler = this.editor.registerCommand(KEY_BACKSPACE_COMMAND2, (event) => this.#handleBackspaceKey(event), COMMAND_PRIORITY_HIGH2);
      this.unregisterEnterKeyHandler = this.editor.registerCommand(KEY_ENTER_COMMAND2, (event) => this.#handleEnterKey(event), COMMAND_PRIORITY_HIGH2);
    }
    #unregisterKeyHandlers() {
      this.unregisterBackspaceKeyHandler?.();
      this.unregisterEnterKeyHandler?.();
      this.unregisterBackspaceKeyHandler = null;
      this.unregisterEnterKeyHandler = null;
    }
    #handleBackspaceKey(event) {
      if (!this.currentTableNode) return false;
      if (this.#isCurrentRowEmpty() && this.#isFirstCellInRow()) {
        event.preventDefault();
        this.#deleteRowAndSelectLastCell();
        return true;
      }
      if (this.#isCurrentCellEmpty() && !this.#isFirstCellInRow()) {
        event.preventDefault();
        this.#selectPreviousCell();
        return true;
      }
      return false;
    }
    #handleEnterKey(event) {
      if (event.ctrlKey || event.metaKey || event.shiftKey || !this.currentTableNode) return false;
      if (this.selection.isInsideList || this.selection.isInsideCodeBlock) return false;
      event.preventDefault();
      if (this.#isCurrentRowLast() && this.#isCurrentRowEmpty()) {
        this.#deleteRowAndSelectNextNode();
      } else if (this.#isCurrentRowLast()) {
        this.#insertRowAndSelectFirstCell();
      } else {
        this.#selectNextRow();
      }
      return true;
    }
  };
  var TableIcons = {
    "insert-row-before": `<svg  viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M7.86804e-07 15C8.29055e-07 15.8284 0.671574 16.5 1.5 16.5H15L15.1533 16.4922C15.8593 16.4205 16.4205 15.8593 16.4922 15.1533L16.5 15V4.5L16.4922 4.34668C16.4154 3.59028 15.7767 3 15 3H13.5L13.5 4.5H15V9H1.5L1.5 4.5L3 4.5V3H1.5C0.671574 3 1.20956e-06 3.67157 1.24577e-06 4.5L7.86804e-07 15ZM15 10.5V15H1.5L1.5 10.5H15Z"/>
    <path d="M4.5 4.5H7.5V7.5H9V4.5H12L12 3L9 3V6.55671e-08L7.5 0V3L4.5 3V4.5Z"/>
    </svg>`,
    "insert-row-after": `<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M7.86804e-07 13.5C7.50592e-07 14.3284 0.671574 15 1.5 15H3V13.5H1.5L1.5 9L15 9V13.5H13.5V15H15C15.7767 15 16.4154 14.4097 16.4922 13.6533L16.5 13.5V3L16.4922 2.84668C16.4205 2.14069 15.8593 1.57949 15.1533 1.50781L15 1.5L1.5 1.5C0.671574 1.5 1.28803e-06 2.17157 1.24577e-06 3L7.86804e-07 13.5ZM15 3V7.5L1.5 7.5L1.5 3L15 3Z"/>
    <path d="M7.5 15V18H9V15H12V13.5H9V10.5H7.5V13.5H4.5V15H7.5Z"/>
    </svg>`,
    "delete-row": `<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
    <path d="M16.4922 12.1533C16.4154 12.9097 15.7767 13.5 15 13.5L12 13.5V12H15V6L1.5 6L1.5 12H4.5V13.5H1.5C0.723337 13.5 0.0846104 12.9097 0.00781328 12.1533L7.86804e-07 12L1.04907e-06 6C1.17362e-06 5.22334 0.590278 4.58461 1.34668 4.50781L1.5 4.5L15 4.5C15.8284 4.5 16.5 5.17157 16.5 6V12L16.4922 12.1533Z"/>
    <path d="M10.3711 15.9316L8.25 13.8096L6.12793 15.9316L5.06738 14.8711L7.18945 12.75L5.06738 10.6289L6.12793 9.56836L8.25 11.6895L10.3711 9.56836L11.4316 10.6289L9.31055 12.75L11.4316 14.8711L10.3711 15.9316Z"/>
    </svg>`,
    "toggle-row": `<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M0.00781328 13.6533C0.0846108 14.4097 0.723337 15 1.5 15L15 15L15.1533 14.9922C15.8593 14.9205 16.4205 14.3593 16.4922 13.6533L16.5 13.5V4.5L16.4922 4.34668C16.4205 3.64069 15.8593 3.07949 15.1533 3.00781L15 3L1.5 3C0.671574 3 1.24863e-06 3.67157 1.18021e-06 4.5L7.86804e-07 13.5L0.00781328 13.6533ZM15 9V13.5L1.5 13.5L1.5 9L15 9Z"/>
    </svg>`,
    "insert-column-before": `<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 0C3.67157 0 3 0.671573 3 1.5V3H4.5V1.5H9V15H4.5V13.5H3V15C3 15.7767 3.59028 16.4154 4.34668 16.4922L4.5 16.5H15L15.1533 16.4922C15.8593 16.4205 16.4205 15.8593 16.4922 15.1533L16.5 15V1.5C16.5 0.671573 15.8284 6.03989e-09 15 0H4.5ZM15 15H10.5V1.5H15V15Z"/>
    <path d="M3 7.5H0V9H3V12H4.5V9H7.5V7.5H4.5V4.5H3V7.5Z"/>
    </svg>`,
    "insert-column-after": `<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M13.5 0C14.3284 0 15 0.671573 15 1.5V3H13.5V1.5H9V15H13.5V13.5H15V15C15 15.7767 14.4097 16.4154 13.6533 16.4922L13.5 16.5H3L2.84668 16.4922C2.14069 16.4205 1.57949 15.8593 1.50781 15.1533L1.5 15V1.5C1.5 0.671573 2.17157 6.03989e-09 3 0H13.5ZM3 15H7.5V1.5H3V15Z"/>
    <path d="M15 7.5H18V9H15V12H13.5V9H10.5V7.5H13.5V4.5H15V7.5Z"/>
    </svg>`,
    "delete-column": `<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.1533 0.0078125C12.9097 0.0846097 13.5 0.723336 13.5 1.5V4.5H12V1.5H6V15H12V12H13.5V15C13.5 15.7767 12.9097 16.4154 12.1533 16.4922L12 16.5H6C5.22334 16.5 4.58461 15.9097 4.50781 15.1533L4.5 15V1.5C4.5 0.671573 5.17157 2.41596e-08 6 0H12L12.1533 0.0078125Z"/>
    <path d="M15.9316 6.12891L13.8105 8.24902L15.9326 10.3711L14.8711 11.4316L12.75 9.31055L10.6289 11.4316L9.56738 10.3711L11.6885 8.24902L9.56836 6.12891L10.6289 5.06836L12.75 7.18848L14.8711 5.06836L15.9316 6.12891Z"/>
    </svg>`,
    "toggle-column": `<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M13.6533 17.9922C14.4097 17.9154 15 17.2767 15 16.5L15 3L14.9922 2.84668C14.9205 2.14069 14.3593 1.57949 13.6533 1.50781L13.5 1.5L4.5 1.5L4.34668 1.50781C3.59028 1.58461 3 2.22334 3 3L3 16.5C3 17.2767 3.59028 17.9154 4.34668 17.9922L4.5 18L13.5 18L13.6533 17.9922ZM9 3L13.5 3L13.5 16.5L9 16.5L9 3Z" />
    </svg>`,
    "delete-table": `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path d="M18.2129 19.2305C18.0925 20.7933 16.7892 22 15.2217 22H7.77832C6.21084 22 4.90753 20.7933 4.78711 19.2305L4 9H19L18.2129 19.2305Z"/><path d="M13 2C14.1046 2 15 2.89543 15 4H19C19.5523 4 20 4.44772 20 5V6C20 6.55228 19.5523 7 19 7H4C3.44772 7 3 6.55228 3 6V5C3 4.44772 3.44772 4 4 4H8C8 2.89543 8.89543 2 10 2H13Z"/>
    </svg>`
  };
  var TableTools = class extends HTMLElement {
    connectedCallback() {
      this.tableController = new TableController(this.#editorElement);
      this.#setUpButtons();
      this.#monitorForTableSelection();
      this.#registerKeyboardShortcuts();
    }
    disconnectedCallback() {
      this.#unregisterKeyboardShortcuts();
      this.unregisterUpdateListener?.();
      this.unregisterUpdateListener = null;
      this.removeEventListener("keydown", this.#handleToolsKeydown);
      this.tableController?.destroy();
      this.tableController = null;
    }
    get #editor() {
      return this.#editorElement.editor;
    }
    get #editorElement() {
      return this.closest("lexxy-editor");
    }
    get #tableToolsButtons() {
      return Array.from(this.querySelectorAll("button, details > summary"));
    }
    #setUpButtons() {
      this.appendChild(this.#createRowButtonsContainer());
      this.appendChild(this.#createColumnButtonsContainer());
      this.appendChild(this.#createDeleteTableButton());
      this.addEventListener("keydown", this.#handleToolsKeydown);
    }
    #createButtonsContainer(childType, setCountProperty, moreMenu) {
      const container = createElement("div", { className: `lexxy-table-control lexxy-table-control--${childType}` });
      const plusButton = this.#createButton(`Add ${childType}`, { action: "insert", childType, direction: "after" }, "+");
      const minusButton = this.#createButton(`Remove ${childType}`, { action: "delete", childType }, "\u2212");
      const dropdown = createElement("details", { className: "lexxy-table-control__more-menu" });
      dropdown.setAttribute("name", "lexxy-dropdown");
      dropdown.tabIndex = -1;
      const count = createElement("summary", {}, `_ ${childType}s`);
      setCountProperty(count);
      dropdown.appendChild(count);
      dropdown.appendChild(moreMenu);
      container.appendChild(minusButton);
      container.appendChild(dropdown);
      container.appendChild(plusButton);
      return container;
    }
    #createRowButtonsContainer() {
      return this.#createButtonsContainer(
        "row",
        (count) => {
          this.rowCount = count;
        },
        this.#createMoreMenuSection("row")
      );
    }
    #createColumnButtonsContainer() {
      return this.#createButtonsContainer(
        "column",
        (count) => {
          this.columnCount = count;
        },
        this.#createMoreMenuSection("column")
      );
    }
    #createMoreMenuSection(childType) {
      const section = createElement("div", { className: "lexxy-table-control__more-menu-details" });
      const addBeforeButton = this.#createButton(`Add ${childType} before`, { action: "insert", childType, direction: "before" });
      const addAfterButton = this.#createButton(`Add ${childType} after`, { action: "insert", childType, direction: "after" });
      const toggleStyleButton = this.#createButton(`Toggle ${childType} style`, { action: "toggle", childType });
      const deleteButton = this.#createButton(`Remove ${childType}`, { action: "delete", childType });
      section.appendChild(addBeforeButton);
      section.appendChild(addAfterButton);
      section.appendChild(toggleStyleButton);
      section.appendChild(deleteButton);
      return section;
    }
    #createDeleteTableButton() {
      const container = createElement("div", { className: "lexxy-table-control" });
      const deleteTableButton = this.#createButton("Delete this table?", { action: "delete", childType: "table" });
      deleteTableButton.classList.add("lexxy-table-control__button--delete-table");
      container.appendChild(deleteTableButton);
      this.deleteContainer = container;
      return container;
    }
    #createButton(label, command = {}, icon = this.#icon(command)) {
      const button = createElement("button", {
        className: "lexxy-table-control__button",
        "aria-label": label,
        type: "button"
      });
      button.tabIndex = -1;
      button.innerHTML = `${icon} <span>${label}</span>`;
      button.dataset.action = command.action;
      button.dataset.childType = command.childType;
      button.dataset.direction = command.direction;
      button.addEventListener("click", () => this.#executeTableCommand(command));
      button.addEventListener("mouseover", () => this.#handleCommandButtonHover());
      button.addEventListener("focus", () => this.#handleCommandButtonHover());
      button.addEventListener("mouseout", () => this.#handleCommandButtonHover());
      return button;
    }
    #registerKeyboardShortcuts() {
      this.unregisterKeyboardShortcuts = this.#editor.registerCommand(KEY_DOWN_COMMAND2, this.#handleAccessibilityShortcutKey, COMMAND_PRIORITY_HIGH2);
    }
    #unregisterKeyboardShortcuts() {
      this.unregisterKeyboardShortcuts?.();
      this.unregisterKeyboardShortcuts = null;
    }
    #handleAccessibilityShortcutKey = (event) => {
      if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === "F10") {
        const firstButton = this.querySelector("button, [tabindex]:not([tabindex='-1'])");
        firstButton?.focus();
      }
    };
    #handleToolsKeydown = (event) => {
      if (event.key === "Escape") {
        this.#handleEscapeKey();
      } else {
        handleRollingTabIndex(this.#tableToolsButtons, event);
      }
    };
    #handleEscapeKey() {
      const cell = this.tableController.currentCell;
      if (!cell) return;
      this.#editor.update(() => {
        cell.select();
        this.#editor.focus();
      });
      this.#update();
    }
    async #handleCommandButtonHover() {
      await nextFrame();
      this.#clearCellStyles();
      const activeElement = this.querySelector("button:hover, button:focus");
      if (!activeElement) return;
      const command = {
        action: activeElement.dataset.action,
        childType: activeElement.dataset.childType,
        direction: activeElement.dataset.direction
      };
      let cellsToHighlight = null;
      switch (command.childType) {
        case "row":
          cellsToHighlight = this.tableController.currentRowCells;
          break;
        case "column":
          cellsToHighlight = this.tableController.currentColumnCells;
          break;
        case "table":
          cellsToHighlight = this.tableController.tableRows;
          break;
      }
      if (!cellsToHighlight) return;
      cellsToHighlight.forEach((cell) => {
        const cellElement = this.#editor.getElementByKey(cell.getKey());
        if (!cellElement) return;
        cellElement.classList.toggle(theme.tableCellHighlight, true);
        Object.assign(cellElement.dataset, command);
      });
    }
    #monitorForTableSelection() {
      this.unregisterUpdateListener = this.#editor.registerUpdateListener(() => {
        this.tableController.updateSelectedTable();
        const tableNode = this.tableController.currentTableNode;
        if (tableNode) {
          this.#show();
        } else {
          this.#hide();
        }
      });
    }
    #executeTableCommand(command) {
      this.tableController.executeTableCommand(command);
      this.#update();
    }
    #show() {
      this.style.display = "flex";
      this.#update();
    }
    #hide() {
      this.style.display = "none";
      this.#clearCellStyles();
    }
    #update() {
      this.#updateButtonsPosition();
      this.#updateRowColumnCount();
      this.#closeMoreMenu();
      this.#handleCommandButtonHover();
    }
    #closeMoreMenu() {
      this.querySelector("details[open]")?.removeAttribute("open");
    }
    #updateButtonsPosition() {
      const tableNode = this.tableController.currentTableNode;
      if (!tableNode) return;
      const tableElement = this.#editor.getElementByKey(tableNode.getKey());
      if (!tableElement) return;
      const tableRect = tableElement.getBoundingClientRect();
      const editorRect = this.#editorElement.getBoundingClientRect();
      const relativeTop = tableRect.top - editorRect.top;
      const relativeCenter = (tableRect.left + tableRect.right) / 2 - editorRect.left;
      this.style.top = `${relativeTop}px`;
      this.style.left = `${relativeCenter}px`;
    }
    #updateRowColumnCount() {
      const tableNode = this.tableController.currentTableNode;
      if (!tableNode) return;
      const tableElement = $getElementForTableNode2(this.#editor, tableNode);
      if (!tableElement) return;
      const rowCount = tableElement.rows;
      const columnCount = tableElement.columns;
      this.rowCount.textContent = `${rowCount} row${rowCount === 1 ? "" : "s"}`;
      this.columnCount.textContent = `${columnCount} column${columnCount === 1 ? "" : "s"}`;
    }
    #setTableCellFocus() {
      const cell = this.tableController.currentCell;
      if (!cell) return;
      const cellElement = this.#editor.getElementByKey(cell.getKey());
      if (!cellElement) return;
      cellElement.classList.add(theme.tableCellFocus);
    }
    #clearCellStyles() {
      this.#editorElement.querySelectorAll(`.${theme.tableCellFocus}`)?.forEach((cell) => {
        cell.classList.remove(theme.tableCellFocus);
      });
      this.#editorElement.querySelectorAll(`.${theme.tableCellHighlight}`)?.forEach((cell) => {
        cell.classList.remove(theme.tableCellHighlight);
        cell.removeAttribute("data-action");
        cell.removeAttribute("data-child-type");
        cell.removeAttribute("data-direction");
      });
      this.#setTableCellFocus();
    }
    #icon(command) {
      const { action, childType } = command;
      const direction = action == "insert" ? command.direction : null;
      const iconId = [action, childType, direction].filter(Boolean).join("-");
      return TableIcons[iconId];
    }
  };
  customElements.define("lexxy-table-tools", TableTools);
  var BaseSource = class {
    // Template method to override
    async buildListItems(filter = "") {
      return Promise.resolve([]);
    }
    // Template method to override
    promptItemFor(listItem) {
      return null;
    }
    // Protected
    buildListItemElementFor(promptItemElement) {
      const template = promptItemElement.querySelector("template[type='menu']");
      const fragment = template.content.cloneNode(true);
      const listItemElement = createElement("li", { role: "option", id: generateDomId("prompt-item"), tabindex: "0" });
      listItemElement.classList.add("lexxy-prompt-menu__item");
      listItemElement.appendChild(fragment);
      return listItemElement;
    }
    async loadPromptItemsFromUrl(url) {
      try {
        const response = await fetch(url);
        const html2 = await response.text();
        const promptItems = parseHtml(html2).querySelectorAll("lexxy-prompt-item");
        return Promise.resolve(Array.from(promptItems));
      } catch (error2) {
        return Promise.reject(error2);
      }
    }
  };
  var LocalFilterSource = class extends BaseSource {
    async buildListItems(filter = "") {
      const promptItems = await this.fetchPromptItems();
      return this.#buildListItemsFromPromptItems(promptItems, filter);
    }
    // Template method to override
    async fetchPromptItems(filter) {
      return Promise.resolve([]);
    }
    promptItemFor(listItem) {
      return this.promptItemByListItem.get(listItem);
    }
    #buildListItemsFromPromptItems(promptItems, filter) {
      const listItems = [];
      this.promptItemByListItem = /* @__PURE__ */ new WeakMap();
      promptItems.forEach((promptItem) => {
        const searchableText = promptItem.getAttribute("search");
        if (!filter || filterMatches(searchableText, filter)) {
          const listItem = this.buildListItemElementFor(promptItem);
          this.promptItemByListItem.set(listItem, promptItem);
          listItems.push(listItem);
        }
      });
      return listItems;
    }
  };
  var InlinePromptSource = class extends LocalFilterSource {
    constructor(inlinePromptItems) {
      super();
      this.inlinePromptItemElements = Array.from(inlinePromptItems);
    }
    async fetchPromptItems() {
      return Promise.resolve(this.inlinePromptItemElements);
    }
  };
  var DeferredPromptSource = class extends LocalFilterSource {
    constructor(url) {
      super();
      this.url = url;
      this.fetchPromptItems();
    }
    async fetchPromptItems() {
      this.promptItems ??= await this.loadPromptItemsFromUrl(this.url);
      return Promise.resolve(this.promptItems);
    }
  };
  var DEBOUNCE_INTERVAL = 200;
  var RemoteFilterSource = class extends BaseSource {
    constructor(url) {
      super();
      this.baseURL = url;
      this.loadAndFilterListItems = debounceAsync(this.fetchFilteredListItems.bind(this), DEBOUNCE_INTERVAL);
    }
    async buildListItems(filter = "") {
      return await this.loadAndFilterListItems(filter);
    }
    promptItemFor(listItem) {
      return this.promptItemByListItem.get(listItem);
    }
    async fetchFilteredListItems(filter) {
      const promptItems = await this.loadPromptItemsFromUrl(this.#urlFor(filter));
      return this.#buildListItemsFromPromptItems(promptItems);
    }
    #urlFor(filter) {
      const url = new URL(this.baseURL, window.location.origin);
      url.searchParams.append("filter", filter);
      return url.toString();
    }
    #buildListItemsFromPromptItems(promptItems) {
      const listItems = [];
      this.promptItemByListItem = /* @__PURE__ */ new WeakMap();
      for (const promptItem of promptItems) {
        const listItem = this.buildListItemElementFor(promptItem);
        this.promptItemByListItem.set(listItem, promptItem);
        listItems.push(listItem);
      }
      return listItems;
    }
  };
  var NOTHING_FOUND_DEFAULT_MESSAGE = "Nothing found";
  var LexicalPromptElement = class extends HTMLElement {
    constructor() {
      super();
      this.keyListeners = [];
    }
    static observedAttributes = ["connected"];
    connectedCallback() {
      this.source = this.#createSource();
      this.#addTriggerListener();
      this.toggleAttribute("connected", true);
    }
    disconnectedCallback() {
      this.source = null;
      this.popoverElement = null;
    }
    attributeChangedCallback(name, oldValue, newValue) {
      if (name === "connected" && this.isConnected && oldValue != null && oldValue !== newValue) {
        requestAnimationFrame(() => this.#reconnect());
      }
    }
    get name() {
      return this.getAttribute("name");
    }
    get trigger() {
      return this.getAttribute("trigger");
    }
    get supportsSpaceInSearches() {
      return this.hasAttribute("supports-space-in-searches");
    }
    get open() {
      return this.popoverElement?.classList?.contains("lexxy-prompt-menu--visible");
    }
    get closed() {
      return !this.open;
    }
    get #doesSpaceSelect() {
      return !this.supportsSpaceInSearches;
    }
    #createSource() {
      const src = this.getAttribute("src");
      if (src) {
        if (this.hasAttribute("remote-filtering")) {
          return new RemoteFilterSource(src);
        } else {
          return new DeferredPromptSource(src);
        }
      } else {
        return new InlinePromptSource(this.querySelectorAll("lexxy-prompt-item"));
      }
    }
    #addTriggerListener() {
      const unregister = this.#editor.registerUpdateListener(({ editorState }) => {
        editorState.read(() => {
          const { node, offset } = this.#selection.selectedNodeWithOffset();
          if (!node) return;
          if ($isTextNode2(node)) {
            const fullText = node.getTextContent();
            const triggerLength = this.trigger.length;
            if (offset >= triggerLength) {
              const textBeforeCursor = fullText.slice(offset - triggerLength, offset);
              if (textBeforeCursor === this.trigger) {
                const isAtStart = offset === triggerLength;
                const charBeforeTrigger = offset > triggerLength ? fullText[offset - triggerLength - 1] : null;
                const isPrecededBySpaceOrNewline = charBeforeTrigger === " " || charBeforeTrigger === "\n";
                if (isAtStart || isPrecededBySpaceOrNewline) {
                  unregister();
                  this.#showPopover();
                }
              }
            }
          }
        });
      });
    }
    #addCursorPositionListener() {
      this.cursorPositionListener = this.#editor.registerUpdateListener(() => {
        if (this.closed) return;
        this.#editor.read(() => {
          const { node, offset } = this.#selection.selectedNodeWithOffset();
          if (!node) return;
          if ($isTextNode2(node) && offset > 0) {
            const fullText = node.getTextContent();
            const textBeforeCursor = fullText.slice(0, offset);
            const lastTriggerIndex = textBeforeCursor.lastIndexOf(this.trigger);
            const triggerEndIndex = lastTriggerIndex + this.trigger.length - 1;
            if (lastTriggerIndex === -1 || offset <= triggerEndIndex) {
              this.#hidePopover();
            }
          } else {
            this.#hidePopover();
          }
        });
      });
    }
    #removeCursorPositionListener() {
      if (this.cursorPositionListener) {
        this.cursorPositionListener();
        this.cursorPositionListener = null;
      }
    }
    get #editor() {
      return this.#editorElement.editor;
    }
    get #editorElement() {
      return this.closest("lexxy-editor");
    }
    get #selection() {
      return this.#editorElement.selection;
    }
    async #showPopover() {
      this.popoverElement ??= await this.#buildPopover();
      this.#resetPopoverPosition();
      await this.#filterOptions();
      this.popoverElement.classList.toggle("lexxy-prompt-menu--visible", true);
      this.#selectFirstOption();
      this.#editorElement.addEventListener("keydown", this.#handleKeydownOnPopover);
      this.#editorElement.addEventListener("lexxy:change", this.#filterOptions);
      this.#registerKeyListeners();
      this.#addCursorPositionListener();
    }
    #registerKeyListeners() {
      this.keyListeners.push(this.#editor.registerCommand(KEY_ENTER_COMMAND2, this.#handleSelectedOption.bind(this), COMMAND_PRIORITY_HIGH2));
      this.keyListeners.push(this.#editor.registerCommand(KEY_TAB_COMMAND2, this.#handleSelectedOption.bind(this), COMMAND_PRIORITY_HIGH2));
      if (this.#doesSpaceSelect) {
        this.keyListeners.push(this.#editor.registerCommand(KEY_SPACE_COMMAND2, this.#handleSelectedOption.bind(this), COMMAND_PRIORITY_HIGH2));
      }
      this.keyListeners.push(this.#editor.registerCommand(KEY_ARROW_UP_COMMAND2, this.#handleArrowUp.bind(this), COMMAND_PRIORITY_HIGH2));
      this.keyListeners.push(this.#editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, this.#handleArrowDown.bind(this), COMMAND_PRIORITY_HIGH2));
    }
    #handleArrowUp(event) {
      this.#moveSelectionUp();
      event.preventDefault();
      return true;
    }
    #handleArrowDown(event) {
      this.#moveSelectionDown();
      event.preventDefault();
      return true;
    }
    #selectFirstOption() {
      const firstOption = this.#listItemElements[0];
      if (firstOption) {
        this.#selectOption(firstOption);
      }
    }
    get #listItemElements() {
      return Array.from(this.popoverElement.querySelectorAll(".lexxy-prompt-menu__item"));
    }
    #selectOption(listItem) {
      this.#clearSelection();
      listItem.toggleAttribute("aria-selected", true);
      listItem.scrollIntoView({ block: "nearest", behavior: "smooth" });
      listItem.focus();
      this.#selection.preservingSelection(() => {
        this.#editorElement.focus();
      });
      this.#editorContentElement.setAttribute("aria-controls", this.popoverElement.id);
      this.#editorContentElement.setAttribute("aria-activedescendant", listItem.id);
      this.#editorContentElement.setAttribute("aria-haspopup", "listbox");
    }
    #clearSelection() {
      this.#listItemElements.forEach((item) => {
        item.toggleAttribute("aria-selected", false);
      });
      this.#editorContentElement.removeAttribute("aria-controls");
      this.#editorContentElement.removeAttribute("aria-activedescendant");
      this.#editorContentElement.removeAttribute("aria-haspopup");
    }
    #positionPopover() {
      const { x: x2, y: y3, fontSize } = this.#selection.cursorPosition;
      const editorRect = this.#editorElement.getBoundingClientRect();
      const contentRect = this.#editorContentElement.getBoundingClientRect();
      const verticalOffset = contentRect.top - editorRect.top;
      if (!this.popoverElement.hasAttribute("data-anchored")) {
        this.popoverElement.style.left = `${x2}px`;
        this.popoverElement.toggleAttribute("data-anchored", true);
      }
      this.popoverElement.style.top = `${y3 + verticalOffset}px`;
      this.popoverElement.style.bottom = "auto";
      const popoverRect = this.popoverElement.getBoundingClientRect();
      const isClippedAtBottom = popoverRect.bottom > window.innerHeight;
      if (isClippedAtBottom || this.popoverElement.hasAttribute("data-clipped-at-bottom")) {
        this.popoverElement.style.top = `${y3 + verticalOffset - popoverRect.height - fontSize}px`;
        this.popoverElement.style.bottom = "auto";
        this.popoverElement.toggleAttribute("data-clipped-at-bottom", true);
      }
    }
    #resetPopoverPosition() {
      this.popoverElement.removeAttribute("data-clipped-at-bottom");
      this.popoverElement.removeAttribute("data-anchored");
    }
    async #hidePopover() {
      this.#clearSelection();
      this.popoverElement.classList.toggle("lexxy-prompt-menu--visible", false);
      this.#editorElement.removeEventListener("lexxy:change", this.#filterOptions);
      this.#editorElement.removeEventListener("keydown", this.#handleKeydownOnPopover);
      this.#unregisterKeyListeners();
      this.#removeCursorPositionListener();
      await nextFrame();
      this.#addTriggerListener();
    }
    #unregisterKeyListeners() {
      this.keyListeners.forEach((unregister) => unregister());
      this.keyListeners = [];
    }
    #filterOptions = async () => {
      if (this.initialPrompt) {
        this.initialPrompt = false;
        return;
      }
      if (this.#editorContents.containsTextBackUntil(this.trigger)) {
        await this.#showFilteredOptions();
        await nextFrame();
        this.#positionPopover();
      } else {
        this.#hidePopover();
      }
    };
    async #showFilteredOptions() {
      const filter = this.#editorContents.textBackUntil(this.trigger);
      const filteredListItems = await this.source.buildListItems(filter);
      this.popoverElement.innerHTML = "";
      if (filteredListItems.length > 0) {
        this.#showResults(filteredListItems);
      } else {
        this.#showEmptyResults();
      }
      this.#selectFirstOption();
    }
    #showResults(filteredListItems) {
      this.popoverElement.classList.remove("lexxy-prompt-menu--empty");
      this.popoverElement.append(...filteredListItems);
    }
    #showEmptyResults() {
      this.popoverElement.classList.add("lexxy-prompt-menu--empty");
      const el = createElement("li", { innerHTML: this.#emptyResultsMessage });
      el.classList.add("lexxy-prompt-menu__item--empty");
      this.popoverElement.append(el);
    }
    get #emptyResultsMessage() {
      return this.getAttribute("empty-results") || NOTHING_FOUND_DEFAULT_MESSAGE;
    }
    #handleKeydownOnPopover = (event) => {
      if (event.key === "Escape") {
        this.#hidePopover();
        this.#editorElement.focus();
        event.stopPropagation();
      }
    };
    #moveSelectionDown() {
      const nextIndex = this.#selectedIndex + 1;
      if (nextIndex < this.#listItemElements.length) this.#selectOption(this.#listItemElements[nextIndex]);
    }
    #moveSelectionUp() {
      const previousIndex = this.#selectedIndex - 1;
      if (previousIndex >= 0) this.#selectOption(this.#listItemElements[previousIndex]);
    }
    get #selectedIndex() {
      return this.#listItemElements.findIndex((item) => item.hasAttribute("aria-selected"));
    }
    get #selectedListItem() {
      return this.#listItemElements[this.#selectedIndex];
    }
    #handleSelectedOption(event) {
      event.preventDefault();
      event.stopPropagation();
      this.#optionWasSelected();
      return true;
    }
    #optionWasSelected() {
      this.#replaceTriggerWithSelectedItem();
      this.#hidePopover();
      this.#editorElement.focus();
    }
    #replaceTriggerWithSelectedItem() {
      const promptItem = this.source.promptItemFor(this.#selectedListItem);
      if (!promptItem) {
        return;
      }
      const templates = Array.from(promptItem.querySelectorAll("template[type='editor']"));
      const stringToReplace = `${this.trigger}${this.#editorContents.textBackUntil(this.trigger)}`;
      if (this.hasAttribute("insert-editable-text")) {
        this.#insertTemplatesAsEditableText(templates, stringToReplace);
      } else {
        this.#insertTemplatesAsAttachments(templates, stringToReplace, promptItem.getAttribute("sgid"));
      }
    }
    #insertTemplatesAsEditableText(templates, stringToReplace) {
      this.#editor.update(() => {
        const nodes = templates.flatMap((template) => this.#buildEditableTextNodes(template));
        this.#editorContents.replaceTextBackUntil(stringToReplace, nodes);
      });
    }
    #buildEditableTextNodes(template) {
      return $generateNodesFromDOM2(this.#editor, parseHtml(`${template.innerHTML}`));
    }
    #insertTemplatesAsAttachments(templates, stringToReplace, fallbackSgid = null) {
      this.#editor.update(() => {
        const attachmentNodes = this.#buildAttachmentNodes(templates, fallbackSgid);
        const spacedAttachmentNodes = attachmentNodes.flatMap((node) => [node, this.#getSpacerTextNode()]).slice(0, -1);
        this.#editorContents.replaceTextBackUntil(stringToReplace, spacedAttachmentNodes);
      });
    }
    #buildAttachmentNodes(templates, fallbackSgid = null) {
      return templates.map(
        (template) => this.#buildAttachmentNode(
          template.innerHTML,
          template.getAttribute("content-type") || this.#defaultPromptContentType,
          template.getAttribute("sgid") || fallbackSgid
        )
      );
    }
    #getSpacerTextNode() {
      return $createTextNode2(" ");
    }
    get #defaultPromptContentType() {
      const attachmentContentTypeNamespace = Lexxy.global.get("attachmentContentTypeNamespace");
      return `application/vnd.${attachmentContentTypeNamespace}.${this.name}`;
    }
    #buildAttachmentNode(innerHtml, contentType, sgid) {
      return new CustomActionTextAttachmentNode({ sgid, contentType, innerHtml });
    }
    get #editorContents() {
      return this.#editorElement.contents;
    }
    get #editorContentElement() {
      return this.#editorElement.editorContentElement;
    }
    async #buildPopover() {
      const popoverContainer = createElement("ul", { role: "listbox", id: generateDomId("prompt-popover") });
      popoverContainer.classList.add("lexxy-prompt-menu");
      popoverContainer.style.position = "absolute";
      popoverContainer.setAttribute("nonce", getNonce());
      popoverContainer.append(...await this.source.buildListItems());
      popoverContainer.addEventListener("click", this.#handlePopoverClick);
      this.#editorElement.appendChild(popoverContainer);
      return popoverContainer;
    }
    #handlePopoverClick = (event) => {
      const listItem = event.target.closest(".lexxy-prompt-menu__item");
      if (listItem) {
        this.#selectOption(listItem);
        this.#optionWasSelected();
      }
    };
    #reconnect() {
      this.disconnectedCallback();
      this.connectedCallback();
    }
  };
  customElements.define("lexxy-prompt", LexicalPromptElement);
  var CodeLanguagePicker = class extends HTMLElement {
    connectedCallback() {
      this.editorElement = this.closest("lexxy-editor");
      this.editor = this.editorElement.editor;
      this.#attachLanguagePicker();
      this.#monitorForCodeBlockSelection();
    }
    #attachLanguagePicker() {
      this.languagePickerElement = this.#createLanguagePicker();
      this.languagePickerElement.addEventListener("change", () => {
        this.#updateCodeBlockLanguage(this.languagePickerElement.value);
      });
      this.languagePickerElement.setAttribute("nonce", getNonce());
      this.appendChild(this.languagePickerElement);
    }
    #createLanguagePicker() {
      const selectElement = createElement("select", { className: "lexxy-code-language-picker", "aria-label": "Pick a language\u2026", name: "lexxy-code-language" });
      for (const [value, label] of Object.entries(this.#languages)) {
        const option = document.createElement("option");
        option.value = value;
        option.textContent = label;
        selectElement.appendChild(option);
      }
      return selectElement;
    }
    get #languages() {
      const languages = { ...CODE_LANGUAGE_FRIENDLY_NAME_MAP2 };
      if (!languages.ruby) languages.ruby = "Ruby";
      if (!languages.php) languages.php = "PHP";
      if (!languages.go) languages.go = "Go";
      if (!languages.bash) languages.bash = "Bash";
      if (!languages.json) languages.json = "JSON";
      if (!languages.diff) languages.diff = "Diff";
      const sortedEntries = Object.entries(languages).sort(([, a2], [, b3]) => a2.localeCompare(b3));
      const plainIndex = sortedEntries.findIndex(([key]) => key === "plain");
      const plainEntry = sortedEntries.splice(plainIndex, 1)[0];
      return Object.fromEntries([plainEntry, ...sortedEntries]);
    }
    #updateCodeBlockLanguage(language) {
      this.editor.update(() => {
        const codeNode = this.#getCurrentCodeNode();
        if (codeNode) {
          codeNode.setLanguage(language);
        }
      });
    }
    #monitorForCodeBlockSelection() {
      this.editor.registerUpdateListener(() => {
        this.editor.getEditorState().read(() => {
          const codeNode = this.#getCurrentCodeNode();
          if (codeNode) {
            this.#codeNodeWasSelected(codeNode);
          } else {
            this.#hideLanguagePicker();
          }
        });
      });
    }
    #getCurrentCodeNode() {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return null;
      }
      const anchorNode = selection.anchor.getNode();
      const parentNode = anchorNode.getParent();
      if ($isCodeNode2(anchorNode)) {
        return anchorNode;
      } else if ($isCodeNode2(parentNode)) {
        return parentNode;
      }
      return null;
    }
    #codeNodeWasSelected(codeNode) {
      const language = codeNode.getLanguage();
      this.#updateLanguagePickerWith(language);
      this.#showLanguagePicker();
      this.#positionLanguagePicker(codeNode);
    }
    #updateLanguagePickerWith(language) {
      if (this.languagePickerElement && language) {
        const normalizedLanguage = normalizeCodeLang2(language);
        this.languagePickerElement.value = normalizedLanguage;
      }
    }
    #positionLanguagePicker(codeNode) {
      const codeElement = this.editor.getElementByKey(codeNode.getKey());
      if (!codeElement) return;
      const codeRect = codeElement.getBoundingClientRect();
      const editorRect = this.editorElement.getBoundingClientRect();
      const relativeTop = codeRect.top - editorRect.top;
      const relativeRight = editorRect.right - codeRect.right;
      this.style.top = `${relativeTop}px`;
      this.style.right = `${relativeRight}px`;
    }
    #showLanguagePicker() {
      this.hidden = false;
    }
    #hideLanguagePicker() {
      this.hidden = true;
    }
  };
  customElements.define("lexxy-code-language-picker", CodeLanguagePicker);
  var configure = Lexxy.configure;

  // lib/lesli_assets_js/application.js
  window.dayjs = import_dayjs.default;
  window.debug = import_browser.default;
  window.Alpine = module_default;
  window.ChartJs = auto_default;
  window.LesliChart = import_lesli_chart.default;
  module_default.start();
  import_browser.default.info("Ruby on Rails SaaS Development Framework", "Lesli");
})();
/*
Lesli

Copyright (c) 2025, Lesli Technologies, S. A.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see http://www.gnu.org/licenses/.

Lesli · Ruby on Rails SaaS Development Framework.

Made with ♥ by LesliTech
Building a better future, one line of code at a time.

@contact  hello@lesli.tech
@website  https://www.lesli.tech
@license  GPLv3 http://www.gnu.org/licenses/gpl-3.0.en.html

// · ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~
// · 
*/
/*! Bundled license information:

lesli-js/src/debug/utils.js:
lesli-js/debug/browser.js:
  (*
  Lesli
  
  Copyright (c) 2021, Lesli Technologies, S. A.
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
  
  Lesli JS - JavaScript utilities for JavaScript applications
  
  Powered by LesliTech
  Building a better future, one line of code at a time.
  
  @contact  <hello@lesli.tech>
  @website  <https://lesli.tech>
  @license  GPLv3 http://www.gnu.org/licenses/gpl-3.0.en.html
  
  // · ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~
  // · 
  *)

lesli-js/src/debug/browser.js:
  (*
  Lesli
  
  Copyright (c) 2020, Lesli Technologies, S. A.
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
  
  Lesli JS - JavaScript utilities for JavaScript applications
  
  Powered by LesliTech
  Building a better future, one line of code at a time.
  
  @contact  <hello@lesli.tech>
  @website  <https://lesli.tech>
  @license  GPLv3 http://www.gnu.org/licenses/gpl-3.0.en.html
  
  // · ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~     ~·~
  // · 
  *)

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.dataset.js:
chart.js/dist/chart.js:
  (*!
   * Chart.js v4.5.1
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)

dompurify/dist/purify.es.mjs:
  (*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE *)
*/
