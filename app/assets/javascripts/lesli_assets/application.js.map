{
  "version": 3,
  "sources": ["../../../../node_modules/prismjs/prism.js", "../../../../node_modules/@rails/activestorage/app/assets/javascripts/activestorage.esm.js", "../../../../node_modules/dayjs/dayjs.min.js", "../../../../lib/lesli_assets_js/lesli_chart.js", "../../../../node_modules/lesli-js/node_modules/dayjs/dayjs.min.js", "../../../../node_modules/lesli-js/src/debug/utils.js", "../../../../node_modules/lesli-js/src/debug/browser.js", "../../../../node_modules/lesli-js/debug/browser.js", "../../../../node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js", "../../../../node_modules/@37signals/lexxy/dist/lexxy.esm.js", "../../../../node_modules/prismjs/components/prism-clike.js", "../../../../node_modules/prismjs/components/prism-markup.js", "../../../../node_modules/prismjs/components/prism-markup-templating.js", "../../../../node_modules/prismjs/components/prism-ruby.js", "../../../../node_modules/prismjs/components/prism-php.js", "../../../../node_modules/prismjs/components/prism-go.js", "../../../../node_modules/prismjs/components/prism-bash.js", "../../../../node_modules/prismjs/components/prism-json.js", "../../../../node_modules/prismjs/components/prism-diff.js", "../../../../node_modules/dompurify/src/utils.ts", "../../../../node_modules/dompurify/src/tags.ts", "../../../../node_modules/dompurify/src/attrs.ts", "../../../../node_modules/dompurify/src/regexp.ts", "../../../../node_modules/dompurify/src/purify.ts", "../../../../node_modules/@lexical/selection/LexicalSelection.dev.mjs", "../../../../node_modules/lexical/Lexical.dev.mjs", "../../../../node_modules/lexical/Lexical.mjs", "../../../../node_modules/@lexical/selection/LexicalSelection.mjs", "../../../../node_modules/@lexical/list/LexicalList.dev.mjs", "../../../../node_modules/@lexical/extension/LexicalExtension.dev.mjs", "../../../../node_modules/@lexical/utils/LexicalUtils.dev.mjs", "../../../../node_modules/@lexical/utils/LexicalUtils.mjs", "../../../../node_modules/@lexical/extension/LexicalExtension.mjs", "../../../../node_modules/@lexical/list/LexicalList.mjs", "../../../../node_modules/@lexical/rich-text/LexicalRichText.dev.mjs", "../../../../node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs", "../../../../node_modules/@lexical/html/LexicalHtml.dev.mjs", "../../../../node_modules/@lexical/html/LexicalHtml.mjs", "../../../../node_modules/@lexical/clipboard/LexicalClipboard.mjs", "../../../../node_modules/@lexical/dragon/LexicalDragon.dev.mjs", "../../../../node_modules/@lexical/dragon/LexicalDragon.mjs", "../../../../node_modules/@lexical/rich-text/LexicalRichText.mjs", "../../../../node_modules/@lexical/code/LexicalCode.dev.mjs", "../../../../node_modules/prismjs/components/prism-javascript.js", "../../../../node_modules/prismjs/components/prism-markdown.js", "../../../../node_modules/prismjs/components/prism-c.js", "../../../../node_modules/prismjs/components/prism-css.js", "../../../../node_modules/prismjs/components/prism-objectivec.js", "../../../../node_modules/prismjs/components/prism-sql.js", "../../../../node_modules/prismjs/components/prism-powershell.js", "../../../../node_modules/prismjs/components/prism-python.js", "../../../../node_modules/prismjs/components/prism-rust.js", "../../../../node_modules/prismjs/components/prism-swift.js", "../../../../node_modules/prismjs/components/prism-typescript.js", "../../../../node_modules/prismjs/components/prism-java.js", "../../../../node_modules/prismjs/components/prism-cpp.js", "../../../../node_modules/@lexical/code/LexicalCode.prod.mjs", "../../../../node_modules/@lexical/code/LexicalCode.mjs", "../../../../node_modules/@lexical/link/LexicalLink.dev.mjs", "../../../../node_modules/@lexical/link/LexicalLink.mjs", "../../../../node_modules/@lexical/table/LexicalTable.dev.mjs", "../../../../node_modules/@lexical/table/LexicalTable.mjs", "../../../../node_modules/@37signals/lexxy/dist/lexxy_helpers.esm.js", "../../../../node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs", "../../../../node_modules/@lexical/plain-text/LexicalPlainText.mjs", "../../../../node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs", "../../../../node_modules/@lexical/markdown/LexicalMarkdown.mjs", "../../../../node_modules/@lexical/history/LexicalHistory.dev.mjs", "../../../../node_modules/@lexical/history/LexicalHistory.mjs", "../../../../node_modules/marked/src/defaults.ts", "../../../../node_modules/marked/src/rules.ts", "../../../../node_modules/marked/src/helpers.ts", "../../../../node_modules/marked/src/Tokenizer.ts", "../../../../node_modules/marked/src/Lexer.ts", "../../../../node_modules/marked/src/Renderer.ts", "../../../../node_modules/marked/src/TextRenderer.ts", "../../../../node_modules/marked/src/Parser.ts", "../../../../node_modules/marked/src/Hooks.ts", "../../../../node_modules/marked/src/Instance.ts", "../../../../node_modules/marked/src/marked.ts", "../../../../lib/lesli_assets_js/application.js", "../../../../node_modules/alpinejs/dist/module.esm.js", "../../../../node_modules/@kurkle/color/dist/color.esm.js", "../../../../node_modules/chart.js/src/helpers/helpers.core.ts", "../../../../node_modules/chart.js/src/helpers/helpers.math.ts", "../../../../node_modules/chart.js/src/helpers/helpers.collection.ts", "../../../../node_modules/chart.js/src/helpers/helpers.extras.ts", "../../../../node_modules/chart.js/src/helpers/helpers.easing.ts", "../../../../node_modules/chart.js/src/helpers/helpers.color.ts", "../../../../node_modules/chart.js/src/core/core.animations.defaults.js", "../../../../node_modules/chart.js/src/core/core.layouts.defaults.js", "../../../../node_modules/chart.js/src/helpers/helpers.intl.ts", "../../../../node_modules/chart.js/src/core/core.ticks.js", "../../../../node_modules/chart.js/src/core/core.scale.defaults.js", "../../../../node_modules/chart.js/src/core/core.defaults.js", "../../../../node_modules/chart.js/src/helpers/helpers.canvas.ts", "../../../../node_modules/chart.js/src/helpers/helpers.options.ts", "../../../../node_modules/chart.js/src/helpers/helpers.config.ts", "../../../../node_modules/chart.js/src/helpers/helpers.curve.ts", "../../../../node_modules/chart.js/src/helpers/helpers.dom.ts", "../../../../node_modules/chart.js/src/helpers/helpers.interpolation.ts", "../../../../node_modules/chart.js/src/helpers/helpers.rtl.ts", "../../../../node_modules/chart.js/src/helpers/helpers.segment.js", "../../../../node_modules/chart.js/src/helpers/helpers.dataset.ts", "../../../../node_modules/chart.js/src/core/core.animator.js", "../../../../node_modules/chart.js/src/core/core.animation.js", "../../../../node_modules/chart.js/src/core/core.animations.js", "../../../../node_modules/chart.js/src/core/core.datasetController.js", "../../../../node_modules/chart.js/src/controllers/controller.bar.js", "../../../../node_modules/chart.js/src/controllers/controller.bubble.js", "../../../../node_modules/chart.js/src/controllers/controller.doughnut.js", "../../../../node_modules/chart.js/src/controllers/controller.line.js", "../../../../node_modules/chart.js/src/controllers/controller.polarArea.js", "../../../../node_modules/chart.js/src/controllers/controller.pie.js", "../../../../node_modules/chart.js/src/controllers/controller.radar.js", "../../../../node_modules/chart.js/src/controllers/controller.scatter.js", "../../../../node_modules/chart.js/src/core/core.adapters.ts", "../../../../node_modules/chart.js/src/core/core.interaction.js", "../../../../node_modules/chart.js/src/core/core.layouts.js", "../../../../node_modules/chart.js/src/platform/platform.base.js", "../../../../node_modules/chart.js/src/platform/platform.basic.js", "../../../../node_modules/chart.js/src/platform/platform.dom.js", "../../../../node_modules/chart.js/src/platform/index.js", "../../../../node_modules/chart.js/src/core/core.element.ts", "../../../../node_modules/chart.js/src/core/core.scale.autoskip.js", "../../../../node_modules/chart.js/src/core/core.scale.js", "../../../../node_modules/chart.js/src/core/core.typedRegistry.js", "../../../../node_modules/chart.js/src/core/core.registry.js", "../../../../node_modules/chart.js/src/core/core.plugins.js", "../../../../node_modules/chart.js/src/core/core.config.js", "../../../../node_modules/chart.js/src/core/core.controller.js", "../../../../node_modules/chart.js/src/elements/element.arc.ts", "../../../../node_modules/chart.js/src/elements/element.line.js", "../../../../node_modules/chart.js/src/elements/element.point.ts", "../../../../node_modules/chart.js/src/elements/element.bar.js", "../../../../node_modules/chart.js/src/plugins/plugin.colors.ts", "../../../../node_modules/chart.js/src/plugins/plugin.decimation.js", "../../../../node_modules/chart.js/src/plugins/plugin.filler/filler.segment.js", "../../../../node_modules/chart.js/src/plugins/plugin.filler/filler.helper.js", "../../../../node_modules/chart.js/src/plugins/plugin.filler/filler.options.js", "../../../../node_modules/chart.js/src/plugins/plugin.filler/filler.target.stack.js", "../../../../node_modules/chart.js/src/plugins/plugin.filler/simpleArc.js", "../../../../node_modules/chart.js/src/plugins/plugin.filler/filler.target.js", "../../../../node_modules/chart.js/src/plugins/plugin.filler/filler.drawing.js", "../../../../node_modules/chart.js/src/plugins/plugin.filler/index.js", "../../../../node_modules/chart.js/src/plugins/plugin.legend.js", "../../../../node_modules/chart.js/src/plugins/plugin.title.js", "../../../../node_modules/chart.js/src/plugins/plugin.subtitle.js", "../../../../node_modules/chart.js/src/plugins/plugin.tooltip.js", "../../../../node_modules/chart.js/src/scales/scale.category.js", "../../../../node_modules/chart.js/src/scales/scale.linearbase.js", "../../../../node_modules/chart.js/src/scales/scale.linear.js", "../../../../node_modules/chart.js/src/scales/scale.logarithmic.js", "../../../../node_modules/chart.js/src/scales/scale.radialLinear.js", "../../../../node_modules/chart.js/src/scales/scale.time.js", "../../../../node_modules/chart.js/src/scales/scale.timeseries.js", "../../../../node_modules/chart.js/src/index.ts", "../../../../node_modules/chart.js/auto/auto.js"],
  "sourcesContent": ["\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\n/// <reference lib=\"WebWorker\"/>\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\nvar Prism = (function (_self) {\n\n\t// Private helper vars\n\tvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\tvar uniqueId = 0;\n\n\t// The grammar object for plaintext\n\tvar plainTextGrammar = {};\n\n\n\tvar _ = {\n\t\t/**\n\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n\t\t * additional languages or plugins yourself.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n\t\t *\n\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.manual = true;\n\t\t * // add a new <script> to load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tmanual: _self.Prism && _self.Prism.manual,\n\t\t/**\n\t\t * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n\t\t * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n\t\t * own worker, you don't want it to do this.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not add its own listeners to the worker.\n\t\t *\n\t\t * You obviously have to change this value before Prism executes. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.disableWorkerMessageHandler = true;\n\t\t * // Load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n\n\t\t/**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */\n\t\tutil: {\n\t\t\tencode: function encode(tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (Array.isArray(tokens)) {\n\t\t\t\t\treturn tokens.map(encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */\n\t\t\tclone: function deepClone(o, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar clone; var id;\n\t\t\t\tswitch (_.util.type(o)) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {\n\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tgetLanguage: function (element) {\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar m = lang.exec(element.className);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\treturn m[1].toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn 'none';\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tsetLanguage: function (element, language) {\n\t\t\t\t// remove all `language-xxxx` classes\n\t\t\t\t// (this might leave behind a leading space)\n\t\t\t\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t\t\t\t// add the new `language-xxxx` class\n\t\t\t\t// (using `classList` will automatically clean up spaces for us)\n\t\t\t\telement.classList.add('language-' + language);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the script element that is currently executing.\n\t\t\t *\n\t\t\t * This does __not__ work for line script element.\n\t\t\t *\n\t\t\t * @returns {HTMLScriptElement | null}\n\t\t\t */\n\t\t\tcurrentScript: function () {\n\t\t\t\tif (typeof document === 'undefined') {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (document.currentScript && document.currentScript.tagName === 'SCRIPT' && 1 < 2 /* hack to trip TS' flow analysis */) {\n\t\t\t\t\treturn /** @type {any} */ (document.currentScript);\n\t\t\t\t}\n\n\t\t\t\t// IE11 workaround\n\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace\n\t\t\t\t// this will not work for inline scripts\n\n\t\t\t\ttry {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.\n\t\t\t\t\t// A stack will look like this:\n\t\t\t\t\t//\n\t\t\t\t\t// Error\n\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)\n\n\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\t\t\t\tfor (var i in scripts) {\n\t\t\t\t\t\t\tif (scripts[i].src == src) {\n\t\t\t\t\t\t\t\treturn scripts[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tisActive: function (element, className, defaultActivation) {\n\t\t\t\tvar no = 'no-' + className;\n\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar classList = element.classList;\n\t\t\t\t\tif (classList.contains(className)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (classList.contains(no)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn !!defaultActivation;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tlanguages: {\n\t\t\t/**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */\n\t\t\tplain: plainTextGrammar,\n\t\t\tplaintext: plainTextGrammar,\n\t\t\ttext: plainTextGrammar,\n\t\t\ttxt: plainTextGrammar,\n\n\t\t\t/**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || /** @type {any} */ (_.languages);\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t/** @type {Grammar} */\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525\n\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {\n\t\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar old = root[inside];\n\t\t\t\troot[inside] = ret;\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === old && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function DFS(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar objId = _.util.objId;\n\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tvar property = o[i];\n\t\t\t\t\t\tvar propertyType = _.util.type(property);\n\n\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, null, visited);\n\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tplugins: {},\n\n\t\t/**\n\t\t * This is the most high-level function in Prism\u2019s API.\n\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n\t\t * each one of them.\n\t\t *\n\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n\t\t *\n\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAll: function (async, callback) {\n\t\t\t_.highlightAllUnder(document, async, callback);\n\t\t},\n\n\t\t/**\n\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n\t\t * {@link Prism.highlightElement} on each one of them.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-highlightall`\n\t\t * 2. `before-all-elements-highlight`\n\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.\n\t\t *\n\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAllUnder: function (container, async, callback) {\n\t\t\tvar env = {\n\t\t\t\tcallback: callback,\n\t\t\t\tcontainer: container,\n\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t\t};\n\n\t\t\t_.hooks.run('before-highlightall', env);\n\n\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n\n\t\t\t_.hooks.run('before-all-elements-highlight', env);\n\n\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {\n\t\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Highlights the code inside a single element.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-sanity-check`\n\t\t * 2. `before-highlight`\n\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t\t * 4. `before-insert`\n\t\t * 5. `after-highlight`\n\t\t * 6. `complete`\n\t\t *\n\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t\t * the element's language.\n\t\t *\n\t\t * @param {Element} element The element containing the code.\n\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n\t\t *\n\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n\t\t * asynchronous highlighting to work. You can build your own bundle on the\n\t\t * [Download page](https://prismjs.com/download.html).\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightElement: function (element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language = _.util.getLanguage(element);\n\t\t\tvar grammar = _.languages[language];\n\n\t\t\t// Set language on the element, if not present\n\t\t\t_.util.setLanguage(element, language);\n\n\t\t\t// Set language on the parent, for styling\n\t\t\tvar parent = element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\t\t\t_.util.setLanguage(parent, language);\n\t\t\t}\n\n\t\t\tvar code = element.textContent;\n\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\n\t\t\tfunction insertHighlightedCode(highlightedCode) {\n\t\t\t\tenv.highlightedCode = highlightedCode;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t}\n\n\t\t\t_.hooks.run('before-sanity-check', env);\n\n\t\t\t// plugins may change/add the parent/element\n\t\t\tparent = env.element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\t\t\tparent.setAttribute('tabindex', '0');\n\t\t\t}\n\n\t\t\tif (!env.code) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_.hooks.run('before-highlight', env);\n\n\t\t\tif (!env.grammar) {\n\t\t\t\tinsertHighlightedCode(_.util.encode(env.code));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\t\tworker.onmessage = function (evt) {\n\t\t\t\t\tinsertHighlightedCode(evt.data);\n\t\t\t\t};\n\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tinsertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Low-level function, only use if you know what you\u2019re doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar env = {\n\t\t\t\tcode: text,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tlanguage: language\n\t\t\t};\n\t\t\t_.hooks.run('before-tokenize', env);\n\t\t\tif (!env.grammar) {\n\t\t\t\tthrow new Error('The language \"' + env.language + '\" has no grammar.');\n\t\t\t}\n\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);\n\t\t\t_.hooks.run('after-tokenize', env);\n\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);\n\t\t},\n\n\t\t/**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */\n\t\ttokenize: function (text, grammar) {\n\t\t\tvar rest = grammar.rest;\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\tvar tokenList = new LinkedList();\n\t\t\taddAfter(tokenList, tokenList.head, text);\n\n\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\t\treturn toArray(tokenList);\n\t\t},\n\n\t\t/**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\t/**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tToken: Token\n\t};\n\t_self.Prism = _;\n\n\n\t// Typescript note:\n\t// The following can be used to import the Token type in JSDoc:\n\t//\n\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */\n\tfunction Token(type, content, alias, matchedStr) {\n\t\t/**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */\n\t\tthis.content = content;\n\t\t/**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.length = (matchedStr || '').length | 0;\n\t}\n\n\t/**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */\n\n\t/**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */\n\tToken.stringify = function stringify(o, language) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\tif (Array.isArray(o)) {\n\t\t\tvar s = '';\n\t\t\to.forEach(function (e) {\n\t\t\t\ts += stringify(e, language);\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: stringify(o.content, language),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language\n\t\t};\n\n\t\tvar aliases = o.alias;\n\t\tif (aliases) {\n\t\t\tif (Array.isArray(aliases)) {\n\t\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t\t} else {\n\t\t\t\tenv.classes.push(aliases);\n\t\t\t}\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\t/**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */\n\tfunction matchPattern(pattern, pos, text, lookbehind) {\n\t\tpattern.lastIndex = pos;\n\t\tvar match = pattern.exec(text);\n\t\tif (match && lookbehind && match[1]) {\n\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\tvar lookbehindLength = match[1].length;\n\t\t\tmatch.index += lookbehindLength;\n\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */\n\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n\t\tfor (var token in grammar) {\n\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar patternObj = patterns[j];\n\t\t\t\tvar inside = patternObj.inside;\n\t\t\t\tvar lookbehind = !!patternObj.lookbehind;\n\t\t\t\tvar greedy = !!patternObj.greedy;\n\t\t\t\tvar alias = patternObj.alias;\n\n\t\t\t\tif (greedy && !patternObj.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n\t\t\t\t}\n\n\t\t\t\t/** @type {RegExp} */\n\t\t\t\tvar pattern = patternObj.pattern || patternObj;\n\n\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode !== tokenList.tail;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index;\n\t\t\t\t\t\tvar to = match.index + match[0].length;\n\t\t\t\t\t\tvar p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode;\n\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tvar from = match.index;\n\t\t\t\t\tvar matchStr = match[0];\n\t\t\t\t\tvar before = str.slice(0, from);\n\t\t\t\t\tvar after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tvar reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);\n\n\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\taddAfter(tokenList, currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\t\tvar nestedRematch = {\n\t\t\t\t\t\t\tcause: token + ',' + j,\n\t\t\t\t\t\t\treach: reach\n\t\t\t\t\t\t};\n\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */\n\n\t/**\n\t * @template T\n\t * @private\n\t */\n\tfunction LinkedList() {\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar head = { value: null, prev: null, next: null };\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.head = head;\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */\n\tfunction addAfter(list, node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tvar next = node.next;\n\n\t\tvar newNode = { value: value, prev: node, next: next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tlist.length++;\n\n\t\treturn newNode;\n\t}\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */\n\tfunction removeRange(list, node, count) {\n\t\tvar next = node.next;\n\t\tfor (var i = 0; i < count && next !== list.tail; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tlist.length -= i;\n\t}\n\t/**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */\n\tfunction toArray(list) {\n\t\tvar array = [];\n\t\tvar node = list.head.next;\n\t\twhile (node !== list.tail) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n\n\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _;\n\t\t}\n\n\t\tif (!_.disableWorkerMessageHandler) {\n\t\t\t// In worker\n\t\t\t_self.addEventListener('message', function (evt) {\n\t\t\t\tvar message = JSON.parse(evt.data);\n\t\t\t\tvar lang = message.language;\n\t\t\t\tvar code = message.code;\n\t\t\t\tvar immediateClose = message.immediateClose;\n\n\t\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\t\tif (immediateClose) {\n\t\t\t\t\t_self.close();\n\t\t\t\t}\n\t\t\t}, false);\n\t\t}\n\n\t\treturn _;\n\t}\n\n\t// Get current script and highlight\n\tvar script = _.util.currentScript();\n\n\tif (script) {\n\t\t_.filename = script.src;\n\n\t\tif (script.hasAttribute('data-manual')) {\n\t\t\t_.manual = true;\n\t\t}\n\t}\n\n\tfunction highlightAutomaticallyCallback() {\n\t\tif (!_.manual) {\n\t\t\t_.highlightAll();\n\t\t}\n\t}\n\n\tif (!_.manual) {\n\t\t// If the document state is \"loading\", then we'll use DOMContentLoaded.\n\t\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n\t\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n\t\t// might take longer one animation frame to execute which can create a race condition where only some plugins have\n\t\t// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n\t\t// See https://github.com/PrismJS/prism/issues/2102\n\t\tvar readyState = document.readyState;\n\t\tif (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);\n\t\t} else {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(highlightAutomaticallyCallback);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(highlightAutomaticallyCallback, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _;\n\n}(_self));\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n\tglobal.Prism = Prism;\n}\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^(\\s*)[\"']|[\"']$/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\n(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: RegExp('@[\\\\w-](?:' + /[^;{\\s\"']|\\s+(?!\\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\\s*\\{))/.source),\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n\tif (!Element.prototype.matches) {\n\t\tElement.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\t}\n\n\tvar LOADING_MESSAGE = 'Loading\u2026';\n\tvar FAILURE_MESSAGE = function (status, message) {\n\t\treturn '\u2716 Error ' + status + ' while fetching file: ' + message;\n\t};\n\tvar FAILURE_EMPTY_MESSAGE = '\u2716 Error: File does not exist or is empty';\n\n\tvar EXTENSIONS = {\n\t\t'js': 'javascript',\n\t\t'py': 'python',\n\t\t'rb': 'ruby',\n\t\t'ps1': 'powershell',\n\t\t'psm1': 'powershell',\n\t\t'sh': 'bash',\n\t\t'bat': 'batch',\n\t\t'h': 'c',\n\t\t'tex': 'latex'\n\t};\n\n\tvar STATUS_ATTR = 'data-src-status';\n\tvar STATUS_LOADING = 'loading';\n\tvar STATUS_LOADED = 'loaded';\n\tvar STATUS_FAILED = 'failed';\n\n\tvar SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '=\"' + STATUS_LOADED + '\"])'\n\t\t+ ':not([' + STATUS_ATTR + '=\"' + STATUS_LOADING + '\"])';\n\n\t/**\n\t * Loads the given file.\n\t *\n\t * @param {string} src The URL or path of the source file to load.\n\t * @param {(result: string) => void} success\n\t * @param {(reason: string) => void} error\n\t */\n\tfunction loadFile(src, success, error) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open('GET', src, true);\n\t\txhr.onreadystatechange = function () {\n\t\t\tif (xhr.readyState == 4) {\n\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\tsuccess(xhr.responseText);\n\t\t\t\t} else {\n\t\t\t\t\tif (xhr.status >= 400) {\n\t\t\t\t\t\terror(FAILURE_MESSAGE(xhr.status, xhr.statusText));\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror(FAILURE_EMPTY_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\txhr.send(null);\n\t}\n\n\t/**\n\t * Parses the given range.\n\t *\n\t * This returns a range with inclusive ends.\n\t *\n\t * @param {string | null | undefined} range\n\t * @returns {[number, number | undefined] | undefined}\n\t */\n\tfunction parseRange(range) {\n\t\tvar m = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(range || '');\n\t\tif (m) {\n\t\t\tvar start = Number(m[1]);\n\t\t\tvar comma = m[2];\n\t\t\tvar end = m[3];\n\n\t\t\tif (!comma) {\n\t\t\t\treturn [start, start];\n\t\t\t}\n\t\t\tif (!end) {\n\t\t\t\treturn [start, undefined];\n\t\t\t}\n\t\t\treturn [start, Number(end)];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tPrism.hooks.add('before-highlightall', function (env) {\n\t\tenv.selector += ', ' + SELECTOR;\n\t});\n\n\tPrism.hooks.add('before-sanity-check', function (env) {\n\t\tvar pre = /** @type {HTMLPreElement} */ (env.element);\n\t\tif (pre.matches(SELECTOR)) {\n\t\t\tenv.code = ''; // fast-path the whole thing and go to complete\n\n\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading\n\n\t\t\t// add code element with loading message\n\t\t\tvar code = pre.appendChild(document.createElement('CODE'));\n\t\t\tcode.textContent = LOADING_MESSAGE;\n\n\t\t\tvar src = pre.getAttribute('data-src');\n\n\t\t\tvar language = env.language;\n\t\t\tif (language === 'none') {\n\t\t\t\t// the language might be 'none' because there is no language set;\n\t\t\t\t// in this case, we want to use the extension as the language\n\t\t\t\tvar extension = (/\\.(\\w+)$/.exec(src) || [, 'none'])[1];\n\t\t\t\tlanguage = EXTENSIONS[extension] || extension;\n\t\t\t}\n\n\t\t\t// set language classes\n\t\t\tPrism.util.setLanguage(code, language);\n\t\t\tPrism.util.setLanguage(pre, language);\n\n\t\t\t// preload the language\n\t\t\tvar autoloader = Prism.plugins.autoloader;\n\t\t\tif (autoloader) {\n\t\t\t\tautoloader.loadLanguages(language);\n\t\t\t}\n\n\t\t\t// load file\n\t\t\tloadFile(\n\t\t\t\tsrc,\n\t\t\t\tfunction (text) {\n\t\t\t\t\t// mark as loaded\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADED);\n\n\t\t\t\t\t// handle data-range\n\t\t\t\t\tvar range = parseRange(pre.getAttribute('data-range'));\n\t\t\t\t\tif (range) {\n\t\t\t\t\t\tvar lines = text.split(/\\r\\n?|\\n/g);\n\n\t\t\t\t\t\t// the range is one-based and inclusive on both ends\n\t\t\t\t\t\tvar start = range[0];\n\t\t\t\t\t\tvar end = range[1] == null ? lines.length : range[1];\n\n\t\t\t\t\t\tif (start < 0) { start += lines.length; }\n\t\t\t\t\t\tstart = Math.max(0, Math.min(start - 1, lines.length));\n\t\t\t\t\t\tif (end < 0) { end += lines.length; }\n\t\t\t\t\t\tend = Math.max(0, Math.min(end, lines.length));\n\n\t\t\t\t\t\ttext = lines.slice(start, end).join('\\n');\n\n\t\t\t\t\t\t// add data-start for line numbers\n\t\t\t\t\t\tif (!pre.hasAttribute('data-start')) {\n\t\t\t\t\t\t\tpre.setAttribute('data-start', String(start + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// highlight code\n\t\t\t\t\tcode.textContent = text;\n\t\t\t\t\tPrism.highlightElement(code);\n\t\t\t\t},\n\t\t\t\tfunction (error) {\n\t\t\t\t\t// mark as failed\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_FAILED);\n\n\t\t\t\t\tcode.textContent = error;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t});\n\n\tPrism.plugins.fileHighlight = {\n\t\t/**\n\t\t * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n\t\t *\n\t\t * Note: Elements which are already loaded or currently loading will not be touched by this method.\n\t\t *\n\t\t * @param {ParentNode} [container=document]\n\t\t */\n\t\thighlight: function highlight(container) {\n\t\t\tvar elements = (container || document).querySelectorAll(SELECTOR);\n\n\t\t\tfor (var i = 0, element; (element = elements[i++]);) {\n\t\t\t\tPrism.highlightElement(element);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar logged = false;\n\t/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */\n\tPrism.fileHighlight = function () {\n\t\tif (!logged) {\n\t\t\tconsole.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');\n\t\t\tlogged = true;\n\t\t}\n\t\tPrism.plugins.fileHighlight.highlight.apply(this, arguments);\n\t};\n\n}());\n", "var sparkMd5 = {\n  exports: {}\n};\n\n(function(module, exports) {\n  (function(factory) {\n    {\n      module.exports = factory();\n    }\n  })((function(undefined$1) {\n    var hex_chr = [ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" ];\n    function md5cycle(x, k) {\n      var a = x[0], b = x[1], c = x[2], d = x[3];\n      a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n      a = (a << 7 | a >>> 25) + b | 0;\n      d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n      d = (d << 12 | d >>> 20) + a | 0;\n      c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n      c = (c << 17 | c >>> 15) + d | 0;\n      b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n      b = (b << 22 | b >>> 10) + c | 0;\n      a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n      a = (a << 7 | a >>> 25) + b | 0;\n      d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n      d = (d << 12 | d >>> 20) + a | 0;\n      c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n      c = (c << 17 | c >>> 15) + d | 0;\n      b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n      b = (b << 22 | b >>> 10) + c | 0;\n      a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n      a = (a << 7 | a >>> 25) + b | 0;\n      d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n      d = (d << 12 | d >>> 20) + a | 0;\n      c += (d & a | ~d & b) + k[10] - 42063 | 0;\n      c = (c << 17 | c >>> 15) + d | 0;\n      b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n      b = (b << 22 | b >>> 10) + c | 0;\n      a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n      a = (a << 7 | a >>> 25) + b | 0;\n      d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n      d = (d << 12 | d >>> 20) + a | 0;\n      c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n      c = (c << 17 | c >>> 15) + d | 0;\n      b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n      b = (b << 22 | b >>> 10) + c | 0;\n      a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n      a = (a << 5 | a >>> 27) + b | 0;\n      d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n      d = (d << 9 | d >>> 23) + a | 0;\n      c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n      c = (c << 14 | c >>> 18) + d | 0;\n      b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n      b = (b << 20 | b >>> 12) + c | 0;\n      a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n      a = (a << 5 | a >>> 27) + b | 0;\n      d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n      d = (d << 9 | d >>> 23) + a | 0;\n      c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n      c = (c << 14 | c >>> 18) + d | 0;\n      b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n      b = (b << 20 | b >>> 12) + c | 0;\n      a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n      a = (a << 5 | a >>> 27) + b | 0;\n      d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n      d = (d << 9 | d >>> 23) + a | 0;\n      c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n      c = (c << 14 | c >>> 18) + d | 0;\n      b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n      b = (b << 20 | b >>> 12) + c | 0;\n      a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n      a = (a << 5 | a >>> 27) + b | 0;\n      d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n      d = (d << 9 | d >>> 23) + a | 0;\n      c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n      c = (c << 14 | c >>> 18) + d | 0;\n      b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n      b = (b << 20 | b >>> 12) + c | 0;\n      a += (b ^ c ^ d) + k[5] - 378558 | 0;\n      a = (a << 4 | a >>> 28) + b | 0;\n      d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n      d = (d << 11 | d >>> 21) + a | 0;\n      c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n      c = (c << 16 | c >>> 16) + d | 0;\n      b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n      b = (b << 23 | b >>> 9) + c | 0;\n      a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n      a = (a << 4 | a >>> 28) + b | 0;\n      d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n      d = (d << 11 | d >>> 21) + a | 0;\n      c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n      c = (c << 16 | c >>> 16) + d | 0;\n      b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n      b = (b << 23 | b >>> 9) + c | 0;\n      a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n      a = (a << 4 | a >>> 28) + b | 0;\n      d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n      d = (d << 11 | d >>> 21) + a | 0;\n      c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n      c = (c << 16 | c >>> 16) + d | 0;\n      b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n      b = (b << 23 | b >>> 9) + c | 0;\n      a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n      a = (a << 4 | a >>> 28) + b | 0;\n      d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n      d = (d << 11 | d >>> 21) + a | 0;\n      c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n      c = (c << 16 | c >>> 16) + d | 0;\n      b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n      b = (b << 23 | b >>> 9) + c | 0;\n      a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n      a = (a << 6 | a >>> 26) + b | 0;\n      d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n      d = (d << 10 | d >>> 22) + a | 0;\n      c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n      c = (c << 15 | c >>> 17) + d | 0;\n      b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n      b = (b << 21 | b >>> 11) + c | 0;\n      a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n      a = (a << 6 | a >>> 26) + b | 0;\n      d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n      d = (d << 10 | d >>> 22) + a | 0;\n      c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n      c = (c << 15 | c >>> 17) + d | 0;\n      b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n      b = (b << 21 | b >>> 11) + c | 0;\n      a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n      a = (a << 6 | a >>> 26) + b | 0;\n      d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n      d = (d << 10 | d >>> 22) + a | 0;\n      c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n      c = (c << 15 | c >>> 17) + d | 0;\n      b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n      b = (b << 21 | b >>> 11) + c | 0;\n      a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n      a = (a << 6 | a >>> 26) + b | 0;\n      d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n      d = (d << 10 | d >>> 22) + a | 0;\n      c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n      c = (c << 15 | c >>> 17) + d | 0;\n      b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n      b = (b << 21 | b >>> 11) + c | 0;\n      x[0] = a + x[0] | 0;\n      x[1] = b + x[1] | 0;\n      x[2] = c + x[2] | 0;\n      x[3] = d + x[3] | 0;\n    }\n    function md5blk(s) {\n      var md5blks = [], i;\n      for (i = 0; i < 64; i += 4) {\n        md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n      }\n      return md5blks;\n    }\n    function md5blk_array(a) {\n      var md5blks = [], i;\n      for (i = 0; i < 64; i += 4) {\n        md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n      }\n      return md5blks;\n    }\n    function md51(s) {\n      var n = s.length, state = [ 1732584193, -271733879, -1732584194, 271733878 ], i, length, tail, tmp, lo, hi;\n      for (i = 64; i <= n; i += 64) {\n        md5cycle(state, md5blk(s.substring(i - 64, i)));\n      }\n      s = s.substring(i - 64);\n      length = s.length;\n      tail = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n      for (i = 0; i < length; i += 1) {\n        tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n      }\n      tail[i >> 2] |= 128 << (i % 4 << 3);\n      if (i > 55) {\n        md5cycle(state, tail);\n        for (i = 0; i < 16; i += 1) {\n          tail[i] = 0;\n        }\n      }\n      tmp = n * 8;\n      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n      lo = parseInt(tmp[2], 16);\n      hi = parseInt(tmp[1], 16) || 0;\n      tail[14] = lo;\n      tail[15] = hi;\n      md5cycle(state, tail);\n      return state;\n    }\n    function md51_array(a) {\n      var n = a.length, state = [ 1732584193, -271733879, -1732584194, 271733878 ], i, length, tail, tmp, lo, hi;\n      for (i = 64; i <= n; i += 64) {\n        md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n      }\n      a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);\n      length = a.length;\n      tail = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n      for (i = 0; i < length; i += 1) {\n        tail[i >> 2] |= a[i] << (i % 4 << 3);\n      }\n      tail[i >> 2] |= 128 << (i % 4 << 3);\n      if (i > 55) {\n        md5cycle(state, tail);\n        for (i = 0; i < 16; i += 1) {\n          tail[i] = 0;\n        }\n      }\n      tmp = n * 8;\n      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n      lo = parseInt(tmp[2], 16);\n      hi = parseInt(tmp[1], 16) || 0;\n      tail[14] = lo;\n      tail[15] = hi;\n      md5cycle(state, tail);\n      return state;\n    }\n    function rhex(n) {\n      var s = \"\", j;\n      for (j = 0; j < 4; j += 1) {\n        s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];\n      }\n      return s;\n    }\n    function hex(x) {\n      var i;\n      for (i = 0; i < x.length; i += 1) {\n        x[i] = rhex(x[i]);\n      }\n      return x.join(\"\");\n    }\n    if (hex(md51(\"hello\")) !== \"5d41402abc4b2a76b9719d911017c592\") ;\n    if (typeof ArrayBuffer !== \"undefined\" && !ArrayBuffer.prototype.slice) {\n      (function() {\n        function clamp(val, length) {\n          val = val | 0 || 0;\n          if (val < 0) {\n            return Math.max(val + length, 0);\n          }\n          return Math.min(val, length);\n        }\n        ArrayBuffer.prototype.slice = function(from, to) {\n          var length = this.byteLength, begin = clamp(from, length), end = length, num, target, targetArray, sourceArray;\n          if (to !== undefined$1) {\n            end = clamp(to, length);\n          }\n          if (begin > end) {\n            return new ArrayBuffer(0);\n          }\n          num = end - begin;\n          target = new ArrayBuffer(num);\n          targetArray = new Uint8Array(target);\n          sourceArray = new Uint8Array(this, begin, num);\n          targetArray.set(sourceArray);\n          return target;\n        };\n      })();\n    }\n    function toUtf8(str) {\n      if (/[\\u0080-\\uFFFF]/.test(str)) {\n        str = unescape(encodeURIComponent(str));\n      }\n      return str;\n    }\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n      var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i;\n      for (i = 0; i < length; i += 1) {\n        arr[i] = str.charCodeAt(i);\n      }\n      return returnUInt8Array ? arr : buff;\n    }\n    function arrayBuffer2Utf8Str(buff) {\n      return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n      var result = new Uint8Array(first.byteLength + second.byteLength);\n      result.set(new Uint8Array(first));\n      result.set(new Uint8Array(second), first.byteLength);\n      return returnUInt8Array ? result : result.buffer;\n    }\n    function hexToBinaryString(hex) {\n      var bytes = [], length = hex.length, x;\n      for (x = 0; x < length - 1; x += 2) {\n        bytes.push(parseInt(hex.substr(x, 2), 16));\n      }\n      return String.fromCharCode.apply(String, bytes);\n    }\n    function SparkMD5() {\n      this.reset();\n    }\n    SparkMD5.prototype.append = function(str) {\n      this.appendBinary(toUtf8(str));\n      return this;\n    };\n    SparkMD5.prototype.appendBinary = function(contents) {\n      this._buff += contents;\n      this._length += contents.length;\n      var length = this._buff.length, i;\n      for (i = 64; i <= length; i += 64) {\n        md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n      }\n      this._buff = this._buff.substring(i - 64);\n      return this;\n    };\n    SparkMD5.prototype.end = function(raw) {\n      var buff = this._buff, length = buff.length, i, tail = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], ret;\n      for (i = 0; i < length; i += 1) {\n        tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);\n      }\n      this._finish(tail, length);\n      ret = hex(this._hash);\n      if (raw) {\n        ret = hexToBinaryString(ret);\n      }\n      this.reset();\n      return ret;\n    };\n    SparkMD5.prototype.reset = function() {\n      this._buff = \"\";\n      this._length = 0;\n      this._hash = [ 1732584193, -271733879, -1732584194, 271733878 ];\n      return this;\n    };\n    SparkMD5.prototype.getState = function() {\n      return {\n        buff: this._buff,\n        length: this._length,\n        hash: this._hash.slice()\n      };\n    };\n    SparkMD5.prototype.setState = function(state) {\n      this._buff = state.buff;\n      this._length = state.length;\n      this._hash = state.hash;\n      return this;\n    };\n    SparkMD5.prototype.destroy = function() {\n      delete this._hash;\n      delete this._buff;\n      delete this._length;\n    };\n    SparkMD5.prototype._finish = function(tail, length) {\n      var i = length, tmp, lo, hi;\n      tail[i >> 2] |= 128 << (i % 4 << 3);\n      if (i > 55) {\n        md5cycle(this._hash, tail);\n        for (i = 0; i < 16; i += 1) {\n          tail[i] = 0;\n        }\n      }\n      tmp = this._length * 8;\n      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n      lo = parseInt(tmp[2], 16);\n      hi = parseInt(tmp[1], 16) || 0;\n      tail[14] = lo;\n      tail[15] = hi;\n      md5cycle(this._hash, tail);\n    };\n    SparkMD5.hash = function(str, raw) {\n      return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n    SparkMD5.hashBinary = function(content, raw) {\n      var hash = md51(content), ret = hex(hash);\n      return raw ? hexToBinaryString(ret) : ret;\n    };\n    SparkMD5.ArrayBuffer = function() {\n      this.reset();\n    };\n    SparkMD5.ArrayBuffer.prototype.append = function(arr) {\n      var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i;\n      this._length += arr.byteLength;\n      for (i = 64; i <= length; i += 64) {\n        md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n      }\n      this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n      return this;\n    };\n    SparkMD5.ArrayBuffer.prototype.end = function(raw) {\n      var buff = this._buff, length = buff.length, tail = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], i, ret;\n      for (i = 0; i < length; i += 1) {\n        tail[i >> 2] |= buff[i] << (i % 4 << 3);\n      }\n      this._finish(tail, length);\n      ret = hex(this._hash);\n      if (raw) {\n        ret = hexToBinaryString(ret);\n      }\n      this.reset();\n      return ret;\n    };\n    SparkMD5.ArrayBuffer.prototype.reset = function() {\n      this._buff = new Uint8Array(0);\n      this._length = 0;\n      this._hash = [ 1732584193, -271733879, -1732584194, 271733878 ];\n      return this;\n    };\n    SparkMD5.ArrayBuffer.prototype.getState = function() {\n      var state = SparkMD5.prototype.getState.call(this);\n      state.buff = arrayBuffer2Utf8Str(state.buff);\n      return state;\n    };\n    SparkMD5.ArrayBuffer.prototype.setState = function(state) {\n      state.buff = utf8Str2ArrayBuffer(state.buff, true);\n      return SparkMD5.prototype.setState.call(this, state);\n    };\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n    SparkMD5.ArrayBuffer.hash = function(arr, raw) {\n      var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);\n      return raw ? hexToBinaryString(ret) : ret;\n    };\n    return SparkMD5;\n  }));\n})(sparkMd5);\n\nvar SparkMD5 = sparkMd5.exports;\n\nconst fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;\n\nclass FileChecksum {\n  static create(file, callback) {\n    const instance = new FileChecksum(file);\n    instance.create(callback);\n  }\n  constructor(file) {\n    this.file = file;\n    this.chunkSize = 2097152;\n    this.chunkCount = Math.ceil(this.file.size / this.chunkSize);\n    this.chunkIndex = 0;\n  }\n  create(callback) {\n    this.callback = callback;\n    this.md5Buffer = new SparkMD5.ArrayBuffer;\n    this.fileReader = new FileReader;\n    this.fileReader.addEventListener(\"load\", (event => this.fileReaderDidLoad(event)));\n    this.fileReader.addEventListener(\"error\", (event => this.fileReaderDidError(event)));\n    this.readNextChunk();\n  }\n  fileReaderDidLoad(event) {\n    this.md5Buffer.append(event.target.result);\n    if (!this.readNextChunk()) {\n      const binaryDigest = this.md5Buffer.end(true);\n      const base64digest = btoa(binaryDigest);\n      this.callback(null, base64digest);\n    }\n  }\n  fileReaderDidError(event) {\n    this.callback(`Error reading ${this.file.name}`);\n  }\n  readNextChunk() {\n    if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {\n      const start = this.chunkIndex * this.chunkSize;\n      const end = Math.min(start + this.chunkSize, this.file.size);\n      const bytes = fileSlice.call(this.file, start, end);\n      this.fileReader.readAsArrayBuffer(bytes);\n      this.chunkIndex++;\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nfunction getMetaValue(name) {\n  const element = findElement(document.head, `meta[name=\"${name}\"]`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\n\nfunction findElements(root, selector) {\n  if (typeof root == \"string\") {\n    selector = root;\n    root = document;\n  }\n  const elements = root.querySelectorAll(selector);\n  return toArray(elements);\n}\n\nfunction findElement(root, selector) {\n  if (typeof root == \"string\") {\n    selector = root;\n    root = document;\n  }\n  return root.querySelector(selector);\n}\n\nfunction dispatchEvent(element, type, eventInit = {}) {\n  const {disabled: disabled} = element;\n  const {bubbles: bubbles, cancelable: cancelable, detail: detail} = eventInit;\n  const event = document.createEvent(\"Event\");\n  event.initEvent(type, bubbles || true, cancelable || true);\n  event.detail = detail || {};\n  try {\n    element.disabled = false;\n    element.dispatchEvent(event);\n  } finally {\n    element.disabled = disabled;\n  }\n  return event;\n}\n\nfunction toArray(value) {\n  if (Array.isArray(value)) {\n    return value;\n  } else if (Array.from) {\n    return Array.from(value);\n  } else {\n    return [].slice.call(value);\n  }\n}\n\nclass BlobRecord {\n  constructor(file, checksum, url, customHeaders = {}) {\n    this.file = file;\n    this.attributes = {\n      filename: file.name,\n      content_type: file.type || \"application/octet-stream\",\n      byte_size: file.size,\n      checksum: checksum\n    };\n    this.xhr = new XMLHttpRequest;\n    this.xhr.open(\"POST\", url, true);\n    this.xhr.responseType = \"json\";\n    this.xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n    this.xhr.setRequestHeader(\"Accept\", \"application/json\");\n    this.xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n    Object.keys(customHeaders).forEach((headerKey => {\n      this.xhr.setRequestHeader(headerKey, customHeaders[headerKey]);\n    }));\n    const csrfToken = getMetaValue(\"csrf-token\");\n    if (csrfToken != undefined) {\n      this.xhr.setRequestHeader(\"X-CSRF-Token\", csrfToken);\n    }\n    this.xhr.addEventListener(\"load\", (event => this.requestDidLoad(event)));\n    this.xhr.addEventListener(\"error\", (event => this.requestDidError(event)));\n  }\n  get status() {\n    return this.xhr.status;\n  }\n  get response() {\n    const {responseType: responseType, response: response} = this.xhr;\n    if (responseType == \"json\") {\n      return response;\n    } else {\n      return JSON.parse(response);\n    }\n  }\n  create(callback) {\n    this.callback = callback;\n    this.xhr.send(JSON.stringify({\n      blob: this.attributes\n    }));\n  }\n  requestDidLoad(event) {\n    if (this.status >= 200 && this.status < 300) {\n      const {response: response} = this;\n      const {direct_upload: direct_upload} = response;\n      delete response.direct_upload;\n      this.attributes = response;\n      this.directUploadData = direct_upload;\n      this.callback(null, this.toJSON());\n    } else {\n      this.requestDidError(event);\n    }\n  }\n  requestDidError(event) {\n    this.callback(`Error creating Blob for \"${this.file.name}\". Status: ${this.status}`);\n  }\n  toJSON() {\n    const result = {};\n    for (const key in this.attributes) {\n      result[key] = this.attributes[key];\n    }\n    return result;\n  }\n}\n\nclass BlobUpload {\n  constructor(blob) {\n    this.blob = blob;\n    this.file = blob.file;\n    const {url: url, headers: headers} = blob.directUploadData;\n    this.xhr = new XMLHttpRequest;\n    this.xhr.open(\"PUT\", url, true);\n    this.xhr.responseType = \"text\";\n    for (const key in headers) {\n      this.xhr.setRequestHeader(key, headers[key]);\n    }\n    this.xhr.addEventListener(\"load\", (event => this.requestDidLoad(event)));\n    this.xhr.addEventListener(\"error\", (event => this.requestDidError(event)));\n  }\n  create(callback) {\n    this.callback = callback;\n    this.xhr.send(this.file.slice());\n  }\n  requestDidLoad(event) {\n    const {status: status, response: response} = this.xhr;\n    if (status >= 200 && status < 300) {\n      this.callback(null, response);\n    } else {\n      this.requestDidError(event);\n    }\n  }\n  requestDidError(event) {\n    this.callback(`Error storing \"${this.file.name}\". Status: ${this.xhr.status}`);\n  }\n}\n\nlet id = 0;\n\nclass DirectUpload {\n  constructor(file, url, delegate, customHeaders = {}) {\n    this.id = ++id;\n    this.file = file;\n    this.url = url;\n    this.delegate = delegate;\n    this.customHeaders = customHeaders;\n  }\n  create(callback) {\n    FileChecksum.create(this.file, ((error, checksum) => {\n      if (error) {\n        callback(error);\n        return;\n      }\n      const blob = new BlobRecord(this.file, checksum, this.url, this.customHeaders);\n      notify(this.delegate, \"directUploadWillCreateBlobWithXHR\", blob.xhr);\n      blob.create((error => {\n        if (error) {\n          callback(error);\n        } else {\n          const upload = new BlobUpload(blob);\n          notify(this.delegate, \"directUploadWillStoreFileWithXHR\", upload.xhr);\n          upload.create((error => {\n            if (error) {\n              callback(error);\n            } else {\n              callback(null, blob.toJSON());\n            }\n          }));\n        }\n      }));\n    }));\n  }\n}\n\nfunction notify(object, methodName, ...messages) {\n  if (object && typeof object[methodName] == \"function\") {\n    return object[methodName](...messages);\n  }\n}\n\nclass DirectUploadController {\n  constructor(input, file) {\n    this.input = input;\n    this.file = file;\n    this.directUpload = new DirectUpload(this.file, this.url, this);\n    this.dispatch(\"initialize\");\n  }\n  start(callback) {\n    const hiddenInput = document.createElement(\"input\");\n    hiddenInput.type = \"hidden\";\n    hiddenInput.name = this.input.name;\n    this.input.insertAdjacentElement(\"beforebegin\", hiddenInput);\n    this.dispatch(\"start\");\n    this.directUpload.create(((error, attributes) => {\n      if (error) {\n        hiddenInput.parentNode.removeChild(hiddenInput);\n        this.dispatchError(error);\n      } else {\n        hiddenInput.value = attributes.signed_id;\n      }\n      this.dispatch(\"end\");\n      callback(error);\n    }));\n  }\n  uploadRequestDidProgress(event) {\n    const progress = event.loaded / event.total * 100;\n    if (progress) {\n      this.dispatch(\"progress\", {\n        progress: progress\n      });\n    }\n  }\n  get url() {\n    return this.input.getAttribute(\"data-direct-upload-url\");\n  }\n  dispatch(name, detail = {}) {\n    detail.file = this.file;\n    detail.id = this.directUpload.id;\n    return dispatchEvent(this.input, `direct-upload:${name}`, {\n      detail: detail\n    });\n  }\n  dispatchError(error) {\n    const event = this.dispatch(\"error\", {\n      error: error\n    });\n    if (!event.defaultPrevented) {\n      alert(error);\n    }\n  }\n  directUploadWillCreateBlobWithXHR(xhr) {\n    this.dispatch(\"before-blob-request\", {\n      xhr: xhr\n    });\n  }\n  directUploadWillStoreFileWithXHR(xhr) {\n    this.dispatch(\"before-storage-request\", {\n      xhr: xhr\n    });\n    xhr.upload.addEventListener(\"progress\", (event => this.uploadRequestDidProgress(event)));\n  }\n}\n\nconst inputSelector = \"input[type=file][data-direct-upload-url]:not([disabled])\";\n\nclass DirectUploadsController {\n  constructor(form) {\n    this.form = form;\n    this.inputs = findElements(form, inputSelector).filter((input => input.files.length));\n  }\n  start(callback) {\n    const controllers = this.createDirectUploadControllers();\n    const startNextController = () => {\n      const controller = controllers.shift();\n      if (controller) {\n        controller.start((error => {\n          if (error) {\n            callback(error);\n            this.dispatch(\"end\");\n          } else {\n            startNextController();\n          }\n        }));\n      } else {\n        callback();\n        this.dispatch(\"end\");\n      }\n    };\n    this.dispatch(\"start\");\n    startNextController();\n  }\n  createDirectUploadControllers() {\n    const controllers = [];\n    this.inputs.forEach((input => {\n      toArray(input.files).forEach((file => {\n        const controller = new DirectUploadController(input, file);\n        controllers.push(controller);\n      }));\n    }));\n    return controllers;\n  }\n  dispatch(name, detail = {}) {\n    return dispatchEvent(this.form, `direct-uploads:${name}`, {\n      detail: detail\n    });\n  }\n}\n\nconst processingAttribute = \"data-direct-uploads-processing\";\n\nconst submitButtonsByForm = new WeakMap;\n\nlet started = false;\n\nfunction start() {\n  if (!started) {\n    started = true;\n    document.addEventListener(\"click\", didClick, true);\n    document.addEventListener(\"submit\", didSubmitForm, true);\n    document.addEventListener(\"ajax:before\", didSubmitRemoteElement);\n  }\n}\n\nfunction didClick(event) {\n  const button = event.target.closest(\"button, input\");\n  if (button && button.type === \"submit\" && button.form) {\n    submitButtonsByForm.set(button.form, button);\n  }\n}\n\nfunction didSubmitForm(event) {\n  handleFormSubmissionEvent(event);\n}\n\nfunction didSubmitRemoteElement(event) {\n  if (event.target.tagName == \"FORM\") {\n    handleFormSubmissionEvent(event);\n  }\n}\n\nfunction handleFormSubmissionEvent(event) {\n  const form = event.target;\n  if (form.hasAttribute(processingAttribute)) {\n    event.preventDefault();\n    return;\n  }\n  const controller = new DirectUploadsController(form);\n  const {inputs: inputs} = controller;\n  if (inputs.length) {\n    event.preventDefault();\n    form.setAttribute(processingAttribute, \"\");\n    inputs.forEach(disable);\n    controller.start((error => {\n      form.removeAttribute(processingAttribute);\n      if (error) {\n        inputs.forEach(enable);\n      } else {\n        submitForm(form);\n      }\n    }));\n  }\n}\n\nfunction submitForm(form) {\n  let button = submitButtonsByForm.get(form) || findElement(form, \"input[type=submit], button[type=submit]\");\n  if (button) {\n    const {disabled: disabled} = button;\n    button.disabled = false;\n    button.focus();\n    button.click();\n    button.disabled = disabled;\n  } else {\n    button = document.createElement(\"input\");\n    button.type = \"submit\";\n    button.style.display = \"none\";\n    form.appendChild(button);\n    button.click();\n    form.removeChild(button);\n  }\n  submitButtonsByForm.delete(form);\n}\n\nfunction disable(input) {\n  input.disabled = true;\n}\n\nfunction enable(input) {\n  input.disabled = false;\n}\n\nfunction autostart() {\n  if (window.ActiveStorage) {\n    start();\n  }\n}\n\nsetTimeout(autostart, 1);\n\nexport { DirectUpload, DirectUploadController, DirectUploadsController, start };\n", "!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",c=\"month\",f=\"quarter\",h=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=\"$isDayjsObject\",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=f+\"Date\",n[d]=f+\"Date\",n[c]=f+\"Month\",n[h]=f+\"FullYear\",n[u]=f+\"Hours\",n[s]=f+\"Minutes\",n[i]=f+\"Seconds\",n[r]=f+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,\"0\")},$=f||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case\"YY\":return String(e.$y).slice(-2);case\"YYYY\":return b.s(e.$y,4,\"0\");case\"M\":return a+1;case\"MM\":return b.s(a+1,2,\"0\");case\"MMM\":return h(n.monthsShort,a,c,3);case\"MMMM\":return h(c,a);case\"D\":return e.$D;case\"DD\":return b.s(e.$D,2,\"0\");case\"d\":return String(e.$W);case\"dd\":return h(n.weekdaysMin,e.$W,o,2);case\"ddd\":return h(n.weekdaysShort,e.$W,o,3);case\"dddd\":return o[e.$W];case\"H\":return String(s);case\"HH\":return b.s(s,2,\"0\");case\"h\":return d(1);case\"hh\":return d(2);case\"a\":return $(s,u,!0);case\"A\":return $(s,u,!1);case\"m\":return String(u);case\"mm\":return b.s(u,2,\"0\");case\"s\":return String(e.$s);case\"ss\":return b.s(e.$s,2,\"0\");case\"SSS\":return b.s(e.$ms,3,\"0\");case\"Z\":return i}return null}(t)||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",c],[\"$y\",h],[\"$D\",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));", "/**\n * LesliChart\n *\n * Small wrapper around Chart.js to standardize:\n * - Turbo-safe rendering\n * - Apex-like API\n * - Compact (sparkline) mode\n * - Event emission\n */\n\nclass LesliChart {\n\n    static initialized = false;\n\n    static init() {\n\n        if (this.initialized) return;\n\n        this.initialized = true;\n\n        // Line chart defaults\n        ChartJs.defaults.elements.line.tension = 0.4;\n        ChartJs.defaults.elements.line.borderCapStyle = \"round\";\n\n        // Bar chart defaults\n        ChartJs.defaults.elements.bar.borderRadius = 6;\n        ChartJs.defaults.elements.bar.borderSkipped = false;\n\n        // Global font defaults\n        ChartJs.defaults.font.family = \"'Source Sans 3', system-ui, sans-serif\";\n        ChartJs.defaults.font.size = 14;\n        \n        // Global color defaults\n        ChartJs.defaults.color = \"#4a4a4a\";\n    }\n\n    /**\n     * Render a chart inside a container\n     *\n     * @param {Object} config\n     * @param {String} config.id        DOM id\n     * @param {String} config.type      \"bar\" | \"line\"\n     * @param {Array}  config.series    Apex-style series\n     * @param {Array}  config.labels    X-axis labels\n     * @param {Boolean} config.compact  Sparkline mode\n     */\n    constructor(config) {\n\n        LesliChart.init();\n\n        // Find the chart container element\n        const container = document.getElementById(config.id);\n\n        // If the element does not exist, exit early\n        if (!container) return;\n\n        const hasMultipleDatasets = config.datasets.length > 1;\n\n        // Clear any previous chart instance.\n        // Important when Turbo re-renders the page.\n        container.innerHTML = \"\";\n\n        // Chart.js requires a <canvas> element to render charts.\n        // We dynamically create it so Turbo reloads remain clean.\n        const canvas = document.createElement(\"canvas\");\n\n        // Attach the canvas to the container\n        container.appendChild(canvas);\n\n        // Get the 2D drawing context from the canvas\n        const ctx = canvas.getContext(\"2d\");\n\n        // Main Chart.js configuration object\n        const chartConfig = {\n\n            // Chart type: \"bar\" or \"line\"\n            type: config.type,\n\n            // Chart data definition\n            data: {\n\n                // X-axis labels\n                labels: config.labels,\n\n                // Series data\n                datasets: config.datasets\n            },\n\n            // Chart behavior and appearance options\n            options: {\n\n                layout: {\n                    padding: {\n                        top: 20,\n                        left: 20,\n                        right: 20,\n                        bottom: 20\n                    }\n                },\n\n                // Automatically resize with container\n                responsive: true,\n\n                // Allow manual height control via CSS\n                maintainAspectRatio: false,\n\n                // Plugin configuration\n                plugins: {\n\n                    // Legend configuration\n                    legend: {\n                        display: hasMultipleDatasets,\n                        position: \"top\",\n                        align: \"center\"\n                    },\n\n                    // Tooltip behavior\n                    tooltip: {\n                        enabled: true\n                    },\n                },\n\n                // Axis configuration\n                scales: {\n                    x: {\n\n                        // Show X axis\n                        display: true,\n\n                        // X-axis label styling\n                        ticks: {\n                            maxRotation: 65,\n                            font: { size: 15 }\n                        },\n\n                        // Hide vertical grid lines\n                        grid: { \n                            display: false \n                        }\n                    },\n                    y: {\n\n                        // Show Y axis\n                        display: true,\n\n                        // Hide horizontal grid lines\n                        grid: {\n                            display: false\n                        }\n                    }\n                },\n\n                // Click handler for points/bars.\n                onClick: (event, elements) => {\n\n                    // If nothing was clicked, do nothing\n                    if (!elements.length) return;\n\n                    // Get the first clicked element\n                    const element = elements[0];\n\n                    // Emit a custom event (Rails / Stimulus / ViewComponent)\n                    emit(\"markerClick\", {\n                        seriesIndex: element.datasetIndex,\n                        dataPointIndex: element.index\n                    });\n                }\n            }\n        };\n\n        // Compact (sparkline-style) overrides\n        // Used for dashboards, cards, or tight layouts\n        if (config.compact) {\n\n            // Hide legend in compact mode\n            chartConfig.options.plugins.legend.display = false;\n\n            // Hide axes for sparkline effect\n            chartConfig.options.scales.x.display = false;\n            chartConfig.options.scales.y.display = false;\n\n            chartConfig.options.layout.padding.top = 8\n            chartConfig.options.layout.padding.left = 0\n            chartConfig.options.layout.padding.right = 0\n            chartConfig.options.layout.padding.bottom = 6\n            \n\n            if (config.type === \"line\") {\n\n                // Adjust padding for better vertical alignment\n                chartConfig.options.layout.padding.top = 10\n                chartConfig.options.layout.padding.bottom = 6\n            }\n        }\n\n        // Create and render the Chart.js instance\n        new ChartJs(ctx, chartConfig);\n    }\n};\n\nmodule.exports = LesliChart\n", "!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",f=\"month\",h=\"quarter\",c=\"year\",d=\"date\",$=\"Invalid Date\",l=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\")},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},D=\"en\",v={};v[D]=M;var p=function(t){return t instanceof _},S=function(t,e,n){var r;if(!t)return D;if(\"string\"==typeof t)v[t]&&(r=t),e&&(v[t]=e,r=t);else{var i=t.name;v[i]=t,r=i}return!n&&r&&(D=r),r||!n&&D},w=function(t,e){if(p(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g=\"set\"+(this.$u?\"UTC\":\"\");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var D=this.$locale().weekStart||0,v=(y<D?y+7:y)-D;return $(r?m-v:m+(6-v),M);case a:case d:return l(g+\"Hours\",0);case u:return l(g+\"Minutes\",1);case s:return l(g+\"Seconds\",2);case i:return l(g+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h=\"set\"+(this.$u?\"UTC\":\"\"),$=(n={},n[a]=h+\"Date\",n[d]=h+\"Date\",n[f]=h+\"Month\",n[c]=h+\"FullYear\",n[u]=h+\"Hours\",n[s]=h+\"Minutes\",n[i]=h+\"Seconds\",n[r]=h+\"Milliseconds\",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].substr(0,s)},c=function(t){return O.s(s%12||12,t,\"0\")},d=n.meridiem||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,\"0\"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,\"0\"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,\"0\"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,\"0\"),s:String(this.$s),ss:O.s(this.$s,2,\"0\"),SSS:O.s(this.$ms,3,\"0\"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,D=O.m(this,M);return D=(l={},l[c]=D/12,l[f]=D,l[h]=D/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?D:O.a(D)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return v[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),b=_.prototype;return w.prototype=b,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",f],[\"$y\",c],[\"$D\",d]].forEach((function(t){b[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=v[D],w.Ls=v,w.p={},w}));", "/*\nLesli\n\nCopyright (c) 2021, Lesli Technologies, S. A.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.\n\nLesli JS - JavaScript utilities for JavaScript applications\n\nPowered by LesliTech\nBuilding a better future, one line of code at a time.\n\n@contact  <hello@lesli.tech>\n@website  <https://lesli.tech>\n@license  GPLv3 http://www.gnu.org/licenses/gpl-3.0.en.html\n\n// \u00B7 ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~\n// \u00B7 \n*/\n\n\nvar dayjs = require(\"dayjs\")\n\n\n// \u00B7 \nclass Utils {\n\n    // \u00B7 \n    buildDate() {\n\n        return dayjs().format(\"MM/DD HH:mm\").toString()\n\n    }\n\n    // \u00B7 \n    buildMessage(message, module, level) {\n\n        // desire output format\n        // [2010-01-17 11:43:37] [ERROR] (cheese module) - Cheese is too ripe!\n        // [2010-01-17 11:43:37] [FATAL] (cheese module) - Cheese was breeding ground for listeria.\n        let newMessage = `[${this.buildDate()}] [${level.toUpperCase()}]`\n\n        if (module) {\n            newMessage += ` (${module})`\n        }\n\n        newMessage = newMessage.concat(\" - \").concat(message)\n\n        return newMessage\n\n    }\n\n    // \u00B7 \n    stylesForBrowser(type) {\n\n        let lineheight=\"1.5;\"\n        let fontsize=\"14px;\"\n        let padding=\"2px;\"\n\n        let info = \"background-color:#3498db;color:#ffffff;\"\n        let warn = \"background-color:#f1c40f;color:#000000;\"\n        let error = \"background-color:#e74c3c;color:#ffffff;\"\n        let fatal = \"background-color:#c0392b;color:#fff394;\"\n        let success = \"background-color:##48c774;color:#000000;\"\n\n        let style = \"\"\n\n        switch (type) {\n            case \"info\": style = info; break;\n            case \"warn\": style = warn; break;\n            case \"error\": style = error; break;\n            case \"fatal\": style = fatal; break;\n            case \"success\": style = success; break;\n        }\n\n        style += \"padding:\" + padding\n        style += \"font-size:\" + fontsize\n        style += \"line-height:\" + lineheight\n\n        return style\n\n    }\n\n    // \u00B7 \n    print_r (data, level = 1) {\n\n        let isArray = Array.isArray(data);\n\n        let comma = \",\"\n        let string = \"\"\n        let padding_key = \"\"\n        let padding_prop = \"\"\n        let newline = \"\\n\"\n\n        for(let i=0;i<(4*level);i++) {\n            padding_prop += \" \"\n        }\n\n        if (level > 1) {\n            padding_key = padding_prop.slice(0, padding_prop.length - 4)\n        }\n\n        if (typeof data == \"object\" && !Array.isArray(data)) {\n\n            string += padding_key + \"{\" + newline\n\n            for(let property in data) {\n\n                if (typeof data[property] == \"object\") {\n                    string += padding_prop + property + \": \" + this.print_r(data[property], level+1) + comma + newline\n                } else {\n                    string += padding_prop + property + \": \" + data[property] + comma + newline\n                }\n                \n            }\n\n            string += padding_key + \"}\"\n\n        } \n\n        if (typeof data == \"object\" && Array.isArray(data)) {\n\n            string += \"[\" + newline\n\n            for(let property in data) {\n\n                if (typeof data[property] == \"object\") {\n                    string += this.print_r(data[property], level+1) + comma + newline\n                } else {\n                    string += padding_prop + data[property] + newline\n                }\n\n            }\n\n            string += padding_key + \"]\"\n\n        }\n\n        // trying to remove last comma if is the end of object or array\n        //string = string.replace(/,\\n/g, \"0\")\n\n        return string\n\n    }\n\n}\n\nmodule.exports = new Utils\n", "/*\nLesli\n\nCopyright (c) 2020, Lesli Technologies, S. A.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.\n\nLesli JS - JavaScript utilities for JavaScript applications\n\nPowered by LesliTech\nBuilding a better future, one line of code at a time.\n\n@contact  <hello@lesli.tech>\n@website  <https://lesli.tech>\n@license  GPLv3 http://www.gnu.org/licenses/gpl-3.0.en.html\n\n// \u00B7 ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~\n// \u00B7 \n*/\n\n\n// \u00B7 Loading node modules\nlet utils = require(\"./utils\")\n\n\n// \u00B7 \nclass BrowserDebugService {\n\n    build(message, modulo, level) {\n        return utils.buildMessage(message, modulo, level)\n    }\n\n    // \u00B7 write information message\n    log(message, modulo = null) {\n        console.log(utils.buildMessage(message, modulo, \"log\"))\n    }\n\n    // \u00B7 write information message\n    msg(message, modulo = null) {\n        console.log(utils.buildMessage(message, modulo, \"msg\"))\n    }\n\n    // \u00B7 write informatie message\n    info(message, modulo = null) {\n        console.info(\"%c\"+utils.buildMessage(message, modulo, \"info\"), utils.stylesForBrowser(\"info\"))\n    }\n\n    // \u00B7 write success message\n    success(message, modulo = null) {\n        console.log(utils.buildMessage(message, modulo, \"msg\"))\n    }\n\n    // \u00B7 write warning message\n    warn(message, modulo = null) {\n        console.warn(\"%c\"+utils.buildMessage(message, modulo, \"warn\"), utils.stylesForBrowser(\"warn\"))\n    }\n\n    // \u00B7 write warning message\n    error(message, modulo = null) {\n        console.error(\"%c\"+utils.buildMessage(message, modulo, \"error\"), utils.stylesForBrowser(\"error\"))\n    }\n\n    // \u00B7 write warning message\n    fatal(message, modulo = null) {\n        console.error(\"%c\"+utils.buildMessage(message, modulo, \"error\"), utils.stylesForBrowser(\"fatal\"))\n    }\n\n    message(title, messages, more_information=null) {\n\n        console.log(\"%c\"+title, \"color:#3689e6;font-size:35px;font-weight:600;line-height:1;\")\n\n        if (typeof messages === \"string\") messages = [ messages ]\n\n        console.log(\"%c\"+messages.join(\"\\n\"), \"background-color:#ffffff;color:#1a1a1a;font-size:18px;font-weight:400;line-height:1.1;\")    \n\n        if (more_information) {\n            console.log(\"%c\"+more_information, \"background-color:#ffffff;color:#1a1a1a;font-size:14px;font-weight:400;line-height:2;\")\n        }\n        \n    }\n\n    lesli_message_warning(title=\"LESLI\", support=\"For mor information contact your system administrator\") {\n        this.message(title, [\n            \"This is a browser feature intended for developers.\",\n            \"For security reasons, DO NOT copy or paste any information, text, or code here.\"\n        ], support)\n    }\n\n}\n\n// \u00B7 \nmodule.exports = new BrowserDebugService()\n", "/*\nLesli\n\nCopyright (c) 2021, Lesli Technologies, S. A.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.\n\nLesli JS - JavaScript utilities for JavaScript applications\n\nPowered by LesliTech\nBuilding a better future, one line of code at a time.\n\n@contact  <hello@lesli.tech>\n@website  <https://lesli.tech>\n@license  GPLv3 http://www.gnu.org/licenses/gpl-3.0.en.html\n\n// \u00B7 ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~\n// \u00B7 \n*/\n\nmodule.exports = require(\"../src/debug/browser\")\n", "/*!\nTurbo 8.0.23\nCopyright \u00A9 2026 37signals LLC\n */\nconst FrameLoadingStyle = {\n  eager: \"eager\",\n  lazy: \"lazy\"\n};\n\n/**\n * Contains a fragment of HTML which is updated based on navigation within\n * it (e.g. via links or form submissions).\n *\n * @customElement turbo-frame\n * @example\n *   <turbo-frame id=\"messages\">\n *     <a href=\"/messages/expanded\">\n *       Show all expanded messages in this frame.\n *     </a>\n *\n *     <form action=\"/messages\">\n *       Show response from this form within this frame.\n *     </form>\n *   </turbo-frame>\n */\nclass FrameElement extends HTMLElement {\n  static delegateConstructor = undefined\n\n  loaded = Promise.resolve()\n\n  static get observedAttributes() {\n    return [\"disabled\", \"loading\", \"src\"]\n  }\n\n  constructor() {\n    super();\n    this.delegate = new FrameElement.delegateConstructor(this);\n  }\n\n  connectedCallback() {\n    this.delegate.connect();\n  }\n\n  disconnectedCallback() {\n    this.delegate.disconnect();\n  }\n\n  reload() {\n    return this.delegate.sourceURLReloaded()\n  }\n\n  attributeChangedCallback(name) {\n    if (name == \"loading\") {\n      this.delegate.loadingStyleChanged();\n    } else if (name == \"src\") {\n      this.delegate.sourceURLChanged();\n    } else if (name == \"disabled\") {\n      this.delegate.disabledChanged();\n    }\n  }\n\n  /**\n   * Gets the URL to lazily load source HTML from\n   */\n  get src() {\n    return this.getAttribute(\"src\")\n  }\n\n  /**\n   * Sets the URL to lazily load source HTML from\n   */\n  set src(value) {\n    if (value) {\n      this.setAttribute(\"src\", value);\n    } else {\n      this.removeAttribute(\"src\");\n    }\n  }\n\n  /**\n   * Gets the refresh mode for the frame.\n   */\n  get refresh() {\n    return this.getAttribute(\"refresh\")\n  }\n\n  /**\n   * Sets the refresh mode for the frame.\n   */\n  set refresh(value) {\n    if (value) {\n      this.setAttribute(\"refresh\", value);\n    } else {\n      this.removeAttribute(\"refresh\");\n    }\n  }\n\n  get shouldReloadWithMorph() {\n    return this.src && this.refresh === \"morph\"\n  }\n\n  /**\n   * Determines if the element is loading\n   */\n  get loading() {\n    return frameLoadingStyleFromString(this.getAttribute(\"loading\") || \"\")\n  }\n\n  /**\n   * Sets the value of if the element is loading\n   */\n  set loading(value) {\n    if (value) {\n      this.setAttribute(\"loading\", value);\n    } else {\n      this.removeAttribute(\"loading\");\n    }\n  }\n\n  /**\n   * Gets the disabled state of the frame.\n   *\n   * If disabled, no requests will be intercepted by the frame.\n   */\n  get disabled() {\n    return this.hasAttribute(\"disabled\")\n  }\n\n  /**\n   * Sets the disabled state of the frame.\n   *\n   * If disabled, no requests will be intercepted by the frame.\n   */\n  set disabled(value) {\n    if (value) {\n      this.setAttribute(\"disabled\", \"\");\n    } else {\n      this.removeAttribute(\"disabled\");\n    }\n  }\n\n  /**\n   * Gets the autoscroll state of the frame.\n   *\n   * If true, the frame will be scrolled into view automatically on update.\n   */\n  get autoscroll() {\n    return this.hasAttribute(\"autoscroll\")\n  }\n\n  /**\n   * Sets the autoscroll state of the frame.\n   *\n   * If true, the frame will be scrolled into view automatically on update.\n   */\n  set autoscroll(value) {\n    if (value) {\n      this.setAttribute(\"autoscroll\", \"\");\n    } else {\n      this.removeAttribute(\"autoscroll\");\n    }\n  }\n\n  /**\n   * Determines if the element has finished loading\n   */\n  get complete() {\n    return !this.delegate.isLoading\n  }\n\n  /**\n   * Gets the active state of the frame.\n   *\n   * If inactive, source changes will not be observed.\n   */\n  get isActive() {\n    return this.ownerDocument === document && !this.isPreview\n  }\n\n  /**\n   * Sets the active state of the frame.\n   *\n   * If inactive, source changes will not be observed.\n   */\n  get isPreview() {\n    return this.ownerDocument?.documentElement?.hasAttribute(\"data-turbo-preview\")\n  }\n}\n\nfunction frameLoadingStyleFromString(style) {\n  switch (style.toLowerCase()) {\n    case \"lazy\":\n      return FrameLoadingStyle.lazy\n    default:\n      return FrameLoadingStyle.eager\n  }\n}\n\nconst drive = {\n  enabled: true,\n  progressBarDelay: 500,\n  unvisitableExtensions: new Set(\n    [\n      \".7z\", \".aac\", \".apk\", \".avi\", \".bmp\", \".bz2\", \".css\", \".csv\", \".deb\", \".dmg\", \".doc\",\n      \".docx\", \".exe\", \".gif\", \".gz\", \".heic\", \".heif\", \".ico\", \".iso\", \".jpeg\", \".jpg\",\n      \".js\", \".json\", \".m4a\", \".mkv\", \".mov\", \".mp3\", \".mp4\", \".mpeg\", \".mpg\", \".msi\",\n      \".ogg\", \".ogv\", \".pdf\", \".pkg\", \".png\", \".ppt\", \".pptx\", \".rar\", \".rtf\",\n      \".svg\", \".tar\", \".tif\", \".tiff\", \".txt\", \".wav\", \".webm\", \".webp\", \".wma\", \".wmv\",\n      \".xls\", \".xlsx\", \".xml\", \".zip\"\n    ]\n  )\n};\n\nfunction activateScriptElement(element) {\n  if (element.getAttribute(\"data-turbo-eval\") == \"false\") {\n    return element\n  } else {\n    const createdScriptElement = document.createElement(\"script\");\n    const cspNonce = getCspNonce();\n    if (cspNonce) {\n      createdScriptElement.nonce = cspNonce;\n    }\n    createdScriptElement.textContent = element.textContent;\n    createdScriptElement.async = false;\n    copyElementAttributes(createdScriptElement, element);\n    return createdScriptElement\n  }\n}\n\nfunction copyElementAttributes(destinationElement, sourceElement) {\n  for (const { name, value } of sourceElement.attributes) {\n    destinationElement.setAttribute(name, value);\n  }\n}\n\nfunction createDocumentFragment(html) {\n  const template = document.createElement(\"template\");\n  template.innerHTML = html;\n  return template.content\n}\n\nfunction dispatch(eventName, { target, cancelable, detail } = {}) {\n  const event = new CustomEvent(eventName, {\n    cancelable,\n    bubbles: true,\n    composed: true,\n    detail\n  });\n\n  if (target && target.isConnected) {\n    target.dispatchEvent(event);\n  } else {\n    document.documentElement.dispatchEvent(event);\n  }\n\n  return event\n}\n\nfunction cancelEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\nfunction nextRepaint() {\n  if (document.visibilityState === \"hidden\") {\n    return nextEventLoopTick()\n  } else {\n    return nextAnimationFrame()\n  }\n}\n\nfunction nextAnimationFrame() {\n  return new Promise((resolve) => requestAnimationFrame(() => resolve()))\n}\n\nfunction nextEventLoopTick() {\n  return new Promise((resolve) => setTimeout(() => resolve(), 0))\n}\n\nfunction parseHTMLDocument(html = \"\") {\n  return new DOMParser().parseFromString(html, \"text/html\")\n}\n\nfunction unindent(strings, ...values) {\n  const lines = interpolate(strings, values).replace(/^\\n/, \"\").split(\"\\n\");\n  const match = lines[0].match(/^\\s+/);\n  const indent = match ? match[0].length : 0;\n  return lines.map((line) => line.slice(indent)).join(\"\\n\")\n}\n\nfunction interpolate(strings, values) {\n  return strings.reduce((result, string, i) => {\n    const value = values[i] == undefined ? \"\" : values[i];\n    return result + string + value\n  }, \"\")\n}\n\nfunction uuid() {\n  return Array.from({ length: 36 })\n    .map((_, i) => {\n      if (i == 8 || i == 13 || i == 18 || i == 23) {\n        return \"-\"\n      } else if (i == 14) {\n        return \"4\"\n      } else if (i == 19) {\n        return (Math.floor(Math.random() * 4) + 8).toString(16)\n      } else {\n        return Math.floor(Math.random() * 16).toString(16)\n      }\n    })\n    .join(\"\")\n}\n\nfunction getAttribute(attributeName, ...elements) {\n  for (const value of elements.map((element) => element?.getAttribute(attributeName))) {\n    if (typeof value == \"string\") return value\n  }\n\n  return null\n}\n\nfunction hasAttribute(attributeName, ...elements) {\n  return elements.some((element) => element && element.hasAttribute(attributeName))\n}\n\nfunction markAsBusy(...elements) {\n  for (const element of elements) {\n    if (element.localName == \"turbo-frame\") {\n      element.setAttribute(\"busy\", \"\");\n    }\n    element.setAttribute(\"aria-busy\", \"true\");\n  }\n}\n\nfunction clearBusyState(...elements) {\n  for (const element of elements) {\n    if (element.localName == \"turbo-frame\") {\n      element.removeAttribute(\"busy\");\n    }\n\n    element.removeAttribute(\"aria-busy\");\n  }\n}\n\nfunction waitForLoad(element, timeoutInMilliseconds = 2000) {\n  return new Promise((resolve) => {\n    const onComplete = () => {\n      element.removeEventListener(\"error\", onComplete);\n      element.removeEventListener(\"load\", onComplete);\n      resolve();\n    };\n\n    element.addEventListener(\"load\", onComplete, { once: true });\n    element.addEventListener(\"error\", onComplete, { once: true });\n    setTimeout(resolve, timeoutInMilliseconds);\n  })\n}\n\nfunction getHistoryMethodForAction(action) {\n  switch (action) {\n    case \"replace\":\n      return history.replaceState\n    case \"advance\":\n    case \"restore\":\n      return history.pushState\n  }\n}\n\nfunction isAction(action) {\n  return action == \"advance\" || action == \"replace\" || action == \"restore\"\n}\n\nfunction getVisitAction(...elements) {\n  const action = getAttribute(\"data-turbo-action\", ...elements);\n\n  return isAction(action) ? action : null\n}\n\nfunction getMetaElement(name) {\n  return document.querySelector(`meta[name=\"${name}\"]`)\n}\n\nfunction getMetaContent(name) {\n  const element = getMetaElement(name);\n  return element && element.content\n}\n\nfunction getCspNonce() {\n  const element = getMetaElement(\"csp-nonce\");\n\n  if (element) {\n    const { nonce, content } = element;\n    return nonce == \"\" ? content : nonce\n  }\n}\n\nfunction setMetaContent(name, content) {\n  let element = getMetaElement(name);\n\n  if (!element) {\n    element = document.createElement(\"meta\");\n    element.setAttribute(\"name\", name);\n\n    document.head.appendChild(element);\n  }\n\n  element.setAttribute(\"content\", content);\n\n  return element\n}\n\nfunction findClosestRecursively(element, selector) {\n  if (element instanceof Element) {\n    return (\n      element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector)\n    )\n  }\n}\n\nfunction elementIsFocusable(element) {\n  const inertDisabledOrHidden = \"[inert], :disabled, [hidden], details:not([open]), dialog:not([open])\";\n\n  return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == \"function\"\n}\n\nfunction queryAutofocusableElement(elementOrDocumentFragment) {\n  return Array.from(elementOrDocumentFragment.querySelectorAll(\"[autofocus]\")).find(elementIsFocusable)\n}\n\nasync function around(callback, reader) {\n  const before = reader();\n\n  callback();\n\n  await nextAnimationFrame();\n\n  const after = reader();\n\n  return [before, after]\n}\n\nfunction doesNotTargetIFrame(name) {\n  if (name === \"_blank\") {\n    return false\n  } else if (name) {\n    for (const element of document.getElementsByName(name)) {\n      if (element instanceof HTMLIFrameElement) return false\n    }\n\n    return true\n  } else {\n    return true\n  }\n}\n\nfunction findLinkFromClickTarget(target) {\n  const link = findClosestRecursively(target, \"a[href], a[xlink\\\\:href]\");\n\n  if (!link) return null\n  if (link.href.startsWith(\"#\")) return null\n  if (link.hasAttribute(\"download\")) return null\n\n  const linkTarget = link.getAttribute(\"target\");\n  if (linkTarget && linkTarget !== \"_self\") return null\n\n  return link\n}\n\nfunction debounce(fn, delay) {\n  let timeoutId = null;\n\n  return (...args) => {\n    const callback = () => fn.apply(this, args);\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(callback, delay);\n  }\n}\n\nconst submitter = {\n  \"aria-disabled\": {\n    beforeSubmit: submitter => {\n      submitter.setAttribute(\"aria-disabled\", \"true\");\n      submitter.addEventListener(\"click\", cancelEvent);\n    },\n\n    afterSubmit: submitter => {\n      submitter.removeAttribute(\"aria-disabled\");\n      submitter.removeEventListener(\"click\", cancelEvent);\n    }\n  },\n\n  \"disabled\": {\n    beforeSubmit: submitter => submitter.disabled = true,\n    afterSubmit: submitter => submitter.disabled = false\n  }\n};\n\nclass Config {\n  #submitter = null\n\n  constructor(config) {\n    Object.assign(this, config);\n  }\n\n  get submitter() {\n    return this.#submitter\n  }\n\n  set submitter(value) {\n    this.#submitter = submitter[value] || value;\n  }\n}\n\nconst forms = new Config({\n  mode: \"on\",\n  submitter: \"disabled\"\n});\n\nconst config = {\n  drive,\n  forms\n};\n\nfunction expandURL(locatable) {\n  return new URL(locatable.toString(), document.baseURI)\n}\n\nfunction getAnchor(url) {\n  let anchorMatch;\n  if (url.hash) {\n    return url.hash.slice(1)\n    // eslint-disable-next-line no-cond-assign\n  } else if ((anchorMatch = url.href.match(/#(.*)$/))) {\n    return anchorMatch[1]\n  }\n}\n\nfunction getAction$1(form, submitter) {\n  const action = submitter?.getAttribute(\"formaction\") || form.getAttribute(\"action\") || form.action;\n\n  return expandURL(action)\n}\n\nfunction getExtension(url) {\n  return (getLastPathComponent(url).match(/\\.[^.]*$/) || [])[0] || \"\"\n}\n\nfunction isPrefixedBy(baseURL, url) {\n  const prefix = addTrailingSlash(url.origin + url.pathname);\n  return addTrailingSlash(baseURL.href) === prefix || baseURL.href.startsWith(prefix)\n}\n\nfunction locationIsVisitable(location, rootLocation) {\n  return isPrefixedBy(location, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location))\n}\n\nfunction getLocationForLink(link) {\n  return expandURL(link.getAttribute(\"href\") || \"\")\n}\n\nfunction getRequestURL(url) {\n  const anchor = getAnchor(url);\n  return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href\n}\n\nfunction toCacheKey(url) {\n  return getRequestURL(url)\n}\n\nfunction urlsAreEqual(left, right) {\n  return expandURL(left).href == expandURL(right).href\n}\n\nfunction getPathComponents(url) {\n  return url.pathname.split(\"/\").slice(1)\n}\n\nfunction getLastPathComponent(url) {\n  return getPathComponents(url).slice(-1)[0]\n}\n\nfunction addTrailingSlash(value) {\n  return value.endsWith(\"/\") ? value : value + \"/\"\n}\n\nclass FetchResponse {\n  constructor(response) {\n    this.response = response;\n  }\n\n  get succeeded() {\n    return this.response.ok\n  }\n\n  get failed() {\n    return !this.succeeded\n  }\n\n  get clientError() {\n    return this.statusCode >= 400 && this.statusCode <= 499\n  }\n\n  get serverError() {\n    return this.statusCode >= 500 && this.statusCode <= 599\n  }\n\n  get redirected() {\n    return this.response.redirected\n  }\n\n  get location() {\n    return expandURL(this.response.url)\n  }\n\n  get isHTML() {\n    return this.contentType && this.contentType.match(/^(?:text\\/([^\\s;,]+\\b)?html|application\\/xhtml\\+xml)\\b/)\n  }\n\n  get statusCode() {\n    return this.response.status\n  }\n\n  get contentType() {\n    return this.header(\"Content-Type\")\n  }\n\n  get responseText() {\n    return this.response.clone().text()\n  }\n\n  get responseHTML() {\n    if (this.isHTML) {\n      return this.response.clone().text()\n    } else {\n      return Promise.resolve(undefined)\n    }\n  }\n\n  header(name) {\n    return this.response.headers.get(name)\n  }\n}\n\nclass LimitedSet extends Set {\n  constructor(maxSize) {\n    super();\n    this.maxSize = maxSize;\n  }\n\n  add(value) {\n    if (this.size >= this.maxSize) {\n      const iterator = this.values();\n      const oldestValue = iterator.next().value;\n      this.delete(oldestValue);\n    }\n    super.add(value);\n  }\n}\n\nconst recentRequests = new LimitedSet(20);\n\nfunction fetchWithTurboHeaders(url, options = {}) {\n  const modifiedHeaders = new Headers(options.headers || {});\n  const requestUID = uuid();\n  recentRequests.add(requestUID);\n  modifiedHeaders.append(\"X-Turbo-Request-Id\", requestUID);\n\n  return window.fetch(url, {\n    ...options,\n    headers: modifiedHeaders\n  })\n}\n\nfunction fetchMethodFromString(method) {\n  switch (method.toLowerCase()) {\n    case \"get\":\n      return FetchMethod.get\n    case \"post\":\n      return FetchMethod.post\n    case \"put\":\n      return FetchMethod.put\n    case \"patch\":\n      return FetchMethod.patch\n    case \"delete\":\n      return FetchMethod.delete\n  }\n}\n\nconst FetchMethod = {\n  get: \"get\",\n  post: \"post\",\n  put: \"put\",\n  patch: \"patch\",\n  delete: \"delete\"\n};\n\nfunction fetchEnctypeFromString(encoding) {\n  switch (encoding.toLowerCase()) {\n    case FetchEnctype.multipart:\n      return FetchEnctype.multipart\n    case FetchEnctype.plain:\n      return FetchEnctype.plain\n    default:\n      return FetchEnctype.urlEncoded\n  }\n}\n\nconst FetchEnctype = {\n  urlEncoded: \"application/x-www-form-urlencoded\",\n  multipart: \"multipart/form-data\",\n  plain: \"text/plain\"\n};\n\nclass FetchRequest {\n  abortController = new AbortController()\n  #resolveRequestPromise = (_value) => {}\n\n  constructor(delegate, method, location, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {\n    const [url, body] = buildResourceAndBody(expandURL(location), method, requestBody, enctype);\n\n    this.delegate = delegate;\n    this.url = url;\n    this.target = target;\n    this.fetchOptions = {\n      credentials: \"same-origin\",\n      redirect: \"follow\",\n      method: method.toUpperCase(),\n      headers: { ...this.defaultHeaders },\n      body: body,\n      signal: this.abortSignal,\n      referrer: this.delegate.referrer?.href\n    };\n    this.enctype = enctype;\n  }\n\n  get method() {\n    return this.fetchOptions.method\n  }\n\n  set method(value) {\n    const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();\n    const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;\n\n    this.url.search = \"\";\n\n    const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);\n\n    this.url = url;\n    this.fetchOptions.body = body;\n    this.fetchOptions.method = fetchMethod.toUpperCase();\n  }\n\n  get headers() {\n    return this.fetchOptions.headers\n  }\n\n  set headers(value) {\n    this.fetchOptions.headers = value;\n  }\n\n  get body() {\n    if (this.isSafe) {\n      return this.url.searchParams\n    } else {\n      return this.fetchOptions.body\n    }\n  }\n\n  set body(value) {\n    this.fetchOptions.body = value;\n  }\n\n  get location() {\n    return this.url\n  }\n\n  get params() {\n    return this.url.searchParams\n  }\n\n  get entries() {\n    return this.body ? Array.from(this.body.entries()) : []\n  }\n\n  cancel() {\n    this.abortController.abort();\n  }\n\n  async perform() {\n    const { fetchOptions } = this;\n    this.delegate.prepareRequest(this);\n    const event = await this.#allowRequestToBeIntercepted(fetchOptions);\n    try {\n      this.delegate.requestStarted(this);\n\n      if (event.detail.fetchRequest) {\n        this.response = event.detail.fetchRequest.response;\n      } else {\n        this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);\n      }\n\n      const response = await this.response;\n      return await this.receive(response)\n    } catch (error) {\n      if (error.name !== \"AbortError\") {\n        if (this.#willDelegateErrorHandling(error)) {\n          this.delegate.requestErrored(this, error);\n        }\n        throw error\n      }\n    } finally {\n      this.delegate.requestFinished(this);\n    }\n  }\n\n  async receive(response) {\n    const fetchResponse = new FetchResponse(response);\n    const event = dispatch(\"turbo:before-fetch-response\", {\n      cancelable: true,\n      detail: { fetchResponse },\n      target: this.target\n    });\n    if (event.defaultPrevented) {\n      this.delegate.requestPreventedHandlingResponse(this, fetchResponse);\n    } else if (fetchResponse.succeeded) {\n      this.delegate.requestSucceededWithResponse(this, fetchResponse);\n    } else {\n      this.delegate.requestFailedWithResponse(this, fetchResponse);\n    }\n    return fetchResponse\n  }\n\n  get defaultHeaders() {\n    return {\n      Accept: \"text/html, application/xhtml+xml\"\n    }\n  }\n\n  get isSafe() {\n    return isSafe(this.method)\n  }\n\n  get abortSignal() {\n    return this.abortController.signal\n  }\n\n  acceptResponseType(mimeType) {\n    this.headers[\"Accept\"] = [mimeType, this.headers[\"Accept\"]].join(\", \");\n  }\n\n  async #allowRequestToBeIntercepted(fetchOptions) {\n    const requestInterception = new Promise((resolve) => (this.#resolveRequestPromise = resolve));\n    const event = dispatch(\"turbo:before-fetch-request\", {\n      cancelable: true,\n      detail: {\n        fetchOptions,\n        url: this.url,\n        resume: this.#resolveRequestPromise\n      },\n      target: this.target\n    });\n    this.url = event.detail.url;\n    if (event.defaultPrevented) await requestInterception;\n\n    return event\n  }\n\n  #willDelegateErrorHandling(error) {\n    const event = dispatch(\"turbo:fetch-request-error\", {\n      target: this.target,\n      cancelable: true,\n      detail: { request: this, error: error }\n    });\n\n    return !event.defaultPrevented\n  }\n}\n\nfunction isSafe(fetchMethod) {\n  return fetchMethodFromString(fetchMethod) == FetchMethod.get\n}\n\nfunction buildResourceAndBody(resource, method, requestBody, enctype) {\n  const searchParams =\n    Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;\n\n  if (isSafe(method)) {\n    return [mergeIntoURLSearchParams(resource, searchParams), null]\n  } else if (enctype == FetchEnctype.urlEncoded) {\n    return [resource, searchParams]\n  } else {\n    return [resource, requestBody]\n  }\n}\n\nfunction entriesExcludingFiles(requestBody) {\n  const entries = [];\n\n  for (const [name, value] of requestBody) {\n    if (value instanceof File) continue\n    else entries.push([name, value]);\n  }\n\n  return entries\n}\n\nfunction mergeIntoURLSearchParams(url, requestBody) {\n  const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));\n\n  url.search = searchParams.toString();\n\n  return url\n}\n\nclass AppearanceObserver {\n  started = false\n\n  constructor(delegate, element) {\n    this.delegate = delegate;\n    this.element = element;\n    this.intersectionObserver = new IntersectionObserver(this.intersect);\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this.intersectionObserver.observe(this.element);\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this.intersectionObserver.unobserve(this.element);\n    }\n  }\n\n  intersect = (entries) => {\n    const lastEntry = entries.slice(-1)[0];\n    if (lastEntry?.isIntersecting) {\n      this.delegate.elementAppearedInViewport(this.element);\n    }\n  }\n}\n\nclass StreamMessage {\n  static contentType = \"text/vnd.turbo-stream.html\"\n\n  static wrap(message) {\n    if (typeof message == \"string\") {\n      return new this(createDocumentFragment(message))\n    } else {\n      return message\n    }\n  }\n\n  constructor(fragment) {\n    this.fragment = importStreamElements(fragment);\n  }\n}\n\nfunction importStreamElements(fragment) {\n  for (const element of fragment.querySelectorAll(\"turbo-stream\")) {\n    const streamElement = document.importNode(element, true);\n\n    for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll(\"script\")) {\n      inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));\n    }\n\n    element.replaceWith(streamElement);\n  }\n\n  return fragment\n}\n\nconst identity = key => key;\n\nclass LRUCache {\n  keys = []\n  entries = {}\n  #toCacheKey\n\n  constructor(size, toCacheKey = identity) {\n    this.size = size;\n    this.#toCacheKey = toCacheKey;\n  }\n\n  has(key) {\n    return this.#toCacheKey(key) in this.entries\n  }\n\n  get(key) {\n    if (this.has(key)) {\n      const entry = this.read(key);\n      this.touch(key);\n      return entry\n    }\n  }\n\n  put(key, entry) {\n    this.write(key, entry);\n    this.touch(key);\n    return entry\n  }\n\n  clear() {\n    for (const key of Object.keys(this.entries)) {\n      this.evict(key);\n    }\n  }\n\n  // Private\n\n  read(key) {\n    return this.entries[this.#toCacheKey(key)]\n  }\n\n  write(key, entry) {\n    this.entries[this.#toCacheKey(key)] = entry;\n  }\n\n  touch(key) {\n    key = this.#toCacheKey(key);\n    const index = this.keys.indexOf(key);\n    if (index > -1) this.keys.splice(index, 1);\n    this.keys.unshift(key);\n    this.trim();\n  }\n\n  trim() {\n    for (const key of this.keys.splice(this.size)) {\n      this.evict(key);\n    }\n  }\n\n  evict(key) {\n    delete this.entries[key];\n  }\n}\n\nconst PREFETCH_DELAY = 100;\n\nclass PrefetchCache extends LRUCache {\n  #prefetchTimeout = null\n  #maxAges = {}\n\n  constructor(size = 1, prefetchDelay = PREFETCH_DELAY) {\n    super(size, toCacheKey);\n    this.prefetchDelay = prefetchDelay;\n  }\n\n  putLater(url, request, ttl) {\n    this.#prefetchTimeout = setTimeout(() => {\n      request.perform();\n      this.put(url, request, ttl);\n      this.#prefetchTimeout = null;\n    }, this.prefetchDelay);\n  }\n\n  put(url, request, ttl = cacheTtl) {\n    super.put(url, request);\n    this.#maxAges[toCacheKey(url)] = new Date(new Date().getTime() + ttl);\n  }\n\n  clear() {\n    super.clear();\n    if (this.#prefetchTimeout) clearTimeout(this.#prefetchTimeout);\n  }\n\n  evict(key) {\n    super.evict(key);\n    delete this.#maxAges[key];\n  }\n\n  has(key) {\n    if (super.has(key)) {\n      const maxAge = this.#maxAges[toCacheKey(key)];\n\n      return maxAge && maxAge > Date.now()\n    } else {\n      return false\n    }\n  }\n}\n\nconst cacheTtl = 10 * 1000;\nconst prefetchCache = new PrefetchCache();\n\nconst FormSubmissionState = {\n  initialized: \"initialized\",\n  requesting: \"requesting\",\n  waiting: \"waiting\",\n  receiving: \"receiving\",\n  stopping: \"stopping\",\n  stopped: \"stopped\"\n};\n\nclass FormSubmission {\n  state = FormSubmissionState.initialized\n\n  static confirmMethod(message) {\n    return Promise.resolve(confirm(message))\n  }\n\n  constructor(delegate, formElement, submitter, mustRedirect = false) {\n    const method = getMethod(formElement, submitter);\n    const action = getAction(getFormAction(formElement, submitter), method);\n    const body = buildFormData(formElement, submitter);\n    const enctype = getEnctype(formElement, submitter);\n\n    this.delegate = delegate;\n    this.formElement = formElement;\n    this.submitter = submitter;\n    this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);\n    this.mustRedirect = mustRedirect;\n  }\n\n  get method() {\n    return this.fetchRequest.method\n  }\n\n  set method(value) {\n    this.fetchRequest.method = value;\n  }\n\n  get action() {\n    return this.fetchRequest.url.toString()\n  }\n\n  set action(value) {\n    this.fetchRequest.url = expandURL(value);\n  }\n\n  get body() {\n    return this.fetchRequest.body\n  }\n\n  get enctype() {\n    return this.fetchRequest.enctype\n  }\n\n  get isSafe() {\n    return this.fetchRequest.isSafe\n  }\n\n  get location() {\n    return this.fetchRequest.url\n  }\n\n  // The submission process\n\n  async start() {\n    const { initialized, requesting } = FormSubmissionState;\n    const confirmationMessage = getAttribute(\"data-turbo-confirm\", this.submitter, this.formElement);\n\n    if (typeof confirmationMessage === \"string\") {\n      const confirmMethod = typeof config.forms.confirm === \"function\" ?\n        config.forms.confirm :\n        FormSubmission.confirmMethod;\n\n      const answer = await confirmMethod(confirmationMessage, this.formElement, this.submitter);\n      if (!answer) {\n        return\n      }\n    }\n\n    if (this.state == initialized) {\n      this.state = requesting;\n      return this.fetchRequest.perform()\n    }\n  }\n\n  stop() {\n    const { stopping, stopped } = FormSubmissionState;\n    if (this.state != stopping && this.state != stopped) {\n      this.state = stopping;\n      this.fetchRequest.cancel();\n      return true\n    }\n  }\n\n  // Fetch request delegate\n\n  prepareRequest(request) {\n    if (!request.isSafe) {\n      const token = getCookieValue(getMetaContent(\"csrf-param\")) || getMetaContent(\"csrf-token\");\n      if (token) {\n        request.headers[\"X-CSRF-Token\"] = token;\n      }\n    }\n\n    if (this.requestAcceptsTurboStreamResponse(request)) {\n      request.acceptResponseType(StreamMessage.contentType);\n    }\n  }\n\n  requestStarted(_request) {\n    this.state = FormSubmissionState.waiting;\n    if (this.submitter) config.forms.submitter.beforeSubmit(this.submitter);\n    this.setSubmitsWith();\n    markAsBusy(this.formElement);\n    dispatch(\"turbo:submit-start\", {\n      target: this.formElement,\n      detail: { formSubmission: this }\n    });\n    this.delegate.formSubmissionStarted(this);\n  }\n\n  requestPreventedHandlingResponse(request, response) {\n    prefetchCache.clear();\n\n    this.result = { success: response.succeeded, fetchResponse: response };\n  }\n\n  requestSucceededWithResponse(request, response) {\n    if (response.clientError || response.serverError) {\n      this.delegate.formSubmissionFailedWithResponse(this, response);\n      return\n    }\n\n    prefetchCache.clear();\n\n    if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {\n      const error = new Error(\"Form responses must redirect to another location\");\n      this.delegate.formSubmissionErrored(this, error);\n    } else {\n      this.state = FormSubmissionState.receiving;\n      this.result = { success: true, fetchResponse: response };\n      this.delegate.formSubmissionSucceededWithResponse(this, response);\n    }\n  }\n\n  requestFailedWithResponse(request, response) {\n    this.result = { success: false, fetchResponse: response };\n    this.delegate.formSubmissionFailedWithResponse(this, response);\n  }\n\n  requestErrored(request, error) {\n    this.result = { success: false, error };\n    this.delegate.formSubmissionErrored(this, error);\n  }\n\n  requestFinished(_request) {\n    this.state = FormSubmissionState.stopped;\n    if (this.submitter) config.forms.submitter.afterSubmit(this.submitter);\n    this.resetSubmitterText();\n    clearBusyState(this.formElement);\n    dispatch(\"turbo:submit-end\", {\n      target: this.formElement,\n      detail: { formSubmission: this, ...this.result }\n    });\n    this.delegate.formSubmissionFinished(this);\n  }\n\n  // Private\n\n  setSubmitsWith() {\n    if (!this.submitter || !this.submitsWith) return\n\n    if (this.submitter.matches(\"button\")) {\n      this.originalSubmitText = this.submitter.innerHTML;\n      this.submitter.innerHTML = this.submitsWith;\n    } else if (this.submitter.matches(\"input\")) {\n      const input = this.submitter;\n      this.originalSubmitText = input.value;\n      input.value = this.submitsWith;\n    }\n  }\n\n  resetSubmitterText() {\n    if (!this.submitter || !this.originalSubmitText) return\n\n    if (this.submitter.matches(\"button\")) {\n      this.submitter.innerHTML = this.originalSubmitText;\n    } else if (this.submitter.matches(\"input\")) {\n      const input = this.submitter;\n      input.value = this.originalSubmitText;\n    }\n  }\n\n  requestMustRedirect(request) {\n    return !request.isSafe && this.mustRedirect\n  }\n\n  requestAcceptsTurboStreamResponse(request) {\n    return !request.isSafe || hasAttribute(\"data-turbo-stream\", this.submitter, this.formElement)\n  }\n\n  get submitsWith() {\n    return this.submitter?.getAttribute(\"data-turbo-submits-with\")\n  }\n}\n\nfunction buildFormData(formElement, submitter) {\n  const formData = new FormData(formElement);\n  const name = submitter?.getAttribute(\"name\");\n  const value = submitter?.getAttribute(\"value\");\n\n  if (name) {\n    formData.append(name, value || \"\");\n  }\n\n  return formData\n}\n\nfunction getCookieValue(cookieName) {\n  if (cookieName != null) {\n    const cookies = document.cookie ? document.cookie.split(\"; \") : [];\n    const cookie = cookies.find((cookie) => cookie.startsWith(cookieName));\n    if (cookie) {\n      const value = cookie.split(\"=\").slice(1).join(\"=\");\n      return value ? decodeURIComponent(value) : undefined\n    }\n  }\n}\n\nfunction responseSucceededWithoutRedirect(response) {\n  return response.statusCode == 200 && !response.redirected\n}\n\nfunction getFormAction(formElement, submitter) {\n  const formElementAction = typeof formElement.action === \"string\" ? formElement.action : null;\n\n  if (submitter?.hasAttribute(\"formaction\")) {\n    return submitter.getAttribute(\"formaction\") || \"\"\n  } else {\n    return formElement.getAttribute(\"action\") || formElementAction || \"\"\n  }\n}\n\nfunction getAction(formAction, fetchMethod) {\n  const action = expandURL(formAction);\n\n  if (isSafe(fetchMethod)) {\n    action.search = \"\";\n  }\n\n  return action\n}\n\nfunction getMethod(formElement, submitter) {\n  const method = submitter?.getAttribute(\"formmethod\") || formElement.getAttribute(\"method\") || \"\";\n  return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get\n}\n\nfunction getEnctype(formElement, submitter) {\n  return fetchEnctypeFromString(submitter?.getAttribute(\"formenctype\") || formElement.enctype)\n}\n\nclass Snapshot {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get activeElement() {\n    return this.element.ownerDocument.activeElement\n  }\n\n  get children() {\n    return [...this.element.children]\n  }\n\n  hasAnchor(anchor) {\n    return this.getElementForAnchor(anchor) != null\n  }\n\n  getElementForAnchor(anchor) {\n    return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null\n  }\n\n  get isConnected() {\n    return this.element.isConnected\n  }\n\n  get firstAutofocusableElement() {\n    return queryAutofocusableElement(this.element)\n  }\n\n  get permanentElements() {\n    return queryPermanentElementsAll(this.element)\n  }\n\n  getPermanentElementById(id) {\n    return getPermanentElementById(this.element, id)\n  }\n\n  getPermanentElementMapForSnapshot(snapshot) {\n    const permanentElementMap = {};\n\n    for (const currentPermanentElement of this.permanentElements) {\n      const { id } = currentPermanentElement;\n      const newPermanentElement = snapshot.getPermanentElementById(id);\n      if (newPermanentElement) {\n        permanentElementMap[id] = [currentPermanentElement, newPermanentElement];\n      }\n    }\n\n    return permanentElementMap\n  }\n}\n\nfunction getPermanentElementById(node, id) {\n  return node.querySelector(`#${id}[data-turbo-permanent]`)\n}\n\nfunction queryPermanentElementsAll(node) {\n  return node.querySelectorAll(\"[id][data-turbo-permanent]\")\n}\n\nclass FormSubmitObserver {\n  started = false\n\n  constructor(delegate, eventTarget) {\n    this.delegate = delegate;\n    this.eventTarget = eventTarget;\n  }\n\n  start() {\n    if (!this.started) {\n      this.eventTarget.addEventListener(\"submit\", this.submitCaptured, true);\n      this.started = true;\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.eventTarget.removeEventListener(\"submit\", this.submitCaptured, true);\n      this.started = false;\n    }\n  }\n\n  submitCaptured = () => {\n    this.eventTarget.removeEventListener(\"submit\", this.submitBubbled, false);\n    this.eventTarget.addEventListener(\"submit\", this.submitBubbled, false);\n  }\n\n  submitBubbled = (event) => {\n    if (!event.defaultPrevented) {\n      const form = event.target instanceof HTMLFormElement ? event.target : undefined;\n      const submitter = event.submitter || undefined;\n\n      if (\n        form &&\n        submissionDoesNotDismissDialog(form, submitter) &&\n        submissionDoesNotTargetIFrame(form, submitter) &&\n        this.delegate.willSubmitForm(form, submitter)\n      ) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        this.delegate.formSubmitted(form, submitter);\n      }\n    }\n  }\n}\n\nfunction submissionDoesNotDismissDialog(form, submitter) {\n  const method = submitter?.getAttribute(\"formmethod\") || form.getAttribute(\"method\");\n\n  return method != \"dialog\"\n}\n\nfunction submissionDoesNotTargetIFrame(form, submitter) {\n  const target = submitter?.getAttribute(\"formtarget\") || form.getAttribute(\"target\");\n\n  return doesNotTargetIFrame(target)\n}\n\nclass View {\n  #resolveRenderPromise = (_value) => {}\n  #resolveInterceptionPromise = (_value) => {}\n\n  constructor(delegate, element) {\n    this.delegate = delegate;\n    this.element = element;\n  }\n\n  // Scrolling\n\n  scrollToAnchor(anchor) {\n    const element = this.snapshot.getElementForAnchor(anchor);\n    if (element) {\n      this.focusElement(element);\n      this.scrollToElement(element);\n    } else {\n      this.scrollToPosition({ x: 0, y: 0 });\n    }\n  }\n\n  scrollToAnchorFromLocation(location) {\n    this.scrollToAnchor(getAnchor(location));\n  }\n\n  scrollToElement(element) {\n    element.scrollIntoView();\n  }\n\n  focusElement(element) {\n    if (element instanceof HTMLElement) {\n      if (element.hasAttribute(\"tabindex\")) {\n        element.focus();\n      } else {\n        element.setAttribute(\"tabindex\", \"-1\");\n        element.focus();\n        element.removeAttribute(\"tabindex\");\n      }\n    }\n  }\n\n  scrollToPosition({ x, y }) {\n    this.scrollRoot.scrollTo(x, y);\n  }\n\n  scrollToTop() {\n    this.scrollToPosition({ x: 0, y: 0 });\n  }\n\n  get scrollRoot() {\n    return window\n  }\n\n  // Rendering\n\n  async render(renderer) {\n    const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;\n\n    // A workaround to ignore tracked element mismatch reloads when performing\n    // a promoted Visit from a frame navigation\n    const shouldInvalidate = willRender;\n\n    if (shouldRender) {\n      try {\n        this.renderPromise = new Promise((resolve) => (this.#resolveRenderPromise = resolve));\n        this.renderer = renderer;\n        await this.prepareToRenderSnapshot(renderer);\n\n        const renderInterception = new Promise((resolve) => (this.#resolveInterceptionPromise = resolve));\n        const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };\n        const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);\n        if (!immediateRender) await renderInterception;\n\n        await this.renderSnapshot(renderer);\n        this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);\n        this.delegate.preloadOnLoadLinksForView(this.element);\n        this.finishRenderingSnapshot(renderer);\n      } finally {\n        delete this.renderer;\n        this.#resolveRenderPromise(undefined);\n        delete this.renderPromise;\n      }\n    } else if (shouldInvalidate) {\n      this.invalidate(renderer.reloadReason);\n    }\n  }\n\n  invalidate(reason) {\n    this.delegate.viewInvalidated(reason);\n  }\n\n  async prepareToRenderSnapshot(renderer) {\n    this.markAsPreview(renderer.isPreview);\n    await renderer.prepareToRender();\n  }\n\n  markAsPreview(isPreview) {\n    if (isPreview) {\n      this.element.setAttribute(\"data-turbo-preview\", \"\");\n    } else {\n      this.element.removeAttribute(\"data-turbo-preview\");\n    }\n  }\n\n  markVisitDirection(direction) {\n    this.element.setAttribute(\"data-turbo-visit-direction\", direction);\n  }\n\n  unmarkVisitDirection() {\n    this.element.removeAttribute(\"data-turbo-visit-direction\");\n  }\n\n  async renderSnapshot(renderer) {\n    await renderer.render();\n  }\n\n  finishRenderingSnapshot(renderer) {\n    renderer.finishRendering();\n  }\n}\n\nclass FrameView extends View {\n  missing() {\n    this.element.innerHTML = `<strong class=\"turbo-frame-error\">Content missing</strong>`;\n  }\n\n  get snapshot() {\n    return new Snapshot(this.element)\n  }\n}\n\nclass LinkInterceptor {\n  constructor(delegate, element) {\n    this.delegate = delegate;\n    this.element = element;\n  }\n\n  start() {\n    this.element.addEventListener(\"click\", this.clickBubbled);\n    document.addEventListener(\"turbo:click\", this.linkClicked);\n    document.addEventListener(\"turbo:before-visit\", this.willVisit);\n  }\n\n  stop() {\n    this.element.removeEventListener(\"click\", this.clickBubbled);\n    document.removeEventListener(\"turbo:click\", this.linkClicked);\n    document.removeEventListener(\"turbo:before-visit\", this.willVisit);\n  }\n\n  clickBubbled = (event) => {\n    if (this.clickEventIsSignificant(event)) {\n      this.clickEvent = event;\n    } else {\n      delete this.clickEvent;\n    }\n  }\n\n  linkClicked = (event) => {\n    if (this.clickEvent && this.clickEventIsSignificant(event)) {\n      if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {\n        this.clickEvent.preventDefault();\n        event.preventDefault();\n        this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);\n      }\n    }\n    delete this.clickEvent;\n  }\n\n  willVisit = (_event) => {\n    delete this.clickEvent;\n  }\n\n  clickEventIsSignificant(event) {\n    const target = event.composed ? event.target?.parentElement : event.target;\n    const element = findLinkFromClickTarget(target) || target;\n\n    return element instanceof Element && element.closest(\"turbo-frame, html\") == this.element\n  }\n}\n\nclass LinkClickObserver {\n  started = false\n\n  constructor(delegate, eventTarget) {\n    this.delegate = delegate;\n    this.eventTarget = eventTarget;\n  }\n\n  start() {\n    if (!this.started) {\n      this.eventTarget.addEventListener(\"click\", this.clickCaptured, true);\n      this.started = true;\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.eventTarget.removeEventListener(\"click\", this.clickCaptured, true);\n      this.started = false;\n    }\n  }\n\n  clickCaptured = () => {\n    this.eventTarget.removeEventListener(\"click\", this.clickBubbled, false);\n    this.eventTarget.addEventListener(\"click\", this.clickBubbled, false);\n  }\n\n  clickBubbled = (event) => {\n    if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {\n      const target = (event.composedPath && event.composedPath()[0]) || event.target;\n      const link = findLinkFromClickTarget(target);\n      if (link && doesNotTargetIFrame(link.target)) {\n        const location = getLocationForLink(link);\n        if (this.delegate.willFollowLinkToLocation(link, location, event)) {\n          event.preventDefault();\n          this.delegate.followedLinkToLocation(link, location);\n        }\n      }\n    }\n  }\n\n  clickEventIsSignificant(event) {\n    return !(\n      (event.target && event.target.isContentEditable) ||\n      event.defaultPrevented ||\n      event.which > 1 ||\n      event.altKey ||\n      event.ctrlKey ||\n      event.metaKey ||\n      event.shiftKey\n    )\n  }\n}\n\nclass FormLinkClickObserver {\n  constructor(delegate, element) {\n    this.delegate = delegate;\n    this.linkInterceptor = new LinkClickObserver(this, element);\n  }\n\n  start() {\n    this.linkInterceptor.start();\n  }\n\n  stop() {\n    this.linkInterceptor.stop();\n  }\n\n  // Link hover observer delegate\n\n  canPrefetchRequestToLocation(link, location) {\n    return false\n  }\n\n  prefetchAndCacheRequestToLocation(link, location) {\n    return\n  }\n\n  // Link click observer delegate\n\n  willFollowLinkToLocation(link, location, originalEvent) {\n    return (\n      this.delegate.willSubmitFormLinkToLocation(link, location, originalEvent) &&\n      (link.hasAttribute(\"data-turbo-method\") || link.hasAttribute(\"data-turbo-stream\"))\n    )\n  }\n\n  followedLinkToLocation(link, location) {\n    const form = document.createElement(\"form\");\n\n    const type = \"hidden\";\n    for (const [name, value] of location.searchParams) {\n      form.append(Object.assign(document.createElement(\"input\"), { type, name, value }));\n    }\n\n    const action = Object.assign(location, { search: \"\" });\n    form.setAttribute(\"data-turbo\", \"true\");\n    form.setAttribute(\"action\", action.href);\n    form.setAttribute(\"hidden\", \"\");\n\n    const method = link.getAttribute(\"data-turbo-method\");\n    if (method) form.setAttribute(\"method\", method);\n\n    const turboFrame = link.getAttribute(\"data-turbo-frame\");\n    if (turboFrame) form.setAttribute(\"data-turbo-frame\", turboFrame);\n\n    const turboAction = getVisitAction(link);\n    if (turboAction) form.setAttribute(\"data-turbo-action\", turboAction);\n\n    const turboConfirm = link.getAttribute(\"data-turbo-confirm\");\n    if (turboConfirm) form.setAttribute(\"data-turbo-confirm\", turboConfirm);\n\n    const turboStream = link.hasAttribute(\"data-turbo-stream\");\n    if (turboStream) form.setAttribute(\"data-turbo-stream\", \"\");\n\n    this.delegate.submittedFormLinkToLocation(link, location, form);\n\n    document.body.appendChild(form);\n    form.addEventListener(\"turbo:submit-end\", () => form.remove(), { once: true });\n    requestAnimationFrame(() => form.requestSubmit());\n  }\n}\n\nclass Bardo {\n  static async preservingPermanentElements(delegate, permanentElementMap, callback) {\n    const bardo = new this(delegate, permanentElementMap);\n    bardo.enter();\n    await callback();\n    bardo.leave();\n  }\n\n  constructor(delegate, permanentElementMap) {\n    this.delegate = delegate;\n    this.permanentElementMap = permanentElementMap;\n  }\n\n  enter() {\n    for (const id in this.permanentElementMap) {\n      const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];\n      this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);\n      this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);\n    }\n  }\n\n  leave() {\n    for (const id in this.permanentElementMap) {\n      const [currentPermanentElement] = this.permanentElementMap[id];\n      this.replaceCurrentPermanentElementWithClone(currentPermanentElement);\n      this.replacePlaceholderWithPermanentElement(currentPermanentElement);\n      this.delegate.leavingBardo(currentPermanentElement);\n    }\n  }\n\n  replaceNewPermanentElementWithPlaceholder(permanentElement) {\n    const placeholder = createPlaceholderForPermanentElement(permanentElement);\n    permanentElement.replaceWith(placeholder);\n  }\n\n  replaceCurrentPermanentElementWithClone(permanentElement) {\n    const clone = permanentElement.cloneNode(true);\n    permanentElement.replaceWith(clone);\n  }\n\n  replacePlaceholderWithPermanentElement(permanentElement) {\n    const placeholder = this.getPlaceholderById(permanentElement.id);\n    placeholder?.replaceWith(permanentElement);\n  }\n\n  getPlaceholderById(id) {\n    return this.placeholders.find((element) => element.content == id)\n  }\n\n  get placeholders() {\n    return [...document.querySelectorAll(\"meta[name=turbo-permanent-placeholder][content]\")]\n  }\n}\n\nfunction createPlaceholderForPermanentElement(permanentElement) {\n  const element = document.createElement(\"meta\");\n  element.setAttribute(\"name\", \"turbo-permanent-placeholder\");\n  element.setAttribute(\"content\", permanentElement.id);\n  return element\n}\n\nclass Renderer {\n  #activeElement = null\n\n  static renderElement(currentElement, newElement) {\n    // Abstract method\n  }\n\n  constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {\n    this.currentSnapshot = currentSnapshot;\n    this.newSnapshot = newSnapshot;\n    this.isPreview = isPreview;\n    this.willRender = willRender;\n    this.renderElement = this.constructor.renderElement;\n    this.promise = new Promise((resolve, reject) => (this.resolvingFunctions = { resolve, reject }));\n  }\n\n  get shouldRender() {\n    return true\n  }\n\n  get shouldAutofocus() {\n    return true\n  }\n\n  get reloadReason() {\n    return\n  }\n\n  prepareToRender() {\n    return\n  }\n\n  render() {\n    // Abstract method\n  }\n\n  finishRendering() {\n    if (this.resolvingFunctions) {\n      this.resolvingFunctions.resolve();\n      delete this.resolvingFunctions;\n    }\n  }\n\n  async preservingPermanentElements(callback) {\n    await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);\n  }\n\n  focusFirstAutofocusableElement() {\n    if (this.shouldAutofocus) {\n      const element = this.connectedSnapshot.firstAutofocusableElement;\n      if (element) {\n        element.focus();\n      }\n    }\n  }\n\n  // Bardo delegate\n\n  enteringBardo(currentPermanentElement) {\n    if (this.#activeElement) return\n\n    if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {\n      this.#activeElement = this.currentSnapshot.activeElement;\n    }\n  }\n\n  leavingBardo(currentPermanentElement) {\n    if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {\n      this.#activeElement.focus();\n\n      this.#activeElement = null;\n    }\n  }\n\n  get connectedSnapshot() {\n    return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot\n  }\n\n  get currentElement() {\n    return this.currentSnapshot.element\n  }\n\n  get newElement() {\n    return this.newSnapshot.element\n  }\n\n  get permanentElementMap() {\n    return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot)\n  }\n\n  get renderMethod() {\n    return \"replace\"\n  }\n}\n\nclass FrameRenderer extends Renderer {\n  static renderElement(currentElement, newElement) {\n    const destinationRange = document.createRange();\n    destinationRange.selectNodeContents(currentElement);\n    destinationRange.deleteContents();\n\n    const frameElement = newElement;\n    const sourceRange = frameElement.ownerDocument?.createRange();\n    if (sourceRange) {\n      sourceRange.selectNodeContents(frameElement);\n      currentElement.appendChild(sourceRange.extractContents());\n    }\n  }\n\n  constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {\n    super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);\n    this.delegate = delegate;\n  }\n\n  get shouldRender() {\n    return true\n  }\n\n  async render() {\n    await nextRepaint();\n    this.preservingPermanentElements(() => {\n      this.loadFrameElement();\n    });\n    this.scrollFrameIntoView();\n    await nextRepaint();\n    this.focusFirstAutofocusableElement();\n    await nextRepaint();\n    this.activateScriptElements();\n  }\n\n  loadFrameElement() {\n    this.delegate.willRenderFrame(this.currentElement, this.newElement);\n    this.renderElement(this.currentElement, this.newElement);\n  }\n\n  scrollFrameIntoView() {\n    if (this.currentElement.autoscroll || this.newElement.autoscroll) {\n      const element = this.currentElement.firstElementChild;\n      const block = readScrollLogicalPosition(this.currentElement.getAttribute(\"data-autoscroll-block\"), \"end\");\n      const behavior = readScrollBehavior(this.currentElement.getAttribute(\"data-autoscroll-behavior\"), \"auto\");\n\n      if (element) {\n        element.scrollIntoView({ block, behavior });\n        return true\n      }\n    }\n    return false\n  }\n\n  activateScriptElements() {\n    for (const inertScriptElement of this.newScriptElements) {\n      const activatedScriptElement = activateScriptElement(inertScriptElement);\n      inertScriptElement.replaceWith(activatedScriptElement);\n    }\n  }\n\n  get newScriptElements() {\n    return this.currentElement.querySelectorAll(\"script\")\n  }\n}\n\nfunction readScrollLogicalPosition(value, defaultValue) {\n  if (value == \"end\" || value == \"start\" || value == \"center\" || value == \"nearest\") {\n    return value\n  } else {\n    return defaultValue\n  }\n}\n\nfunction readScrollBehavior(value, defaultValue) {\n  if (value == \"auto\" || value == \"smooth\") {\n    return value\n  } else {\n    return defaultValue\n  }\n}\n\n/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   * @property {Element[]} activeElementAndParents\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n    // this is safe even with siblings, because normalizeParent returns a SlicedParentNode if needed.\n    return Array.from(oldParent.childNodes);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (\n      activeElementId &&\n      activeElementId !== document.activeElement?.getAttribute(\"id\")\n    ) {\n      activeElement = ctx.target.querySelector(`[id=\"${activeElementId}\"]`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element) {\n          // we can pretend the id is non-null because the next `.has` line will reject it if not\n          const newChildId = /** @type {String} */ (\n            newChild.getAttribute(\"id\")\n          );\n          if (ctx.persistentIds.has(newChildId)) {\n            // move it and all its children here and morph\n            const movedChild = moveBeforeById(\n              oldParent,\n              newChildId,\n              insertionPoint,\n              ctx,\n            );\n            morphNode(movedChild, newChild, ctx);\n            insertionPoint = movedChild.nextSibling;\n            continue;\n          }\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          // @ts-ignore pretend cursor is Element rather than Node, we're just testing for array inclusion\n          if (ctx.activeElementAndParents.includes(cursor)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          // We can't use .id because of form input shadowing, and we can't count on .getAttribute's presence because it could be a document-fragment\n          (!oldElt.getAttribute?.(\"id\") ||\n            oldElt.getAttribute?.(\"id\") === newElt.getAttribute?.(\"id\"))\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          // ctx.target.id unsafe because of form input shadowing\n          // ctx.target could be a document fragment which doesn't have `getAttribute`\n          (ctx.target.getAttribute?.(\"id\") === id && ctx.target) ||\n            ctx.target.querySelector(`[id=\"${id}\"]`) ||\n            ctx.pantry.querySelector(`[id=\"${id}\"]`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      // we know id is non-null String, because this function is only called on elements with ids\n      const id = /** @type {String} */ (element.getAttribute(\"id\"));\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ; else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        activeElementAndParents: createActiveElementAndParents(oldNode),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * @param {Element} oldNode\n     * @returns {Element[]}\n     */\n    function createActiveElementAndParents(oldNode) {\n      /** @type {Element[]} */\n      let activeElementAndParents = [];\n      let elt = document.activeElement;\n      if (elt?.tagName !== \"BODY\" && oldNode.contains(elt)) {\n        while (elt) {\n          activeElementAndParents.push(elt);\n          if (elt === oldNode) break;\n          elt = elt.parentElement;\n        }\n      }\n      return activeElementAndParents;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      // root could be a document fragment which doesn't have `getAttribute`\n      if (root.getAttribute?.(\"id\")) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        // we can pretend id is non-null String, because the .has line will reject it immediately if not\n        const id = /** @type {String} */ (elt.getAttribute(\"id\"));\n        if (persistentIds.has(id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so instead we create a fake parent node that only sees a slice of its children.\n          /** @type {Element} */\n          return /** @type {any} */ (new SlicedParentNode(newContent));\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * A fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * This is useful because the node may have siblings that we don't want in the morph, and it may also be moved\n     * or replaced with one or more elements during the morph. This class effectively allows us a window into\n     * a slice of a node's children.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849\u20131916)\n     */\n    class SlicedParentNode {\n      /** @param {Node} node */\n      constructor(node) {\n        this.originalNode = node;\n        this.realParentNode = /** @type {Element} */ (node.parentNode);\n        this.previousSibling = node.previousSibling;\n        this.nextSibling = node.nextSibling;\n      }\n\n      /** @returns {Node[]} */\n      get childNodes() {\n        // return slice of realParent's current childNodes, based on previousSibling and nextSibling\n        const nodes = [];\n        let cursor = this.previousSibling\n          ? this.previousSibling.nextSibling\n          : this.realParentNode.firstChild;\n        while (cursor && cursor != this.nextSibling) {\n          nodes.push(cursor);\n          cursor = cursor.nextSibling;\n        }\n        return nodes;\n      }\n\n      /**\n       * @param {string} selector\n       * @returns {Element[]}\n       */\n      querySelectorAll(selector) {\n        return this.childNodes.reduce((results, node) => {\n          if (node instanceof Element) {\n            if (node.matches(selector)) results.push(node);\n            const nodeList = node.querySelectorAll(selector);\n            for (let i = 0; i < nodeList.length; i++) {\n              results.push(nodeList[i]);\n            }\n          }\n          return results;\n        }, /** @type {Element[]} */ ([]));\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      insertBefore(node, referenceNode) {\n        return this.realParentNode.insertBefore(node, referenceNode);\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      moveBefore(node, referenceNode) {\n        // @ts-ignore - use new moveBefore feature\n        return this.realParentNode.moveBefore(node, referenceNode);\n      }\n\n      /**\n       * for later use with populateIdMapWithTree to halt upwards iteration\n       * @returns {Node}\n       */\n      get __idiomorphRoot() {\n        return this.originalNode;\n      }\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\n/**\n * Morph the state of the currentElement based on the attributes and contents of\n * the newElement. Morphing may dispatch turbo:before-morph-element,\n * turbo:before-morph-attribute, and turbo:morph-element events.\n *\n * @param currentElement Element destination of morphing changes\n * @param newElement Element source of morphing changes\n */\nfunction morphElements(currentElement, newElement, { callbacks, ...options } = {}) {\n  Idiomorph.morph(currentElement, newElement, {\n    ...options,\n    callbacks: new DefaultIdiomorphCallbacks(callbacks)\n  });\n}\n\n/**\n * Morph the child elements of the currentElement based on the child elements of\n * the newElement. Morphing children may dispatch turbo:before-morph-element,\n * turbo:before-morph-attribute, and turbo:morph-element events.\n *\n * @param currentElement Element destination of morphing children changes\n * @param newElement Element source of morphing children changes\n */\nfunction morphChildren(currentElement, newElement, options = {}) {\n  morphElements(currentElement, newElement.childNodes, {\n    ...options,\n    morphStyle: \"innerHTML\"\n  });\n}\n\nfunction shouldRefreshFrameWithMorphing(currentFrame, newFrame) {\n  return currentFrame instanceof FrameElement &&\n    currentFrame.shouldReloadWithMorph && (!newFrame || areFramesCompatibleForRefreshing(currentFrame, newFrame)) &&\n    !currentFrame.closest(\"[data-turbo-permanent]\")\n}\n\nfunction areFramesCompatibleForRefreshing(currentFrame, newFrame) {\n  // newFrame cannot yet be an instance of FrameElement because custom\n  // elements don't get initialized until they're attached to the DOM, so\n  // test its Element#nodeName instead\n  return newFrame instanceof Element && newFrame.nodeName === \"TURBO-FRAME\" && currentFrame.id === newFrame.id &&\n  (!newFrame.getAttribute(\"src\") || urlsAreEqual(currentFrame.src, newFrame.getAttribute(\"src\")))\n}\n\nfunction closestFrameReloadableWithMorphing(node) {\n  return node.parentElement.closest(\"turbo-frame[src][refresh=morph]\")\n}\n\nclass DefaultIdiomorphCallbacks {\n  #beforeNodeMorphed\n\n  constructor({ beforeNodeMorphed } = {}) {\n    this.#beforeNodeMorphed = beforeNodeMorphed || (() => true);\n  }\n\n  beforeNodeAdded = (node) => {\n    return !(node.id && node.hasAttribute(\"data-turbo-permanent\") && document.getElementById(node.id))\n  }\n\n  beforeNodeMorphed = (currentElement, newElement) => {\n    if (currentElement instanceof Element) {\n      if (!currentElement.hasAttribute(\"data-turbo-permanent\") && this.#beforeNodeMorphed(currentElement, newElement)) {\n        const event = dispatch(\"turbo:before-morph-element\", {\n          cancelable: true,\n          target: currentElement,\n          detail: { currentElement, newElement }\n        });\n\n        return !event.defaultPrevented\n      } else {\n        return false\n      }\n    }\n  }\n\n  beforeAttributeUpdated = (attributeName, target, mutationType) => {\n    const event = dispatch(\"turbo:before-morph-attribute\", {\n      cancelable: true,\n      target,\n      detail: { attributeName, mutationType }\n    });\n\n    return !event.defaultPrevented\n  }\n\n  beforeNodeRemoved = (node) => {\n    return this.beforeNodeMorphed(node)\n  }\n\n  afterNodeMorphed = (currentElement, newElement) => {\n    if (currentElement instanceof Element) {\n      dispatch(\"turbo:morph-element\", {\n        target: currentElement,\n        detail: { currentElement, newElement }\n      });\n    }\n  }\n}\n\nclass MorphingFrameRenderer extends FrameRenderer {\n  static renderElement(currentElement, newElement) {\n    dispatch(\"turbo:before-frame-morph\", {\n      target: currentElement,\n      detail: { currentElement, newElement }\n    });\n\n    morphChildren(currentElement, newElement, {\n      callbacks: {\n        beforeNodeMorphed: (node, newNode) => {\n          if (\n            shouldRefreshFrameWithMorphing(node, newNode) &&\n              closestFrameReloadableWithMorphing(node) === currentElement\n          ) {\n            node.reload();\n            return false\n          }\n          return true\n        }\n      }\n    });\n  }\n\n  async preservingPermanentElements(callback) {\n    return await callback()\n  }\n}\n\nclass ProgressBar {\n  static animationDuration = 300 /*ms*/\n\n  static get defaultCSS() {\n    return unindent`\n      .turbo-progress-bar {\n        position: fixed;\n        display: block;\n        top: 0;\n        left: 0;\n        height: 3px;\n        background: #0076ff;\n        z-index: 2147483647;\n        transition:\n          width ${ProgressBar.animationDuration}ms ease-out,\n          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;\n        transform: translate3d(0, 0, 0);\n      }\n    `\n  }\n\n  hiding = false\n  value = 0\n  visible = false\n\n  constructor() {\n    this.stylesheetElement = this.createStylesheetElement();\n    this.progressElement = this.createProgressElement();\n    this.installStylesheetElement();\n    this.setValue(0);\n  }\n\n  show() {\n    if (!this.visible) {\n      this.visible = true;\n      this.installProgressElement();\n      this.startTrickling();\n    }\n  }\n\n  hide() {\n    if (this.visible && !this.hiding) {\n      this.hiding = true;\n      this.fadeProgressElement(() => {\n        this.uninstallProgressElement();\n        this.stopTrickling();\n        this.visible = false;\n        this.hiding = false;\n      });\n    }\n  }\n\n  setValue(value) {\n    this.value = value;\n    this.refresh();\n  }\n\n  // Private\n\n  installStylesheetElement() {\n    document.head.insertBefore(this.stylesheetElement, document.head.firstChild);\n  }\n\n  installProgressElement() {\n    this.progressElement.style.width = \"0\";\n    this.progressElement.style.opacity = \"1\";\n    document.documentElement.insertBefore(this.progressElement, document.body);\n    this.refresh();\n  }\n\n  fadeProgressElement(callback) {\n    this.progressElement.style.opacity = \"0\";\n    setTimeout(callback, ProgressBar.animationDuration * 1.5);\n  }\n\n  uninstallProgressElement() {\n    if (this.progressElement.parentNode) {\n      document.documentElement.removeChild(this.progressElement);\n    }\n  }\n\n  startTrickling() {\n    if (!this.trickleInterval) {\n      this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);\n    }\n  }\n\n  stopTrickling() {\n    window.clearInterval(this.trickleInterval);\n    delete this.trickleInterval;\n  }\n\n  trickle = () => {\n    this.setValue(this.value + Math.random() / 100);\n  }\n\n  refresh() {\n    requestAnimationFrame(() => {\n      this.progressElement.style.width = `${10 + this.value * 90}%`;\n    });\n  }\n\n  createStylesheetElement() {\n    const element = document.createElement(\"style\");\n    element.type = \"text/css\";\n    element.textContent = ProgressBar.defaultCSS;\n    const cspNonce = getCspNonce();\n    if (cspNonce) {\n      element.nonce = cspNonce;\n    }\n    return element\n  }\n\n  createProgressElement() {\n    const element = document.createElement(\"div\");\n    element.className = \"turbo-progress-bar\";\n    return element\n  }\n}\n\nclass HeadSnapshot extends Snapshot {\n  detailsByOuterHTML = this.children\n    .filter((element) => !elementIsNoscript(element))\n    .map((element) => elementWithoutNonce(element))\n    .reduce((result, element) => {\n      const { outerHTML } = element;\n      const details =\n        outerHTML in result\n          ? result[outerHTML]\n          : {\n              type: elementType(element),\n              tracked: elementIsTracked(element),\n              elements: []\n            };\n      return {\n        ...result,\n        [outerHTML]: {\n          ...details,\n          elements: [...details.elements, element]\n        }\n      }\n    }, {})\n\n  get trackedElementSignature() {\n    return Object.keys(this.detailsByOuterHTML)\n      .filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked)\n      .join(\"\")\n  }\n\n  getScriptElementsNotInSnapshot(snapshot) {\n    return this.getElementsMatchingTypeNotInSnapshot(\"script\", snapshot)\n  }\n\n  getStylesheetElementsNotInSnapshot(snapshot) {\n    return this.getElementsMatchingTypeNotInSnapshot(\"stylesheet\", snapshot)\n  }\n\n  getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {\n    return Object.keys(this.detailsByOuterHTML)\n      .filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML))\n      .map((outerHTML) => this.detailsByOuterHTML[outerHTML])\n      .filter(({ type }) => type == matchedType)\n      .map(({ elements: [element] }) => element)\n  }\n\n  get provisionalElements() {\n    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {\n      const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];\n      if (type == null && !tracked) {\n        return [...result, ...elements]\n      } else if (elements.length > 1) {\n        return [...result, ...elements.slice(1)]\n      } else {\n        return result\n      }\n    }, [])\n  }\n\n  getMetaValue(name) {\n    const element = this.findMetaElementByName(name);\n    return element ? element.getAttribute(\"content\") : null\n  }\n\n  findMetaElementByName(name) {\n    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {\n      const {\n        elements: [element]\n      } = this.detailsByOuterHTML[outerHTML];\n      return elementIsMetaElementWithName(element, name) ? element : result\n    }, undefined | undefined)\n  }\n}\n\nfunction elementType(element) {\n  if (elementIsScript(element)) {\n    return \"script\"\n  } else if (elementIsStylesheet(element)) {\n    return \"stylesheet\"\n  }\n}\n\nfunction elementIsTracked(element) {\n  return element.getAttribute(\"data-turbo-track\") == \"reload\"\n}\n\nfunction elementIsScript(element) {\n  const tagName = element.localName;\n  return tagName == \"script\"\n}\n\nfunction elementIsNoscript(element) {\n  const tagName = element.localName;\n  return tagName == \"noscript\"\n}\n\nfunction elementIsStylesheet(element) {\n  const tagName = element.localName;\n  return tagName == \"style\" || (tagName == \"link\" && element.getAttribute(\"rel\") == \"stylesheet\")\n}\n\nfunction elementIsMetaElementWithName(element, name) {\n  const tagName = element.localName;\n  return tagName == \"meta\" && element.getAttribute(\"name\") == name\n}\n\nfunction elementWithoutNonce(element) {\n  if (element.hasAttribute(\"nonce\")) {\n    element.setAttribute(\"nonce\", \"\");\n  }\n\n  return element\n}\n\nclass PageSnapshot extends Snapshot {\n  static fromHTMLString(html = \"\") {\n    return this.fromDocument(parseHTMLDocument(html))\n  }\n\n  static fromElement(element) {\n    return this.fromDocument(element.ownerDocument)\n  }\n\n  static fromDocument({ documentElement, body, head }) {\n    return new this(documentElement, body, new HeadSnapshot(head))\n  }\n\n  constructor(documentElement, body, headSnapshot) {\n    super(body);\n    this.documentElement = documentElement;\n    this.headSnapshot = headSnapshot;\n  }\n\n  clone() {\n    const clonedElement = this.element.cloneNode(true);\n\n    const selectElements = this.element.querySelectorAll(\"select\");\n    const clonedSelectElements = clonedElement.querySelectorAll(\"select\");\n\n    for (const [index, source] of selectElements.entries()) {\n      const clone = clonedSelectElements[index];\n      for (const option of clone.selectedOptions) option.selected = false;\n      for (const option of source.selectedOptions) clone.options[option.index].selected = true;\n    }\n\n    for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type=\"password\"]')) {\n      clonedPasswordInput.value = \"\";\n    }\n\n    for (const clonedNoscriptElement of clonedElement.querySelectorAll(\"noscript\")) {\n      clonedNoscriptElement.remove();\n    }\n\n    return new PageSnapshot(this.documentElement, clonedElement, this.headSnapshot)\n  }\n\n  get lang() {\n    return this.documentElement.getAttribute(\"lang\")\n  }\n\n  get dir() {\n    return this.documentElement.getAttribute(\"dir\")\n  }\n\n  get headElement() {\n    return this.headSnapshot.element\n  }\n\n  get rootLocation() {\n    const root = this.getSetting(\"root\") ?? \"/\";\n    return expandURL(root)\n  }\n\n  get cacheControlValue() {\n    return this.getSetting(\"cache-control\")\n  }\n\n  get isPreviewable() {\n    return this.cacheControlValue != \"no-preview\"\n  }\n\n  get isCacheable() {\n    return this.cacheControlValue != \"no-cache\"\n  }\n\n  get isVisitable() {\n    return this.getSetting(\"visit-control\") != \"reload\"\n  }\n\n  get prefersViewTransitions() {\n    const viewTransitionEnabled = this.getSetting(\"view-transition\") === \"true\" || this.headSnapshot.getMetaValue(\"view-transition\") === \"same-origin\";\n    return viewTransitionEnabled && !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\n  }\n\n  get refreshMethod() {\n    return this.getSetting(\"refresh-method\")\n  }\n\n  get refreshScroll() {\n    return this.getSetting(\"refresh-scroll\")\n  }\n\n  // Private\n\n  getSetting(name) {\n    return this.headSnapshot.getMetaValue(`turbo-${name}`)\n  }\n}\n\nclass ViewTransitioner {\n  #viewTransitionStarted = false\n  #lastOperation = Promise.resolve()\n\n  renderChange(useViewTransition, render) {\n    if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {\n      this.#viewTransitionStarted = true;\n      this.#lastOperation = this.#lastOperation.then(async () => {\n        await document.startViewTransition(render).finished;\n      });\n    } else {\n      this.#lastOperation = this.#lastOperation.then(render);\n    }\n\n    return this.#lastOperation\n  }\n\n  get viewTransitionsAvailable() {\n    return document.startViewTransition\n  }\n}\n\nconst defaultOptions = {\n  action: \"advance\",\n  historyChanged: false,\n  visitCachedSnapshot: () => {},\n  willRender: true,\n  updateHistory: true,\n  shouldCacheSnapshot: true,\n  acceptsStreamResponse: false,\n  refresh: {}\n};\n\nconst TimingMetric = {\n  visitStart: \"visitStart\",\n  requestStart: \"requestStart\",\n  requestEnd: \"requestEnd\",\n  visitEnd: \"visitEnd\"\n};\n\nconst VisitState = {\n  initialized: \"initialized\",\n  started: \"started\",\n  canceled: \"canceled\",\n  failed: \"failed\",\n  completed: \"completed\"\n};\n\nconst SystemStatusCode = {\n  networkFailure: 0,\n  timeoutFailure: -1,\n  contentTypeMismatch: -2\n};\n\nconst Direction = {\n  advance: \"forward\",\n  restore: \"back\",\n  replace: \"none\"\n};\n\nclass Visit {\n  identifier = uuid() // Required by turbo-ios\n  timingMetrics = {}\n\n  followedRedirect = false\n  historyChanged = false\n  scrolled = false\n  shouldCacheSnapshot = true\n  acceptsStreamResponse = false\n  snapshotCached = false\n  state = VisitState.initialized\n  viewTransitioner = new ViewTransitioner()\n\n  constructor(delegate, location, restorationIdentifier, options = {}) {\n    this.delegate = delegate;\n    this.location = location;\n    this.restorationIdentifier = restorationIdentifier || uuid();\n\n    const {\n      action,\n      historyChanged,\n      referrer,\n      snapshot,\n      snapshotHTML,\n      response,\n      visitCachedSnapshot,\n      willRender,\n      updateHistory,\n      shouldCacheSnapshot,\n      acceptsStreamResponse,\n      direction,\n      refresh\n    } = {\n      ...defaultOptions,\n      ...options\n    };\n    this.action = action;\n    this.historyChanged = historyChanged;\n    this.referrer = referrer;\n    this.snapshot = snapshot;\n    this.snapshotHTML = snapshotHTML;\n    this.response = response;\n    this.isPageRefresh = this.view.isPageRefresh(this);\n    this.visitCachedSnapshot = visitCachedSnapshot;\n    this.willRender = willRender;\n    this.updateHistory = updateHistory;\n    this.scrolled = !willRender;\n    this.shouldCacheSnapshot = shouldCacheSnapshot;\n    this.acceptsStreamResponse = acceptsStreamResponse;\n    this.direction = direction || Direction[action];\n    this.refresh = refresh;\n  }\n\n  get adapter() {\n    return this.delegate.adapter\n  }\n\n  get view() {\n    return this.delegate.view\n  }\n\n  get history() {\n    return this.delegate.history\n  }\n\n  get restorationData() {\n    return this.history.getRestorationDataForIdentifier(this.restorationIdentifier)\n  }\n\n  start() {\n    if (this.state == VisitState.initialized) {\n      this.recordTimingMetric(TimingMetric.visitStart);\n      this.state = VisitState.started;\n      this.adapter.visitStarted(this);\n      this.delegate.visitStarted(this);\n    }\n  }\n\n  cancel() {\n    if (this.state == VisitState.started) {\n      if (this.request) {\n        this.request.cancel();\n      }\n      this.cancelRender();\n      this.state = VisitState.canceled;\n    }\n  }\n\n  complete() {\n    if (this.state == VisitState.started) {\n      this.recordTimingMetric(TimingMetric.visitEnd);\n      this.adapter.visitCompleted(this);\n      this.state = VisitState.completed;\n      this.followRedirect();\n\n      if (!this.followedRedirect) {\n        this.delegate.visitCompleted(this);\n      }\n    }\n  }\n\n  fail() {\n    if (this.state == VisitState.started) {\n      this.state = VisitState.failed;\n      this.adapter.visitFailed(this);\n      this.delegate.visitCompleted(this);\n    }\n  }\n\n  changeHistory() {\n    if (!this.historyChanged && this.updateHistory) {\n      const actionForHistory = this.location.href === this.referrer?.href ? \"replace\" : this.action;\n      const method = getHistoryMethodForAction(actionForHistory);\n      this.history.update(method, this.location, this.restorationIdentifier);\n      this.historyChanged = true;\n    }\n  }\n\n  issueRequest() {\n    if (this.hasPreloadedResponse()) {\n      this.simulateRequest();\n    } else if (this.shouldIssueRequest() && !this.request) {\n      this.request = new FetchRequest(this, FetchMethod.get, this.location);\n      this.request.perform();\n    }\n  }\n\n  simulateRequest() {\n    if (this.response) {\n      this.startRequest();\n      this.recordResponse();\n      this.finishRequest();\n    }\n  }\n\n  startRequest() {\n    this.recordTimingMetric(TimingMetric.requestStart);\n    this.adapter.visitRequestStarted(this);\n  }\n\n  recordResponse(response = this.response) {\n    this.response = response;\n    if (response) {\n      const { statusCode } = response;\n      if (isSuccessful(statusCode)) {\n        this.adapter.visitRequestCompleted(this);\n      } else {\n        this.adapter.visitRequestFailedWithStatusCode(this, statusCode);\n      }\n    }\n  }\n\n  finishRequest() {\n    this.recordTimingMetric(TimingMetric.requestEnd);\n    this.adapter.visitRequestFinished(this);\n  }\n\n  loadResponse() {\n    if (this.response) {\n      const { statusCode, responseHTML } = this.response;\n      this.render(async () => {\n        if (this.shouldCacheSnapshot) this.cacheSnapshot();\n        if (this.view.renderPromise) await this.view.renderPromise;\n\n        if (isSuccessful(statusCode) && responseHTML != null) {\n          const snapshot = PageSnapshot.fromHTMLString(responseHTML);\n          await this.renderPageSnapshot(snapshot, false);\n\n          this.adapter.visitRendered(this);\n          this.complete();\n        } else {\n          await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);\n          this.adapter.visitRendered(this);\n          this.fail();\n        }\n      });\n    }\n  }\n\n  getCachedSnapshot() {\n    const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();\n\n    if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {\n      if (this.action == \"restore\" || snapshot.isPreviewable) {\n        return snapshot\n      }\n    }\n  }\n\n  getPreloadedSnapshot() {\n    if (this.snapshotHTML) {\n      return PageSnapshot.fromHTMLString(this.snapshotHTML)\n    }\n  }\n\n  hasCachedSnapshot() {\n    return this.getCachedSnapshot() != null\n  }\n\n  loadCachedSnapshot() {\n    const snapshot = this.getCachedSnapshot();\n    if (snapshot) {\n      const isPreview = this.shouldIssueRequest();\n      this.render(async () => {\n        this.cacheSnapshot();\n        if (this.isPageRefresh) {\n          this.adapter.visitRendered(this);\n        } else {\n          if (this.view.renderPromise) await this.view.renderPromise;\n\n          await this.renderPageSnapshot(snapshot, isPreview);\n\n          this.adapter.visitRendered(this);\n          if (!isPreview) {\n            this.complete();\n          }\n        }\n      });\n    }\n  }\n\n  followRedirect() {\n    if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {\n      this.adapter.visitProposedToLocation(this.redirectedToLocation, {\n        action: \"replace\",\n        response: this.response,\n        shouldCacheSnapshot: false,\n        willRender: false\n      });\n      this.followedRedirect = true;\n    }\n  }\n\n  // Fetch request delegate\n\n  prepareRequest(request) {\n    if (this.acceptsStreamResponse) {\n      request.acceptResponseType(StreamMessage.contentType);\n    }\n  }\n\n  requestStarted() {\n    this.startRequest();\n  }\n\n  requestPreventedHandlingResponse(_request, _response) {}\n\n  async requestSucceededWithResponse(request, response) {\n    const responseHTML = await response.responseHTML;\n    const { redirected, statusCode } = response;\n    if (responseHTML == undefined) {\n      this.recordResponse({\n        statusCode: SystemStatusCode.contentTypeMismatch,\n        redirected\n      });\n    } else {\n      this.redirectedToLocation = response.redirected ? response.location : undefined;\n      this.recordResponse({ statusCode: statusCode, responseHTML, redirected });\n    }\n  }\n\n  async requestFailedWithResponse(request, response) {\n    const responseHTML = await response.responseHTML;\n    const { redirected, statusCode } = response;\n    if (responseHTML == undefined) {\n      this.recordResponse({\n        statusCode: SystemStatusCode.contentTypeMismatch,\n        redirected\n      });\n    } else {\n      this.recordResponse({ statusCode: statusCode, responseHTML, redirected });\n    }\n  }\n\n  requestErrored(_request, _error) {\n    this.recordResponse({\n      statusCode: SystemStatusCode.networkFailure,\n      redirected: false\n    });\n  }\n\n  requestFinished() {\n    this.finishRequest();\n  }\n\n  // Scrolling\n\n  performScroll() {\n    if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {\n      if (this.action == \"restore\") {\n        this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();\n      } else {\n        this.scrollToAnchor() || this.view.scrollToTop();\n      }\n\n      this.scrolled = true;\n    }\n  }\n\n  scrollToRestoredPosition() {\n    const { scrollPosition } = this.restorationData;\n    if (scrollPosition) {\n      this.view.scrollToPosition(scrollPosition);\n      return true\n    }\n  }\n\n  scrollToAnchor() {\n    const anchor = getAnchor(this.location);\n    if (anchor != null) {\n      this.view.scrollToAnchor(anchor);\n      return true\n    }\n  }\n\n  // Instrumentation\n\n  recordTimingMetric(metric) {\n    this.timingMetrics[metric] = new Date().getTime();\n  }\n\n  getTimingMetrics() {\n    return { ...this.timingMetrics }\n  }\n\n  // Private\n\n  hasPreloadedResponse() {\n    return typeof this.response == \"object\"\n  }\n\n  shouldIssueRequest() {\n    if (this.action == \"restore\") {\n      return !this.hasCachedSnapshot()\n    } else {\n      return this.willRender\n    }\n  }\n\n  cacheSnapshot() {\n    if (!this.snapshotCached) {\n      this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));\n      this.snapshotCached = true;\n    }\n  }\n\n  async render(callback) {\n    this.cancelRender();\n    await new Promise((resolve) => {\n      this.frame =\n        document.visibilityState === \"hidden\" ? setTimeout(() => resolve(), 0) : requestAnimationFrame(() => resolve());\n    });\n    await callback();\n    delete this.frame;\n  }\n\n  async renderPageSnapshot(snapshot, isPreview) {\n    await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {\n      await this.view.renderPage(snapshot, isPreview, this.willRender, this);\n      this.performScroll();\n    });\n  }\n\n  cancelRender() {\n    if (this.frame) {\n      cancelAnimationFrame(this.frame);\n      delete this.frame;\n    }\n  }\n}\n\nfunction isSuccessful(statusCode) {\n  return statusCode >= 200 && statusCode < 300\n}\n\nclass BrowserAdapter {\n  progressBar = new ProgressBar()\n\n  constructor(session) {\n    this.session = session;\n  }\n\n  visitProposedToLocation(location, options) {\n    if (locationIsVisitable(location, this.navigator.rootLocation)) {\n      this.navigator.startVisit(location, options?.restorationIdentifier || uuid(), options);\n    } else {\n      window.location.href = location.toString();\n    }\n  }\n\n  visitStarted(visit) {\n    this.location = visit.location;\n    this.redirectedToLocation = null;\n\n    visit.loadCachedSnapshot();\n    visit.issueRequest();\n  }\n\n  visitRequestStarted(visit) {\n    this.progressBar.setValue(0);\n    if (visit.hasCachedSnapshot() || visit.action != \"restore\") {\n      this.showVisitProgressBarAfterDelay();\n    } else {\n      this.showProgressBar();\n    }\n  }\n\n  visitRequestCompleted(visit) {\n    visit.loadResponse();\n\n    if (visit.response.redirected) {\n      this.redirectedToLocation = visit.redirectedToLocation;\n    }\n  }\n\n  visitRequestFailedWithStatusCode(visit, statusCode) {\n    switch (statusCode) {\n      case SystemStatusCode.networkFailure:\n      case SystemStatusCode.timeoutFailure:\n      case SystemStatusCode.contentTypeMismatch:\n        return this.reload({\n          reason: \"request_failed\",\n          context: {\n            statusCode\n          }\n        })\n      default:\n        return visit.loadResponse()\n    }\n  }\n\n  visitRequestFinished(_visit) {}\n\n  visitCompleted(_visit) {\n    this.progressBar.setValue(1);\n    this.hideVisitProgressBar();\n  }\n\n  pageInvalidated(reason) {\n    this.reload(reason);\n  }\n\n  visitFailed(_visit) {\n    this.progressBar.setValue(1);\n    this.hideVisitProgressBar();\n  }\n\n  visitRendered(_visit) {}\n\n  // Link prefetching\n\n  linkPrefetchingIsEnabledForLocation(location) {\n    return true\n  }\n\n  // Form Submission Delegate\n\n  formSubmissionStarted(_formSubmission) {\n    this.progressBar.setValue(0);\n    this.showFormProgressBarAfterDelay();\n  }\n\n  formSubmissionFinished(_formSubmission) {\n    this.progressBar.setValue(1);\n    this.hideFormProgressBar();\n  }\n\n  // Private\n\n  showVisitProgressBarAfterDelay() {\n    this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);\n  }\n\n  hideVisitProgressBar() {\n    this.progressBar.hide();\n    if (this.visitProgressBarTimeout != null) {\n      window.clearTimeout(this.visitProgressBarTimeout);\n      delete this.visitProgressBarTimeout;\n    }\n  }\n\n  showFormProgressBarAfterDelay() {\n    if (this.formProgressBarTimeout == null) {\n      this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);\n    }\n  }\n\n  hideFormProgressBar() {\n    this.progressBar.hide();\n    if (this.formProgressBarTimeout != null) {\n      window.clearTimeout(this.formProgressBarTimeout);\n      delete this.formProgressBarTimeout;\n    }\n  }\n\n  showProgressBar = () => {\n    this.progressBar.show();\n  }\n\n  reload(reason) {\n    dispatch(\"turbo:reload\", { detail: reason });\n\n    window.location.href = (this.redirectedToLocation || this.location)?.toString() || window.location.href;\n  }\n\n  get navigator() {\n    return this.session.navigator\n  }\n}\n\nclass CacheObserver {\n  selector = \"[data-turbo-temporary]\"\n\n  started = false\n\n  start() {\n    if (!this.started) {\n      this.started = true;\n      addEventListener(\"turbo:before-cache\", this.removeTemporaryElements, false);\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.started = false;\n      removeEventListener(\"turbo:before-cache\", this.removeTemporaryElements, false);\n    }\n  }\n\n  removeTemporaryElements = (_event) => {\n    for (const element of this.temporaryElements) {\n      element.remove();\n    }\n  }\n\n  get temporaryElements() {\n    return [...document.querySelectorAll(this.selector)]\n  }\n}\n\nclass FrameRedirector {\n  constructor(session, element) {\n    this.session = session;\n    this.element = element;\n    this.linkInterceptor = new LinkInterceptor(this, element);\n    this.formSubmitObserver = new FormSubmitObserver(this, element);\n  }\n\n  start() {\n    this.linkInterceptor.start();\n    this.formSubmitObserver.start();\n  }\n\n  stop() {\n    this.linkInterceptor.stop();\n    this.formSubmitObserver.stop();\n  }\n\n  // Link interceptor delegate\n\n  shouldInterceptLinkClick(element, _location, _event) {\n    return this.#shouldRedirect(element)\n  }\n\n  linkClickIntercepted(element, url, event) {\n    const frame = this.#findFrameElement(element);\n    if (frame) {\n      frame.delegate.linkClickIntercepted(element, url, event);\n    }\n  }\n\n  // Form submit observer delegate\n\n  willSubmitForm(element, submitter) {\n    return (\n      element.closest(\"turbo-frame\") == null &&\n      this.#shouldSubmit(element, submitter) &&\n      this.#shouldRedirect(element, submitter)\n    )\n  }\n\n  formSubmitted(element, submitter) {\n    const frame = this.#findFrameElement(element, submitter);\n    if (frame) {\n      frame.delegate.formSubmitted(element, submitter);\n    }\n  }\n\n  #shouldSubmit(form, submitter) {\n    const action = getAction$1(form, submitter);\n    const meta = this.element.ownerDocument.querySelector(`meta[name=\"turbo-root\"]`);\n    const rootLocation = expandURL(meta?.content ?? \"/\");\n\n    return this.#shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation)\n  }\n\n  #shouldRedirect(element, submitter) {\n    const isNavigatable =\n      element instanceof HTMLFormElement\n        ? this.session.submissionIsNavigatable(element, submitter)\n        : this.session.elementIsNavigatable(element);\n\n    if (isNavigatable) {\n      const frame = this.#findFrameElement(element, submitter);\n      return frame ? frame != element.closest(\"turbo-frame\") : false\n    } else {\n      return false\n    }\n  }\n\n  #findFrameElement(element, submitter) {\n    const id = submitter?.getAttribute(\"data-turbo-frame\") || element.getAttribute(\"data-turbo-frame\");\n    if (id && id != \"_top\") {\n      const frame = this.element.querySelector(`#${id}:not([disabled])`);\n      if (frame instanceof FrameElement) {\n        return frame\n      }\n    }\n  }\n}\n\nclass History {\n  location\n  restorationIdentifier = uuid()\n  restorationData = {}\n  started = false\n  currentIndex = 0\n\n  constructor(delegate) {\n    this.delegate = delegate;\n  }\n\n  start() {\n    if (!this.started) {\n      addEventListener(\"popstate\", this.onPopState, false);\n      this.currentIndex = history.state?.turbo?.restorationIndex || 0;\n      this.started = true;\n      this.replace(new URL(window.location.href));\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      removeEventListener(\"popstate\", this.onPopState, false);\n      this.started = false;\n    }\n  }\n\n  push(location, restorationIdentifier) {\n    this.update(history.pushState, location, restorationIdentifier);\n  }\n\n  replace(location, restorationIdentifier) {\n    this.update(history.replaceState, location, restorationIdentifier);\n  }\n\n  update(method, location, restorationIdentifier = uuid()) {\n    if (method === history.pushState) ++this.currentIndex;\n\n    const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };\n    method.call(history, state, \"\", location.href);\n    this.location = location;\n    this.restorationIdentifier = restorationIdentifier;\n  }\n\n  // Restoration data\n\n  getRestorationDataForIdentifier(restorationIdentifier) {\n    return this.restorationData[restorationIdentifier] || {}\n  }\n\n  updateRestorationData(additionalData) {\n    const { restorationIdentifier } = this;\n    const restorationData = this.restorationData[restorationIdentifier];\n    this.restorationData[restorationIdentifier] = {\n      ...restorationData,\n      ...additionalData\n    };\n  }\n\n  // Scroll restoration\n\n  assumeControlOfScrollRestoration() {\n    if (!this.previousScrollRestoration) {\n      this.previousScrollRestoration = history.scrollRestoration ?? \"auto\";\n      history.scrollRestoration = \"manual\";\n    }\n  }\n\n  relinquishControlOfScrollRestoration() {\n    if (this.previousScrollRestoration) {\n      history.scrollRestoration = this.previousScrollRestoration;\n      delete this.previousScrollRestoration;\n    }\n  }\n\n  // Event handlers\n\n  onPopState = (event) => {\n    const { turbo } = event.state || {};\n    this.location = new URL(window.location.href);\n\n    if (turbo) {\n      const { restorationIdentifier, restorationIndex } = turbo;\n      this.restorationIdentifier = restorationIdentifier;\n      const direction = restorationIndex > this.currentIndex ? \"forward\" : \"back\";\n      this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);\n      this.currentIndex = restorationIndex;\n    } else {\n      this.currentIndex++;\n      this.delegate.historyPoppedWithEmptyState(this.location);\n    }\n  }\n}\n\nclass LinkPrefetchObserver {\n  started = false\n  #prefetchedLink = null\n\n  constructor(delegate, eventTarget) {\n    this.delegate = delegate;\n    this.eventTarget = eventTarget;\n  }\n\n  start() {\n    if (this.started) return\n\n    if (this.eventTarget.readyState === \"loading\") {\n      this.eventTarget.addEventListener(\"DOMContentLoaded\", this.#enable, { once: true });\n    } else {\n      this.#enable();\n    }\n  }\n\n  stop() {\n    if (!this.started) return\n\n    this.eventTarget.removeEventListener(\"mouseenter\", this.#tryToPrefetchRequest, {\n      capture: true,\n      passive: true\n    });\n    this.eventTarget.removeEventListener(\"mouseleave\", this.#cancelRequestIfObsolete, {\n      capture: true,\n      passive: true\n    });\n\n    this.eventTarget.removeEventListener(\"turbo:before-fetch-request\", this.#tryToUsePrefetchedRequest, true);\n    this.started = false;\n  }\n\n  #enable = () => {\n    this.eventTarget.addEventListener(\"mouseenter\", this.#tryToPrefetchRequest, {\n      capture: true,\n      passive: true\n    });\n    this.eventTarget.addEventListener(\"mouseleave\", this.#cancelRequestIfObsolete, {\n      capture: true,\n      passive: true\n    });\n\n    this.eventTarget.addEventListener(\"turbo:before-fetch-request\", this.#tryToUsePrefetchedRequest, true);\n    this.started = true;\n  }\n\n  #tryToPrefetchRequest = (event) => {\n    if (getMetaContent(\"turbo-prefetch\") === \"false\") return\n\n    const target = event.target;\n    const isLink = target.matches && target.matches(\"a[href]:not([target^=_]):not([download])\");\n\n    if (isLink && this.#isPrefetchable(target)) {\n      const link = target;\n      const location = getLocationForLink(link);\n\n      if (this.delegate.canPrefetchRequestToLocation(link, location)) {\n        this.#prefetchedLink = link;\n\n        const fetchRequest = new FetchRequest(\n          this,\n          FetchMethod.get,\n          location,\n          new URLSearchParams(),\n          target\n        );\n\n        fetchRequest.fetchOptions.priority = \"low\";\n\n        prefetchCache.putLater(location, fetchRequest, this.#cacheTtl);\n      }\n    }\n  }\n\n  #cancelRequestIfObsolete = (event) => {\n    if (event.target === this.#prefetchedLink) this.#cancelPrefetchRequest();\n  }\n\n  #cancelPrefetchRequest = () => {\n    prefetchCache.clear();\n    this.#prefetchedLink = null;\n  }\n\n  #tryToUsePrefetchedRequest = (event) => {\n    if (event.target.tagName !== \"FORM\" && event.detail.fetchOptions.method === \"GET\") {\n      const cached = prefetchCache.get(event.detail.url);\n\n      if (cached) {\n        // User clicked link, use cache response\n        event.detail.fetchRequest = cached;\n      }\n\n      prefetchCache.clear();\n    }\n  }\n\n  prepareRequest(request) {\n    const link = request.target;\n\n    request.headers[\"X-Sec-Purpose\"] = \"prefetch\";\n\n    const turboFrame = link.closest(\"turbo-frame\");\n    const turboFrameTarget = link.getAttribute(\"data-turbo-frame\") || turboFrame?.getAttribute(\"target\") || turboFrame?.id;\n\n    if (turboFrameTarget && turboFrameTarget !== \"_top\") {\n      request.headers[\"Turbo-Frame\"] = turboFrameTarget;\n    }\n  }\n\n  // Fetch request interface\n\n  requestSucceededWithResponse() {}\n\n  requestStarted(fetchRequest) {}\n\n  requestErrored(fetchRequest) {}\n\n  requestFinished(fetchRequest) {}\n\n  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}\n\n  requestFailedWithResponse(fetchRequest, fetchResponse) {}\n\n  get #cacheTtl() {\n    return Number(getMetaContent(\"turbo-prefetch-cache-time\")) || cacheTtl\n  }\n\n  #isPrefetchable(link) {\n    const href = link.getAttribute(\"href\");\n\n    if (!href) return false\n\n    if (unfetchableLink(link)) return false\n    if (linkToTheSamePage(link)) return false\n    if (linkOptsOut(link)) return false\n    if (nonSafeLink(link)) return false\n    if (eventPrevented(link)) return false\n\n    return true\n  }\n}\n\nconst unfetchableLink = (link) => {\n  return link.origin !== document.location.origin || ![\"http:\", \"https:\"].includes(link.protocol) || link.hasAttribute(\"target\")\n};\n\nconst linkToTheSamePage = (link) => {\n  return (link.pathname + link.search === document.location.pathname + document.location.search) || link.href.startsWith(\"#\")\n};\n\nconst linkOptsOut = (link) => {\n  if (link.getAttribute(\"data-turbo-prefetch\") === \"false\") return true\n  if (link.getAttribute(\"data-turbo\") === \"false\") return true\n\n  const turboPrefetchParent = findClosestRecursively(link, \"[data-turbo-prefetch]\");\n  if (turboPrefetchParent && turboPrefetchParent.getAttribute(\"data-turbo-prefetch\") === \"false\") return true\n\n  return false\n};\n\nconst nonSafeLink = (link) => {\n  const turboMethod = link.getAttribute(\"data-turbo-method\");\n  if (turboMethod && turboMethod.toLowerCase() !== \"get\") return true\n\n  if (isUJS(link)) return true\n  if (link.hasAttribute(\"data-turbo-confirm\")) return true\n  if (link.hasAttribute(\"data-turbo-stream\")) return true\n\n  return false\n};\n\nconst isUJS = (link) => {\n  return link.hasAttribute(\"data-remote\") || link.hasAttribute(\"data-behavior\") || link.hasAttribute(\"data-confirm\") || link.hasAttribute(\"data-method\")\n};\n\nconst eventPrevented = (link) => {\n  const event = dispatch(\"turbo:before-prefetch\", { target: link, cancelable: true });\n  return event.defaultPrevented\n};\n\nclass Navigator {\n  constructor(delegate) {\n    this.delegate = delegate;\n  }\n\n  proposeVisit(location, options = {}) {\n    if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) {\n      this.delegate.visitProposedToLocation(location, options);\n    }\n  }\n\n  startVisit(locatable, restorationIdentifier, options = {}) {\n    this.stop();\n    this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {\n      referrer: this.location,\n      ...options\n    });\n    this.currentVisit.start();\n  }\n\n  submitForm(form, submitter) {\n    this.stop();\n    this.formSubmission = new FormSubmission(this, form, submitter, true);\n\n    this.formSubmission.start();\n  }\n\n  stop() {\n    if (this.formSubmission) {\n      this.formSubmission.stop();\n      delete this.formSubmission;\n    }\n\n    if (this.currentVisit) {\n      this.currentVisit.cancel();\n      delete this.currentVisit;\n    }\n  }\n\n  get adapter() {\n    return this.delegate.adapter\n  }\n\n  get view() {\n    return this.delegate.view\n  }\n\n  get rootLocation() {\n    return this.view.snapshot.rootLocation\n  }\n\n  get history() {\n    return this.delegate.history\n  }\n\n  // Form submission delegate\n\n  formSubmissionStarted(formSubmission) {\n    // Not all adapters implement formSubmissionStarted\n    if (typeof this.adapter.formSubmissionStarted === \"function\") {\n      this.adapter.formSubmissionStarted(formSubmission);\n    }\n  }\n\n  async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {\n    if (formSubmission == this.formSubmission) {\n      const responseHTML = await fetchResponse.responseHTML;\n      if (responseHTML) {\n        const shouldCacheSnapshot = formSubmission.isSafe;\n        if (!shouldCacheSnapshot) {\n          this.view.clearSnapshotCache();\n        }\n\n        const { statusCode, redirected } = fetchResponse;\n        const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);\n        const visitOptions = {\n          action,\n          shouldCacheSnapshot,\n          response: { statusCode, responseHTML, redirected }\n        };\n        this.proposeVisit(fetchResponse.location, visitOptions);\n      }\n    }\n  }\n\n  async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {\n    const responseHTML = await fetchResponse.responseHTML;\n\n    if (responseHTML) {\n      const snapshot = PageSnapshot.fromHTMLString(responseHTML);\n      if (fetchResponse.serverError) {\n        await this.view.renderError(snapshot, this.currentVisit);\n      } else {\n        await this.view.renderPage(snapshot, false, true, this.currentVisit);\n      }\n      if (snapshot.refreshScroll !== \"preserve\") {\n        this.view.scrollToTop();\n      }\n      this.view.clearSnapshotCache();\n    }\n  }\n\n  formSubmissionErrored(formSubmission, error) {\n    console.error(error);\n  }\n\n  formSubmissionFinished(formSubmission) {\n    // Not all adapters implement formSubmissionFinished\n    if (typeof this.adapter.formSubmissionFinished === \"function\") {\n      this.adapter.formSubmissionFinished(formSubmission);\n    }\n  }\n\n  // Link prefetching\n\n  linkPrefetchingIsEnabledForLocation(location) {\n    // Not all adapters implement linkPrefetchingIsEnabledForLocation\n    if (typeof this.adapter.linkPrefetchingIsEnabledForLocation === \"function\") {\n      return this.adapter.linkPrefetchingIsEnabledForLocation(location)\n    }\n\n    return true\n  }\n\n  // Visit delegate\n\n  visitStarted(visit) {\n    this.delegate.visitStarted(visit);\n  }\n\n  visitCompleted(visit) {\n    this.delegate.visitCompleted(visit);\n    delete this.currentVisit;\n  }\n\n  // Same-page links are no longer handled with a Visit.\n  // This method is still needed for Turbo Native adapters.\n  locationWithActionIsSamePage(location, action) {\n    return false\n  }\n\n  // Visits\n\n  get location() {\n    return this.history.location\n  }\n\n  get restorationIdentifier() {\n    return this.history.restorationIdentifier\n  }\n\n  #getActionForFormSubmission(formSubmission, fetchResponse) {\n    const { submitter, formElement } = formSubmission;\n    return getVisitAction(submitter, formElement) || this.#getDefaultAction(fetchResponse)\n  }\n\n  #getDefaultAction(fetchResponse) {\n    const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;\n    return sameLocationRedirect ? \"replace\" : \"advance\"\n  }\n}\n\nconst PageStage = {\n  initial: 0,\n  loading: 1,\n  interactive: 2,\n  complete: 3\n};\n\nclass PageObserver {\n  stage = PageStage.initial\n  started = false\n\n  constructor(delegate) {\n    this.delegate = delegate;\n  }\n\n  start() {\n    if (!this.started) {\n      if (this.stage == PageStage.initial) {\n        this.stage = PageStage.loading;\n      }\n      document.addEventListener(\"readystatechange\", this.interpretReadyState, false);\n      addEventListener(\"pagehide\", this.pageWillUnload, false);\n      this.started = true;\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      document.removeEventListener(\"readystatechange\", this.interpretReadyState, false);\n      removeEventListener(\"pagehide\", this.pageWillUnload, false);\n      this.started = false;\n    }\n  }\n\n  interpretReadyState = () => {\n    const { readyState } = this;\n    if (readyState == \"interactive\") {\n      this.pageIsInteractive();\n    } else if (readyState == \"complete\") {\n      this.pageIsComplete();\n    }\n  }\n\n  pageIsInteractive() {\n    if (this.stage == PageStage.loading) {\n      this.stage = PageStage.interactive;\n      this.delegate.pageBecameInteractive();\n    }\n  }\n\n  pageIsComplete() {\n    this.pageIsInteractive();\n    if (this.stage == PageStage.interactive) {\n      this.stage = PageStage.complete;\n      this.delegate.pageLoaded();\n    }\n  }\n\n  pageWillUnload = () => {\n    this.delegate.pageWillUnload();\n  }\n\n  get readyState() {\n    return document.readyState\n  }\n}\n\nclass ScrollObserver {\n  started = false\n\n  constructor(delegate) {\n    this.delegate = delegate;\n  }\n\n  start() {\n    if (!this.started) {\n      addEventListener(\"scroll\", this.onScroll, false);\n      this.onScroll();\n      this.started = true;\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      removeEventListener(\"scroll\", this.onScroll, false);\n      this.started = false;\n    }\n  }\n\n  onScroll = () => {\n    this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });\n  }\n\n  // Private\n\n  updatePosition(position) {\n    this.delegate.scrollPositionChanged(position);\n  }\n}\n\nclass StreamMessageRenderer {\n  render({ fragment }) {\n    Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {\n      withAutofocusFromFragment(fragment, () => {\n        withPreservedFocus(() => {\n          document.documentElement.appendChild(fragment);\n        });\n      });\n    });\n  }\n\n  // Bardo delegate\n\n  enteringBardo(currentPermanentElement, newPermanentElement) {\n    newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));\n  }\n\n  leavingBardo() {}\n}\n\nfunction getPermanentElementMapForFragment(fragment) {\n  const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);\n  const permanentElementMap = {};\n  for (const permanentElementInDocument of permanentElementsInDocument) {\n    const { id } = permanentElementInDocument;\n\n    for (const streamElement of fragment.querySelectorAll(\"turbo-stream\")) {\n      const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);\n\n      if (elementInStream) {\n        permanentElementMap[id] = [permanentElementInDocument, elementInStream];\n      }\n    }\n  }\n\n  return permanentElementMap\n}\n\nasync function withAutofocusFromFragment(fragment, callback) {\n  const generatedID = `turbo-stream-autofocus-${uuid()}`;\n  const turboStreams = fragment.querySelectorAll(\"turbo-stream\");\n  const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);\n  let willAutofocusId = null;\n\n  if (elementWithAutofocus) {\n    if (elementWithAutofocus.id) {\n      willAutofocusId = elementWithAutofocus.id;\n    } else {\n      willAutofocusId = generatedID;\n    }\n\n    elementWithAutofocus.id = willAutofocusId;\n  }\n\n  callback();\n  await nextRepaint();\n\n  const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;\n\n  if (hasNoActiveElement && willAutofocusId) {\n    const elementToAutofocus = document.getElementById(willAutofocusId);\n\n    if (elementIsFocusable(elementToAutofocus)) {\n      elementToAutofocus.focus();\n    }\n    if (elementToAutofocus && elementToAutofocus.id == generatedID) {\n      elementToAutofocus.removeAttribute(\"id\");\n    }\n  }\n}\n\nasync function withPreservedFocus(callback) {\n  const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);\n\n  const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;\n\n  if (restoreFocusTo) {\n    const elementToFocus = document.getElementById(restoreFocusTo);\n\n    if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {\n      elementToFocus.focus();\n    }\n  }\n}\n\nfunction firstAutofocusableElementInStreams(nodeListOfStreamElements) {\n  for (const streamElement of nodeListOfStreamElements) {\n    const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);\n\n    if (elementWithAutofocus) return elementWithAutofocus\n  }\n\n  return null\n}\n\nclass StreamObserver {\n  sources = new Set()\n  #started = false\n\n  constructor(delegate) {\n    this.delegate = delegate;\n  }\n\n  start() {\n    if (!this.#started) {\n      this.#started = true;\n      addEventListener(\"turbo:before-fetch-response\", this.inspectFetchResponse, false);\n    }\n  }\n\n  stop() {\n    if (this.#started) {\n      this.#started = false;\n      removeEventListener(\"turbo:before-fetch-response\", this.inspectFetchResponse, false);\n    }\n  }\n\n  connectStreamSource(source) {\n    if (!this.streamSourceIsConnected(source)) {\n      this.sources.add(source);\n      source.addEventListener(\"message\", this.receiveMessageEvent, false);\n    }\n  }\n\n  disconnectStreamSource(source) {\n    if (this.streamSourceIsConnected(source)) {\n      this.sources.delete(source);\n      source.removeEventListener(\"message\", this.receiveMessageEvent, false);\n    }\n  }\n\n  streamSourceIsConnected(source) {\n    return this.sources.has(source)\n  }\n\n  inspectFetchResponse = (event) => {\n    const response = fetchResponseFromEvent(event);\n    if (response && fetchResponseIsStream(response)) {\n      event.preventDefault();\n      this.receiveMessageResponse(response);\n    }\n  }\n\n  receiveMessageEvent = (event) => {\n    if (this.#started && typeof event.data == \"string\") {\n      this.receiveMessageHTML(event.data);\n    }\n  }\n\n  async receiveMessageResponse(response) {\n    const html = await response.responseHTML;\n    if (html) {\n      this.receiveMessageHTML(html);\n    }\n  }\n\n  receiveMessageHTML(html) {\n    this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));\n  }\n}\n\nfunction fetchResponseFromEvent(event) {\n  const fetchResponse = event.detail?.fetchResponse;\n  if (fetchResponse instanceof FetchResponse) {\n    return fetchResponse\n  }\n}\n\nfunction fetchResponseIsStream(response) {\n  const contentType = response.contentType ?? \"\";\n  return contentType.startsWith(StreamMessage.contentType)\n}\n\nclass ErrorRenderer extends Renderer {\n  static renderElement(currentElement, newElement) {\n    const { documentElement, body } = document;\n\n    documentElement.replaceChild(newElement, body);\n  }\n\n  async render() {\n    this.replaceHeadAndBody();\n    this.activateScriptElements();\n  }\n\n  replaceHeadAndBody() {\n    const { documentElement, head } = document;\n    documentElement.replaceChild(this.newHead, head);\n    this.renderElement(this.currentElement, this.newElement);\n  }\n\n  activateScriptElements() {\n    for (const replaceableElement of this.scriptElements) {\n      const parentNode = replaceableElement.parentNode;\n      if (parentNode) {\n        const element = activateScriptElement(replaceableElement);\n        parentNode.replaceChild(element, replaceableElement);\n      }\n    }\n  }\n\n  get newHead() {\n    return this.newSnapshot.headSnapshot.element\n  }\n\n  get scriptElements() {\n    return document.documentElement.querySelectorAll(\"script\")\n  }\n}\n\nclass PageRenderer extends Renderer {\n  static renderElement(currentElement, newElement) {\n    if (document.body && newElement instanceof HTMLBodyElement) {\n      document.body.replaceWith(newElement);\n    } else {\n      document.documentElement.appendChild(newElement);\n    }\n  }\n\n  get shouldRender() {\n    return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical\n  }\n\n  get reloadReason() {\n    if (!this.newSnapshot.isVisitable) {\n      return {\n        reason: \"turbo_visit_control_is_reload\"\n      }\n    }\n\n    if (!this.trackedElementsAreIdentical) {\n      return {\n        reason: \"tracked_element_mismatch\"\n      }\n    }\n  }\n\n  async prepareToRender() {\n    this.#setLanguage();\n    await this.mergeHead();\n  }\n\n  async render() {\n    if (this.willRender) {\n      await this.replaceBody();\n    }\n  }\n\n  finishRendering() {\n    super.finishRendering();\n    if (!this.isPreview) {\n      this.focusFirstAutofocusableElement();\n    }\n  }\n\n  get currentHeadSnapshot() {\n    return this.currentSnapshot.headSnapshot\n  }\n\n  get newHeadSnapshot() {\n    return this.newSnapshot.headSnapshot\n  }\n\n  get newElement() {\n    return this.newSnapshot.element\n  }\n\n  #setLanguage() {\n    const { documentElement } = this.currentSnapshot;\n    const { dir, lang } = this.newSnapshot;\n\n    if (lang) {\n      documentElement.setAttribute(\"lang\", lang);\n    } else {\n      documentElement.removeAttribute(\"lang\");\n    }\n    if (dir) {\n      documentElement.setAttribute(\"dir\", dir);\n    } else {\n      documentElement.removeAttribute(\"dir\");\n    }\n  }\n\n  async mergeHead() {\n    const mergedHeadElements = this.mergeProvisionalElements();\n    const newStylesheetElements = this.copyNewHeadStylesheetElements();\n    this.copyNewHeadScriptElements();\n\n    await mergedHeadElements;\n    await newStylesheetElements;\n\n    if (this.willRender) {\n      this.removeUnusedDynamicStylesheetElements();\n    }\n  }\n\n  async replaceBody() {\n    await this.preservingPermanentElements(async () => {\n      this.activateNewBody();\n      await this.assignNewBody();\n    });\n  }\n\n  get trackedElementsAreIdentical() {\n    return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature\n  }\n\n  async copyNewHeadStylesheetElements() {\n    const loadingElements = [];\n\n    for (const element of this.newHeadStylesheetElements) {\n      loadingElements.push(waitForLoad(element));\n\n      document.head.appendChild(element);\n    }\n\n    await Promise.all(loadingElements);\n  }\n\n  copyNewHeadScriptElements() {\n    for (const element of this.newHeadScriptElements) {\n      document.head.appendChild(activateScriptElement(element));\n    }\n  }\n\n  removeUnusedDynamicStylesheetElements() {\n    for (const element of this.unusedDynamicStylesheetElements) {\n      document.head.removeChild(element);\n    }\n  }\n\n  async mergeProvisionalElements() {\n    const newHeadElements = [...this.newHeadProvisionalElements];\n\n    for (const element of this.currentHeadProvisionalElements) {\n      if (!this.isCurrentElementInElementList(element, newHeadElements)) {\n        document.head.removeChild(element);\n      }\n    }\n\n    for (const element of newHeadElements) {\n      document.head.appendChild(element);\n    }\n  }\n\n  isCurrentElementInElementList(element, elementList) {\n    for (const [index, newElement] of elementList.entries()) {\n      // if title element...\n      if (element.tagName == \"TITLE\") {\n        if (newElement.tagName != \"TITLE\") {\n          continue\n        }\n        if (element.innerHTML == newElement.innerHTML) {\n          elementList.splice(index, 1);\n          return true\n        }\n      }\n\n      // if any other element...\n      if (newElement.isEqualNode(element)) {\n        elementList.splice(index, 1);\n        return true\n      }\n    }\n\n    return false\n  }\n\n  removeCurrentHeadProvisionalElements() {\n    for (const element of this.currentHeadProvisionalElements) {\n      document.head.removeChild(element);\n    }\n  }\n\n  copyNewHeadProvisionalElements() {\n    for (const element of this.newHeadProvisionalElements) {\n      document.head.appendChild(element);\n    }\n  }\n\n  activateNewBody() {\n    document.adoptNode(this.newElement);\n    this.removeNoscriptElements();\n    this.activateNewBodyScriptElements();\n  }\n\n  removeNoscriptElements() {\n    for (const noscriptElement of this.newElement.querySelectorAll(\"noscript\")) {\n      noscriptElement.remove();\n    }\n  }\n\n  activateNewBodyScriptElements() {\n    for (const inertScriptElement of this.newBodyScriptElements) {\n      const activatedScriptElement = activateScriptElement(inertScriptElement);\n      inertScriptElement.replaceWith(activatedScriptElement);\n    }\n  }\n\n  async assignNewBody() {\n    await this.renderElement(this.currentElement, this.newElement);\n  }\n\n  get unusedDynamicStylesheetElements() {\n    return this.oldHeadStylesheetElements.filter((element) => {\n      return element.getAttribute(\"data-turbo-track\") === \"dynamic\"\n    })\n  }\n\n  get oldHeadStylesheetElements() {\n    return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot)\n  }\n\n  get newHeadStylesheetElements() {\n    return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot)\n  }\n\n  get newHeadScriptElements() {\n    return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot)\n  }\n\n  get currentHeadProvisionalElements() {\n    return this.currentHeadSnapshot.provisionalElements\n  }\n\n  get newHeadProvisionalElements() {\n    return this.newHeadSnapshot.provisionalElements\n  }\n\n  get newBodyScriptElements() {\n    return this.newElement.querySelectorAll(\"script\")\n  }\n}\n\nclass MorphingPageRenderer extends PageRenderer {\n  static renderElement(currentElement, newElement) {\n    morphElements(currentElement, newElement, {\n      callbacks: {\n        beforeNodeMorphed: (node, newNode) => {\n          if (\n            shouldRefreshFrameWithMorphing(node, newNode) &&\n              !closestFrameReloadableWithMorphing(node)\n          ) {\n            node.reload();\n            return false\n          }\n          return true\n        }\n      }\n    });\n\n    dispatch(\"turbo:morph\", { detail: { currentElement, newElement } });\n  }\n\n  async preservingPermanentElements(callback) {\n    return await callback()\n  }\n\n  get renderMethod() {\n    return \"morph\"\n  }\n\n  get shouldAutofocus() {\n    return false\n  }\n}\n\nclass SnapshotCache extends LRUCache {\n  constructor(size) {\n    super(size, toCacheKey);\n  }\n\n  get snapshots() {\n    return this.entries\n  }\n}\n\nclass PageView extends View {\n  snapshotCache = new SnapshotCache(10)\n  lastRenderedLocation = new URL(location.href)\n  forceReloaded = false\n\n  shouldTransitionTo(newSnapshot) {\n    return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions\n  }\n\n  renderPage(snapshot, isPreview = false, willRender = true, visit) {\n    const shouldMorphPage = this.isPageRefresh(visit) && (visit?.refresh?.method || this.snapshot.refreshMethod) === \"morph\";\n    const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;\n\n    const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);\n\n    if (!renderer.shouldRender) {\n      this.forceReloaded = true;\n    } else {\n      visit?.changeHistory();\n    }\n\n    return this.render(renderer)\n  }\n\n  renderError(snapshot, visit) {\n    visit?.changeHistory();\n    const renderer = new ErrorRenderer(this.snapshot, snapshot, false);\n    return this.render(renderer)\n  }\n\n  clearSnapshotCache() {\n    this.snapshotCache.clear();\n  }\n\n  async cacheSnapshot(snapshot = this.snapshot) {\n    if (snapshot.isCacheable) {\n      this.delegate.viewWillCacheSnapshot();\n      const { lastRenderedLocation: location } = this;\n      await nextEventLoopTick();\n      const cachedSnapshot = snapshot.clone();\n      this.snapshotCache.put(location, cachedSnapshot);\n      return cachedSnapshot\n    }\n  }\n\n  getCachedSnapshotForLocation(location) {\n    return this.snapshotCache.get(location)\n  }\n\n  isPageRefresh(visit) {\n    return !visit || (this.lastRenderedLocation.pathname === visit.location.pathname && visit.action === \"replace\")\n  }\n\n  shouldPreserveScrollPosition(visit) {\n    return this.isPageRefresh(visit) && (visit?.refresh?.scroll || this.snapshot.refreshScroll) === \"preserve\"\n  }\n\n  get snapshot() {\n    return PageSnapshot.fromElement(this.element)\n  }\n}\n\nclass Preloader {\n  selector = \"a[data-turbo-preload]\"\n\n  constructor(delegate, snapshotCache) {\n    this.delegate = delegate;\n    this.snapshotCache = snapshotCache;\n  }\n\n  start() {\n    if (document.readyState === \"loading\") {\n      document.addEventListener(\"DOMContentLoaded\", this.#preloadAll);\n    } else {\n      this.preloadOnLoadLinksForView(document.body);\n    }\n  }\n\n  stop() {\n    document.removeEventListener(\"DOMContentLoaded\", this.#preloadAll);\n  }\n\n  preloadOnLoadLinksForView(element) {\n    for (const link of element.querySelectorAll(this.selector)) {\n      if (this.delegate.shouldPreloadLink(link)) {\n        this.preloadURL(link);\n      }\n    }\n  }\n\n  async preloadURL(link) {\n    const location = new URL(link.href);\n\n    if (this.snapshotCache.has(location)) {\n      return\n    }\n\n    const fetchRequest = new FetchRequest(this, FetchMethod.get, location, new URLSearchParams(), link);\n    await fetchRequest.perform();\n  }\n\n  // Fetch request delegate\n\n  prepareRequest(fetchRequest) {\n    fetchRequest.headers[\"X-Sec-Purpose\"] = \"prefetch\";\n  }\n\n  async requestSucceededWithResponse(fetchRequest, fetchResponse) {\n    try {\n      const responseHTML = await fetchResponse.responseHTML;\n      const snapshot = PageSnapshot.fromHTMLString(responseHTML);\n\n      this.snapshotCache.put(fetchRequest.url, snapshot);\n    } catch (_) {\n      // If we cannot preload that is ok!\n    }\n  }\n\n  requestStarted(fetchRequest) {}\n\n  requestErrored(fetchRequest) {}\n\n  requestFinished(fetchRequest) {}\n\n  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}\n\n  requestFailedWithResponse(fetchRequest, fetchResponse) {}\n\n  #preloadAll = () => {\n    this.preloadOnLoadLinksForView(document.body);\n  }\n}\n\nclass Cache {\n  constructor(session) {\n    this.session = session;\n  }\n\n  clear() {\n    this.session.clearCache();\n  }\n\n  resetCacheControl() {\n    this.#setCacheControl(\"\");\n  }\n\n  exemptPageFromCache() {\n    this.#setCacheControl(\"no-cache\");\n  }\n\n  exemptPageFromPreview() {\n    this.#setCacheControl(\"no-preview\");\n  }\n\n  #setCacheControl(value) {\n    setMetaContent(\"turbo-cache-control\", value);\n  }\n}\n\nclass Session {\n  navigator = new Navigator(this)\n  history = new History(this)\n  view = new PageView(this, document.documentElement)\n  adapter = new BrowserAdapter(this)\n\n  pageObserver = new PageObserver(this)\n  cacheObserver = new CacheObserver()\n  linkPrefetchObserver = new LinkPrefetchObserver(this, document)\n  linkClickObserver = new LinkClickObserver(this, window)\n  formSubmitObserver = new FormSubmitObserver(this, document)\n  scrollObserver = new ScrollObserver(this)\n  streamObserver = new StreamObserver(this)\n  formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement)\n  frameRedirector = new FrameRedirector(this, document.documentElement)\n  streamMessageRenderer = new StreamMessageRenderer()\n  cache = new Cache(this)\n\n  enabled = true\n  started = false\n  #pageRefreshDebouncePeriod = 150\n\n  constructor(recentRequests) {\n    this.recentRequests = recentRequests;\n    this.preloader = new Preloader(this, this.view.snapshotCache);\n    this.debouncedRefresh = this.refresh;\n    this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;\n  }\n\n  start() {\n    if (!this.started) {\n      this.pageObserver.start();\n      this.cacheObserver.start();\n      this.linkPrefetchObserver.start();\n      this.formLinkClickObserver.start();\n      this.linkClickObserver.start();\n      this.formSubmitObserver.start();\n      this.scrollObserver.start();\n      this.streamObserver.start();\n      this.frameRedirector.start();\n      this.history.start();\n      this.preloader.start();\n      this.started = true;\n      this.enabled = true;\n    }\n  }\n\n  disable() {\n    this.enabled = false;\n  }\n\n  stop() {\n    if (this.started) {\n      this.pageObserver.stop();\n      this.cacheObserver.stop();\n      this.linkPrefetchObserver.stop();\n      this.formLinkClickObserver.stop();\n      this.linkClickObserver.stop();\n      this.formSubmitObserver.stop();\n      this.scrollObserver.stop();\n      this.streamObserver.stop();\n      this.frameRedirector.stop();\n      this.history.stop();\n      this.preloader.stop();\n      this.started = false;\n    }\n  }\n\n  registerAdapter(adapter) {\n    this.adapter = adapter;\n  }\n\n  visit(location, options = {}) {\n    const frameElement = options.frame ? document.getElementById(options.frame) : null;\n\n    if (frameElement instanceof FrameElement) {\n      const action = options.action || getVisitAction(frameElement);\n\n      frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);\n      frameElement.src = location.toString();\n    } else {\n      this.navigator.proposeVisit(expandURL(location), options);\n    }\n  }\n\n  refresh(url, options = {}) {\n    options = typeof options === \"string\" ? { requestId: options } : options;\n\n    const { method, requestId, scroll } = options;\n    const isRecentRequest = requestId && this.recentRequests.has(requestId);\n    const isCurrentUrl = url === document.baseURI;\n    if (!isRecentRequest && !this.navigator.currentVisit && isCurrentUrl) {\n      this.visit(url, { action: \"replace\", shouldCacheSnapshot: false, refresh: { method, scroll } });\n    }\n  }\n\n  connectStreamSource(source) {\n    this.streamObserver.connectStreamSource(source);\n  }\n\n  disconnectStreamSource(source) {\n    this.streamObserver.disconnectStreamSource(source);\n  }\n\n  renderStreamMessage(message) {\n    this.streamMessageRenderer.render(StreamMessage.wrap(message));\n  }\n\n  clearCache() {\n    this.view.clearSnapshotCache();\n  }\n\n  setProgressBarDelay(delay) {\n    console.warn(\n      \"Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`\"\n    );\n\n    this.progressBarDelay = delay;\n  }\n\n  set progressBarDelay(delay) {\n    config.drive.progressBarDelay = delay;\n  }\n\n  get progressBarDelay() {\n    return config.drive.progressBarDelay\n  }\n\n  set drive(value) {\n    config.drive.enabled = value;\n  }\n\n  get drive() {\n    return config.drive.enabled\n  }\n\n  set formMode(value) {\n    config.forms.mode = value;\n  }\n\n  get formMode() {\n    return config.forms.mode\n  }\n\n  get location() {\n    return this.history.location\n  }\n\n  get restorationIdentifier() {\n    return this.history.restorationIdentifier\n  }\n\n  get pageRefreshDebouncePeriod() {\n    return this.#pageRefreshDebouncePeriod\n  }\n\n  set pageRefreshDebouncePeriod(value) {\n    this.refresh = debounce(this.debouncedRefresh.bind(this), value);\n    this.#pageRefreshDebouncePeriod = value;\n  }\n\n  // Preloader delegate\n\n  shouldPreloadLink(element) {\n    const isUnsafe = element.hasAttribute(\"data-turbo-method\");\n    const isStream = element.hasAttribute(\"data-turbo-stream\");\n    const frameTarget = element.getAttribute(\"data-turbo-frame\");\n    const frame = frameTarget == \"_top\" ?\n      null :\n      document.getElementById(frameTarget) || findClosestRecursively(element, \"turbo-frame:not([disabled])\");\n\n    if (isUnsafe || isStream || frame instanceof FrameElement) {\n      return false\n    } else {\n      const location = new URL(element.href);\n\n      return this.elementIsNavigatable(element) && locationIsVisitable(location, this.snapshot.rootLocation)\n    }\n  }\n\n  // History delegate\n\n  historyPoppedToLocationWithRestorationIdentifierAndDirection(location, restorationIdentifier, direction) {\n    if (this.enabled) {\n      this.navigator.startVisit(location, restorationIdentifier, {\n        action: \"restore\",\n        historyChanged: true,\n        direction\n      });\n    } else {\n      this.adapter.pageInvalidated({\n        reason: \"turbo_disabled\"\n      });\n    }\n  }\n\n  historyPoppedWithEmptyState(location) {\n    this.history.replace(location);\n    this.view.lastRenderedLocation = location;\n    this.view.cacheSnapshot();\n  }\n\n  // Scroll observer delegate\n\n  scrollPositionChanged(position) {\n    this.history.updateRestorationData({ scrollPosition: position });\n  }\n\n  // Form click observer delegate\n\n  willSubmitFormLinkToLocation(link, location) {\n    return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation)\n  }\n\n  submittedFormLinkToLocation() {}\n\n  // Link hover observer delegate\n\n  canPrefetchRequestToLocation(link, location) {\n    return (\n      this.elementIsNavigatable(link) &&\n      locationIsVisitable(location, this.snapshot.rootLocation) &&\n      this.navigator.linkPrefetchingIsEnabledForLocation(location)\n    )\n  }\n\n  // Link click observer delegate\n\n  willFollowLinkToLocation(link, location, event) {\n    return (\n      this.elementIsNavigatable(link) &&\n      locationIsVisitable(location, this.snapshot.rootLocation) &&\n      this.applicationAllowsFollowingLinkToLocation(link, location, event)\n    )\n  }\n\n  followedLinkToLocation(link, location) {\n    const action = this.getActionForLink(link);\n    const acceptsStreamResponse = link.hasAttribute(\"data-turbo-stream\");\n\n    this.visit(location.href, { action, acceptsStreamResponse });\n  }\n\n  // Navigator delegate\n\n  allowsVisitingLocationWithAction(location, action) {\n    return this.applicationAllowsVisitingLocation(location)\n  }\n\n  visitProposedToLocation(location, options) {\n    extendURLWithDeprecatedProperties(location);\n    this.adapter.visitProposedToLocation(location, options);\n  }\n\n  // Visit delegate\n\n  visitStarted(visit) {\n    if (!visit.acceptsStreamResponse) {\n      markAsBusy(document.documentElement);\n      this.view.markVisitDirection(visit.direction);\n    }\n    extendURLWithDeprecatedProperties(visit.location);\n    this.notifyApplicationAfterVisitingLocation(visit.location, visit.action);\n  }\n\n  visitCompleted(visit) {\n    this.view.unmarkVisitDirection();\n    clearBusyState(document.documentElement);\n    this.notifyApplicationAfterPageLoad(visit.getTimingMetrics());\n  }\n\n  // Form submit observer delegate\n\n  willSubmitForm(form, submitter) {\n    const action = getAction$1(form, submitter);\n\n    return (\n      this.submissionIsNavigatable(form, submitter) &&\n      locationIsVisitable(expandURL(action), this.snapshot.rootLocation)\n    )\n  }\n\n  formSubmitted(form, submitter) {\n    this.navigator.submitForm(form, submitter);\n  }\n\n  // Page observer delegate\n\n  pageBecameInteractive() {\n    this.view.lastRenderedLocation = this.location;\n    this.notifyApplicationAfterPageLoad();\n  }\n\n  pageLoaded() {\n    this.history.assumeControlOfScrollRestoration();\n  }\n\n  pageWillUnload() {\n    this.history.relinquishControlOfScrollRestoration();\n  }\n\n  // Stream observer delegate\n\n  receivedMessageFromStream(message) {\n    this.renderStreamMessage(message);\n  }\n\n  // Page view delegate\n\n  viewWillCacheSnapshot() {\n    this.notifyApplicationBeforeCachingSnapshot();\n  }\n\n  allowsImmediateRender({ element }, options) {\n    const event = this.notifyApplicationBeforeRender(element, options);\n    const {\n      defaultPrevented,\n      detail: { render }\n    } = event;\n\n    if (this.view.renderer && render) {\n      this.view.renderer.renderElement = render;\n    }\n\n    return !defaultPrevented\n  }\n\n  viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {\n    this.view.lastRenderedLocation = this.history.location;\n    this.notifyApplicationAfterRender(renderMethod);\n  }\n\n  preloadOnLoadLinksForView(element) {\n    this.preloader.preloadOnLoadLinksForView(element);\n  }\n\n  viewInvalidated(reason) {\n    this.adapter.pageInvalidated(reason);\n  }\n\n  // Frame element\n\n  frameLoaded(frame) {\n    this.notifyApplicationAfterFrameLoad(frame);\n  }\n\n  frameRendered(fetchResponse, frame) {\n    this.notifyApplicationAfterFrameRender(fetchResponse, frame);\n  }\n\n  // Application events\n\n  applicationAllowsFollowingLinkToLocation(link, location, ev) {\n    const event = this.notifyApplicationAfterClickingLinkToLocation(link, location, ev);\n    return !event.defaultPrevented\n  }\n\n  applicationAllowsVisitingLocation(location) {\n    const event = this.notifyApplicationBeforeVisitingLocation(location);\n    return !event.defaultPrevented\n  }\n\n  notifyApplicationAfterClickingLinkToLocation(link, location, event) {\n    return dispatch(\"turbo:click\", {\n      target: link,\n      detail: { url: location.href, originalEvent: event },\n      cancelable: true\n    })\n  }\n\n  notifyApplicationBeforeVisitingLocation(location) {\n    return dispatch(\"turbo:before-visit\", {\n      detail: { url: location.href },\n      cancelable: true\n    })\n  }\n\n  notifyApplicationAfterVisitingLocation(location, action) {\n    return dispatch(\"turbo:visit\", { detail: { url: location.href, action } })\n  }\n\n  notifyApplicationBeforeCachingSnapshot() {\n    return dispatch(\"turbo:before-cache\")\n  }\n\n  notifyApplicationBeforeRender(newBody, options) {\n    return dispatch(\"turbo:before-render\", {\n      detail: { newBody, ...options },\n      cancelable: true\n    })\n  }\n\n  notifyApplicationAfterRender(renderMethod) {\n    return dispatch(\"turbo:render\", { detail: { renderMethod } })\n  }\n\n  notifyApplicationAfterPageLoad(timing = {}) {\n    return dispatch(\"turbo:load\", {\n      detail: { url: this.location.href, timing }\n    })\n  }\n\n  notifyApplicationAfterFrameLoad(frame) {\n    return dispatch(\"turbo:frame-load\", { target: frame })\n  }\n\n  notifyApplicationAfterFrameRender(fetchResponse, frame) {\n    return dispatch(\"turbo:frame-render\", {\n      detail: { fetchResponse },\n      target: frame,\n      cancelable: true\n    })\n  }\n\n  // Helpers\n\n  submissionIsNavigatable(form, submitter) {\n    if (config.forms.mode == \"off\") {\n      return false\n    } else {\n      const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;\n\n      if (config.forms.mode == \"optin\") {\n        return submitterIsNavigatable && form.closest('[data-turbo=\"true\"]') != null\n      } else {\n        return submitterIsNavigatable && this.elementIsNavigatable(form)\n      }\n    }\n  }\n\n  elementIsNavigatable(element) {\n    const container = findClosestRecursively(element, \"[data-turbo]\");\n    const withinFrame = findClosestRecursively(element, \"turbo-frame\");\n\n    // Check if Drive is enabled on the session or we're within a Frame.\n    if (config.drive.enabled || withinFrame) {\n      // Element is navigatable by default, unless `data-turbo=\"false\"`.\n      if (container) {\n        return container.getAttribute(\"data-turbo\") != \"false\"\n      } else {\n        return true\n      }\n    } else {\n      // Element isn't navigatable by default, unless `data-turbo=\"true\"`.\n      if (container) {\n        return container.getAttribute(\"data-turbo\") == \"true\"\n      } else {\n        return false\n      }\n    }\n  }\n\n  // Private\n\n  getActionForLink(link) {\n    return getVisitAction(link) || \"advance\"\n  }\n\n  get snapshot() {\n    return this.view.snapshot\n  }\n}\n\n// Older versions of the Turbo Native adapters referenced the\n// `Location#absoluteURL` property in their implementations of\n// the `Adapter#visitProposedToLocation()` and `#visitStarted()`\n// methods. The Location class has since been removed in favor\n// of the DOM URL API, and accordingly all Adapter methods now\n// receive URL objects.\n//\n// We alias #absoluteURL to #toString() here to avoid crashing\n// older adapters which do not expect URL objects. We should\n// consider removing this support at some point in the future.\n\nfunction extendURLWithDeprecatedProperties(url) {\n  Object.defineProperties(url, deprecatedLocationPropertyDescriptors);\n}\n\nconst deprecatedLocationPropertyDescriptors = {\n  absoluteURL: {\n    get() {\n      return this.toString()\n    }\n  }\n};\n\nconst session = new Session(recentRequests);\n\n// Rename `navigator` to avoid shadowing `window.navigator`\nconst { cache, navigator: sessionNavigator } = session;\n\n/**\n * Starts the main session.\n * This initialises any necessary observers such as those to monitor\n * link interactions.\n */\nfunction start() {\n  session.start();\n}\n\n/**\n * Registers an adapter for the main session.\n *\n * @param adapter Adapter to register\n */\nfunction registerAdapter(adapter) {\n  session.registerAdapter(adapter);\n}\n\n/**\n * Performs an application visit to the given location.\n *\n * @param location Location to visit (a URL or path)\n * @param options Options to apply\n * @param options.action Type of history navigation to apply (\"restore\",\n * \"replace\" or \"advance\")\n * @param options.historyChanged Specifies whether the browser history has\n * already been changed for this visit or not\n * @param options.referrer Specifies the referrer of this visit such that\n * navigations to the same page will not result in a new history entry.\n * @param options.snapshotHTML Cached snapshot to render\n * @param options.response Response of the specified location\n */\nfunction visit(location, options) {\n  session.visit(location, options);\n}\n\n/**\n * Connects a stream source to the main session.\n *\n * @param source Stream source to connect\n */\nfunction connectStreamSource(source) {\n  session.connectStreamSource(source);\n}\n\n/**\n * Disconnects a stream source from the main session.\n *\n * @param source Stream source to disconnect\n */\nfunction disconnectStreamSource(source) {\n  session.disconnectStreamSource(source);\n}\n\n/**\n * Renders a stream message to the main session by appending it to the\n * current document.\n *\n * @param message Message to render\n */\nfunction renderStreamMessage(message) {\n  session.renderStreamMessage(message);\n}\n\n/**\n * Sets the delay after which the progress bar will appear during navigation.\n *\n * The progress bar appears after 500ms by default.\n *\n * Note that this method has no effect when used with the iOS or Android\n * adapters.\n *\n * @param delay Time to delay in milliseconds\n */\nfunction setProgressBarDelay(delay) {\n  console.warn(\n    \"Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`\"\n  );\n  config.drive.progressBarDelay = delay;\n}\n\nfunction setConfirmMethod(confirmMethod) {\n  console.warn(\n    \"Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`\"\n  );\n  config.forms.confirm = confirmMethod;\n}\n\nfunction setFormMode(mode) {\n  console.warn(\n    \"Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`\"\n  );\n  config.forms.mode = mode;\n}\n\n/**\n * Morph the state of the currentBody based on the attributes and contents of\n * the newBody. Morphing body elements may dispatch turbo:morph,\n * turbo:before-morph-element, turbo:before-morph-attribute, and\n * turbo:morph-element events.\n *\n * @param currentBody HTMLBodyElement destination of morphing changes\n * @param newBody HTMLBodyElement source of morphing changes\n */\nfunction morphBodyElements(currentBody, newBody) {\n  MorphingPageRenderer.renderElement(currentBody, newBody);\n}\n\n/**\n * Morph the child elements of the currentFrame based on the child elements of\n * the newFrame. Morphing turbo-frame elements may dispatch turbo:before-frame-morph,\n * turbo:before-morph-element, turbo:before-morph-attribute, and\n * turbo:morph-element events.\n *\n * @param currentFrame FrameElement destination of morphing children changes\n * @param newFrame FrameElement source of morphing children changes\n */\nfunction morphTurboFrameElements(currentFrame, newFrame) {\n  MorphingFrameRenderer.renderElement(currentFrame, newFrame);\n}\n\nvar Turbo = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  PageRenderer: PageRenderer,\n  PageSnapshot: PageSnapshot,\n  FrameRenderer: FrameRenderer,\n  fetch: fetchWithTurboHeaders,\n  config: config,\n  session: session,\n  cache: cache,\n  navigator: sessionNavigator,\n  start: start,\n  registerAdapter: registerAdapter,\n  visit: visit,\n  connectStreamSource: connectStreamSource,\n  disconnectStreamSource: disconnectStreamSource,\n  renderStreamMessage: renderStreamMessage,\n  setProgressBarDelay: setProgressBarDelay,\n  setConfirmMethod: setConfirmMethod,\n  setFormMode: setFormMode,\n  morphBodyElements: morphBodyElements,\n  morphTurboFrameElements: morphTurboFrameElements,\n  morphChildren: morphChildren,\n  morphElements: morphElements\n});\n\nclass TurboFrameMissingError extends Error {}\n\nclass FrameController {\n  fetchResponseLoaded = (_fetchResponse) => Promise.resolve()\n  #currentFetchRequest = null\n  #resolveVisitPromise = () => {}\n  #connected = false\n  #hasBeenLoaded = false\n  #ignoredAttributes = new Set()\n  #shouldMorphFrame = false\n  action = null\n\n  constructor(element) {\n    this.element = element;\n    this.view = new FrameView(this, this.element);\n    this.appearanceObserver = new AppearanceObserver(this, this.element);\n    this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);\n    this.linkInterceptor = new LinkInterceptor(this, this.element);\n    this.restorationIdentifier = uuid();\n    this.formSubmitObserver = new FormSubmitObserver(this, this.element);\n  }\n\n  // Frame delegate\n\n  connect() {\n    if (!this.#connected) {\n      this.#connected = true;\n      if (this.loadingStyle == FrameLoadingStyle.lazy) {\n        this.appearanceObserver.start();\n      } else {\n        this.#loadSourceURL();\n      }\n      this.formLinkClickObserver.start();\n      this.linkInterceptor.start();\n      this.formSubmitObserver.start();\n    }\n  }\n\n  disconnect() {\n    if (this.#connected) {\n      this.#connected = false;\n      this.appearanceObserver.stop();\n      this.formLinkClickObserver.stop();\n      this.linkInterceptor.stop();\n      this.formSubmitObserver.stop();\n\n      if (!this.element.hasAttribute(\"recurse\")) {\n        this.#currentFetchRequest?.cancel();\n      }\n    }\n  }\n\n  disabledChanged() {\n    if (this.disabled) {\n      this.#currentFetchRequest?.cancel();\n    } else if (this.loadingStyle == FrameLoadingStyle.eager) {\n      this.#loadSourceURL();\n    }\n  }\n\n  sourceURLChanged() {\n    if (this.#isIgnoringChangesTo(\"src\")) return\n\n    if (!this.sourceURL) {\n      this.#currentFetchRequest?.cancel();\n    }\n\n    if (this.element.isConnected) {\n      this.complete = false;\n    }\n\n    if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {\n      this.#loadSourceURL();\n    }\n  }\n\n  sourceURLReloaded() {\n    const { refresh, src } = this.element;\n\n    this.#shouldMorphFrame = src && refresh === \"morph\";\n\n    this.element.removeAttribute(\"complete\");\n    this.element.src = null;\n    this.element.src = src;\n    return this.element.loaded\n  }\n\n  loadingStyleChanged() {\n    if (this.loadingStyle == FrameLoadingStyle.lazy) {\n      this.appearanceObserver.start();\n    } else {\n      this.appearanceObserver.stop();\n      this.#loadSourceURL();\n    }\n  }\n\n  async #loadSourceURL() {\n    if (this.enabled && this.isActive && !this.complete && this.sourceURL) {\n      this.element.loaded = this.#visit(expandURL(this.sourceURL));\n      this.appearanceObserver.stop();\n      await this.element.loaded;\n      this.#hasBeenLoaded = true;\n    }\n  }\n\n  async loadResponse(fetchResponse) {\n    if (fetchResponse.redirected || (fetchResponse.succeeded && fetchResponse.isHTML)) {\n      this.sourceURL = fetchResponse.response.url;\n    }\n\n    try {\n      const html = await fetchResponse.responseHTML;\n      if (html) {\n        const document = parseHTMLDocument(html);\n        const pageSnapshot = PageSnapshot.fromDocument(document);\n\n        if (pageSnapshot.isVisitable) {\n          await this.#loadFrameResponse(fetchResponse, document);\n        } else {\n          await this.#handleUnvisitableFrameResponse(fetchResponse);\n        }\n      }\n    } finally {\n      this.#shouldMorphFrame = false;\n      this.fetchResponseLoaded = () => Promise.resolve();\n    }\n  }\n\n  // Appearance observer delegate\n\n  elementAppearedInViewport(element) {\n    this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));\n    this.#loadSourceURL();\n  }\n\n  // Form link click observer delegate\n\n  willSubmitFormLinkToLocation(link) {\n    return this.#shouldInterceptNavigation(link)\n  }\n\n  submittedFormLinkToLocation(link, _location, form) {\n    const frame = this.#findFrameElement(link);\n    if (frame) form.setAttribute(\"data-turbo-frame\", frame.id);\n  }\n\n  // Link interceptor delegate\n\n  shouldInterceptLinkClick(element, _location, _event) {\n    return this.#shouldInterceptNavigation(element)\n  }\n\n  linkClickIntercepted(element, location) {\n    this.#navigateFrame(element, location);\n  }\n\n  // Form submit observer delegate\n\n  willSubmitForm(element, submitter) {\n    return element.closest(\"turbo-frame\") == this.element && this.#shouldInterceptNavigation(element, submitter)\n  }\n\n  formSubmitted(element, submitter) {\n    if (this.formSubmission) {\n      this.formSubmission.stop();\n    }\n\n    this.formSubmission = new FormSubmission(this, element, submitter);\n\n    const { fetchRequest } = this.formSubmission;\n    const frame = this.#findFrameElement(element, submitter);\n\n    this.prepareRequest(fetchRequest, frame);\n    this.formSubmission.start();\n  }\n\n  // Fetch request delegate\n\n  prepareRequest(request, frame = this) {\n    request.headers[\"Turbo-Frame\"] = frame.id;\n\n    if (this.currentNavigationElement?.hasAttribute(\"data-turbo-stream\")) {\n      request.acceptResponseType(StreamMessage.contentType);\n    }\n  }\n\n  requestStarted(_request) {\n    markAsBusy(this.element);\n  }\n\n  requestPreventedHandlingResponse(_request, _response) {\n    this.#resolveVisitPromise();\n  }\n\n  async requestSucceededWithResponse(request, response) {\n    await this.loadResponse(response);\n    this.#resolveVisitPromise();\n  }\n\n  async requestFailedWithResponse(request, response) {\n    await this.loadResponse(response);\n    this.#resolveVisitPromise();\n  }\n\n  requestErrored(request, error) {\n    console.error(error);\n    this.#resolveVisitPromise();\n  }\n\n  requestFinished(_request) {\n    clearBusyState(this.element);\n  }\n\n  // Form submission delegate\n\n  formSubmissionStarted({ formElement }) {\n    markAsBusy(formElement, this.#findFrameElement(formElement));\n  }\n\n  formSubmissionSucceededWithResponse(formSubmission, response) {\n    const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);\n\n    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));\n    frame.delegate.loadResponse(response);\n\n    if (!formSubmission.isSafe) {\n      session.clearCache();\n    }\n  }\n\n  formSubmissionFailedWithResponse(formSubmission, fetchResponse) {\n    this.element.delegate.loadResponse(fetchResponse);\n    session.clearCache();\n  }\n\n  formSubmissionErrored(formSubmission, error) {\n    console.error(error);\n  }\n\n  formSubmissionFinished({ formElement }) {\n    clearBusyState(formElement, this.#findFrameElement(formElement));\n  }\n\n  // View delegate\n\n  allowsImmediateRender({ element: newFrame }, options) {\n    const event = dispatch(\"turbo:before-frame-render\", {\n      target: this.element,\n      detail: { newFrame, ...options },\n      cancelable: true\n    });\n\n    const {\n      defaultPrevented,\n      detail: { render }\n    } = event;\n\n    if (this.view.renderer && render) {\n      this.view.renderer.renderElement = render;\n    }\n\n    return !defaultPrevented\n  }\n\n  viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {}\n\n  preloadOnLoadLinksForView(element) {\n    session.preloadOnLoadLinksForView(element);\n  }\n\n  viewInvalidated() {}\n\n  // Frame renderer delegate\n\n  willRenderFrame(currentElement, _newElement) {\n    this.previousFrameElement = currentElement.cloneNode(true);\n  }\n\n  visitCachedSnapshot = ({ element }) => {\n    const frame = element.querySelector(\"#\" + this.element.id);\n\n    if (frame && this.previousFrameElement) {\n      frame.replaceChildren(...this.previousFrameElement.children);\n    }\n\n    delete this.previousFrameElement;\n  }\n\n  // Private\n\n  async #loadFrameResponse(fetchResponse, document) {\n    const newFrameElement = await this.extractForeignFrameElement(document.body);\n    const rendererClass = this.#shouldMorphFrame ? MorphingFrameRenderer : FrameRenderer;\n\n    if (newFrameElement) {\n      const snapshot = new Snapshot(newFrameElement);\n      const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);\n      if (this.view.renderPromise) await this.view.renderPromise;\n      this.changeHistory();\n\n      await this.view.render(renderer);\n      this.complete = true;\n      session.frameRendered(fetchResponse, this.element);\n      session.frameLoaded(this.element);\n      await this.fetchResponseLoaded(fetchResponse);\n    } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {\n      this.#handleFrameMissingFromResponse(fetchResponse);\n    }\n  }\n\n  async #visit(url) {\n    const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);\n\n    this.#currentFetchRequest?.cancel();\n    this.#currentFetchRequest = request;\n\n    return new Promise((resolve) => {\n      this.#resolveVisitPromise = () => {\n        this.#resolveVisitPromise = () => {};\n        this.#currentFetchRequest = null;\n        resolve();\n      };\n      request.perform();\n    })\n  }\n\n  #navigateFrame(element, url, submitter) {\n    const frame = this.#findFrameElement(element, submitter);\n\n    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter, element, frame));\n\n    this.#withCurrentNavigationElement(element, () => {\n      frame.src = url;\n    });\n  }\n\n  proposeVisitIfNavigatedWithAction(frame, action = null) {\n    this.action = action;\n\n    if (this.action) {\n      const pageSnapshot = PageSnapshot.fromElement(frame).clone();\n      const { visitCachedSnapshot } = frame.delegate;\n\n      frame.delegate.fetchResponseLoaded = async (fetchResponse) => {\n        if (frame.src) {\n          const { statusCode, redirected } = fetchResponse;\n          const responseHTML = await fetchResponse.responseHTML;\n          const response = { statusCode, redirected, responseHTML };\n          const options = {\n            response,\n            visitCachedSnapshot,\n            willRender: false,\n            updateHistory: false,\n            restorationIdentifier: this.restorationIdentifier,\n            snapshot: pageSnapshot\n          };\n\n          if (this.action) options.action = this.action;\n\n          session.visit(frame.src, options);\n        }\n      };\n    }\n  }\n\n  changeHistory() {\n    if (this.action) {\n      const method = getHistoryMethodForAction(this.action);\n      session.history.update(method, expandURL(this.element.src || \"\"), this.restorationIdentifier);\n    }\n  }\n\n  async #handleUnvisitableFrameResponse(fetchResponse) {\n    console.warn(\n      `The response (${fetchResponse.statusCode}) from <turbo-frame id=\"${this.element.id}\"> is performing a full page visit due to turbo-visit-control.`\n    );\n\n    await this.#visitResponse(fetchResponse.response);\n  }\n\n  #willHandleFrameMissingFromResponse(fetchResponse) {\n    this.element.setAttribute(\"complete\", \"\");\n\n    const response = fetchResponse.response;\n    const visit = async (url, options) => {\n      if (url instanceof Response) {\n        this.#visitResponse(url);\n      } else {\n        session.visit(url, options);\n      }\n    };\n\n    const event = dispatch(\"turbo:frame-missing\", {\n      target: this.element,\n      detail: { response, visit },\n      cancelable: true\n    });\n\n    return !event.defaultPrevented\n  }\n\n  #handleFrameMissingFromResponse(fetchResponse) {\n    this.view.missing();\n    this.#throwFrameMissingError(fetchResponse);\n  }\n\n  #throwFrameMissingError(fetchResponse) {\n    const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id=\"${this.element.id}\"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;\n    throw new TurboFrameMissingError(message)\n  }\n\n  async #visitResponse(response) {\n    const wrapped = new FetchResponse(response);\n    const responseHTML = await wrapped.responseHTML;\n    const { location, redirected, statusCode } = wrapped;\n\n    return session.visit(location, { response: { redirected, statusCode, responseHTML } })\n  }\n\n  #findFrameElement(element, submitter) {\n    const id = getAttribute(\"data-turbo-frame\", submitter, element) || this.element.getAttribute(\"target\");\n    const target = this.#getFrameElementById(id);\n\n    return target instanceof FrameElement ? target : this.element\n  }\n\n  async extractForeignFrameElement(container) {\n    let element;\n    const id = CSS.escape(this.id);\n\n    try {\n      element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);\n      if (element) {\n        return element\n      }\n\n      element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);\n      if (element) {\n        await element.loaded;\n        return await this.extractForeignFrameElement(element)\n      }\n    } catch (error) {\n      console.error(error);\n      return new FrameElement()\n    }\n\n    return null\n  }\n\n  #formActionIsVisitable(form, submitter) {\n    const action = getAction$1(form, submitter);\n\n    return locationIsVisitable(expandURL(action), this.rootLocation)\n  }\n\n  #shouldInterceptNavigation(element, submitter) {\n    const id = getAttribute(\"data-turbo-frame\", submitter, element) || this.element.getAttribute(\"target\");\n\n    if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter)) {\n      return false\n    }\n\n    if (!this.enabled || id == \"_top\") {\n      return false\n    }\n\n    if (id) {\n      const frameElement = this.#getFrameElementById(id);\n      if (frameElement) {\n        return !frameElement.disabled\n      } else if (id == \"_parent\") {\n        return false\n      }\n    }\n\n    if (!session.elementIsNavigatable(element)) {\n      return false\n    }\n\n    if (submitter && !session.elementIsNavigatable(submitter)) {\n      return false\n    }\n\n    return true\n  }\n\n  // Computed properties\n\n  get id() {\n    return this.element.id\n  }\n\n  get disabled() {\n    return this.element.disabled\n  }\n\n  get enabled() {\n    return !this.disabled\n  }\n\n  get sourceURL() {\n    if (this.element.src) {\n      return this.element.src\n    }\n  }\n\n  set sourceURL(sourceURL) {\n    this.#ignoringChangesToAttribute(\"src\", () => {\n      this.element.src = sourceURL ?? null;\n    });\n  }\n\n  get loadingStyle() {\n    return this.element.loading\n  }\n\n  get isLoading() {\n    return this.formSubmission !== undefined || this.#resolveVisitPromise() !== undefined\n  }\n\n  get complete() {\n    return this.element.hasAttribute(\"complete\")\n  }\n\n  set complete(value) {\n    if (value) {\n      this.element.setAttribute(\"complete\", \"\");\n    } else {\n      this.element.removeAttribute(\"complete\");\n    }\n  }\n\n  get isActive() {\n    return this.element.isActive && this.#connected\n  }\n\n  get rootLocation() {\n    const meta = this.element.ownerDocument.querySelector(`meta[name=\"turbo-root\"]`);\n    const root = meta?.content ?? \"/\";\n    return expandURL(root)\n  }\n\n  #isIgnoringChangesTo(attributeName) {\n    return this.#ignoredAttributes.has(attributeName)\n  }\n\n  #ignoringChangesToAttribute(attributeName, callback) {\n    this.#ignoredAttributes.add(attributeName);\n    callback();\n    this.#ignoredAttributes.delete(attributeName);\n  }\n\n  #withCurrentNavigationElement(element, callback) {\n    this.currentNavigationElement = element;\n    callback();\n    delete this.currentNavigationElement;\n  }\n\n  #getFrameElementById(id) {\n    if (id != null) {\n      const element = id === \"_parent\" ?\n        this.element.parentElement.closest(\"turbo-frame\") :\n        document.getElementById(id);\n      if (element instanceof FrameElement) {\n        return element\n      }\n    }\n  }\n}\n\nfunction activateElement(element, currentURL) {\n  if (element) {\n    const src = element.getAttribute(\"src\");\n    if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {\n      throw new Error(`Matching <turbo-frame id=\"${element.id}\"> element has a source URL which references itself`)\n    }\n    if (element.ownerDocument !== document) {\n      element = document.importNode(element, true);\n    }\n\n    if (element instanceof FrameElement) {\n      element.connectedCallback();\n      element.disconnectedCallback();\n      return element\n    }\n  }\n}\n\nconst StreamActions = {\n  after() {\n    this.removeDuplicateTargetSiblings();\n    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e.nextSibling));\n  },\n\n  append() {\n    this.removeDuplicateTargetChildren();\n    this.targetElements.forEach((e) => e.append(this.templateContent));\n  },\n\n  before() {\n    this.removeDuplicateTargetSiblings();\n    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e));\n  },\n\n  prepend() {\n    this.removeDuplicateTargetChildren();\n    this.targetElements.forEach((e) => e.prepend(this.templateContent));\n  },\n\n  remove() {\n    this.targetElements.forEach((e) => e.remove());\n  },\n\n  replace() {\n    const method = this.getAttribute(\"method\");\n\n    this.targetElements.forEach((targetElement) => {\n      if (method === \"morph\") {\n        morphElements(targetElement, this.templateContent);\n      } else {\n        targetElement.replaceWith(this.templateContent);\n      }\n    });\n  },\n\n  update() {\n    const method = this.getAttribute(\"method\");\n\n    this.targetElements.forEach((targetElement) => {\n      if (method === \"morph\") {\n        morphChildren(targetElement, this.templateContent);\n      } else {\n        targetElement.innerHTML = \"\";\n        targetElement.append(this.templateContent);\n      }\n    });\n  },\n\n  refresh() {\n    const method = this.getAttribute(\"method\");\n    const requestId = this.requestId;\n    const scroll = this.getAttribute(\"scroll\");\n\n    session.refresh(this.baseURI, { method, requestId, scroll });\n  }\n};\n\n// <turbo-stream action=replace target=id><template>...\n\n/**\n * Renders updates to the page from a stream of messages.\n *\n * Using the `action` attribute, this can be configured one of eight ways:\n *\n * - `after` - inserts the result after the target\n * - `append` - appends the result to the target\n * - `before` - inserts the result before the target\n * - `prepend` - prepends the result to the target\n * - `refresh` - initiates a page refresh\n * - `remove` - removes the target\n * - `replace` - replaces the outer HTML of the target\n * - `update` - replaces the inner HTML of the target\n *\n * @customElement turbo-stream\n * @example\n *   <turbo-stream action=\"append\" target=\"dom_id\">\n *     <template>\n *       Content to append to target designated with the dom_id.\n *     </template>\n *   </turbo-stream>\n */\nclass StreamElement extends HTMLElement {\n  static async renderElement(newElement) {\n    await newElement.performAction();\n  }\n\n  async connectedCallback() {\n    try {\n      await this.render();\n    } catch (error) {\n      console.error(error);\n    } finally {\n      this.disconnect();\n    }\n  }\n\n  async render() {\n    return (this.renderPromise ??= (async () => {\n      const event = this.beforeRenderEvent;\n\n      if (this.dispatchEvent(event)) {\n        await nextRepaint();\n        await event.detail.render(this);\n      }\n    })())\n  }\n\n  disconnect() {\n    try {\n      this.remove();\n      // eslint-disable-next-line no-empty\n    } catch {}\n  }\n\n  /**\n   * Removes duplicate children (by ID)\n   */\n  removeDuplicateTargetChildren() {\n    this.duplicateChildren.forEach((c) => c.remove());\n  }\n\n  /**\n   * Gets the list of duplicate children (i.e. those with the same ID)\n   */\n  get duplicateChildren() {\n    const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.getAttribute(\"id\"));\n    const newChildrenIds = [...(this.templateContent?.children || [])].filter((c) => !!c.getAttribute(\"id\")).map((c) => c.getAttribute(\"id\"));\n\n    return existingChildren.filter((c) => newChildrenIds.includes(c.getAttribute(\"id\")))\n  }\n\n  /**\n  * Removes duplicate siblings (by ID)\n  */\n  removeDuplicateTargetSiblings() {\n    this.duplicateSiblings.forEach((c) => c.remove());\n  }\n\n  /**\n  * Gets the list of duplicate siblings (i.e. those with the same ID)\n  */\n  get duplicateSiblings() {\n    const existingChildren = this.targetElements.flatMap((e) => [...e.parentElement.children]).filter((c) => !!c.id);\n    const newChildrenIds = [...(this.templateContent?.children || [])].filter((c) => !!c.id).map((c) => c.id);\n\n    return existingChildren.filter((c) => newChildrenIds.includes(c.id))\n  }\n\n  /**\n   * Gets the action function to be performed.\n   */\n  get performAction() {\n    if (this.action) {\n      const actionFunction = StreamActions[this.action];\n      if (actionFunction) {\n        return actionFunction\n      }\n      this.#raise(\"unknown action\");\n    }\n    this.#raise(\"action attribute is missing\");\n  }\n\n  /**\n   * Gets the target elements which the template will be rendered to.\n   */\n  get targetElements() {\n    if (this.target) {\n      return this.targetElementsById\n    } else if (this.targets) {\n      return this.targetElementsByQuery\n    } else {\n      this.#raise(\"target or targets attribute is missing\");\n    }\n  }\n\n  /**\n   * Gets the contents of the main `<template>`.\n   */\n  get templateContent() {\n    return this.templateElement.content.cloneNode(true)\n  }\n\n  /**\n   * Gets the main `<template>` used for rendering\n   */\n  get templateElement() {\n    if (this.firstElementChild === null) {\n      const template = this.ownerDocument.createElement(\"template\");\n      this.appendChild(template);\n      return template\n    } else if (this.firstElementChild instanceof HTMLTemplateElement) {\n      return this.firstElementChild\n    }\n    this.#raise(\"first child element must be a <template> element\");\n  }\n\n  /**\n   * Gets the current action.\n   */\n  get action() {\n    return this.getAttribute(\"action\")\n  }\n\n  /**\n   * Gets the current target (an element ID) to which the result will\n   * be rendered.\n   */\n  get target() {\n    return this.getAttribute(\"target\")\n  }\n\n  /**\n   * Gets the current \"targets\" selector (a CSS selector)\n   */\n  get targets() {\n    return this.getAttribute(\"targets\")\n  }\n\n  /**\n   * Reads the request-id attribute\n   */\n  get requestId() {\n    return this.getAttribute(\"request-id\")\n  }\n\n  #raise(message) {\n    throw new Error(`${this.description}: ${message}`)\n  }\n\n  get description() {\n    return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? \"<turbo-stream>\"\n  }\n\n  get beforeRenderEvent() {\n    return new CustomEvent(\"turbo:before-stream-render\", {\n      bubbles: true,\n      cancelable: true,\n      detail: { newStream: this, render: StreamElement.renderElement }\n    })\n  }\n\n  get targetElementsById() {\n    const element = this.ownerDocument?.getElementById(this.target);\n\n    if (element !== null) {\n      return [element]\n    } else {\n      return []\n    }\n  }\n\n  get targetElementsByQuery() {\n    const elements = this.ownerDocument?.querySelectorAll(this.targets);\n\n    if (elements.length !== 0) {\n      return Array.prototype.slice.call(elements)\n    } else {\n      return []\n    }\n  }\n}\n\nclass StreamSourceElement extends HTMLElement {\n  streamSource = null\n\n  connectedCallback() {\n    this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);\n\n    connectStreamSource(this.streamSource);\n  }\n\n  disconnectedCallback() {\n    if (this.streamSource) {\n      this.streamSource.close();\n\n      disconnectStreamSource(this.streamSource);\n    }\n  }\n\n  get src() {\n    return this.getAttribute(\"src\") || \"\"\n  }\n}\n\nFrameElement.delegateConstructor = FrameController;\n\nif (customElements.get(\"turbo-frame\") === undefined) {\n  customElements.define(\"turbo-frame\", FrameElement);\n}\n\nif (customElements.get(\"turbo-stream\") === undefined) {\n  customElements.define(\"turbo-stream\", StreamElement);\n}\n\nif (customElements.get(\"turbo-stream-source\") === undefined) {\n  customElements.define(\"turbo-stream-source\", StreamSourceElement);\n}\n\n(() => {\n  const scriptElement = document.currentScript;\n  if (!scriptElement) return\n  if (scriptElement.hasAttribute(\"data-turbo-suppress-warning\")) return\n\n  let element = scriptElement.parentElement;\n  while (element) {\n    if (element == document.body) {\n      return console.warn(\n        unindent`\n        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!\n\n        Load your application\u2019s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.\n\n        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements\n\n        \u2014\u2014\n        Suppress this warning by adding a \"data-turbo-suppress-warning\" attribute to: %s\n      `,\n        scriptElement.outerHTML\n      )\n    }\n\n    element = element.parentElement;\n  }\n})();\n\nwindow.Turbo = { ...Turbo, StreamActions };\nstart();\n\nexport { FetchEnctype, FetchMethod, FetchRequest, FetchResponse, FrameElement, FrameLoadingStyle, FrameRenderer, PageRenderer, PageSnapshot, StreamActions, StreamElement, StreamSourceElement, cache, config, connectStreamSource, disconnectStreamSource, fetchWithTurboHeaders as fetch, fetchEnctypeFromString, fetchMethodFromString, isSafe, morphBodyElements, morphChildren, morphElements, morphTurboFrameElements, sessionNavigator as navigator, registerAdapter, renderStreamMessage, session, setConfirmMethod, setFormMode, setProgressBarDelay, start, visit };\n", "import 'prismjs';\nimport 'prismjs/components/prism-clike';\nimport 'prismjs/components/prism-markup';\nimport 'prismjs/components/prism-markup-templating';\nimport 'prismjs/components/prism-ruby';\nimport 'prismjs/components/prism-php';\nimport 'prismjs/components/prism-go';\nimport 'prismjs/components/prism-bash';\nimport 'prismjs/components/prism-json';\nimport 'prismjs/components/prism-diff';\nimport DOMPurify from 'dompurify';\nimport { getStyleObjectFromCSS, getCSSFromStyleObject, $getSelectionStyleValueForProperty, $patchStyleText } from '@lexical/selection';\nimport { $isTextNode, TextNode, $isRangeSelection, SKIP_DOM_SELECTION_TAG, SELECTION_CHANGE_COMMAND, COMMAND_PRIORITY_HIGH, $getSelection, DecoratorNode, $getNodeByKey, HISTORY_MERGE_TAG, FORMAT_TEXT_COMMAND, $createTextNode, $isRootOrShadowRoot, UNDO_COMMAND, REDO_COMMAND, PASTE_COMMAND, COMMAND_PRIORITY_LOW, KEY_TAB_COMMAND, COMMAND_PRIORITY_NORMAL, OUTDENT_CONTENT_COMMAND, INDENT_CONTENT_COMMAND, $isNodeSelection, $getRoot, $isLineBreakNode, $isElementNode, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ARROW_DOWN_COMMAND, KEY_DELETE_COMMAND, KEY_BACKSPACE_COMMAND, $createNodeSelection, $setSelection, $createParagraphNode, KEY_ENTER_COMMAND, $isParagraphNode, $insertNodes, $createLineBreakNode, PASTE_TAG, createCommand, createState, defineExtension, $setState, $getState, $hasUpdateTag, CLEAR_HISTORY_COMMAND, $addUpdateTag, KEY_DOWN_COMMAND, KEY_SPACE_COMMAND } from 'lexical';\nimport { $isListNode, $isListItemNode, INSERT_UNORDERED_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, ListNode, $getListDepth, $createListNode, ListItemNode, registerList } from '@lexical/list';\nimport { $isQuoteNode, $isHeadingNode, $createQuoteNode, $createHeadingNode, RichTextExtension, QuoteNode, HeadingNode, registerRichText } from '@lexical/rich-text';\nimport { $isCodeNode, CodeNode, normalizeCodeLang, CodeHighlightNode, registerCodeHighlighting, CODE_LANGUAGE_FRIENDLY_NAME_MAP } from '@lexical/code';\nimport { $isLinkNode, $createAutoLinkNode, $toggleLink, $createLinkNode, LinkNode, AutoLinkNode } from '@lexical/link';\nimport { $getTableCellNodeFromLexicalNode, INSERT_TABLE_COMMAND, TableCellNode, TableNode, TableRowNode, registerTablePlugin, registerTableSelectionObserver, setScrollableTablesActive, TableCellHeaderStates, $insertTableRowAtSelection, $insertTableColumnAtSelection, $deleteTableRowAtSelection, $deleteTableColumnAtSelection, $findTableNode, $getTableRowIndexFromTableCellNode, $getTableColumnIndexFromTableCellNode, $findCellNode, $getElementForTableNode } from '@lexical/table';\nimport { createElement, createAttachmentFigure, isPreviewableImage, dispatchCustomEvent, parseHtml, dispatch, generateDomId } from './lexxy_helpers.esm.js';\nexport { highlightCode as highlightAll, highlightCode } from './lexxy_helpers.esm.js';\nimport { buildEditorFromExtensions } from '@lexical/extension';\nimport { registerPlainText } from '@lexical/plain-text';\nimport { $generateNodesFromDOM, $generateHtmlFromNodes } from '@lexical/html';\nimport { registerMarkdownShortcuts, TRANSFORMERS } from '@lexical/markdown';\nimport { createEmptyHistoryState, registerHistory } from '@lexical/history';\nimport { $getNearestNodeOfType } from '@lexical/utils';\nimport { marked } from 'marked';\nimport { $insertDataTransferForRichText } from '@lexical/clipboard';\n\n// Configure Prism for manual highlighting mode\n// This must be set before importing prismjs\nwindow.Prism = window.Prism || {};\nwindow.Prism.manual = true;\n\nfunction deepMerge(target, source) {\n  const result = { ...target, ...source };\n  for (const [ key, value ] of Object.entries(source)) {\n    if (arePlainHashes(target[key], value)) {\n      result[key] = deepMerge(target[key], value);\n    }\n  }\n\n  return result\n}\n\nfunction arePlainHashes(...values) {\n  return values.every(value => value && value.constructor == Object)\n}\n\nclass Configuration {\n  #tree = {}\n\n  constructor(...configs) {\n    this.merge(...configs);\n  }\n\n  merge(...configs) {\n    return this.#tree = configs.reduce(deepMerge, this.#tree)\n  }\n\n  get(path) {\n    const keys = path.split(\".\");\n    return keys.reduce((node, key) => node[key], this.#tree)\n  }\n}\n\nfunction range(from, to) {\n  return [ ...Array(1 + to - from).keys() ].map(i => i + from)\n}\n\nconst global = new Configuration({\n  attachmentTagName: \"action-text-attachment\",\n  attachmentContentTypeNamespace: \"actiontext\",\n  authenticatedUploads: false,\n  extensions: []\n});\n\nconst presets = new Configuration({\n  default: {\n    attachments: true,\n    markdown: true,\n    multiLine: true,\n    richText: true,\n    toolbar: true,\n    highlight: {\n      buttons: {\n        color: range(1, 9).map(n => `var(--highlight-${n})`),\n        \"background-color\": range(1, 9).map(n => `var(--highlight-bg-${n})`),\n      },\n      permit: {\n        color: [],\n        \"background-color\": []\n      }\n    }\n  }\n});\n\nvar Lexxy = {\n  global,\n  presets,\n  configure({ global: newGlobal, ...newPresets }) {\n    if (newGlobal) {\n      global.merge(newGlobal);\n    }\n    presets.merge(newPresets);\n  }\n};\n\nconst ALLOWED_HTML_TAGS = [ \"a\", \"b\", \"blockquote\", \"br\", \"code\", \"em\",\n  \"figcaption\", \"figure\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"i\", \"img\", \"li\", \"mark\", \"ol\", \"p\", \"pre\", \"q\", \"s\", \"strong\", \"ul\", \"table\", \"tbody\", \"tr\", \"th\", \"td\" ];\n\nconst ALLOWED_HTML_ATTRIBUTES = [ \"alt\", \"caption\", \"class\", \"content\", \"content-type\", \"contenteditable\",\n  \"data-direct-upload-id\", \"data-sgid\", \"filename\", \"filesize\", \"height\", \"href\", \"presentation\",\n  \"previewable\", \"sgid\", \"src\", \"style\", \"title\", \"url\", \"width\" ];\n\nconst ALLOWED_STYLE_PROPERTIES = [ \"color\", \"background-color\" ];\n\nfunction styleFilterHook(_currentNode, hookEvent) {\n  if (hookEvent.attrName === \"style\" && hookEvent.attrValue) {\n    const styles = { ...getStyleObjectFromCSS(hookEvent.attrValue) };\n    const sanitizedStyles = { };\n\n    for (const property in styles) {\n      if (ALLOWED_STYLE_PROPERTIES.includes(property)) {\n        sanitizedStyles[property] = styles[property];\n      }\n    }\n\n    if (Object.keys(sanitizedStyles).length) {\n      hookEvent.attrValue = getCSSFromStyleObject(sanitizedStyles);\n    } else {\n      hookEvent.keepAttr = false;\n    }\n  }\n}\n\nDOMPurify.addHook(\"uponSanitizeAttribute\", styleFilterHook);\n\nDOMPurify.addHook(\"uponSanitizeElement\", (node, data) => {\n  if (data.tagName === \"strong\" || data.tagName === \"em\") {\n    node.removeAttribute(\"class\");\n  }\n});\n\nfunction buildConfig() {\n  return {\n    ALLOWED_TAGS: ALLOWED_HTML_TAGS.concat(Lexxy.global.get(\"attachmentTagName\")),\n    ALLOWED_ATTR: ALLOWED_HTML_ATTRIBUTES,\n    ADD_URI_SAFE_ATTR: [ \"caption\", \"filename\" ],\n    SAFE_FOR_XML: false // So that it does not strip attributes that contains serialized HTML (like content)\n  }\n}\n\nfunction getNonce() {\n  const element = document.head.querySelector(\"meta[name=csp-nonce]\");\n  return element?.content\n}\n\nfunction getNearestListItemNode(node) {\n  let current = node;\n  while (current !== null) {\n    if ($isListItemNode(current)) return current\n    current = current.getParent();\n  }\n  return null\n}\n\nfunction getListType(node) {\n  let current = node;\n  while (current) {\n    if ($isListNode(current)) {\n      return current.getListType()\n    }\n    current = current.getParent();\n  }\n  return null\n}\n\nfunction isPrintableCharacter(event) {\n  // Ignore if modifier keys are pressed (except Shift for uppercase)\n  if (event.ctrlKey || event.metaKey || event.altKey) return false\n\n  // Ignore special keys\n  if (event.key.length > 1 && event.key !== \"Enter\" && event.key !== \"Space\") return false\n\n  // Accept single character keys (letters, numbers, punctuation)\n  return event.key.length === 1\n}\n\nfunction extendTextNodeConversion(conversionName, ...callbacks) {\n  return extendConversion(TextNode, conversionName, (conversionOutput, element) => ({\n    ...conversionOutput,\n    forChild: (lexicalNode, parentNode) => {\n      const originalForChild = conversionOutput?.forChild ?? (x => x);\n      let childNode = originalForChild(lexicalNode, parentNode);\n\n\n      if ($isTextNode(childNode)) {\n        childNode = callbacks.reduce(\n          (childNode, callback) => callback(childNode, element) ?? childNode,\n          childNode\n        );\n        return childNode\n      }\n    }\n  }))\n}\n\nfunction extendConversion(nodeKlass, conversionName, callback = (output => output)) {\n  return (element) => {\n    const converter = nodeKlass.importDOM()?.[conversionName]?.(element);\n    if (!converter) return null\n\n    const conversionOutput = converter.conversion(element);\n    if (!conversionOutput) return conversionOutput\n\n    return callback(conversionOutput, element) ?? conversionOutput\n  }\n}\n\nfunction isSelectionHighlighted(selection) {\n  if (!$isRangeSelection(selection)) return false\n\n  if (selection.isCollapsed()) {\n    return hasHighlightStyles(selection.style)\n  } else {\n    return selection.hasFormat(\"highlight\")\n  }\n}\n\nfunction hasHighlightStyles(cssOrStyles) {\n  const styles = typeof cssOrStyles === \"string\" ? getStyleObjectFromCSS(cssOrStyles) : cssOrStyles;\n  return !!(styles.color || styles[\"background-color\"])\n}\n\nclass StyleCanonicalizer {\n  constructor(property, allowedValues= []) {\n    this._property = property;\n    this._allowedValues = allowedValues;\n    this._canonicalValues = this.#allowedValuesIdentityObject;\n  }\n\n  applyCanonicalization(css) {\n    const styles = { ...getStyleObjectFromCSS(css) };\n\n    styles[this._property] = this.getCanonicalAllowedValue(styles[this._property]);\n    if (!styles[this._property]) {\n      delete styles[this._property];\n    }\n\n    return getCSSFromStyleObject(styles)\n  }\n\n  getCanonicalAllowedValue(value) {\n    return this._canonicalValues[value] ||= this.#resolveCannonicalValue(value)\n  }\n\n  // Private\n\n  get #allowedValuesIdentityObject() {\n    return this._allowedValues.reduce((object, value) => ({ ...object, [value]: value }), {})\n  }\n\n  #resolveCannonicalValue(value) {\n    let index = this.#computedAllowedValues.indexOf(value);\n    index ||= this.#computedAllowedValues.indexOf(getComputedStyleForProperty(this._property, value));\n    return index === -1 ? null : this._allowedValues[index]\n  }\n\n  get #computedAllowedValues() {\n    return this._computedAllowedValues ||= this._allowedValues.map(\n      value => getComputedStyleForProperty(this._property, value)\n    )\n  }\n}\n\nfunction getComputedStyleForProperty(property, value) {\n  const style = `${property}: ${value};`;\n\n  // the element has to be attached to the DOM have computed styles\n  const element = document.body.appendChild(createElement(\"span\", { style: \"display: none;\" + style }));\n  const computedStyle = window.getComputedStyle(element).getPropertyValue(property);\n  element.remove();\n\n  return computedStyle\n}\n\nfunction handleRollingTabIndex(elements, event) {\n  const previousActiveElement = document.activeElement;\n\n  if (elements.includes(previousActiveElement)) {\n    const finder = new NextElementFinder(elements, event.key);\n\n    if (finder.selectNext(previousActiveElement)) {\n      event.preventDefault();\n    }\n  }\n}\n\nclass NextElementFinder {\n  constructor(elements, key) {\n    this.elements = elements;\n    this.key = key;\n  }\n\n  selectNext(fromElement) {\n    const nextElement = this.#findNextElement(fromElement);\n\n    if (nextElement) {\n      const inactiveElements = this.elements.filter(element => element !== nextElement);\n      this.#unsetTabIndex(inactiveElements);\n      this.#focusWithActiveTabIndex(nextElement);\n      return true\n    }\n\n    return false\n  }\n\n  #findNextElement(fromElement) {\n    switch (this.key) {\n      case \"ArrowRight\":\n      case \"ArrowDown\":\n        return this.#findNextSibling(fromElement)\n\n      case \"ArrowLeft\":\n      case \"ArrowUp\":\n        return this.#findPreviousSibling(fromElement)\n\n      case \"Home\":\n        return this.#findFirst()\n\n      case \"End\":\n        return this.#findLast()\n    }\n  }\n\n  #findFirst(elements = this.elements) {\n    return elements.find(isActiveAndVisible)\n  }\n\n  #findLast(elements = this.elements) {\n    return elements.findLast(isActiveAndVisible)\n  }\n\n  #findNextSibling(element) {\n    const afterElements = this.elements.slice(this.#indexOf(element) + 1);\n    return this.#findFirst(afterElements)\n  }\n\n  #findPreviousSibling(element) {\n    const beforeElements = this.elements.slice(0, this.#indexOf(element));\n    return this.#findLast(beforeElements)\n  }\n\n  #indexOf(element) {\n    return this.elements.indexOf(element)\n  }\n\n  #focusWithActiveTabIndex(element) {\n    if (isActiveAndVisible(element)) {\n      element.tabIndex = 0;\n      element.focus();\n    }\n  }\n\n  #unsetTabIndex(elements) {\n    elements.forEach(element => element.tabIndex = -1);\n  }\n}\n\nfunction isActiveAndVisible(element) {\n  return element && !element.disabled && element.checkVisibility()\n}\n\nclass LexicalToolbarElement extends HTMLElement {\n  static observedAttributes = [ \"connected\" ]\n\n  constructor() {\n    super();\n    this.internals = this.attachInternals();\n    this.internals.role = \"toolbar\";\n\n    this.#createEditorPromise();\n  }\n\n  connectedCallback() {\n    requestAnimationFrame(() => this.#refreshToolbarOverflow());\n    this.setAttribute(\"role\", \"toolbar\");\n    this.#installResizeObserver();\n  }\n\n  disconnectedCallback() {\n    this.#uninstallResizeObserver();\n    this.#unbindHotkeys();\n    this.#unbindFocusListeners();\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"connected\" && this.isConnected && oldValue != null && oldValue !== newValue) {\n      requestAnimationFrame(() => this.#reconnect());\n    }\n  }\n\n  setEditor(editorElement) {\n    this.editorElement = editorElement;\n    this.editor = editorElement.editor;\n    this.#bindButtons();\n    this.#bindHotkeys();\n    this.#resetTabIndexValues();\n    this.#setItemPositionValues();\n    this.#monitorSelectionChanges();\n    this.#monitorHistoryChanges();\n    this.#refreshToolbarOverflow();\n    this.#bindFocusListeners();\n\n    this.resolveEditorPromise(editorElement);\n\n    this.toggleAttribute(\"connected\", true);\n  }\n\n  async getEditorElement() {\n    return this.editorElement || await this.editorPromise\n  }\n\n  #reconnect() {\n    this.disconnectedCallback();\n    this.connectedCallback();\n  }\n\n  #createEditorPromise() {\n    this.editorPromise = new Promise((resolve) => {\n      this.resolveEditorPromise = resolve;\n    });\n  }\n\n  #installResizeObserver() {\n    this.resizeObserver = new ResizeObserver(() => this.#refreshToolbarOverflow());\n    this.resizeObserver.observe(this);\n  }\n\n  #uninstallResizeObserver() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n  }\n\n  #bindButtons() {\n    this.addEventListener(\"click\", this.#handleButtonClicked.bind(this));\n  }\n\n  #handleButtonClicked(event) {\n    this.#handleTargetClicked(event, \"[data-command]\", this.#dispatchButtonCommand.bind(this));\n  }\n\n  #handleTargetClicked(event, selector, callback) {\n    const button = event.target.closest(selector);\n    if (button) {\n      callback(event, button);\n    }\n  }\n\n  #dispatchButtonCommand(event, { dataset: { command, payload } }) {\n    const isKeyboard = event instanceof PointerEvent && event.pointerId === -1;\n\n    this.editor.update(() => {\n      this.editor.dispatchCommand(command, payload);\n    }, { tag: isKeyboard ? SKIP_DOM_SELECTION_TAG : undefined } );\n  }\n\n  #bindHotkeys() {\n    this.editorElement.addEventListener(\"keydown\", this.#handleHotkey);\n  }\n\n  #unbindHotkeys() {\n    this.editorElement?.removeEventListener(\"keydown\", this.#handleHotkey);\n  }\n\n  #handleHotkey = (event) => {\n    const buttons = this.querySelectorAll(\"[data-hotkey]\");\n    buttons.forEach((button) => {\n      const hotkeys = button.dataset.hotkey.toLowerCase().split(/\\s+/);\n      if (hotkeys.includes(this.#keyCombinationFor(event))) {\n        event.preventDefault();\n        event.stopPropagation();\n        button.click();\n      }\n    });\n  }\n\n  #keyCombinationFor(event) {\n    const pressedKey = event.key.toLowerCase();\n    const modifiers = [\n      event.ctrlKey ? \"ctrl\" : null,\n      event.metaKey ? \"cmd\" : null,\n      event.altKey ? \"alt\" : null,\n      event.shiftKey ? \"shift\" : null,\n    ].filter(Boolean);\n\n    return [ ...modifiers, pressedKey ].join(\"+\")\n  }\n\n  #bindFocusListeners() {\n    this.editorElement.addEventListener(\"lexxy:focus\", this.#handleEditorFocus);\n    this.editorElement.addEventListener(\"lexxy:blur\", this.#handleEditorBlur);\n    this.addEventListener(\"keydown\", this.#handleKeydown);\n  }\n\n  #unbindFocusListeners() {\n    this.editorElement.removeEventListener(\"lexxy:focus\", this.#handleEditorFocus);\n    this.editorElement.removeEventListener(\"lexxy:blur\", this.#handleEditorBlur);\n    this.removeEventListener(\"keydown\", this.#handleKeydown);\n  }\n\n  #handleEditorFocus = () => {\n    this.#focusableItems[0].tabIndex = 0;\n  }\n\n  #handleEditorBlur = () => {\n    this.#resetTabIndexValues();\n    this.#closeDropdowns();\n  }\n\n  #handleKeydown = (event) => {\n    handleRollingTabIndex(this.#focusableItems, event);\n  }\n\n  #resetTabIndexValues() {\n    this.#focusableItems.forEach((button) => {\n      button.tabIndex = -1;\n    });\n  }\n\n  #monitorSelectionChanges() {\n    this.editor.registerCommand(\n      SELECTION_CHANGE_COMMAND,\n      () => {\n        this.#closeDropdowns();\n        this.#updateButtonStates();\n        return false\n      }, COMMAND_PRIORITY_HIGH);\n  }\n\n  #monitorHistoryChanges() {\n    this.editor.registerUpdateListener(() => {\n      this.#updateUndoRedoButtonStates();\n    });\n  }\n\n  #updateUndoRedoButtonStates() {\n    this.editor.getEditorState().read(() => {\n      const historyState = this.editorElement.historyState;\n      if (historyState) {\n        this.#setButtonDisabled(\"undo\", historyState.undoStack.length === 0);\n        this.#setButtonDisabled(\"redo\", historyState.redoStack.length === 0);\n      }\n    });\n  }\n\n  #updateButtonStates() {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) return\n\n    const anchorNode = selection.anchor.getNode();\n    if (!anchorNode.getParent()) { return }\n\n    const topLevelElement = anchorNode.getTopLevelElementOrThrow();\n\n    const isBold = selection.hasFormat(\"bold\");\n    const isItalic = selection.hasFormat(\"italic\");\n    const isStrikethrough = selection.hasFormat(\"strikethrough\");\n    const isHighlight = isSelectionHighlighted(selection);\n    const isInLink = this.#isInLink(anchorNode);\n    const isInQuote = $isQuoteNode(topLevelElement);\n    const isInHeading = $isHeadingNode(topLevelElement);\n    const isInCode = $isCodeNode(topLevelElement) || selection.hasFormat(\"code\");\n    const isInList = this.#isInList(anchorNode);\n    const listType = getListType(anchorNode);\n    const isInTable = $getTableCellNodeFromLexicalNode(anchorNode) !== null;\n\n    this.#setButtonPressed(\"bold\", isBold);\n    this.#setButtonPressed(\"italic\", isItalic);\n    this.#setButtonPressed(\"strikethrough\", isStrikethrough);\n    this.#setButtonPressed(\"highlight\", isHighlight);\n    this.#setButtonPressed(\"link\", isInLink);\n    this.#setButtonPressed(\"quote\", isInQuote);\n    this.#setButtonPressed(\"heading\", isInHeading);\n    this.#setButtonPressed(\"code\", isInCode);\n    this.#setButtonPressed(\"unordered-list\", isInList && listType === \"bullet\");\n    this.#setButtonPressed(\"ordered-list\", isInList && listType === \"number\");\n    this.#setButtonPressed(\"table\", isInTable);\n\n    this.#updateUndoRedoButtonStates();\n  }\n\n  #isInList(node) {\n    let current = node;\n    while (current) {\n      if ($isListNode(current) || $isListItemNode(current)) return true\n      current = current.getParent();\n    }\n    return false\n  }\n\n  #isInLink(node) {\n    let current = node;\n    while (current) {\n      if ($isLinkNode(current)) return true\n      current = current.getParent();\n    }\n    return false\n  }\n\n  #setButtonPressed(name, isPressed) {\n    const button = this.querySelector(`[name=\"${name}\"]`);\n    if (button) {\n      button.setAttribute(\"aria-pressed\", isPressed.toString());\n    }\n  }\n\n  #setButtonDisabled(name, isDisabled) {\n    const button = this.querySelector(`[name=\"${name}\"]`);\n    if (button) {\n      button.disabled = isDisabled;\n      button.setAttribute(\"aria-disabled\", isDisabled.toString());\n    }\n  }\n\n  #toolbarIsOverflowing() {\n    // Safari can report inconsistent clientWidth values on more than 100% window zoom level,\n    // that was affecting the toolbar overflow calculation. We're adding +1 to get around this issue.\n    return (this.scrollWidth - this.#overflow.clientWidth) > this.clientWidth + 1\n  }\n\n  #refreshToolbarOverflow = () => {\n    this.#resetToolbarOverflow();\n    this.#compactMenu();\n\n    this.#overflow.style.display = this.#overflowMenu.children.length ? \"block\" : \"none\";\n    this.#overflow.setAttribute(\"nonce\", getNonce());\n\n    const isOverflowing = this.#overflowMenu.children.length > 0;\n    this.toggleAttribute(\"overflowing\", isOverflowing);\n    this.#overflowMenu.toggleAttribute(\"disabled\", !isOverflowing);\n  }\n\n  #compactMenu() {\n    const buttons = this.#buttons.reverse();\n    let movedToOverflow = false;\n\n    for (const button of buttons) {\n      if (this.#toolbarIsOverflowing()) {\n        this.#overflowMenu.prepend(button);\n        movedToOverflow = true;\n      } else {\n        if (movedToOverflow) this.#overflowMenu.prepend(button);\n        break\n      }\n    }\n  }\n\n  #resetToolbarOverflow() {\n    const items = Array.from(this.#overflowMenu.children);\n    items.sort((a, b) => this.#itemPosition(b) - this.#itemPosition(a));\n\n    items.forEach((item) => {\n      const nextItem = this.querySelector(`[data-position=\"${this.#itemPosition(item) + 1}\"]`) ?? this.#overflow;\n      this.insertBefore(item, nextItem);\n    });\n  }\n\n  #itemPosition(item) {\n    return parseInt(item.dataset.position ?? \"999\")\n  }\n\n  #setItemPositionValues() {\n    this.#toolbarItems.forEach((item, index) => {\n      if (item.dataset.position === undefined) {\n        item.dataset.position = index;\n      }\n    });\n  }\n\n  #closeDropdowns() {\n   this.#dropdowns.forEach((details) => {\n     details.open = false;\n   });\n }\n\n  get #dropdowns() {\n    return this.querySelectorAll(\"details\")\n  }\n\n  get #overflow() {\n    return this.querySelector(\".lexxy-editor__toolbar-overflow\")\n  }\n\n  get #overflowMenu() {\n    return this.querySelector(\".lexxy-editor__toolbar-overflow-menu\")\n  }\n\n  get #buttons() {\n    return Array.from(this.querySelectorAll(\":scope > button\"))\n  }\n\n  get #focusableItems() {\n    return Array.from(this.querySelectorAll(\":scope button, :scope > details > summary\"))\n  }\n\n  get #toolbarItems() {\n    return Array.from(this.querySelectorAll(\":scope > *:not(.lexxy-editor__toolbar-overflow)\"))\n  }\n\n  static get defaultTemplate() {\n    return `\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"bold\" data-command=\"bold\" title=\"Bold\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5 22V2h8.183c1.764 0 3.174.435 4.228 1.304 1.055.87 1.582 2.076 1.582 3.62 0 .8-.148 1.503-.445 2.109a3.94 3.94 0 01-1.194 1.465 4.866 4.866 0 01-1.726.806v.176c.786.078 1.51.312 2.172.703a4.293 4.293 0 011.596 1.627c.403.693.604 1.543.604 2.549 0 1.192-.292 2.207-.877 3.048-.585.84-1.39 1.484-2.416 1.934-1.026.44-2.206.659-3.538.659H5zM8.854 4.974v5.348h2.56c.873 0 1.582-.107 2.129-.322.556-.215.963-.523 1.222-.923.269-.41.403-.904.403-1.48 0-.82-.254-1.46-.762-1.92-.499-.468-1.204-.703-2.115-.703H8.854zm0 8.103v5.949h2.877c1.534 0 2.636-.245 3.307-.733.671-.498 1.007-1.221 1.007-2.168 0-.635-.134-1.178-.403-1.627-.268-.459-.666-.81-1.193-1.055-.518-.244-1.156-.366-1.913-.366H8.854z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"italic\" data-command=\"italic\" title=\"Italic\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.1 4h-1.5l-3.2 16h1.5l-.4 2h-7l.4-2h1.5l3.2-16h-1.5l.4-2h7l-.4 2z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"strikethrough\" data-command=\"strikethrough\" title=\"Strikethrough\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n          <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.70588 16.1591C4.81459 19.7901 7.48035 22 11.6668 22C15.9854 22 18.724 19.6296 18.724 15.8779C18.724 15.5007 18.6993 15.1427 18.6474 14.8066H14.3721C14.8637 15.2085 15.0799 15.7037 15.0799 16.3471C15.0799 17.7668 13.7532 18.7984 11.8113 18.7984C9.88053 18.7984 8.38582 17.7531 8.21659 16.1591H4.70588ZM5.23953 9.31962H9.88794C9.10723 8.88889 8.75888 8.33882 8.75888 7.57339C8.75888 6.13992 9.96576 5.18793 11.7631 5.18793C13.5852 5.18793 14.8761 6.1797 14.9959 7.81344H18.4102C18.3485 4.31824 15.8038 2 11.752 2C7.867 2 5.09129 4.35802 5.09129 7.92044C5.09129 8.41838 5.14071 8.88477 5.23953 9.31962ZM2.23529 10.6914C1.90767 10.6914 1.59347 10.8359 1.36181 11.0931C1.13015 11.3504 1 11.6993 1 12.0631C1 12.4269 1.13015 12.7758 1.36181 13.0331C1.59347 13.2903 1.90767 13.4348 2.23529 13.4348H20.7647C21.0923 13.4348 21.4065 13.2903 21.6382 13.0331C21.8699 12.7758 22 12.4269 22 12.0631C22 11.6993 21.8699 11.3504 21.6382 11.0931C21.4065 10.8359 21.0923 10.6914 20.7647 10.6914H2.23529Z\"/>\n        </svg>\n      </button>\n\n      <details class=\"lexxy-editor__toolbar-dropdown\" name=\"lexxy-dropdown\">\n        <summary class=\"lexxy-editor__toolbar-button\" name=\"highlight\" title=\"Color highlight\">\n          <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.65422 0.711575C7.1856 0.242951 6.42579 0.242951 5.95717 0.711575C5.48853 1.18021 5.48853 1.94 5.95717 2.40864L8.70864 5.16011L2.85422 11.0145C1.44834 12.4204 1.44833 14.6998 2.85422 16.1057L7.86011 21.1115C9.26599 22.5174 11.5454 22.5174 12.9513 21.1115L19.6542 14.4087C20.1228 13.94 20.1228 13.1802 19.6542 12.7115L11.8544 4.91171L11.2542 4.31158L7.65422 0.711575ZM4.55127 12.7115L10.4057 6.85716L17.1087 13.56H4.19981C4.19981 13.253 4.31696 12.9459 4.55127 12.7115ZM23.6057 20.76C23.6057 22.0856 22.5311 23.16 21.2057 23.16C19.8802 23.16 18.8057 22.0856 18.8057 20.76C18.8057 19.5408 19.8212 18.5339 20.918 17.4462C21.0135 17.3516 21.1096 17.2563 21.2057 17.16C21.3018 17.2563 21.398 17.3516 21.4935 17.4462C22.5903 18.5339 23.6057 19.5408 23.6057 20.76Z\"/></svg>\n        </summary>\n        <lexxy-highlight-dropdown class=\"lexxy-editor__toolbar-dropdown-content\">\n          <div class=\"lexxy-highlight-colors\"></div>\n          <button data-command=\"removeHighlight\" class=\"lexxy-editor__toolbar-button lexxy-editor__toolbar-dropdown-reset\">Remove all coloring</button>\n        </lexxy-highlight-dropdown>\n      </details>\n\n      <details class=\"lexxy-editor__toolbar-dropdown\" name=\"lexxy-dropdown\">\n        <summary class=\"lexxy-editor__toolbar-button\" name=\"link\" title=\"Link\" data-hotkey=\"cmd+k ctrl+k\">\n          <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.111 9.546a1.5 1.5 0 012.121 0 5.5 5.5 0 010 7.778l-2.828 2.828a5.5 5.5 0 01-7.778 0 5.498 5.498 0 010-7.777l2.828-2.83a1.5 1.5 0 01.355-.262 6.52 6.52 0 00.351 3.799l-1.413 1.414a2.499 2.499 0 000 3.535 2.499 2.499 0 003.535 0l2.83-2.828a2.5 2.5 0 000-3.536 1.5 1.5 0 010-2.121z\"/><path d=\"M12.111 3.89a5.5 5.5 0 117.778 7.777l-2.828 2.829a1.496 1.496 0 01-.355.262 6.522 6.522 0 00-.351-3.8l1.413-1.412a2.5 2.5 0 10-3.536-3.535l-2.828 2.828a2.5 2.5 0 000 3.536 1.5 1.5 0 01-2.122 2.12 5.5 5.5 0 010-7.777l2.83-2.829z\"/></svg>\n        </summary>\n        <lexxy-link-dropdown class=\"lexxy-editor__toolbar-dropdown-content\">\n          <form method=\"dialog\">\n            <input type=\"url\" placeholder=\"Enter a URL\u2026\" class=\"input\">\n            <div class=\"lexxy-editor__toolbar-dropdown-actions\">\n              <button type=\"submit\" class=\"lexxy-editor__toolbar-button\" value=\"link\">Link</button>\n              <button type=\"button\" class=\"lexxy-editor__toolbar-button\" value=\"unlink\">Unlink</button>\n            </div>\n          </form>\n        </lexxy-link-dropdown>\n      </details>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"quote\" data-command=\"insertQuoteBlock\" title=\"Quote\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.5 5C8.985 5 11 7.09 11 9.667c0 2.694-.962 5.005-2.187 6.644-.613.82-1.3 1.481-1.978 1.943-.668.454-1.375.746-2.022.746a.563.563 0 01-.52-.36.602.602 0 01.067-.57l.055-.066.009-.009.041-.048a4.25 4.25 0 00.168-.21c.143-.188.336-.47.53-.84a6.743 6.743 0 00.75-2.605C3.705 13.994 2 12.038 2 9.667 2 7.089 4.015 5 6.5 5zM17.5 5C19.985 5 22 7.09 22 9.667c0 2.694-.962 5.005-2.187 6.644-.613.82-1.3 1.481-1.978 1.943-.668.454-1.375.746-2.023.746a.563.563 0 01-.52-.36.602.602 0 01.068-.57l.055-.066.009-.009.041-.048c.039-.045.097-.115.168-.21a6.16 6.16 0 00.53-.84 6.745 6.745 0 00.75-2.605C14.705 13.994 13 12.038 13 9.667 13 7.089 15.015 5 17.5 5z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"heading\" data-command=\"rotateHeadingFormat\" title=\"Heading\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.322 5.315H9.64V22H5.684V5.315H0v-3.31h15.322v3.31z\"/><path d=\"M23.957 11.79H19.92V22h-3.402V11.79H12.48V9.137h11.477v2.653z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"code\" data-command=\"insertCodeBlock\" title=\"Code\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.121 6l-6 6 6 6-2.12 2.121-7.061-7.06a1.5 1.5 0 010-2.121L8 3.879 10.121 6zM23.06 10.94a1.5 1.5 0 010 2.12L16 20.121 13.88 18l6-6-6-6L16 3.879l7.06 7.06z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"unordered-list\" data-command=\"insertUnorderedList\" title=\"Bullet list\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5 5a2 2 0 11-4 0 2 2 0 014 0zM5 12a2 2 0 11-4 0 2 2 0 014 0zM5 19a2 2 0 11-4 0 2 2 0 014 0zM7 5.25C7 4.56 7.56 4 8.25 4h13.5a1.25 1.25 0 110 2.5H8.25C7.56 6.5 7 5.94 7 5.25zM7 12.25c0-.69.56-1.25 1.25-1.25h13.5a1.25 1.25 0 110 2.5H8.25c-.69 0-1.25-.56-1.25-1.25zM7 19.25c0-.69.56-1.25 1.25-1.25h13.5a1.25 1.25 0 110 2.5H8.25c-.69 0-1.25-.56-1.25-1.25z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"ordered-list\" data-command=\"insertOrderedList\" title=\"Numbered list\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7 5.25C7 4.56 7.56 4 8.25 4h13.5a1.25 1.25 0 110 2.5H8.25C7.56 6.5 7 5.94 7 5.25zM7 12.25c0-.69.56-1.25 1.25-1.25h13.5a1.25 1.25 0 110 2.5H8.25c-.69 0-1.25-.56-1.25-1.25zM7 19.25c0-.69.56-1.25 1.25-1.25h13.5a1.25 1.25 0 110 2.5H8.25c-.69 0-1.25-.56-1.25-1.25zM4.438 8H3.39V3.684H3.34c-.133.093-.267.188-.402.285l-.407.289a129.5 129.5 0 00-.402.285v-.969l.633-.453c.21-.15.42-.302.629-.453h1.046V8zM2.672 11.258h-1v-.051c0-.206.036-.405.11-.598.075-.195.188-.37.34-.527.15-.156.339-.281.566-.375.229-.094.498-.14.808-.14.367 0 .688.065.961.195s.484.308.633.535c.15.224.226.478.226.762 0 .244-.046.463-.14.656-.091.19-.209.368-.352.535-.14.164-.289.332-.445.504L3.168 14.09v.05h2.238V15H1.723v-.656l1.949-2.102c.096-.101.19-.207.281-.316.091-.112.167-.232.227-.36a.953.953 0 00.09-.41.712.712 0 00-.387-.648.845.845 0 00-.41-.098.81.81 0 00-.43.11.75.75 0 00-.277.293.824.824 0 00-.094.386V11.258zM2.852 19.66v-.812h.562a.917.917 0 00.43-.098.742.742 0 00.293-.266.673.673 0 00.101-.379.654.654 0 00-.234-.523.87.87 0 00-.59-.2.987.987 0 00-.336.055.837.837 0 00-.258.149.712.712 0 00-.172.215.66.66 0 00-.066.25h-.98c.007-.209.053-.403.136-.582.084-.18.203-.336.36-.469.156-.135.346-.24.57-.316.227-.076.486-.115.777-.118a2.33 2.33 0 01.965.176c.271.12.48.285.63.496.15.209.227.448.23.719a1.11 1.11 0 01-.16.637 1.28 1.28 0 01-.825.586v.054c.162.016.33.07.504.164.177.094.328.232.453.415.125.18.189.411.192.695a1.37 1.37 0 01-.157.676c-.104.197-.25.365-.437.503-.188.136-.404.24-.649.313-.242.07-.5.105-.777.105-.401 0-.743-.067-1.027-.203a1.608 1.608 0 01-.649-.547 1.46 1.46 0 01-.238-.75h.969c.01.128.057.243.14.344a.885.885 0 00.332.238c.141.058.3.088.477.09.195 0 .366-.034.512-.101a.798.798 0 00.336-.29.744.744 0 00.117-.425.74.74 0 00-.446-.695 1.082 1.082 0 00-.496-.106h-.59z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"upload\" data-command=\"uploadAttachments\" title=\"Upload file\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16 8a2 2 0 110 4 2 2 0 010-4z\"\"/><path d=\"M22 2a1 1 0 011 1v18a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h20zM3 18.714L9 11l5.25 6.75L17 15l4 4V4H3v14.714z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"table\" data-command=\"insertTable\" title=\"Insert a table\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M20.2041 2.01074C21.2128 2.113 22 2.96435 22 4V20L21.9893 20.2041C21.8938 21.1457 21.1457 21.8938 20.2041 21.9893L20 22H4C2.96435 22 2.113 21.2128 2.01074 20.2041L2 20V4C2 2.89543 2.89543 2 4 2H20L20.2041 2.01074ZM4 13V20H11V13H4ZM13 13V20H20V13H13ZM4 11H11V4H4V11ZM13 11H20V4H13V11Z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"divider\" data-command=\"insertHorizontalDivider\" title=\"Insert a divider\">\n        <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 12C0 11.4477 0.447715 11 1 11H23C23.5523 11 24 11.4477 24 12C24 12.5523 23.5523 13 23 13H1C0.447716 13 0 12.5523 0 12Z\"/><path d=\"M4 5C4 3.89543 4.89543 3 6 3H18C19.1046 3 20 3.89543 20 5C20 6.10457 19.1046 7 18 7H6C4.89543 7 4 6.10457 4 5Z\"/><path d=\"M4 19C4 17.8954 4.89543 17 6 17H18C19.1046 17 20 17.8954 20 19C20 20.1046 19.1046 21 18 21H6C4.89543 21 4 20.1046 4 19Z\"/></svg>\n      </button>\n \n      <div class=\"lexxy-editor__toolbar-spacer\" role=\"separator\"></div>\n \n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"undo\" data-command=\"undo\" title=\"Undo\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.64648 8.26531C7.93911 6.56386 10.7827 5.77629 13.624 6.05535C16.4655 6.33452 19.1018 7.66079 21.0195 9.77605C22.5839 11.5016 23.5799 13.6516 23.8936 15.9352C24.0115 16.7939 23.2974 17.4997 22.4307 17.4997C21.5641 17.4997 20.8766 16.7915 20.7148 15.9401C20.4295 14.4379 19.7348 13.0321 18.6943 11.8844C17.3 10.3464 15.3835 9.38139 13.3174 9.17839C11.2514 8.97546 9.18359 9.54856 7.5166 10.7858C6.38259 11.6275 5.48981 12.7361 4.90723 13.9997H8.5C9.3283 13.9997 9.99979 14.6714 10 15.4997C10 16.3281 9.32843 16.9997 8.5 16.9997H1.5C0.671573 16.9997 0 16.3281 0 15.4997V8.49968C0.000213656 7.67144 0.671705 6.99968 1.5 6.99968C2.3283 6.99968 2.99979 7.67144 3 8.49968V11.0212C3.7166 9.9704 4.60793 9.03613 5.64648 8.26531Z\"/></svg>\n      </button>\n\n      <button class=\"lexxy-editor__toolbar-button\" type=\"button\" name=\"redo\" data-command=\"redo\" title=\"Redo\">\n        <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.2599 8.26531C15.9672 6.56386 13.1237 5.77629 10.2823 6.05535C7.4408 6.33452 4.80455 7.66079 2.88681 9.77605C1.32245 11.5016 0.326407 13.6516 0.0127834 15.9352C-0.105117 16.7939 0.608975 17.4997 1.47567 17.4997C2.34228 17.4997 3.02969 16.7915 3.19149 15.9401C3.47682 14.4379 4.17156 13.0321 5.212 11.8844C6.60637 10.3464 8.52287 9.38139 10.589 9.17839C12.655 8.97546 14.7227 9.54856 16.3897 10.7858C17.5237 11.6275 18.4165 12.7361 18.9991 13.9997H15.4063C14.578 13.9997 13.9066 14.6714 13.9063 15.4997C13.9063 16.3281 14.5779 16.9997 15.4063 16.9997H22.4063C23.2348 16.9997 23.9063 16.3281 23.9063 15.4997V8.49968C23.9061 7.67144 23.2346 6.99968 22.4063 6.99968C21.578 6.99968 20.9066 7.67144 20.9063 8.49968V11.0212C20.1897 9.9704 19.2984 9.03613 18.2599 8.26531Z\"/></svg>\n      </button>\n\n      <details class=\"lexxy-editor__toolbar-dropdown lexxy-editor__toolbar-overflow\" name=\"lexxy-dropdown\">\n        <summary class=\"lexxy-editor__toolbar-button\" aria-label=\"Show more toolbar buttons\">\u2022\u2022\u2022</summary>\n        <div class=\"lexxy-editor__toolbar-dropdown-content lexxy-editor__toolbar-overflow-menu\" aria-label=\"More toolbar buttons\"></div>\n      </details>\n    `\n  }\n}\n\ncustomElements.define(\"lexxy-toolbar\", LexicalToolbarElement);\n\nvar theme = {\n  text: {\n    bold: \"lexxy-content__bold\",\n    italic: \"lexxy-content__italic\",\n    strikethrough: \"lexxy-content__strikethrough\",\n    underline: \"lexxy-content__underline\",\n    highlight: \"lexxy-content__highlight\"\n  },\n  tableCellHeader: \"lexxy-content__table-cell--header\",\n  tableCellSelected: \"lexxy-content__table-cell--selected\",\n  tableSelection: \"lexxy-content__table--selection\",\n  tableScrollableWrapper: \"lexxy-content__table-wrapper\",\n  tableCellHighlight: \"lexxy-content__table-cell--highlight\",\n  tableCellFocus: \"lexxy-content__table-cell--focus\",\n  list: {\n    nested: {\n      listitem: \"lexxy-nested-listitem\",\n    }\n  },\n  codeHighlight: {\n    addition: \"code-token__selector\",\n    atrule: \"code-token__attr\",\n    attr: \"code-token__attr\",\n    \"attr-name\": \"code-token__attr\",\n    \"attr-value\": \"code-token__selector\",\n    boolean: \"code-token__property\",\n    bold: \"code-token__variable\",\n    builtin: \"code-token__selector\",\n    cdata: \"code-token__comment\",\n    char: \"code-token__selector\",\n    class: \"code-token__function\",\n    \"class-name\": \"code-token__function\",\n    color: \"code-token__property\",\n    comment: \"code-token__comment\",\n    constant: \"code-token__property\",\n    coord: \"code-token__comment\",\n    decorator: \"code-token__function\",\n    deleted: \"code-token__operator\",\n    deletion: \"code-token__operator\",\n    directive: \"code-token__attr\",\n    \"directive-hash\": \"code-token__property\",\n    doctype: \"code-token__comment\",\n    entity: \"code-token__operator\",\n    function: \"code-token__function\",\n    hexcode: \"code-token__property\",\n    important: \"code-token__function\",\n    inserted: \"code-token__selector\",\n    italic: \"code-token__comment\",\n    keyword: \"code-token__attr\",\n    line: \"code-token__selector\",\n    namespace: \"code-token__variable\",\n    number: \"code-token__property\",\n    macro: \"code-token__function\",\n    operator: \"code-token__operator\",\n    parameter: \"code-token__variable\",\n    prolog: \"code-token__comment\",\n    property: \"code-token__property\",\n    punctuation: \"code-token__punctuation\",\n    \"raw-string\": \"code-token__operator\",\n    regex: \"code-token__variable\",\n    script: \"code-token__function\",\n    selector: \"code-token__selector\",\n    string: \"code-token__selector\",\n    style: \"code-token__function\",\n    symbol: \"code-token__property\",\n    tag: \"code-token__property\",\n    title: \"code-token__function\",\n    \"type-definition\": \"code-token__function\",\n    url: \"code-token__operator\",\n    variable: \"code-token__variable\",\n  }\n};\n\nfunction bytesToHumanSize(bytes) {\n  if (bytes === 0) return \"0 B\"\n  const sizes = [ \"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\" ];\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  const value = bytes / Math.pow(1024, i);\n  return `${ value.toFixed(2) } ${ sizes[i] }`\n}\n\nclass ActionTextAttachmentNode extends DecoratorNode {\n  static getType() {\n    return \"action_text_attachment\"\n  }\n\n  static clone(node) {\n    return new ActionTextAttachmentNode({ ...node }, node.__key)\n  }\n\n  static importJSON(serializedNode) {\n    return new ActionTextAttachmentNode({ ...serializedNode })\n  }\n\n  static importDOM() {\n    return {\n      [this.TAG_NAME]: () => {\n        return {\n          conversion: (attachment) => ({\n            node: new ActionTextAttachmentNode({\n              sgid: attachment.getAttribute(\"sgid\"),\n              src: attachment.getAttribute(\"url\"),\n              previewable: attachment.getAttribute(\"previewable\"),\n              altText: attachment.getAttribute(\"alt\"),\n              caption: attachment.getAttribute(\"caption\"),\n              contentType: attachment.getAttribute(\"content-type\"),\n              fileName: attachment.getAttribute(\"filename\"),\n              fileSize: attachment.getAttribute(\"filesize\"),\n              width: attachment.getAttribute(\"width\"),\n              height: attachment.getAttribute(\"height\")\n            })\n          }), priority: 1\n        }\n      },\n      \"img\": () => {\n        return {\n          conversion: (img) => ({\n            node: new ActionTextAttachmentNode({\n              src: img.getAttribute(\"src\"),\n              caption: img.getAttribute(\"alt\") || \"\",\n              contentType: \"image/*\",\n              width: img.getAttribute(\"width\"),\n              height: img.getAttribute(\"height\")\n            })\n          }), priority: 1\n        }\n      },\n      \"video\": () => {\n        return {\n          conversion: (video) => {\n            const videoSource = video.getAttribute(\"src\") || video.querySelector(\"source\")?.src;\n            const fileName = videoSource?.split(\"/\")?.pop();\n            const contentType = video.querySelector(\"source\")?.getAttribute(\"content-type\") || \"video/*\";\n\n            return {\n              node: new ActionTextAttachmentNode({\n                src: videoSource,\n                fileName: fileName,\n                contentType: contentType\n              })\n            }\n          }, priority: 1\n        }\n      }\n    }\n  }\n\n  static get TAG_NAME() {\n    return Lexxy.global.get(\"attachmentTagName\")\n  }\n\n  constructor({ tagName, sgid, src, previewable, altText, caption, contentType, fileName, fileSize, width, height }, key) {\n    super(key);\n\n    this.tagName = tagName || ActionTextAttachmentNode.TAG_NAME;\n    this.sgid = sgid;\n    this.src = src;\n    this.previewable = previewable;\n    this.altText = altText || \"\";\n    this.caption = caption || \"\";\n    this.contentType = contentType || \"\";\n    this.fileName = fileName || \"\";\n    this.fileSize = fileSize;\n    this.width = width;\n    this.height = height;\n  }\n\n  createDOM() {\n    const figure = this.createAttachmentFigure();\n\n    figure.addEventListener(\"click\", () => {\n      this.#select(figure);\n    });\n\n    if (this.isPreviewableAttachment) {\n      figure.appendChild(this.#createDOMForImage());\n      figure.appendChild(this.#createEditableCaption());\n    } else {\n      figure.appendChild(this.#createDOMForFile());\n      figure.appendChild(this.#createDOMForNotImage());\n    }\n\n    return figure\n  }\n\n  updateDOM() {\n    return true\n  }\n\n  getTextContent() {\n    return `[${this.caption || this.fileName}]\\n\\n`\n  }\n\n  isInline() {\n    return false\n  }\n\n  exportDOM() {\n    const attachment = createElement(this.tagName, {\n      sgid: this.sgid,\n      previewable: this.previewable || null,\n      url: this.src,\n      alt: this.altText,\n      caption: this.caption,\n      \"content-type\": this.contentType,\n      filename: this.fileName,\n      filesize: this.fileSize,\n      width: this.width,\n      height: this.height,\n      presentation: \"gallery\"\n    });\n\n    return { element: attachment }\n  }\n\n  exportJSON() {\n    return {\n      type: \"action_text_attachment\",\n      version: 1,\n      tagName: this.tagName,\n      sgid: this.sgid,\n      src: this.src,\n      previewable: this.previewable,\n      altText: this.altText,\n      caption: this.caption,\n      contentType: this.contentType,\n      fileName: this.fileName,\n      fileSize: this.fileSize,\n      width: this.width,\n      height: this.height\n    }\n  }\n\n  decorate() {\n    return null\n  }\n\n  createAttachmentFigure() {\n    return createAttachmentFigure(this.contentType, this.isPreviewableAttachment, this.fileName)\n  }\n\n  get #isPreviewableImage() {\n    return isPreviewableImage(this.contentType)\n  }\n\n  get isPreviewableAttachment() {\n    return this.#isPreviewableImage || this.previewable\n  }\n\n  #createDOMForImage() {\n    return createElement(\"img\", { src: this.src, alt: this.altText, ...this.#imageDimensions })\n  }\n\n  get #imageDimensions() {\n    if (this.width && this.height) {\n      return { width: this.width, height: this.height }\n    } else {\n      return {}\n    }\n  }\n\n  #createDOMForFile() {\n    const extension = this.fileName ? this.fileName.split(\".\").pop().toLowerCase() : \"unknown\";\n    return createElement(\"span\", { className: \"attachment__icon\", textContent: `${extension}` })\n  }\n\n  #createDOMForNotImage() {\n    const figcaption = createElement(\"figcaption\", { className: \"attachment__caption\" });\n\n    const nameTag = createElement(\"strong\", { className: \"attachment__name\", textContent: this.caption || this.fileName });\n\n    figcaption.appendChild(nameTag);\n\n    if (this.fileSize) {\n      const sizeSpan = createElement(\"span\", { className: \"attachment__size\", textContent: bytesToHumanSize(this.fileSize) });\n      figcaption.appendChild(sizeSpan);\n    }\n\n    return figcaption\n  }\n\n  #select(figure) {\n    dispatchCustomEvent(figure, \"lexxy:internal:select-node\", { key: this.getKey() });\n  }\n\n  #createEditableCaption() {\n    const caption = createElement(\"figcaption\", { className: \"attachment__caption\" });\n    const input = createElement(\"textarea\", {\n      value: this.caption,\n      placeholder: this.fileName,\n      rows: \"1\"\n    });\n\n    input.addEventListener(\"focusin\", () => input.placeholder = \"Add caption...\");\n    input.addEventListener(\"blur\", this.#handleCaptionInputBlurred.bind(this));\n    input.addEventListener(\"keydown\", this.#handleCaptionInputKeydown.bind(this));\n\n    caption.appendChild(input);\n\n    return caption\n  }\n\n  #handleCaptionInputBlurred(event) {\n    const input = event.target;\n\n    input.placeholder = this.fileName;\n    this.#updateCaptionValueFromInput(input);\n  }\n\n  #updateCaptionValueFromInput(input) {\n    dispatchCustomEvent(input, \"lexxy:internal:invalidate-node\", { key: this.getKey(), values: { caption: input.value } });\n  }\n\n  #handleCaptionInputKeydown(event) {\n    if (event.key === \"Enter\") {\n      this.#updateCaptionValueFromInput(event.target);\n      dispatchCustomEvent(event.target, \"lexxy:internal:move-to-next-line\");\n      event.preventDefault();\n    }\n    event.stopPropagation();\n  }\n}\n\nasync function loadFileIntoImage(file, image) {\n  return new Promise((resolve) => {\n    const reader = new FileReader();\n\n    image.addEventListener(\"load\", () => {\n      resolve(image);\n    });\n\n    reader.onload = (event) => {\n      image.src = event.target.result || null;\n    };\n\n    reader.readAsDataURL(file);\n  })\n}\n\nclass ActionTextAttachmentUploadNode extends ActionTextAttachmentNode {\n  static getType() {\n    return \"action_text_attachment_upload\"\n  }\n\n  static clone(node) {\n    return new ActionTextAttachmentUploadNode({ ...node }, node.__key)\n  }\n\n  static importJSON(serializedNode) {\n    return new ActionTextAttachmentUploadNode({ ...serializedNode })\n  }\n\n  // Should never run since this is a transient node. Defined to remove console warning.\n  static importDOM() {\n    return null\n  }\n\n  constructor(node, key) {\n    const { file, uploadUrl, blobUrlTemplate, editor, progress } = node;\n    super({ ...node, contentType: file.type }, key);\n    this.file = file;\n    this.uploadUrl = uploadUrl;\n    this.blobUrlTemplate = blobUrlTemplate;\n    this.src = null;\n    this.editor = editor;\n    this.progress = progress || 0;\n  }\n\n  createDOM() {\n    const figure = this.createAttachmentFigure();\n\n    if (this.isPreviewableAttachment) {\n      figure.appendChild(this.#createDOMForImage());\n    } else {\n      figure.appendChild(this.#createDOMForFile());\n    }\n\n    figure.appendChild(this.#createCaption());\n\n    const progressBar = createElement(\"progress\", { value: this.progress, max: 100 });\n    figure.appendChild(progressBar);\n\n    // We wait for images to download so that we can pass the dimensions down to the attachment. We do this\n    // so that we can render images in edit mode with the dimensions set, which prevent vertical layout shifts.\n    this.#loadFigure(figure).then(() => this.#startUpload(progressBar, figure));\n\n    return figure\n  }\n\n  exportDOM() {\n    const img = document.createElement(\"img\");\n    if (this.src) {\n      img.src = this.src;\n    }\n    return { element: img }\n  }\n\n  exportJSON() {\n    return {\n      type: \"action_text_attachment_upload\",\n      version: 1,\n      progress: this.progress,\n      uploadUrl: this.uploadUrl,\n      blobUrlTemplate: this.blobUrlTemplate,\n      ...super.exportJSON()\n    }\n  }\n\n  #createDOMForImage() {\n    return createElement(\"img\")\n  }\n\n  #createDOMForFile() {\n    const extension = this.#getFileExtension();\n    const span = createElement(\"span\", { className: \"attachment__icon\", textContent: extension });\n    return span\n  }\n\n  #getFileExtension() {\n    return this.file.name.split(\".\").pop().toLowerCase()\n  }\n\n  #createCaption() {\n    const figcaption = createElement(\"figcaption\", { className: \"attachment__caption\" });\n\n    const nameSpan = createElement(\"span\", { className: \"attachment__name\", textContent: this.file.name || \"\" });\n    const sizeSpan = createElement(\"span\", { className: \"attachment__size\", textContent: bytesToHumanSize(this.file.size) });\n    figcaption.appendChild(nameSpan);\n    figcaption.appendChild(sizeSpan);\n\n    return figcaption\n  }\n\n  #loadFigure(figure) {\n    const image = figure.querySelector(\"img\");\n    if (!image) {\n      return Promise.resolve()\n    } else {\n      return loadFileIntoImage(this.file, image)\n    }\n  }\n\n  async #startUpload(progressBar, figure) {\n    const { DirectUpload } = await import('@rails/activestorage');\n    const shouldAuthenticateUploads = Lexxy.global.get(\"authenticatedUploads\");\n\n    const upload = new DirectUpload(this.file, this.uploadUrl, this);\n\n    upload.delegate = {\n      directUploadWillCreateBlobWithXHR: (request) => {\n        if (shouldAuthenticateUploads) request.withCredentials = true;\n      },\n      directUploadWillStoreFileWithXHR: (request) => {\n        if (shouldAuthenticateUploads) request.withCredentials = true;\n\n        request.upload.addEventListener(\"progress\", (event) => {\n          this.editor.update(() => {\n            progressBar.value = Math.round(event.loaded / event.total * 100);\n          });\n        });\n      }\n    };\n\n    upload.create((error, blob) => {\n      if (error) {\n        this.#handleUploadError(figure);\n      } else {\n        this.#loadFigurePreviewFromBlob(blob, figure).then(() => {\n          this.#showUploadedAttachment(figure, blob);\n        });\n      }\n    });\n  }\n\n  #handleUploadError(figure) {\n    figure.innerHTML = \"\";\n    figure.classList.add(\"attachment--error\");\n    figure.appendChild(createElement(\"div\", { innerText: `Error uploading ${this.file?.name ?? \"image\"}` }));\n  }\n\n  async #showUploadedAttachment(figure, blob) {\n    this.editor.update(() => {\n      const image = figure.querySelector(\"img\");\n\n      const src = this.blobUrlTemplate\n        .replace(\":signed_id\", blob.signed_id)\n        .replace(\":filename\", encodeURIComponent(blob.filename));\n      const latest = $getNodeByKey(this.getKey());\n      if (latest) {\n        latest.replace(new ActionTextAttachmentNode({\n          tagName: this.tagName,\n          sgid: blob.attachable_sgid,\n          src: blob.previewable ? blob.url : src,\n          altText: blob.filename,\n          contentType: blob.content_type,\n          fileName: blob.filename,\n          fileSize: blob.byte_size,\n          width: image?.naturalWidth,\n          previewable: blob.previewable,\n          height: image?.naturalHeight\n        }));\n      }\n    }, { tag: HISTORY_MERGE_TAG });\n  }\n\n  async #loadFigurePreviewFromBlob(blob, figure) {\n    if (blob.previewable) {\n      return new Promise((resolve) => {\n        this.editor.update(() => {\n          const image = this.#createDOMForImage();\n          image.addEventListener(\"load\", () => {\n            resolve();\n          });\n          image.src = blob.url;\n          figure.insertBefore(image, figure.firstChild);\n        });\n      })\n    } else {\n      return Promise.resolve()\n    }\n  }\n}\n\nclass HorizontalDividerNode extends DecoratorNode {\n  static getType() {\n    return \"horizontal_divider\"\n  }\n\n  static clone(node) {\n    return new HorizontalDividerNode(node.__key)\n  }\n\n  static importJSON(serializedNode) {\n    return new HorizontalDividerNode()\n  }\n\n  static importDOM() {\n    return {\n      \"hr\": (hr) => {\n        return {\n          conversion: () => ({\n            node: new HorizontalDividerNode()\n          }),\n          priority: 1\n        }\n      }\n    }\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  createDOM() {\n    const figure = createElement(\"figure\", { className: \"horizontal-divider\" });\n    const hr = createElement(\"hr\");\n\n    figure.addEventListener(\"click\", (event) => {\n      dispatchCustomEvent(figure, \"lexxy:internal:select-node\", { key: this.getKey() });\n    });\n\n    figure.appendChild(hr);\n\n    return figure\n  }\n\n  updateDOM() {\n    return true\n  }\n\n  getTextContent() {\n    return \"\u2504\\n\\n\"\n  }\n\n  isInline() {\n    return false\n  }\n\n  exportDOM() {\n    const hr = createElement(\"hr\");\n    return { element: hr }\n  }\n\n  exportJSON() {\n    return {\n      type: \"horizontal_divider\",\n      version: 1\n    }\n  }\n\n  decorate() {\n    return null\n  }\n}\n\nconst COMMANDS = [\n  \"bold\",\n  \"italic\",\n  \"strikethrough\",\n  \"link\",\n  \"unlink\",\n  \"toggleHighlight\",\n  \"removeHighlight\",\n  \"rotateHeadingFormat\",\n  \"insertUnorderedList\",\n  \"insertOrderedList\",\n  \"insertQuoteBlock\",\n  \"insertCodeBlock\",\n  \"insertHorizontalDivider\",\n  \"uploadAttachments\",\n\n  \"insertTable\",\n\n  \"undo\",\n  \"redo\"\n];\n\nclass CommandDispatcher {\n  static configureFor(editorElement) {\n    new CommandDispatcher(editorElement);\n  }\n\n  constructor(editorElement) {\n    this.editorElement = editorElement;\n    this.editor = editorElement.editor;\n    this.selection = editorElement.selection;\n    this.contents = editorElement.contents;\n    this.clipboard = editorElement.clipboard;\n    this.highlighter = editorElement.highlighter;\n\n    this.#registerCommands();\n    this.#registerKeyboardCommands();\n    this.#registerDragAndDropHandlers();\n  }\n\n  dispatchPaste(event) {\n    return this.clipboard.paste(event)\n  }\n\n  dispatchBold() {\n    this.editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"bold\");\n  }\n\n  dispatchItalic() {\n    this.editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"italic\");\n  }\n\n  dispatchStrikethrough() {\n    this.editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"strikethrough\");\n  }\n\n  dispatchToggleHighlight(styles) {\n    this.highlighter.toggle(styles);\n  }\n\n  dispatchRemoveHighlight() {\n    this.highlighter.remove();\n  }\n\n  dispatchLink(url) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      if (selection.isCollapsed()) {\n        const autoLinkNode = $createAutoLinkNode(url);\n        const textNode = $createTextNode(url);\n        autoLinkNode.append(textNode);\n        selection.insertNodes([ autoLinkNode ]);\n      } else {\n        $toggleLink(url);\n      }\n    });\n  }\n\n  dispatchUnlink() {\n    this.#toggleLink(null);\n  }\n\n  dispatchInsertUnorderedList() {\n    const selection = $getSelection();\n    if (!selection) return\n\n    const anchorNode = selection.anchor.getNode();\n\n    if (this.selection.isInsideList && anchorNode && getListType(anchorNode) === \"bullet\") {\n      this.contents.unwrapSelectedListItems();\n    } else {\n      this.editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined);\n    }\n  }\n\n  dispatchInsertOrderedList() {\n    const selection = $getSelection();\n    if (!selection) return\n\n    const anchorNode = selection.anchor.getNode();\n\n    if (this.selection.isInsideList && anchorNode && getListType(anchorNode) === \"number\") {\n      this.contents.unwrapSelectedListItems();\n    } else {\n      this.editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined);\n    }\n  }\n\n  dispatchInsertQuoteBlock() {\n    this.contents.toggleNodeWrappingAllSelectedNodes((node) => $isQuoteNode(node), () => $createQuoteNode());\n  }\n\n  dispatchInsertCodeBlock() {\n    this.editor.update(() => {\n      if (this.selection.hasSelectedWordsInSingleLine) {\n        this.editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"code\");\n      } else {\n        this.contents.toggleNodeWrappingAllSelectedLines((node) => $isCodeNode(node), () => new CodeNode(\"plain\"));\n      }\n    });\n  }\n\n  dispatchInsertHorizontalDivider() {\n    this.contents.insertAtCursorEnsuringLineBelow(new HorizontalDividerNode());\n\n    this.editor.focus();\n  }\n\n  dispatchRotateHeadingFormat() {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      if ($isRootOrShadowRoot(selection.anchor.getNode())) {\n        selection.insertNodes([ $createHeadingNode(\"h2\") ]);\n        return\n      }\n\n      const topLevelElement = selection.anchor.getNode().getTopLevelElementOrThrow();\n      let nextTag = \"h2\";\n      if ($isHeadingNode(topLevelElement)) {\n        const currentTag = topLevelElement.getTag();\n        if (currentTag === \"h2\") {\n          nextTag = \"h3\";\n        } else if (currentTag === \"h3\") {\n          nextTag = \"h4\";\n        } else if (currentTag === \"h4\") {\n          nextTag = null;\n        } else {\n          nextTag = \"h2\";\n        }\n      }\n\n      if (nextTag) {\n        this.contents.insertNodeWrappingEachSelectedLine(() => $createHeadingNode(nextTag));\n      } else {\n        this.contents.removeFormattingFromSelectedLines();\n      }\n    });\n  }\n\n  dispatchUploadAttachments() {\n    const input = createElement(\"input\", {\n      type: \"file\",\n      multiple: true,\n      style: \"display: none;\",\n      onchange: ({ target }) => {\n        const files = Array.from(target.files);\n        if (!files.length) return\n\n        for (const file of files) {\n          this.contents.uploadFile(file);\n        }\n      }\n    });\n\n    this.editorElement.appendChild(input); // Append and remove just for the sake of making it testable\n    input.click();\n    setTimeout(() => input.remove(), 1000);\n  }\n\n  dispatchInsertTable() {\n    this.editor.dispatchCommand(INSERT_TABLE_COMMAND, { \"rows\": 3, \"columns\": 3, \"includeHeaders\": true });\n  }\n\n  dispatchUndo() {\n    this.editor.dispatchCommand(UNDO_COMMAND, undefined);\n  }\n\n  dispatchRedo() {\n    this.editor.dispatchCommand(REDO_COMMAND, undefined);\n  }\n\n  #registerCommands() {\n    for (const command of COMMANDS) {\n      const methodName = `dispatch${capitalize(command)}`;\n      this.#registerCommandHandler(command, 0, this[methodName].bind(this));\n    }\n\n    this.#registerCommandHandler(PASTE_COMMAND, COMMAND_PRIORITY_LOW, this.dispatchPaste.bind(this));\n  }\n\n  #registerCommandHandler(command, priority, handler) {\n    this.editor.registerCommand(command, handler, priority);\n  }\n\n  #registerKeyboardCommands() {\n    this.editor.registerCommand(KEY_TAB_COMMAND, this.#handleTabKey.bind(this), COMMAND_PRIORITY_NORMAL);\n  }\n\n  #registerDragAndDropHandlers() {\n    if (this.editorElement.supportsAttachments) {\n      this.dragCounter = 0;\n      this.editor.getRootElement().addEventListener(\"dragover\", this.#handleDragOver.bind(this));\n      this.editor.getRootElement().addEventListener(\"drop\", this.#handleDrop.bind(this));\n      this.editor.getRootElement().addEventListener(\"dragenter\", this.#handleDragEnter.bind(this));\n      this.editor.getRootElement().addEventListener(\"dragleave\", this.#handleDragLeave.bind(this));\n    }\n  }\n\n  #handleDragEnter(event) {\n    this.dragCounter++;\n    if (this.dragCounter === 1) {\n      this.editor.getRootElement().classList.add(\"lexxy-editor--drag-over\");\n    }\n  }\n\n  #handleDragLeave(event) {\n    this.dragCounter--;\n    if (this.dragCounter === 0) {\n      this.editor.getRootElement().classList.remove(\"lexxy-editor--drag-over\");\n    }\n  }\n\n  #handleDragOver(event) {\n    event.preventDefault();\n  }\n\n  #handleDrop(event) {\n    event.preventDefault();\n\n    this.dragCounter = 0;\n    this.editor.getRootElement().classList.remove(\"lexxy-editor--drag-over\");\n\n    const dataTransfer = event.dataTransfer;\n    if (!dataTransfer) return\n\n    const files = Array.from(dataTransfer.files);\n    if (!files.length) return\n\n    for (const file of files) {\n      this.contents.uploadFile(file);\n    }\n\n    this.editor.focus();\n  }\n\n  #handleTabKey(event) {\n    if (this.selection.isInsideList) {\n      return this.#handleTabForList(event)\n    } else if (this.selection.isInsideCodeBlock) {\n      return this.#handleTabForCode()\n    }\n    return false\n  }\n\n  #handleTabForList(event) {\n    if (event.shiftKey && !this.selection.isIndentedList) return false\n\n    event.preventDefault();\n    const command = event.shiftKey? OUTDENT_CONTENT_COMMAND : INDENT_CONTENT_COMMAND;\n    return this.editor.dispatchCommand(command)\n  }\n\n  #handleTabForCode() {\n    const selection = $getSelection();\n    return $isRangeSelection(selection) && selection.isCollapsed()\n  }\n\n  // Not using TOGGLE_LINK_COMMAND because it's not handled unless you use React/LinkPlugin\n  #toggleLink(url) {\n    this.editor.update(() => {\n      if (url === null) {\n        $toggleLink(null);\n      } else {\n        $toggleLink(url);\n      }\n    });\n  }\n}\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nfunction debounceAsync(fn, wait) {\n  let timeout;\n\n  return (...args) => {\n    clearTimeout(timeout);\n\n    return new Promise((resolve, reject) => {\n      timeout = setTimeout(async () => {\n        try {\n          const result = await fn(...args);\n          resolve(result);\n        } catch (err) {\n          reject(err);\n        }\n      }, wait);\n    })\n  }\n}\n\nfunction nextFrame() {\n  return new Promise(requestAnimationFrame)\n}\n\nclass Selection {\n  constructor(editorElement) {\n    this.editorElement = editorElement;\n    this.editorContentElement = editorElement.editorContentElement;\n    this.editor = this.editorElement.editor;\n    this.previouslySelectedKeys = new Set();\n\n    this.#listenForNodeSelections();\n    this.#processSelectionChangeCommands();\n    this.#handleInputWhenDecoratorNodesSelected();\n    this.#containEditorFocus();\n  }\n\n  set current(selection) {\n    this.editor.update(() => {\n      this.#syncSelectedClasses();\n    });\n  }\n\n  get hasNodeSelection() {\n    let result = false;\n    this.editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      result = selection !== null && $isNodeSelection(selection);\n    });\n    return result\n  }\n\n  get cursorPosition() {\n    let position = { x: 0, y: 0 };\n\n    this.editor.getEditorState().read(() => {\n      const range = this.#getValidSelectionRange();\n      if (!range) return\n\n      const rect = this.#getReliableRectFromRange(range);\n      if (!rect) return\n\n      position = this.#calculateCursorPosition(rect, range);\n    });\n\n    return position\n  }\n\n  placeCursorAtTheEnd() {\n    this.editor.update(() => {\n      const root = $getRoot();\n      const lastDescendant = root.getLastDescendant();\n\n      if (lastDescendant && $isTextNode(lastDescendant)) {\n        lastDescendant.selectEnd();\n      } else {\n        root.selectEnd();\n      }\n    });\n  }\n\n  selectedNodeWithOffset() {\n    const selection = $getSelection();\n    if (!selection) return { node: null, offset: 0 }\n\n    if ($isRangeSelection(selection)) {\n      return {\n        node: selection.anchor.getNode(),\n        offset: selection.anchor.offset\n      }\n    } else if ($isNodeSelection(selection)) {\n      const [ node ] = selection.getNodes();\n      return {\n        node,\n        offset: 0\n      }\n    }\n\n    return { node: null, offset: 0 }\n  }\n\n  preservingSelection(fn) {\n    let selectionState = null;\n\n    this.editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if (selection && $isRangeSelection(selection)) {\n        selectionState = {\n          anchor: { key: selection.anchor.key, offset: selection.anchor.offset },\n          focus: { key: selection.focus.key, offset: selection.focus.offset }\n        };\n      }\n    });\n\n    fn();\n\n    if (selectionState) {\n      this.editor.update(() => {\n        const selection = $getSelection();\n        if (selection && $isRangeSelection(selection)) {\n          selection.anchor.set(selectionState.anchor.key, selectionState.anchor.offset, \"text\");\n          selection.focus.set(selectionState.focus.key, selectionState.focus.offset, \"text\");\n        }\n      });\n    }\n  }\n\n  get hasSelectedWordsInSingleLine() {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) return false\n\n    if (selection.isCollapsed()) return false\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n\n    if (anchorNode.getTopLevelElement() !== focusNode.getTopLevelElement()) {\n      return false\n    }\n\n    const anchorElement = anchorNode.getTopLevelElement();\n    if (!anchorElement) return false\n\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      if ($isLineBreakNode(node)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  get isInsideList() {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) return false\n\n    const anchorNode = selection.anchor.getNode();\n    return getNearestListItemNode(anchorNode) !== null\n  }\n\n  get isIndentedList() {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) return false\n\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const closestListNode = $getNearestNodeOfType(node, ListNode);\n      if (closestListNode && $getListDepth(closestListNode) > 1) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  get isInsideCodeBlock() {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) return false\n\n    const anchorNode = selection.anchor.getNode();\n    return $getNearestNodeOfType(anchorNode, CodeNode) !== null\n  }\n\n  get isTableCellSelected() {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) return false\n\n    const anchorNode = selection.anchor.getNode();\n    return $getNearestNodeOfType(anchorNode, TableCellNode) !== null\n  }\n\n  get nodeAfterCursor() {\n    const { anchorNode, offset } = this.#getCollapsedSelectionData();\n    if (!anchorNode) return null\n\n    if ($isTextNode(anchorNode)) {\n      return this.#getNodeAfterTextNode(anchorNode, offset)\n    }\n\n    if ($isElementNode(anchorNode)) {\n      return this.#getNodeAfterElementNode(anchorNode, offset)\n    }\n\n    return this.#findNextSiblingUp(anchorNode)\n  }\n\n  get topLevelNodeAfterCursor() {\n    const { anchorNode, offset } = this.#getCollapsedSelectionData();\n    if (!anchorNode) return null\n\n    if ($isTextNode(anchorNode)) {\n      return this.#getNextNodeFromTextEnd(anchorNode)\n    }\n\n    if ($isElementNode(anchorNode)) {\n      return this.#getNodeAfterElementNode(anchorNode, offset)\n    }\n\n    return this.#findNextSiblingUp(anchorNode)\n  }\n\n  get nodeBeforeCursor() {\n    const { anchorNode, offset } = this.#getCollapsedSelectionData();\n    if (!anchorNode) return null\n\n    if ($isTextNode(anchorNode)) {\n      return this.#getNodeBeforeTextNode(anchorNode, offset)\n    }\n\n    if ($isElementNode(anchorNode)) {\n      return this.#getNodeBeforeElementNode(anchorNode, offset)\n    }\n\n    return this.#findPreviousSiblingUp(anchorNode)\n  }\n\n  get topLevelNodeBeforeCursor() {\n    const { anchorNode, offset } = this.#getCollapsedSelectionData();\n    if (!anchorNode) return null\n\n    if ($isTextNode(anchorNode)) {\n      return this.#getPreviousNodeFromTextStart(anchorNode)\n    }\n\n    if ($isElementNode(anchorNode)) {\n      return this.#getNodeBeforeElementNode(anchorNode, offset)\n    }\n\n    return this.#findPreviousSiblingUp(anchorNode)\n  }\n\n  get #contents() {\n    return this.editorElement.contents\n  }\n\n  get #currentlySelectedKeys() {\n    if (this.currentlySelectedKeys) { return this.currentlySelectedKeys }\n\n    this.currentlySelectedKeys = new Set();\n\n    const selection = $getSelection();\n    if (selection && $isNodeSelection(selection)) {\n      for (const node of selection.getNodes()) {\n        this.currentlySelectedKeys.add(node.getKey());\n      }\n    }\n\n    return this.currentlySelectedKeys\n  }\n\n  #processSelectionChangeCommands() {\n    this.editor.registerCommand(KEY_ARROW_LEFT_COMMAND, this.#selectPreviousNode.bind(this), COMMAND_PRIORITY_LOW);\n    this.editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, this.#selectNextNode.bind(this), COMMAND_PRIORITY_LOW);\n    this.editor.registerCommand(KEY_ARROW_UP_COMMAND, this.#selectPreviousTopLevelNode.bind(this), COMMAND_PRIORITY_LOW);\n    this.editor.registerCommand(KEY_ARROW_DOWN_COMMAND, this.#selectNextTopLevelNode.bind(this), COMMAND_PRIORITY_LOW);\n\n    this.editor.registerCommand(KEY_DELETE_COMMAND, this.#deleteSelectedOrNext.bind(this), COMMAND_PRIORITY_LOW);\n    this.editor.registerCommand(KEY_BACKSPACE_COMMAND, this.#deletePreviousOrNext.bind(this), COMMAND_PRIORITY_LOW);\n\n    this.editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n      this.current = $getSelection();\n    }, COMMAND_PRIORITY_LOW);\n  }\n\n  #listenForNodeSelections() {\n    this.editor.getRootElement().addEventListener(\"lexxy:internal:select-node\", async (event) => {\n      await nextFrame();\n\n      const { key } = event.detail;\n      this.editor.update(() => {\n        const node = $getNodeByKey(key);\n        if (node) {\n          const selection = $createNodeSelection();\n          selection.add(node.getKey());\n          $setSelection(selection);\n        }\n        this.editor.focus();\n      });\n    });\n\n    this.editor.getRootElement().addEventListener(\"lexxy:internal:move-to-next-line\", (event) => {\n      this.#selectOrAppendNextLine();\n    });\n  }\n\n  // In Safari, when the only node in the document is an attachment, it won't let you enter text\n  // before/below it. There is probably a better fix here, but this workaround solves the problem until\n  // we find it.\n  #handleInputWhenDecoratorNodesSelected() {\n    this.editor.getRootElement().addEventListener(\"keydown\", (event) => {\n      if (isPrintableCharacter(event)) {\n        this.editor.update(() => {\n          const selection = $getSelection();\n\n          if ($isRangeSelection(selection) && selection.isCollapsed()) {\n            const anchorNode = selection.anchor.getNode();\n            const offset = selection.anchor.offset;\n\n            const nodeBefore = this.#getNodeBeforePosition(anchorNode, offset);\n            const nodeAfter = this.#getNodeAfterPosition(anchorNode, offset);\n\n            if (nodeBefore instanceof DecoratorNode && !nodeBefore.isInline()) {\n              event.preventDefault();\n              this.#contents.createParagraphAfterNode(nodeBefore, event.key);\n              return\n            } else if (nodeAfter instanceof DecoratorNode && !nodeAfter.isInline()) {\n              event.preventDefault();\n              this.#contents.createParagraphBeforeNode(nodeAfter, event.key);\n              return\n            }\n          }\n        });\n      }\n    }, true);\n  }\n\n  #getNodeBeforePosition(node, offset) {\n    if ($isTextNode(node) && offset === 0) {\n      return node.getPreviousSibling()\n    }\n    if ($isElementNode(node) && offset > 0) {\n      return node.getChildAtIndex(offset - 1)\n    }\n    return null\n  }\n\n  #getNodeAfterPosition(node, offset) {\n    if ($isTextNode(node) && offset === node.getTextContentSize()) {\n      return node.getNextSibling()\n    }\n    if ($isElementNode(node)) {\n      return node.getChildAtIndex(offset)\n    }\n    return null\n  }\n\n  #containEditorFocus() {\n    // Workaround for a bizarre Chrome bug where the cursor abandons the editor to focus on not-focusable elements\n    // above when navigating UP/DOWN when Lexical shows its fake cursor on custom decorator nodes.\n    this.editorContentElement.addEventListener(\"keydown\", (event) => {\n      if (event.key === \"ArrowUp\") {\n        const lexicalCursor = this.editor.getRootElement().querySelector(\"[data-lexical-cursor]\");\n\n        if (lexicalCursor) {\n          let currentElement = lexicalCursor.previousElementSibling;\n          while (currentElement && currentElement.hasAttribute(\"data-lexical-cursor\")) {\n            currentElement = currentElement.previousElementSibling;\n          }\n\n          if (!currentElement) {\n            event.preventDefault();\n          }\n        }\n      }\n\n      if (event.key === \"ArrowDown\") {\n        const lexicalCursor = this.editor.getRootElement().querySelector(\"[data-lexical-cursor]\");\n\n        if (lexicalCursor) {\n          let currentElement = lexicalCursor.nextElementSibling;\n          while (currentElement && currentElement.hasAttribute(\"data-lexical-cursor\")) {\n            currentElement = currentElement.nextElementSibling;\n          }\n\n          if (!currentElement) {\n            event.preventDefault();\n          }\n        }\n      }\n    }, true);\n  }\n\n  #syncSelectedClasses() {\n    this.#clearPreviouslyHighlightedItems();\n    this.#highlightNewItems();\n\n    this.previouslySelectedKeys = this.#currentlySelectedKeys;\n    this.currentlySelectedKeys = null;\n  }\n\n  #clearPreviouslyHighlightedItems() {\n    for (const key of this.previouslySelectedKeys) {\n      if (!this.#currentlySelectedKeys.has(key)) {\n        const dom = this.editor.getElementByKey(key);\n        if (dom) dom.classList.remove(\"node--selected\");\n      }\n    }\n  }\n\n  #highlightNewItems() {\n    for (const key of this.#currentlySelectedKeys) {\n      if (!this.previouslySelectedKeys.has(key)) {\n        const nodeElement = this.editor.getElementByKey(key);\n        if (nodeElement) nodeElement.classList.add(\"node--selected\");\n      }\n    }\n  }\n\n  async #selectPreviousNode() {\n    if (this.hasNodeSelection) {\n      await this.#withCurrentNode((currentNode) => currentNode.selectPrevious());\n    } else {\n      this.#selectInLexical(this.nodeBeforeCursor);\n    }\n  }\n\n  async #selectNextNode() {\n    if (this.hasNodeSelection) {\n      await this.#withCurrentNode((currentNode) => currentNode.selectNext(0, 0));\n    } else {\n      this.#selectInLexical(this.nodeAfterCursor);\n    }\n  }\n\n  async #selectPreviousTopLevelNode() {\n    if (this.hasNodeSelection) {\n      await this.#withCurrentNode((currentNode) => currentNode.selectPrevious());\n    } else {\n      this.#selectInLexical(this.topLevelNodeBeforeCursor);\n    }\n  }\n\n  async #selectNextTopLevelNode() {\n    if (this.hasNodeSelection) {\n      await this.#withCurrentNode((currentNode) => currentNode.selectNext(0, 0));\n    } else {\n      this.#selectInLexical(this.topLevelNodeAfterCursor);\n    }\n  }\n\n  async #withCurrentNode(fn) {\n    await nextFrame();\n    if (this.hasNodeSelection) {\n      this.editor.update(() => {\n        fn($getSelection().getNodes()[0]);\n        this.editor.focus();\n      });\n    }\n  }\n\n  async #selectOrAppendNextLine() {\n    this.editor.update(() => {\n      const topLevelElement = this.#getTopLevelElementFromSelection();\n      if (!topLevelElement) return\n\n      this.#moveToOrCreateNextLine(topLevelElement);\n    });\n  }\n\n  #getTopLevelElementFromSelection() {\n    const selection = $getSelection();\n    if (!selection) return null\n\n    if ($isNodeSelection(selection)) {\n      return this.#getTopLevelFromNodeSelection(selection)\n    }\n\n    if ($isRangeSelection(selection)) {\n      return this.#getTopLevelFromRangeSelection(selection)\n    }\n\n    return null\n  }\n\n  #getTopLevelFromNodeSelection(selection) {\n    const nodes = selection.getNodes();\n    return nodes.length > 0 ? nodes[0].getTopLevelElement() : null\n  }\n\n  #getTopLevelFromRangeSelection(selection) {\n    const anchorNode = selection.anchor.getNode();\n    return anchorNode.getTopLevelElement()\n  }\n\n  #moveToOrCreateNextLine(topLevelElement) {\n    const nextSibling = topLevelElement.getNextSibling();\n\n    if (nextSibling) {\n      nextSibling.selectStart();\n    } else {\n      this.#createAndSelectNewParagraph();\n    }\n  }\n\n  #createAndSelectNewParagraph() {\n    const root = $getRoot();\n    const newParagraph = $createParagraphNode();\n    root.append(newParagraph);\n    newParagraph.selectStart();\n  }\n\n  #selectInLexical(node) {\n    if (!node || !(node instanceof DecoratorNode)) return\n\n    this.editor.update(() => {\n      const selection = $createNodeSelection();\n      selection.add(node.getKey());\n      $setSelection(selection);\n    });\n  }\n\n  #deleteSelectedOrNext() {\n    const node = this.nodeAfterCursor;\n    if (node instanceof DecoratorNode) {\n      this.#selectInLexical(node);\n      return true\n    } else {\n      this.#contents.deleteSelectedNodes();\n    }\n\n    return false\n  }\n\n  #deletePreviousOrNext() {\n    const node = this.nodeBeforeCursor;\n    if (node instanceof DecoratorNode) {\n      this.#selectInLexical(node);\n      return true\n    } else {\n      this.#contents.deleteSelectedNodes();\n    }\n\n    return false\n  }\n\n  #getValidSelectionRange() {\n    const lexicalSelection = $getSelection();\n    if (!lexicalSelection || !lexicalSelection.isCollapsed()) return null\n\n    const nativeSelection = window.getSelection();\n    if (!nativeSelection || nativeSelection.rangeCount === 0) return null\n\n    return nativeSelection.getRangeAt(0)\n  }\n\n  #getReliableRectFromRange(range) {\n    let rect = range.getBoundingClientRect();\n\n    if (this.#isRectUnreliable(rect)) {\n      const marker = this.#createAndInsertMarker(range);\n      rect = marker.getBoundingClientRect();\n      this.#restoreSelectionAfterMarker(marker);\n      marker.remove();\n    }\n\n    return rect\n  }\n\n  #isRectUnreliable(rect) {\n    return rect.width === 0 && rect.height === 0 || rect.top === 0 && rect.left === 0\n  }\n\n  #createAndInsertMarker(range) {\n    const marker = this.#createMarker();\n    range.insertNode(marker);\n    return marker\n  }\n\n  #createMarker() {\n    const marker = document.createElement(\"span\");\n    marker.textContent = \"\\u200b\";\n    marker.style.display = \"inline-block\";\n    marker.style.width = \"1px\";\n    marker.style.height = \"1em\";\n    marker.style.lineHeight = \"normal\";\n    marker.setAttribute(\"nonce\", getNonce());\n    return marker\n  }\n\n  #restoreSelectionAfterMarker(marker) {\n    const nativeSelection = window.getSelection();\n    nativeSelection.removeAllRanges();\n    const newRange = document.createRange();\n    newRange.setStartAfter(marker);\n    newRange.collapse(true);\n    nativeSelection.addRange(newRange);\n  }\n\n  #calculateCursorPosition(rect, range) {\n    const rootRect = this.editor.getRootElement().getBoundingClientRect();\n    const x = rect.left - rootRect.left;\n    let y = rect.top - rootRect.top;\n\n    const fontSize = this.#getFontSizeForCursor(range);\n    if (!isNaN(fontSize)) {\n      y += fontSize;\n    }\n\n    return { x, y, fontSize }\n  }\n\n  #getFontSizeForCursor(range) {\n    const nativeSelection = window.getSelection();\n    const anchorNode = nativeSelection.anchorNode;\n    const parentElement = this.#getElementFromNode(anchorNode);\n\n    if (parentElement instanceof HTMLElement) {\n      const computed = window.getComputedStyle(parentElement);\n      return parseFloat(computed.fontSize)\n    }\n\n    return 0\n  }\n\n  #getElementFromNode(node) {\n    return node?.nodeType === Node.TEXT_NODE ? node.parentElement : node\n  }\n\n  #getCollapsedSelectionData() {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return { anchorNode: null, offset: 0 }\n    }\n\n    const { anchor } = selection;\n    return { anchorNode: anchor.getNode(), offset: anchor.offset }\n  }\n\n  #getNodeAfterTextNode(anchorNode, offset) {\n    if (offset === anchorNode.getTextContentSize()) {\n      return this.#getNextNodeFromTextEnd(anchorNode)\n    }\n    return null\n  }\n\n  #getNextNodeFromTextEnd(anchorNode) {\n    if (anchorNode.getNextSibling() instanceof DecoratorNode) {\n      return anchorNode.getNextSibling()\n    }\n    const parent = anchorNode.getParent();\n    return parent ? parent.getNextSibling() : null\n  }\n\n  #getNodeAfterElementNode(anchorNode, offset) {\n    if (offset < anchorNode.getChildrenSize()) {\n      return anchorNode.getChildAtIndex(offset)\n    }\n    return this.#findNextSiblingUp(anchorNode)\n  }\n\n  #getNodeBeforeTextNode(anchorNode, offset) {\n    if (offset === 0) {\n      return this.#getPreviousNodeFromTextStart(anchorNode)\n    }\n    return null\n  }\n\n  #getPreviousNodeFromTextStart(anchorNode) {\n    if (anchorNode.getPreviousSibling() instanceof DecoratorNode) {\n      return anchorNode.getPreviousSibling()\n    }\n    const parent = anchorNode.getParent();\n    return parent.getPreviousSibling()\n  }\n\n  #getNodeBeforeElementNode(anchorNode, offset) {\n    if (offset > 0) {\n      return anchorNode.getChildAtIndex(offset - 1)\n    }\n    return this.#findPreviousSiblingUp(anchorNode)\n  }\n\n  #findNextSiblingUp(node) {\n    let current = node;\n    while (current && current.getNextSibling() == null) {\n      current = current.getParent();\n    }\n    return current ? current.getNextSibling() : null\n  }\n\n  #findPreviousSiblingUp(node) {\n    let current = node;\n    while (current && current.getPreviousSibling() == null) {\n      current = current.getParent();\n    }\n    return current ? current.getPreviousSibling() : null\n  }\n}\n\nfunction sanitize(html) {\n  return DOMPurify.sanitize(html, buildConfig())\n}\n\nfunction dasherize(value) {\n  return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`)\n}\n\nfunction isUrl(string) {\n  try {\n    new URL(string);\n    return true\n  } catch {\n    return false\n  }\n}\n\nfunction normalizeFilteredText(string) {\n  return string\n    .toLowerCase()\n    .normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\") // Remove diacritics\n}\n\nfunction filterMatches(text, potentialMatch) {\n  return normalizeFilteredText(text).includes(normalizeFilteredText(potentialMatch))\n}\n\nfunction upcaseFirst(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1)\n}\n\nclass EditorConfiguration {\n  #editorElement\n  #config\n\n  constructor(editorElement) {\n    this.#editorElement = editorElement;\n    this.#config = new Configuration(\n      Lexxy.presets.get(\"default\"),\n      Lexxy.presets.get(editorElement.preset),\n      this.#overrides\n    );\n  }\n\n  get(path) {\n    return this.#config.get(path)\n  }\n\n  get #overrides() {\n    const overrides = {};\n    for (const option of this.#defaultOptions) {\n      const attribute = dasherize(option);\n      if (this.#editorElement.hasAttribute(attribute)) {\n        overrides[option] = this.#parseAttribute(attribute);\n      }\n    }\n    return overrides\n  }\n\n  get #defaultOptions() {\n    return Object.keys(Lexxy.presets.get(\"default\"))\n  }\n\n  #parseAttribute(attribute) {\n    const value = this.#editorElement.getAttribute(attribute);\n    try {\n      return JSON.parse(value)\n    } catch {\n      return value\n    }\n  }\n}\n\nclass CustomActionTextAttachmentNode extends DecoratorNode {\n  static getType() {\n    return \"custom_action_text_attachment\"\n  }\n\n  static clone(node) {\n    return new CustomActionTextAttachmentNode({ ...node }, node.__key)\n  }\n\n  static importJSON(serializedNode) {\n    return new CustomActionTextAttachmentNode({ ...serializedNode })\n  }\n\n  static importDOM() {\n\n    return {\n      [this.TAG_NAME]: (element) => {\n        if (!element.getAttribute(\"content\")) {\n          return null\n        }\n\n        return {\n          conversion: (attachment) => {\n            // Preserve initial space if present since Lexical removes it\n            const nodes = [];\n            const previousSibling = attachment.previousSibling;\n            if (previousSibling && previousSibling.nodeType === Node.TEXT_NODE && /\\s$/.test(previousSibling.textContent)) {\n              nodes.push($createTextNode(\" \"));\n            }\n\n            nodes.push(new CustomActionTextAttachmentNode({\n              sgid: attachment.getAttribute(\"sgid\"),\n              innerHtml: JSON.parse(attachment.getAttribute(\"content\")),\n              contentType: attachment.getAttribute(\"content-type\")\n            }));\n\n            nodes.push($createTextNode(\" \"));\n\n            return { node: nodes }\n          },\n          priority: 2\n        }\n      }\n    }\n  }\n\n  static get TAG_NAME() {\n    return Lexxy.global.get(\"attachmentTagName\")\n  }\n\n  constructor({ tagName, sgid, contentType, innerHtml }, key) {\n    super(key);\n\n    const contentTypeNamespace = Lexxy.global.get(\"attachmentContentTypeNamespace\");\n\n    this.tagName = tagName || CustomActionTextAttachmentNode.TAG_NAME;\n    this.sgid = sgid;\n    this.contentType = contentType || `application/vnd.${contentTypeNamespace}.unknown`;\n    this.innerHtml = innerHtml;\n  }\n\n  createDOM() {\n    const figure = createElement(this.tagName, { \"content-type\": this.contentType, \"data-lexxy-decorator\": true });\n\n    figure.addEventListener(\"click\", (event) => {\n      dispatchCustomEvent(figure, \"lexxy:internal:select-node\", { key: this.getKey() });\n    });\n\n    figure.insertAdjacentHTML(\"beforeend\", this.innerHtml);\n\n    return figure\n  }\n\n  updateDOM() {\n    return true\n  }\n\n  getTextContent() {\n    return this.createDOM().textContent.trim() || `[${this.contentType}]`\n  }\n\n  isInline() {\n    return true\n  }\n\n  exportDOM() {\n    const attachment = createElement(this.tagName, {\n      sgid: this.sgid,\n      content: JSON.stringify(this.innerHtml),\n      \"content-type\": this.contentType\n    });\n\n    return { element: attachment }\n  }\n\n  exportJSON() {\n    return {\n      type: \"custom_action_text_attachment\",\n      version: 1,\n      tagName: this.tagName,\n      sgid: this.sgid,\n      contentType: this.contentType,\n      innerHtml: this.innerHtml\n    }\n  }\n\n  decorate() {\n    return null\n  }\n}\n\nclass FormatEscaper {\n  constructor(editorElement) {\n    this.editorElement = editorElement;\n    this.editor = editorElement.editor;\n  }\n\n  monitor() {\n    this.editor.registerCommand(\n      KEY_ENTER_COMMAND,\n      (event) => this.#handleEnterKey(event),\n      COMMAND_PRIORITY_HIGH\n    );\n  }\n\n  #handleEnterKey(event) {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) return false\n\n    const anchorNode = selection.anchor.getNode();\n\n    if (!this.#isInsideBlockquote(anchorNode)) return false\n\n    return this.#handleLists(event, anchorNode)\n      || this.#handleBlockquotes(event, anchorNode)\n  }\n\n  #handleLists(event, anchorNode) {\n    if (this.#shouldEscapeFromEmptyListItem(anchorNode) || this.#shouldEscapeFromEmptyParagraphInListItem(anchorNode)) {\n      event.preventDefault();\n      this.#escapeFromList(anchorNode);\n      return true\n    }\n\n    return false\n  }\n\n  #handleBlockquotes(event, anchorNode) {\n    if (this.#shouldEscapeFromEmptyParagraphInBlockquote(anchorNode)) {\n      event.preventDefault();\n      this.#escapeFromBlockquote(anchorNode);\n      return true\n    }\n\n    return false\n  }\n\n  #isInsideBlockquote(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n      if ($isQuoteNode(currentNode)) {\n        return true\n      }\n      currentNode = currentNode.getParent();\n    }\n\n    return false\n  }\n\n  #shouldEscapeFromEmptyListItem(node) {\n    const listItem = this.#getListItemNode(node);\n    if (!listItem) return false\n\n    return this.#isNodeEmpty(listItem)\n  }\n\n  #shouldEscapeFromEmptyParagraphInListItem(node) {\n    const paragraph = this.#getParagraphNode(node);\n    if (!paragraph) return false\n\n    if (!this.#isNodeEmpty(paragraph)) return false\n\n    const parent = paragraph.getParent();\n    return parent && $isListItemNode(parent)\n  }\n\n  #isNodeEmpty(node) {\n    if (node.getTextContent().trim() !== \"\") return false\n\n    const children = node.getChildren();\n    if (children.length === 0) return true\n\n    return children.every(child => {\n      if ($isLineBreakNode(child)) return true\n      return this.#isNodeEmpty(child)\n    })\n  }\n\n  #getListItemNode(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n      if ($isListItemNode(currentNode)) {\n        return currentNode\n      }\n      currentNode = currentNode.getParent();\n    }\n\n    return null\n  }\n\n  #escapeFromList(anchorNode) {\n    const listItem = this.#getListItemNode(anchorNode);\n    if (!listItem) return\n\n    const parentList = listItem.getParent();\n    if (!parentList || !$isListNode(parentList)) return\n\n    const blockquote = parentList.getParent();\n    const isInBlockquote = blockquote && $isQuoteNode(blockquote);\n\n    if (isInBlockquote) {\n      const listItemsAfter = this.#getListItemSiblingsAfter(listItem);\n      const nonEmptyListItems = listItemsAfter.filter(item => !this.#isNodeEmpty(item));\n\n      if (nonEmptyListItems.length > 0) {\n        this.#splitBlockquoteWithList(blockquote, parentList, listItem, nonEmptyListItems);\n        return\n      }\n    }\n\n    const paragraph = $createParagraphNode();\n    parentList.insertAfter(paragraph);\n\n    listItem.remove();\n    paragraph.selectStart();\n  }\n\n  #shouldEscapeFromEmptyParagraphInBlockquote(node) {\n    const paragraph = this.#getParagraphNode(node);\n    if (!paragraph) return false\n\n    if (!this.#isNodeEmpty(paragraph)) return false\n\n    const parent = paragraph.getParent();\n    return parent && $isQuoteNode(parent)\n  }\n\n  #getParagraphNode(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n      if ($isParagraphNode(currentNode)) {\n        return currentNode\n      }\n      currentNode = currentNode.getParent();\n    }\n\n    return null\n  }\n\n  #escapeFromBlockquote(anchorNode) {\n    const paragraph = this.#getParagraphNode(anchorNode);\n    if (!paragraph) return\n\n    const blockquote = paragraph.getParent();\n    if (!blockquote || !$isQuoteNode(blockquote)) return\n\n    const siblingsAfter = this.#getSiblingsAfter(paragraph);\n    const nonEmptySiblings = siblingsAfter.filter(sibling => !this.#isNodeEmpty(sibling));\n\n    if (nonEmptySiblings.length > 0) {\n      this.#splitBlockquote(blockquote, paragraph, nonEmptySiblings);\n    } else {\n      const newParagraph = $createParagraphNode();\n      blockquote.insertAfter(newParagraph);\n      paragraph.remove();\n      newParagraph.selectStart();\n    }\n  }\n\n  #getSiblingsAfter(node) {\n    const siblings = [];\n    let sibling = node.getNextSibling();\n\n    while (sibling) {\n      siblings.push(sibling);\n      sibling = sibling.getNextSibling();\n    }\n\n    return siblings\n  }\n\n  #getListItemSiblingsAfter(listItem) {\n    const siblings = [];\n    let sibling = listItem.getNextSibling();\n\n    while (sibling) {\n      if ($isListItemNode(sibling)) {\n        siblings.push(sibling);\n      }\n      sibling = sibling.getNextSibling();\n    }\n\n    return siblings\n  }\n\n  #splitBlockquoteWithList(blockquote, parentList, emptyListItem, listItemsAfter) {\n    const blockquoteSiblingsAfterList = this.#getSiblingsAfter(parentList);\n    const nonEmptyBlockquoteSiblings = blockquoteSiblingsAfterList.filter(sibling => !this.#isNodeEmpty(sibling));\n\n    const middleParagraph = $createParagraphNode();\n    blockquote.insertAfter(middleParagraph);\n\n    const newList = $createListNode(parentList.getListType());\n\n    const newBlockquote = $createQuoteNode();\n    middleParagraph.insertAfter(newBlockquote);\n    newBlockquote.append(newList);\n\n    listItemsAfter.forEach(item => {\n      newList.append(item);\n    });\n\n    nonEmptyBlockquoteSiblings.forEach(sibling => {\n      newBlockquote.append(sibling);\n    });\n\n    emptyListItem.remove();\n\n    this.#removeTrailingEmptyListItems(parentList);\n    this.#removeTrailingEmptyNodes(newBlockquote);\n\n    if (parentList.getChildrenSize() === 0) {\n      parentList.remove();\n\n      if (blockquote.getChildrenSize() === 0) {\n        blockquote.remove();\n      }\n    } else {\n      this.#removeTrailingEmptyNodes(blockquote);\n    }\n\n    middleParagraph.selectStart();\n  }\n\n  #removeTrailingEmptyListItems(list) {\n    const items = list.getChildren();\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n      if ($isListItemNode(item) && this.#isNodeEmpty(item)) {\n        item.remove();\n      } else {\n        break\n      }\n    }\n  }\n\n  #removeTrailingEmptyNodes(blockquote) {\n    const children = blockquote.getChildren();\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      if (this.#isNodeEmpty(child)) {\n        child.remove();\n      } else {\n        break\n      }\n    }\n  }\n\n  #splitBlockquote(blockquote, emptyParagraph, siblingsAfter) {\n    const newParagraph = $createParagraphNode();\n    blockquote.insertAfter(newParagraph);\n\n    const newBlockquote = $createQuoteNode();\n    newParagraph.insertAfter(newBlockquote);\n\n    siblingsAfter.forEach(sibling => {\n      newBlockquote.append(sibling);\n    });\n\n    emptyParagraph.remove();\n\n    this.#removeTrailingEmptyNodes(blockquote);\n    this.#removeTrailingEmptyNodes(newBlockquote);\n\n    newParagraph.selectStart();\n  }\n}\n\nclass Contents {\n  constructor(editorElement) {\n    this.editorElement = editorElement;\n    this.editor = editorElement.editor;\n\n    new FormatEscaper(editorElement).monitor();\n  }\n\n  insertHtml(html, { tag } = {}) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      const nodes = $generateNodesFromDOM(this.editor, parseHtml(html));\n      selection.insertNodes(nodes);\n    }, { tag });\n  }\n\n  insertAtCursor(node) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      const selectedNodes = selection?.getNodes();\n\n      if ($isRangeSelection(selection)) {\n        $insertNodes([ node ]);\n      } else if ($isNodeSelection(selection) && selectedNodes && selectedNodes.length > 0) {\n        const lastNode = selectedNodes[selectedNodes.length - 1];\n        lastNode.insertAfter(node);\n      } else {\n        const root = $getRoot();\n        root.append(node);\n      }\n    });\n  }\n\n  insertAtCursorEnsuringLineBelow(node) {\n    this.insertAtCursor(node);\n    this.#insertLineBelowIfLastNode(node);\n  }\n\n  insertNodeWrappingEachSelectedLine(newNodeFn) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      const selectedNodes = selection.extract();\n\n      selectedNodes.forEach((node) => {\n        const parent = node.getParent();\n        if (!parent) { return }\n\n        const topLevelElement = node.getTopLevelElementOrThrow();\n        const wrappingNode = newNodeFn();\n        wrappingNode.append(...topLevelElement.getChildren());\n        topLevelElement.replace(wrappingNode);\n      });\n    });\n  }\n\n  toggleNodeWrappingAllSelectedLines(isFormatAppliedFn, newNodeFn) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      const topLevelElement = selection.anchor.getNode().getTopLevelElementOrThrow();\n\n      // Check if format is already applied\n      if (isFormatAppliedFn(topLevelElement)) {\n        this.removeFormattingFromSelectedLines();\n      } else {\n        this.#insertNodeWrappingAllSelectedLines(newNodeFn);\n      }\n    });\n  }\n\n  toggleNodeWrappingAllSelectedNodes(isFormatAppliedFn, newNodeFn) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      const topLevelElement = selection.anchor.getNode().getTopLevelElement();\n\n      // Check if format is already applied\n      if (topLevelElement && isFormatAppliedFn(topLevelElement)) {\n        this.#unwrap(topLevelElement);\n      } else {\n        this.#insertNodeWrappingAllSelectedNodes(newNodeFn);\n      }\n    });\n  }\n\n  removeFormattingFromSelectedLines() {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      const topLevelElement = selection.anchor.getNode().getTopLevelElementOrThrow();\n      const paragraph = $createParagraphNode();\n      paragraph.append(...topLevelElement.getChildren());\n      topLevelElement.replace(paragraph);\n    });\n  }\n\n  hasSelectedText() {\n    let result = false;\n\n    this.editor.read(() => {\n      const selection = $getSelection();\n      result = $isRangeSelection(selection) && !selection.isCollapsed();\n    });\n\n    return result\n  }\n\n  unwrapSelectedListItems() {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      const { listItems, parentLists } = this.#collectSelectedListItems(selection);\n      if (listItems.size > 0) {\n        const newParagraphs = this.#convertListItemsToParagraphs(listItems);\n        this.#removeEmptyParentLists(parentLists);\n        this.#selectNewParagraphs(newParagraphs);\n      }\n    });\n  }\n\n  createLink(url) {\n    let linkNodeKey = null;\n\n    this.editor.update(() => {\n      const textNode = $createTextNode(url);\n      const linkNode = $createLinkNode(url);\n      linkNode.append(textNode);\n\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        selection.insertNodes([ linkNode ]);\n        linkNodeKey = linkNode.getKey();\n      }\n    });\n\n    return linkNodeKey\n  }\n\n  createLinkWithSelectedText(url) {\n    if (!this.hasSelectedText()) return\n\n    this.editor.update(() => {\n      $toggleLink(url);\n    });\n  }\n\n  textBackUntil(string) {\n    let result = \"\";\n\n    this.editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if (!selection || !selection.isCollapsed()) return\n\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n\n      if (!$isTextNode(anchorNode)) return\n\n      const fullText = anchorNode.getTextContent();\n      const offset = anchor.offset;\n\n      const textBeforeCursor = fullText.slice(0, offset);\n\n      const lastIndex = textBeforeCursor.lastIndexOf(string);\n      if (lastIndex !== -1) {\n        result = textBeforeCursor.slice(lastIndex + string.length);\n      }\n    });\n\n    return result\n  }\n\n  containsTextBackUntil(string) {\n    let result = false;\n\n    this.editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if (!selection || !selection.isCollapsed()) return\n\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n\n      if (!$isTextNode(anchorNode)) return\n\n      const fullText = anchorNode.getTextContent();\n      const offset = anchor.offset;\n\n      const textBeforeCursor = fullText.slice(0, offset);\n\n      result = textBeforeCursor.includes(string);\n    });\n\n    return result\n  }\n\n  replaceTextBackUntil(stringToReplace, replacementNodes) {\n    replacementNodes = Array.isArray(replacementNodes) ? replacementNodes : [ replacementNodes ];\n\n    this.editor.update(() => {\n      const { anchorNode, offset } = this.#getTextAnchorData();\n      if (!anchorNode) return\n\n      const lastIndex = this.#findLastIndexBeforeCursor(anchorNode, offset, stringToReplace);\n      if (lastIndex === -1) return\n\n      this.#performTextReplacement(anchorNode, offset, lastIndex, replacementNodes);\n    });\n  }\n\n  createParagraphAfterNode(node, text) {\n    const newParagraph = $createParagraphNode();\n    node.insertAfter(newParagraph);\n    newParagraph.selectStart();\n\n    // Insert the typed text\n    if (text) {\n      newParagraph.append($createTextNode(text));\n      newParagraph.select(1, 1); // Place cursor after the text\n    }\n  }\n\n  createParagraphBeforeNode(node, text) {\n    const newParagraph = $createParagraphNode();\n    node.insertBefore(newParagraph);\n    newParagraph.selectStart();\n\n    // Insert the typed text\n    if (text) {\n      newParagraph.append($createTextNode(text));\n      newParagraph.select(1, 1); // Place cursor after the text\n    }\n  }\n\n  uploadFile(file) {\n    if (!this.editorElement.supportsAttachments) {\n      console.warn(\"This editor does not supports attachments (it's configured with [attachments=false])\");\n      return\n    }\n\n    if (!this.#shouldUploadFile(file)) {\n      return\n    }\n\n    const uploadUrl = this.editorElement.directUploadUrl;\n    const blobUrlTemplate = this.editorElement.blobUrlTemplate;\n\n    this.editor.update(() => {\n      const uploadedImageNode = new ActionTextAttachmentUploadNode({ file: file, uploadUrl: uploadUrl, blobUrlTemplate: blobUrlTemplate, editor: this.editor });\n      this.insertAtCursor(uploadedImageNode);\n    }, { tag: HISTORY_MERGE_TAG });\n  }\n\n  async deleteSelectedNodes() {\n    let focusNode = null;\n\n    this.editor.update(() => {\n      if (this.#selection.hasNodeSelection) {\n        const nodesToRemove = $getSelection().getNodes();\n        if (nodesToRemove.length === 0) return\n\n        focusNode = this.#findAdjacentNodeTo(nodesToRemove);\n        this.#deleteNodes(nodesToRemove);\n      }\n    });\n\n    await nextFrame();\n\n    this.editor.update(() => {\n      this.#selectAfterDeletion(focusNode);\n      this.editor.focus();\n    });\n  }\n\n  replaceNodeWithHTML(nodeKey, html, options = {}) {\n    this.editor.update(() => {\n      const node = $getNodeByKey(nodeKey);\n      if (!node) return\n\n      const selection = $getSelection();\n      let wasSelected = false;\n\n      if ($isRangeSelection(selection)) {\n        const selectedNodes = selection.getNodes();\n        wasSelected = selectedNodes.includes(node) || selectedNodes.some(n => n.getParent() === node);\n\n        if (wasSelected) {\n          $setSelection(null);\n        }\n      }\n\n      const replacementNode = options.attachment ? this.#createCustomAttachmentNodeWithHtml(html, options.attachment) : this.#createHtmlNodeWith(html);\n      node.replace(replacementNode);\n\n      if (wasSelected) {\n        replacementNode.selectEnd();\n      }\n    });\n  }\n\n  insertHTMLBelowNode(nodeKey, html, options = {}) {\n    this.editor.update(() => {\n      const node = $getNodeByKey(nodeKey);\n      if (!node) return\n\n      const previousNode = node.getTopLevelElement() || node;\n\n      const newNode = options.attachment ? this.#createCustomAttachmentNodeWithHtml(html, options.attachment) : this.#createHtmlNodeWith(html);\n      previousNode.insertAfter(newNode);\n    });\n  }\n\n  get #selection() {\n    return this.editorElement.selection\n  }\n\n  #insertLineBelowIfLastNode(node) {\n    this.editor.update(() => {\n      const nextSibling = node.getNextSibling();\n      if (!nextSibling) {\n        const newParagraph = $createParagraphNode();\n        node.insertAfter(newParagraph);\n        newParagraph.selectStart();\n      }\n    });\n  }\n\n  #unwrap(node) {\n    const children = node.getChildren();\n\n    if (children.length == 0) {\n      node.insertBefore($createParagraphNode());\n    } else {\n      children.forEach((child) => {\n        if ($isTextNode(child) && child.getTextContent().trim() !== \"\") {\n          const newParagraph = $createParagraphNode();\n          newParagraph.append(child);\n          node.insertBefore(newParagraph);\n        } else if (!$isLineBreakNode(child)) {\n          node.insertBefore(child);\n        }\n      });\n    }\n\n    node.remove();\n  }\n\n  #insertNodeWrappingAllSelectedNodes(newNodeFn) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      const selectedNodes = selection.extract();\n      if (selectedNodes.length === 0) {\n        return\n      }\n\n      const topLevelElements = new Set();\n      selectedNodes.forEach((node) => {\n        const topLevel = node.getTopLevelElementOrThrow();\n        topLevelElements.add(topLevel);\n      });\n\n      const elements = this.#withoutTrailingEmptyParagraphs(Array.from(topLevelElements));\n      if (elements.length === 0) {\n        this.#removeStandaloneEmptyParagraph();\n        this.insertAtCursor(newNodeFn());\n        return\n      }\n\n      const wrappingNode = newNodeFn();\n      elements[0].insertBefore(wrappingNode);\n      elements.forEach((element) => {\n        wrappingNode.append(element);\n      });\n    });\n  }\n\n  #withoutTrailingEmptyParagraphs(elements) {\n    let lastNonEmptyIndex = elements.length - 1;\n\n    // Find the last non-empty paragraph\n    while (lastNonEmptyIndex >= 0) {\n      const element = elements[lastNonEmptyIndex];\n      if (!$isParagraphNode(element) || !this.#isElementEmpty(element)) {\n        break\n      }\n      lastNonEmptyIndex--;\n    }\n\n    return elements.slice(0, lastNonEmptyIndex + 1)\n  }\n\n  #isElementEmpty(element) {\n    // Check text content first\n    if (element.getTextContent().trim() !== \"\") return false\n\n    // Check if it only contains line breaks\n    const children = element.getChildren();\n    return children.length === 0 || children.every(child => $isLineBreakNode(child))\n  }\n\n  #removeStandaloneEmptyParagraph() {\n    const root = $getRoot();\n    if (root.getChildrenSize() === 1) {\n      const firstChild = root.getFirstChild();\n      if (firstChild && $isParagraphNode(firstChild) && this.#isElementEmpty(firstChild)) {\n        firstChild.remove();\n      }\n    }\n  }\n\n  #insertNodeWrappingAllSelectedLines(newNodeFn) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      if (selection.isCollapsed()) {\n        this.#wrapCurrentLine(selection, newNodeFn);\n      } else {\n        this.#wrapMultipleSelectedLines(selection, newNodeFn);\n      }\n    });\n  }\n\n  #wrapCurrentLine(selection, newNodeFn) {\n    const anchorNode = selection.anchor.getNode();\n\n    const topLevelElement = anchorNode.getTopLevelElementOrThrow();\n\n    if (topLevelElement.getTextContent()) {\n      const wrappingNode = newNodeFn();\n      wrappingNode.append(...topLevelElement.getChildren());\n      topLevelElement.replace(wrappingNode);\n    } else {\n      $insertNodes([ newNodeFn() ]);\n    }\n  }\n\n  #wrapMultipleSelectedLines(selection, newNodeFn) {\n    const selectedParagraphs = this.#extractSelectedParagraphs(selection);\n    if (selectedParagraphs.length === 0) return\n\n    const { lineSet, nodesToDelete } = this.#extractUniqueLines(selectedParagraphs);\n    if (lineSet.size === 0) return\n\n    const wrappingNode = this.#createWrappingNodeWithLines(newNodeFn, lineSet);\n    this.#replaceWithWrappingNode(selection, wrappingNode);\n    this.#removeNodes(nodesToDelete);\n  }\n\n  #extractSelectedParagraphs(selection) {\n    const selectedNodes = selection.extract();\n    const selectedParagraphs = selectedNodes\n      .map((node) => this.#getParagraphFromNode(node))\n      .filter(Boolean);\n\n    $setSelection(null);\n    return selectedParagraphs\n  }\n\n  #getParagraphFromNode(node) {\n    if ($isParagraphNode(node)) return node\n    if ($isTextNode(node) && node.getParent() && $isParagraphNode(node.getParent())) {\n      return node.getParent()\n    }\n    return null\n  }\n\n  #extractUniqueLines(selectedParagraphs) {\n    const lineSet = new Set();\n    const nodesToDelete = new Set();\n\n    selectedParagraphs.forEach((paragraphNode) => {\n      const textContent = paragraphNode.getTextContent();\n      if (textContent) {\n        textContent.split(\"\\n\").forEach((line) => {\n          if (line.trim()) lineSet.add(line);\n        });\n      }\n      nodesToDelete.add(paragraphNode);\n    });\n\n    return { lineSet, nodesToDelete }\n  }\n\n  #createWrappingNodeWithLines(newNodeFn, lineSet) {\n    const wrappingNode = newNodeFn();\n    const lines = Array.from(lineSet);\n\n    lines.forEach((lineText, index) => {\n      wrappingNode.append($createTextNode(lineText));\n      if (index < lines.length - 1) {\n        wrappingNode.append($createLineBreakNode());\n      }\n    });\n\n    return wrappingNode\n  }\n\n  #replaceWithWrappingNode(selection, wrappingNode) {\n    const anchorNode = selection.anchor.getNode();\n    const parent = anchorNode.getParent();\n    if (parent) {\n      parent.replace(wrappingNode);\n    }\n  }\n\n  #removeNodes(nodesToDelete) {\n    nodesToDelete.forEach((node) => node.remove());\n  }\n\n  #deleteNodes(nodes) {\n    // Use splice() instead of node.remove() for proper removal and\n    // reconciliation. Would have issues with removing unintended decorator nodes\n    // with node.remove()\n    nodes.forEach((node) => {\n      const parent = node.getParent();\n      if (!$isElementNode(parent)) return\n\n      const children = parent.getChildren();\n      const index = children.indexOf(node);\n\n      if (index >= 0) {\n        parent.splice(index, 1, []);\n      }\n    });\n  }\n\n  #findAdjacentNodeTo(nodes) {\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n\n    return firstNode?.getPreviousSibling() || lastNode?.getNextSibling()\n  }\n\n  #selectAfterDeletion(focusNode) {\n    const root = $getRoot();\n    if (root.getChildrenSize() === 0) {\n      const newParagraph = $createParagraphNode();\n      root.append(newParagraph);\n      newParagraph.selectStart();\n    } else if (focusNode) {\n      if ($isTextNode(focusNode) || $isParagraphNode(focusNode)) {\n        focusNode.selectEnd();\n      } else {\n        focusNode.selectNext(0, 0);\n      }\n    }\n  }\n\n  #collectSelectedListItems(selection) {\n    const nodes = selection.getNodes();\n    const listItems = new Set();\n    const parentLists = new Set();\n\n    for (const node of nodes) {\n      const listItem = getNearestListItemNode(node);\n      if (listItem) {\n        listItems.add(listItem);\n        const parentList = listItem.getParent();\n        if (parentList && $isListNode(parentList)) {\n          parentLists.add(parentList);\n        }\n      }\n    }\n\n    return { listItems, parentLists }\n  }\n\n  #convertListItemsToParagraphs(listItems) {\n    const newParagraphs = [];\n\n    for (const listItem of listItems) {\n      const paragraph = this.#convertListItemToParagraph(listItem);\n      if (paragraph) {\n        newParagraphs.push(paragraph);\n      }\n    }\n\n    return newParagraphs\n  }\n\n  #convertListItemToParagraph(listItem) {\n    const parentList = listItem.getParent();\n    if (!parentList || !$isListNode(parentList)) return null\n\n    const paragraph = $createParagraphNode();\n    const sublists = this.#extractSublistsAndContent(listItem, paragraph);\n\n    listItem.insertAfter(paragraph);\n    this.#insertSublists(paragraph, sublists);\n    listItem.remove();\n\n    return paragraph\n  }\n\n  #extractSublistsAndContent(listItem, paragraph) {\n    const sublists = [];\n\n    listItem.getChildren().forEach((child) => {\n      if ($isListNode(child)) {\n        sublists.push(child);\n      } else {\n        paragraph.append(child);\n      }\n    });\n\n    return sublists\n  }\n\n  #insertSublists(paragraph, sublists) {\n    sublists.forEach((sublist) => {\n      paragraph.insertAfter(sublist);\n    });\n  }\n\n  #removeEmptyParentLists(parentLists) {\n    for (const parentList of parentLists) {\n      if ($isListNode(parentList) && parentList.getChildrenSize() === 0) {\n        parentList.remove();\n      }\n    }\n  }\n\n  #selectNewParagraphs(newParagraphs) {\n    if (newParagraphs.length === 0) return\n\n    const firstParagraph = newParagraphs[0];\n    const lastParagraph = newParagraphs[newParagraphs.length - 1];\n\n    if (newParagraphs.length === 1) {\n      firstParagraph.selectEnd();\n    } else {\n      this.#selectParagraphRange(firstParagraph, lastParagraph);\n    }\n  }\n\n  #selectParagraphRange(firstParagraph, lastParagraph) {\n    firstParagraph.selectStart();\n    const currentSelection = $getSelection();\n    if (currentSelection && $isRangeSelection(currentSelection)) {\n      currentSelection.anchor.set(firstParagraph.getKey(), 0, \"element\");\n      currentSelection.focus.set(lastParagraph.getKey(), lastParagraph.getChildrenSize(), \"element\");\n    }\n  }\n\n  #getTextAnchorData() {\n    const selection = $getSelection();\n    if (!selection || !selection.isCollapsed()) return { anchorNode: null, offset: 0 }\n\n    const anchor = selection.anchor;\n    const anchorNode = anchor.getNode();\n\n    if (!$isTextNode(anchorNode)) return { anchorNode: null, offset: 0 }\n\n    return { anchorNode, offset: anchor.offset }\n  }\n\n  #findLastIndexBeforeCursor(anchorNode, offset, stringToReplace) {\n    const fullText = anchorNode.getTextContent();\n    const textBeforeCursor = fullText.slice(0, offset);\n    return textBeforeCursor.lastIndexOf(stringToReplace)\n  }\n\n  #performTextReplacement(anchorNode, offset, lastIndex, replacementNodes) {\n    const fullText = anchorNode.getTextContent();\n    const textBeforeString = fullText.slice(0, lastIndex);\n    const textAfterCursor = fullText.slice(offset);\n\n    const textNodeBefore = $createTextNode(textBeforeString);\n    const textNodeAfter = $createTextNode(textAfterCursor || \" \");\n\n    anchorNode.replace(textNodeBefore);\n\n    const lastInsertedNode = this.#insertReplacementNodes(textNodeBefore, replacementNodes);\n    lastInsertedNode.insertAfter(textNodeAfter);\n\n    this.#appendLineBreakIfNeeded(textNodeAfter.getParentOrThrow());\n    const cursorOffset = textAfterCursor ? 0 : 1;\n    textNodeAfter.select(cursorOffset, cursorOffset);\n  }\n\n  #insertReplacementNodes(startNode, replacementNodes) {\n    let previousNode = startNode;\n    for (const node of replacementNodes) {\n      previousNode.insertAfter(node);\n      previousNode = node;\n    }\n    return previousNode\n  }\n\n  #appendLineBreakIfNeeded(paragraph) {\n    if ($isParagraphNode(paragraph) && this.editorElement.supportsMultiLine) {\n      const children = paragraph.getChildren();\n      const last = children[children.length - 1];\n      const beforeLast = children[children.length - 2];\n\n      if ($isTextNode(last) && last.getTextContent() === \"\" && (beforeLast && !$isTextNode(beforeLast))) {\n        paragraph.append($createLineBreakNode());\n      }\n    }\n  }\n\n  #createCustomAttachmentNodeWithHtml(html, options = {}) {\n    const attachmentConfig = typeof options === \"object\" ? options : {};\n\n    return new CustomActionTextAttachmentNode({\n      sgid: attachmentConfig.sgid || null,\n      contentType: \"text/html\",\n      innerHtml: html\n    })\n  }\n\n  #createHtmlNodeWith(html) {\n    const htmlNodes = $generateNodesFromDOM(this.editor, parseHtml(html));\n    return htmlNodes[0] || $createParagraphNode()\n  }\n\n  #shouldUploadFile(file) {\n    return dispatch(this.editorElement, \"lexxy:file-accept\", { file }, true)\n  }\n}\n\nclass Clipboard {\n  constructor(editorElement) {\n    this.editorElement = editorElement;\n    this.editor = editorElement.editor;\n    this.contents = editorElement.contents;\n  }\n\n  paste(event) {\n    const clipboardData = event.clipboardData;\n\n    if (!clipboardData) return false\n\n    if (this.#isPlainTextOrURLPasted(clipboardData) && !this.#isPastingIntoCodeBlock()) {\n      this.#pastePlainText(clipboardData);\n      event.preventDefault();\n      return true\n    }\n\n    this.#handlePastedFiles(clipboardData);\n  }\n\n  #isPlainTextOrURLPasted(clipboardData) {\n    return this.#isOnlyPlainTextPasted(clipboardData) || this.#isOnlyURLPasted(clipboardData)\n  }\n\n  #isOnlyPlainTextPasted(clipboardData) {\n    const types = Array.from(clipboardData.types);\n    return types.length === 1 && types[0] === \"text/plain\"\n  }\n\n  #isOnlyURLPasted(clipboardData) {\n    // Safari URLs are copied as a text/plain + text/uri-list object\n    const types = Array.from(clipboardData.types);\n    return types.length === 2 && types.includes(\"text/uri-list\") && types.includes(\"text/plain\")\n  }\n\n  #isPastingIntoCodeBlock() {\n    let result = false;\n\n    this.editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      let currentNode = selection.anchor.getNode();\n\n      while (currentNode) {\n        if ($isCodeNode(currentNode)) {\n          result = true;\n          return\n        }\n        currentNode = currentNode.getParent();\n      }\n    });\n\n    return result\n  }\n\n  #pastePlainText(clipboardData) {\n    const item = clipboardData.items[0];\n    item.getAsString((text) => {\n      if (isUrl(text) && this.contents.hasSelectedText()) {\n        this.contents.createLinkWithSelectedText(text);\n      } else if (isUrl(text)) {\n        const nodeKey = this.contents.createLink(text);\n        this.#dispatchLinkInsertEvent(nodeKey, { url: text });\n      } else if (this.editorElement.supportsMarkdown) {\n        this.#pasteMarkdown(text);\n      } else {\n        this.#pasteRichText(clipboardData);\n      }\n    });\n  }\n\n  #dispatchLinkInsertEvent(nodeKey, payload) {\n    const linkManipulationMethods = {\n      replaceLinkWith: (html, options) => this.contents.replaceNodeWithHTML(nodeKey, html, options),\n      insertBelowLink: (html, options) => this.contents.insertHTMLBelowNode(nodeKey, html, options)\n    };\n\n    dispatch(this.editorElement, \"lexxy:insert-link\", {\n      ...payload,\n      ...linkManipulationMethods\n    });\n  }\n\n  #pasteMarkdown(text) {\n    const html = marked(text);\n    this.contents.insertHtml(html, { tag: [ PASTE_TAG ] });\n  }\n\n  #pasteRichText(clipboardData) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      $insertDataTransferForRichText(clipboardData, selection, this.editor);\n    }, { tag: PASTE_TAG });\n  }\n\n  #handlePastedFiles(clipboardData) {\n    if (!this.editorElement.supportsAttachments) return\n\n    const html = clipboardData.getData(\"text/html\");\n    if (html) return // Ignore if image copied from browser since we will load it as a remote image\n\n    this.#preservingScrollPosition(() => {\n      for (const item of clipboardData.items) {\n        const file = item.getAsFile();\n        if (!file) continue\n\n        this.contents.uploadFile(file);\n      }\n    });\n  }\n\n  // Deals with an issue in Safari where it scrolls to the tops after pasting attachments\n  async #preservingScrollPosition(callback) {\n    const scrollY = window.scrollY;\n    const scrollX = window.scrollX;\n\n    callback();\n\n    await nextFrame();\n\n    window.scrollTo(scrollX, scrollY);\n    this.editor.focus();\n  }\n}\n\nclass Extensions {\n\n  constructor(lexxyElement) {\n    this.lexxyElement = lexxyElement;\n\n    this.enabledExtensions = this.#initializeExtensions();\n  }\n\n  get lexicalExtensions() {\n    return this.enabledExtensions.map(ext => ext.lexicalExtension).filter(Boolean)\n  }\n\n  initializeToolbars() {\n    if (this.#lexxyToolbar) {\n      this.enabledExtensions.forEach(ext => ext.initializeToobar(this.#lexxyToolbar));\n    }\n  }\n\n  get #lexxyToolbar() {\n    return this.lexxyElement.toolbar\n  }\n\n  #initializeExtensions() {\n    const extensionDefinitions = Lexxy.global.get(\"extensions\");\n\n    return extensionDefinitions.map(\n      extension => new extension(this.lexxyElement)\n    ).filter(extension => extension.enabled)\n  }\n}\n\nconst TOGGLE_HIGHLIGHT_COMMAND = createCommand();\n\nconst hasPastedStylesState = createState(\"hasPastedStyles\", {\n  parse: (value) => value || false\n});\n\nconst HighlightExtension = defineExtension({\n  dependencies: [ RichTextExtension ],\n  name: \"lexxy/highlight\",\n  config: {\n    color: { buttons: [], permit: [] },\n    \"background-color\": { buttons: [], permit: [] }\n  },\n  html: {\n    import: {\n      mark: $markConversion\n    }\n  },\n  register(editor, config) {\n    const canonicalizers = buildCanonicalizers(config);\n\n    editor.registerCommand(TOGGLE_HIGHLIGHT_COMMAND, $toggleSelectionStyles, COMMAND_PRIORITY_NORMAL);\n    editor.registerNodeTransform(TextNode, $syncHighlightWithStyle);\n    editor.registerNodeTransform(TextNode, (textNode) => $canonicalizePastedStyles(textNode, canonicalizers));\n  }\n});\n\nfunction $applyHighlightStyle(textNode, element) {\n  const elementStyles = {\n    color: element.style?.color,\n    \"background-color\": element.style?.backgroundColor\n  };\n\n  if ($hasUpdateTag(PASTE_TAG)) { $setPastedStyles(textNode); }\n  const highlightStyle = getCSSFromStyleObject(elementStyles);\n\n  if (highlightStyle.length) {\n    return textNode.setStyle(textNode.getStyle() + highlightStyle)\n  }\n}\n\nfunction $markConversion() {\n  return {\n    conversion: extendTextNodeConversion(\"mark\", $applyHighlightStyle),\n    priority: 1\n  }\n}\n\nfunction buildCanonicalizers(config) {\n  return [\n    new StyleCanonicalizer(\"color\", [ ...config.buttons.color, ...config.permit.color ]),\n    new StyleCanonicalizer(\"background-color\", [ ...config.buttons[\"background-color\"], ...config.permit[\"background-color\"] ])\n  ]\n}\n\nfunction $toggleSelectionStyles(styles) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) return\n\n  const patch = {};\n  for (const property in styles) {\n    const oldValue = $getSelectionStyleValueForProperty(selection, property);\n    patch[property] = toggleOrReplace(oldValue, styles[property]);\n  }\n\n  $patchStyleText(selection, patch);\n}\n\nfunction toggleOrReplace(oldValue, newValue) {\n  return oldValue === newValue ? null : newValue\n}\n\nfunction $syncHighlightWithStyle(textNode) {\n  if (hasHighlightStyles(textNode.getStyle()) !== textNode.hasFormat(\"highlight\")) {\n    textNode.toggleFormat(\"highlight\");\n  }\n}\n\nfunction $canonicalizePastedStyles(textNode, canonicalizers = []) {\n  if ($hasPastedStyles(textNode)) {\n    $setPastedStyles(textNode, false);\n\n    const canonicalizedCSS = canonicalizers.reduce((css, canonicalizer) => {\n      return canonicalizer.applyCanonicalization(css)\n    }, textNode.getStyle());\n\n    textNode.setStyle(canonicalizedCSS);\n  }\n}\n\nfunction $setPastedStyles(textNode, value = true) {\n  $setState(textNode, hasPastedStylesState, value);\n}\n\nfunction $hasPastedStyles(textNode) {\n  return $getState(textNode, hasPastedStylesState)\n}\n\nclass Highlighter {\n\n  constructor(editorElement) {\n    this.editorElement = editorElement;\n  }\n\n  get editor() {\n    return this.editorElement.editor\n  }\n\n  get lexicalExtension() {\n    return [ HighlightExtension, this.editorElement.config.get(\"highlight\") ]\n  }\n\n  toggle(styles) {\n    this.editor.dispatchCommand(TOGGLE_HIGHLIGHT_COMMAND, styles);\n  }\n\n  remove() {\n    this.toggle({ \"color\": null, \"background-color\": null });\n  }\n}\n\nconst TRIX_LANGUAGE_ATTR = \"language\";\n\nconst TrixContentExtension = defineExtension({\n  name: \"lexxy/trix-content\",\n  html: {\n    import: {\n      em: (element) => onlyStyledElements(element, {\n        conversion: extendTextNodeConversion(\"i\", $applyHighlightStyle),\n        priority: 1\n      }),\n      span: (element) => onlyStyledElements(element, {\n        conversion: extendTextNodeConversion(\"mark\", $applyHighlightStyle),\n        priority: 1\n      }),\n      strong: (element) => onlyStyledElements(element, {\n        conversion: extendTextNodeConversion(\"b\", $applyHighlightStyle),\n        priority: 1\n      }),\n      del: () => ({\n        conversion: extendTextNodeConversion(\"s\", $applyStrikethrough, $applyHighlightStyle),\n        priority: 1\n      }),\n      pre: (element) => onlyPreLanguageElements(element, {\n        conversion: extendConversion(CodeNode, \"pre\", $applyLanguage),\n        priority: 1\n      })\n    }\n  }\n});\n\nfunction onlyStyledElements(element, conversion) {\n  const elementHighlighted = element.style.color !== \"\" || element.style.backgroundColor !== \"\";\n  return elementHighlighted ? conversion : null\n}\n\nfunction $applyStrikethrough(textNode) {\n  if (!textNode.hasFormat(\"strikethrough\")) textNode.toggleFormat(\"strikethrough\");\n  return textNode\n}\n\nfunction onlyPreLanguageElements(element, conversion) {\n  return element.hasAttribute(TRIX_LANGUAGE_ATTR) ? conversion : null\n}\n\nfunction $applyLanguage(conversionOutput, element) {\n  const language = normalizeCodeLang(element.getAttribute(TRIX_LANGUAGE_ATTR));\n  conversionOutput.node.setLanguage(language);\n}\n\nclass WrappedTableNode extends TableNode {\n  static clone(node) {\n    return new WrappedTableNode(node.__key)\n  }\n\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n\n    return {\n      ...superExport,\n      after: (tableElement) => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n          const clonedTable = tableElement.cloneNode(true);\n          const wrappedTable = createElement(\"figure\", { className: \"lexxy-content__table-wrapper\" }, clonedTable.outerHTML);\n          return wrappedTable\n        }\n\n        return tableElement\n      }\n    }\n  }\n}\n\nconst TablesLexicalExtension = defineExtension({\n  name: \"lexxy/tables\",\n  nodes: [\n    WrappedTableNode,\n    {\n      replace: TableNode,\n      with: () => new WrappedTableNode()\n    },\n    TableCellNode,\n    TableRowNode\n  ],\n  register(editor) {\n    // Register Lexical table plugins\n    registerTablePlugin(editor);\n    registerTableSelectionObserver(editor, true);\n    setScrollableTablesActive(editor, true);\n\n    // Bug fix: Prevent hardcoded background color (Lexical #8089)\n    editor.registerNodeTransform(TableCellNode, (node) => {\n      if (node.getBackgroundColor() === null) {\n        node.setBackgroundColor(\"\");\n      }\n    });\n\n    // Bug fix: Fix column header states (Lexical #8090)\n    editor.registerNodeTransform(TableCellNode, (node) => {\n      const headerState = node.getHeaderStyles();\n\n      if (headerState !== TableCellHeaderStates.ROW) return\n\n      const rowParent = node.getParent();\n      const tableNode = rowParent?.getParent();\n      if (!tableNode) return\n\n      const rows = tableNode.getChildren();\n      const cellIndex = rowParent.getChildren().indexOf(node);\n\n      const cellsInRow = rowParent.getChildren();\n      const isHeaderRow = cellsInRow.every(cell =>\n        cell.getHeaderStyles() !== TableCellHeaderStates.NO_STATUS\n      );\n\n      const isHeaderColumn = rows.every(row => {\n        const cell = row.getChildren()[cellIndex];\n        return cell && cell.getHeaderStyles() !== TableCellHeaderStates.NO_STATUS\n      });\n\n      let newHeaderState = TableCellHeaderStates.NO_STATUS;\n\n      if (isHeaderRow) {\n        newHeaderState |= TableCellHeaderStates.ROW;\n      }\n\n      if (isHeaderColumn) {\n        newHeaderState |= TableCellHeaderStates.COLUMN;\n      }\n\n      if (newHeaderState !== headerState) {\n        node.setHeaderStyles(newHeaderState, TableCellHeaderStates.BOTH);\n      }\n    });\n\n    editor.registerCommand(\"insertTableRowAfter\", () => {\n      $insertTableRowAtSelection(true);\n    }, COMMAND_PRIORITY_NORMAL);\n\n    editor.registerCommand(\"insertTableRowBefore\", () => {\n      $insertTableRowAtSelection(false);\n    }, COMMAND_PRIORITY_NORMAL);\n\n    editor.registerCommand(\"insertTableColumnAfter\", () => {\n      $insertTableColumnAtSelection(true);\n    }, COMMAND_PRIORITY_NORMAL);\n\n    editor.registerCommand(\"insertTableColumnBefore\", () => {\n      $insertTableColumnAtSelection(false);\n    }, COMMAND_PRIORITY_NORMAL);\n\n    editor.registerCommand(\"deleteTableRow\", () => {\n      $deleteTableRowAtSelection();\n    }, COMMAND_PRIORITY_NORMAL);\n\n    editor.registerCommand(\"deleteTableColumn\", () => {\n      $deleteTableColumnAtSelection();\n    }, COMMAND_PRIORITY_NORMAL);\n\n    editor.registerCommand(\"deleteTable\", () => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return false\n      $findTableNode(selection.anchor.getNode())?.remove();\n    }, COMMAND_PRIORITY_NORMAL);\n  }\n});\n\nclass LexicalEditorElement extends HTMLElement {\n  static formAssociated = true\n  static debug = false\n  static commands = [ \"bold\", \"italic\", \"strikethrough\" ]\n\n  static observedAttributes = [ \"connected\", \"required\" ]\n\n  #initialValue = \"\"\n  #validationTextArea = document.createElement(\"textarea\")\n\n  constructor() {\n    super();\n    this.internals = this.attachInternals();\n    this.internals.role = \"presentation\";\n  }\n\n  connectedCallback() {\n    this.id ??= generateDomId(\"lexxy-editor\");\n    this.config = new EditorConfiguration(this);\n    this.extensions = new Extensions(this);\n    this.highlighter = new Highlighter(this);\n\n    this.editor = this.#createEditor();\n\n    this.contents = new Contents(this);\n    this.selection = new Selection(this);\n    this.clipboard = new Clipboard(this);\n\n    CommandDispatcher.configureFor(this);\n    this.#initialize();\n\n    requestAnimationFrame(() => dispatch(this, \"lexxy:initialize\"));\n    this.toggleAttribute(\"connected\", true);\n\n    this.#handleAutofocus();\n\n    this.valueBeforeDisconnect = null;\n  }\n\n  disconnectedCallback() {\n    this.valueBeforeDisconnect = this.value;\n    this.#reset(); // Prevent hangs with Safari when morphing\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"connected\" && this.isConnected && oldValue != null && oldValue !== newValue) {\n      requestAnimationFrame(() => this.#reconnect());\n    }\n\n    if (name === \"required\" && this.isConnected) {\n      this.#validationTextArea.required = this.hasAttribute(\"required\");\n      this.#setValidity();\n    }\n  }\n\n  formResetCallback() {\n    this.value = this.#initialValue;\n    this.editor.dispatchCommand(CLEAR_HISTORY_COMMAND, undefined);\n  }\n\n  toString() {\n    if (!this.cachedStringValue) {\n      this.editor?.getEditorState().read(() => {\n        this.cachedStringValue = $getRoot().getTextContent();\n      });\n    }\n\n    return this.cachedStringValue\n  }\n\n  get form() {\n    return this.internals.form\n  }\n\n  get name() {\n    return this.getAttribute(\"name\")\n  }\n\n  get toolbarElement() {\n    if (!this.#hasToolbar) return null\n\n    this.toolbar = this.toolbar || this.#findOrCreateDefaultToolbar();\n    return this.toolbar\n  }\n\n  get directUploadUrl() {\n    return this.dataset.directUploadUrl\n  }\n\n  get blobUrlTemplate() {\n    return this.dataset.blobUrlTemplate\n  }\n\n  get isEmpty() {\n    return [ \"<p><br></p>\", \"<p></p>\", \"\" ].includes(this.value.trim())\n  }\n\n  get isBlank() {\n    return this.isEmpty || this.toString().match(/^\\s*$/g) !== null\n  }\n\n  get hasOpenPrompt() {\n    return this.querySelector(\".lexxy-prompt-menu.lexxy-prompt-menu--visible\") !== null\n  }\n\n  get preset() {\n    return this.getAttribute(\"preset\") || \"default\"\n  }\n\n  get supportsAttachments() {\n    return this.config.get(\"attachments\")\n  }\n\n  get supportsMarkdown() {\n    return this.supportsRichText && this.config.get(\"markdown\")\n  }\n\n  get supportsMultiLine() {\n    return this.config.get(\"multiLine\") && !this.isSingleLineMode\n  }\n\n  get supportsRichText() {\n    return this.config.get(\"richText\")\n  }\n\n  // TODO: Deprecate `single-line` attribute\n  get isSingleLineMode() {\n    return this.hasAttribute(\"single-line\")\n  }\n\n  get contentTabIndex() {\n    return parseInt(this.editorContentElement?.getAttribute(\"tabindex\") ?? \"0\")\n  }\n\n  focus() {\n    this.editor.focus(() => this.#onFocus());\n  }\n\n  get value() {\n    if (!this.cachedValue) {\n      this.editor?.getEditorState().read(() => {\n        this.cachedValue = sanitize($generateHtmlFromNodes(this.editor, null));\n      });\n    }\n\n    return this.cachedValue\n  }\n\n  set value(html) {\n    this.editor.update(() => {\n      $addUpdateTag(SKIP_DOM_SELECTION_TAG);\n      const root = $getRoot();\n      root.clear();\n      root.append(...this.#parseHtmlIntoLexicalNodes(html));\n      root.selectEnd();\n\n      this.#toggleEmptyStatus();\n\n      // The first time you set the value, when the editor is empty, it seems to leave Lexical\n      // in an inconsistent state until, at least, you focus. You can type but adding attachments\n      // fails because no root node detected. This is a workaround to deal with the issue.\n      requestAnimationFrame(() => this.editor?.update(() => { }));\n    });\n  }\n\n  #parseHtmlIntoLexicalNodes(html) {\n    if (!html) html = \"<p></p>\";\n    const nodes = $generateNodesFromDOM(this.editor, parseHtml(`<div>${html}</div>`));\n\n    if (nodes.length === 0) {\n      return [ $createParagraphNode() ]\n    }\n\n    // Custom decorator block elements such action-text-attachments get wrapped into <p> automatically by Lexical.\n    // We flatten those.\n    return nodes.map(node => {\n      if (node.getType() === \"paragraph\" && node.getChildrenSize() === 1) {\n        const child = node.getFirstChild();\n        if (child instanceof DecoratorNode && !child.isInline()) {\n          return child\n        }\n      }\n      return node\n    })\n  }\n\n  #initialize() {\n    this.#synchronizeWithChanges();\n    this.#registerComponents();\n    this.#listenForInvalidatedNodes();\n    this.#handleEnter();\n    this.#registerFocusEvents();\n    this.#attachDebugHooks();\n    this.#attachToolbar();\n    this.#loadInitialValue();\n    this.#resetBeforeTurboCaches();\n  }\n\n  #createEditor() {\n    this.editorContentElement ||= this.#createEditorContentElement();\n\n    const editor = buildEditorFromExtensions({\n        name: \"lexxy/core\",\n        namespace: \"Lexxy\",\n        theme: theme,\n        nodes: this.#lexicalNodes\n      },\n      ...this.#lexicalExtensions\n    );\n\n    editor.setRootElement(this.editorContentElement);\n\n    return editor\n  }\n\n  get #lexicalExtensions() {\n    const extensions = [ ];\n    const richTextExtensions = [\n      this.highlighter.lexicalExtension,\n      TrixContentExtension,\n      TablesLexicalExtension\n    ];\n\n    if (this.supportsRichText) {\n      extensions.push(...richTextExtensions);\n    }\n\n    extensions.push(...this.extensions.lexicalExtensions);\n\n    return extensions\n  }\n\n  get #lexicalNodes() {\n    const nodes = [ CustomActionTextAttachmentNode ];\n\n    if (this.supportsRichText) {\n      nodes.push(\n        QuoteNode,\n        HeadingNode,\n        ListNode,\n        ListItemNode,\n        CodeNode,\n        CodeHighlightNode,\n        LinkNode,\n        AutoLinkNode,\n        HorizontalDividerNode\n      );\n    }\n\n    if (this.supportsAttachments) {\n      nodes.push(ActionTextAttachmentNode, ActionTextAttachmentUploadNode);\n    }\n\n    return nodes\n  }\n\n  #createEditorContentElement() {\n    const editorContentElement = createElement(\"div\", {\n      classList: \"lexxy-editor__content\",\n      contenteditable: true,\n      role: \"textbox\",\n      \"aria-multiline\": true,\n      \"aria-label\": this.#labelText,\n      placeholder: this.getAttribute(\"placeholder\")\n    });\n    editorContentElement.id = `${this.id}-content`;\n    this.#ariaAttributes.forEach(attribute => editorContentElement.setAttribute(attribute.name, attribute.value));\n    this.appendChild(editorContentElement);\n\n    if (this.getAttribute(\"tabindex\")) {\n      editorContentElement.setAttribute(\"tabindex\", this.getAttribute(\"tabindex\"));\n      this.removeAttribute(\"tabindex\");\n    } else {\n      editorContentElement.setAttribute(\"tabindex\", 0);\n    }\n\n    return editorContentElement\n  }\n\n  get #labelText() {\n    return Array.from(this.internals.labels).map(label => label.textContent).join(\" \")\n  }\n\n  get #ariaAttributes() {\n    return Array.from(this.attributes).filter(attribute => attribute.name.startsWith(\"aria-\"))\n  }\n\n  set #internalFormValue(html) {\n    const changed = this.#internalFormValue !== undefined && this.#internalFormValue !== this.value;\n\n    this.internals.setFormValue(html);\n    this._internalFormValue = html;\n    this.#validationTextArea.value = this.isEmpty ? \"\" : html;\n\n    if (changed) {\n      dispatch(this, \"lexxy:change\");\n    }\n  }\n\n  get #internalFormValue() {\n    return this._internalFormValue\n  }\n\n  #loadInitialValue() {\n    const initialHtml = this.valueBeforeDisconnect || this.getAttribute(\"value\") || \"<p></p>\";\n    this.value = this.#initialValue = initialHtml;\n  }\n\n  #resetBeforeTurboCaches() {\n    document.addEventListener(\"turbo:before-cache\", this.#handleTurboBeforeCache);\n  }\n\n  #handleTurboBeforeCache = (event) => {\n    this.#reset();\n  }\n\n  #synchronizeWithChanges() {\n    this.#addUnregisterHandler(this.editor.registerUpdateListener(({ editorState }) => {\n      this.#clearCachedValues();\n      this.#internalFormValue = this.value;\n      this.#toggleEmptyStatus();\n      this.#setValidity();\n    }));\n  }\n\n  #clearCachedValues() {\n    this.cachedValue = null;\n    this.cachedStringValue = null;\n  }\n\n  #addUnregisterHandler(handler) {\n    this.unregisterHandlers = this.unregisterHandlers || [];\n    this.unregisterHandlers.push(handler);\n  }\n\n  #unregisterHandlers() {\n    this.unregisterHandlers?.forEach((handler) => {\n      handler();\n    });\n    this.unregisterHandlers = null;\n  }\n\n  #registerComponents() {\n    if (this.supportsRichText) {\n      registerRichText(this.editor);\n      registerList(this.editor);\n      this.#registerTableComponents();\n      this.#registerCodeHiglightingComponents();\n      if (this.supportsMarkdown) {\n        registerMarkdownShortcuts(this.editor, TRANSFORMERS);\n      }\n    } else {\n      registerPlainText(this.editor);\n    }\n    this.historyState = createEmptyHistoryState();\n    registerHistory(this.editor, this.historyState, 20);\n  }\n\n  #registerTableComponents() {\n    this.tableTools = createElement(\"lexxy-table-tools\");\n    this.append(this.tableTools);\n  }\n\n  #registerCodeHiglightingComponents() {\n    registerCodeHighlighting(this.editor);\n    this.codeLanguagePicker = createElement(\"lexxy-code-language-picker\");\n    this.append(this.codeLanguagePicker);\n  }\n\n  #listenForInvalidatedNodes() {\n    this.editor.getRootElement().addEventListener(\"lexxy:internal:invalidate-node\", (event) => {\n      const { key, values } = event.detail;\n\n      this.editor.update(() => {\n        const node = $getNodeByKey(key);\n\n        if (node instanceof ActionTextAttachmentNode) {\n          const updatedNode = node.getWritable();\n          Object.assign(updatedNode, values);\n        }\n      });\n    });\n  }\n\n  #handleEnter() {\n    // We can't prevent these externally using regular keydown because Lexical handles it first.\n    this.editor.registerCommand(\n      KEY_ENTER_COMMAND,\n      (event) => {\n        // Prevent CTRL+ENTER\n        if (event.ctrlKey || event.metaKey) {\n          event.preventDefault();\n          return true\n        }\n\n        // In single line mode, prevent ENTER\n        if (!this.supportsMultiLine) {\n          event.preventDefault();\n          return true\n        }\n\n        return false\n      },\n      COMMAND_PRIORITY_NORMAL\n    );\n  }\n\n  #registerFocusEvents() {\n    this.addEventListener(\"focusin\", this.#handleFocusIn);\n    this.addEventListener(\"focusout\", this.#handleFocusOut);\n  }\n\n  #handleFocusIn(event) {\n    if (this.#elementInEditorOrToolbar(event.target) && !this.currentlyFocused) {\n      dispatch(this, \"lexxy:focus\");\n      this.currentlyFocused = true;\n    }\n  }\n\n  #handleFocusOut(event) {\n    if (!this.#elementInEditorOrToolbar(event.relatedTarget)) {\n      dispatch(this, \"lexxy:blur\");\n      this.currentlyFocused = false;\n    }\n  }\n\n  #elementInEditorOrToolbar(element) {\n    return this.contains(element) || this.toolbarElement?.contains(element)\n  }\n\n  #onFocus() {\n    if (this.isEmpty) {\n      this.selection.placeCursorAtTheEnd();\n    }\n  }\n\n  #handleAutofocus() {\n    if (!document.querySelector(\":focus\")) {\n      if (this.hasAttribute(\"autofocus\") && document.querySelector(\"[autofocus]\") === this) {\n        this.focus();\n      }\n    }\n  }\n\n\n  #attachDebugHooks() {\n    if (!LexicalEditorElement.debug) return\n\n    this.#addUnregisterHandler(this.editor.registerUpdateListener(({ editorState }) => {\n      editorState.read(() => {\n        console.debug(\"HTML: \", this.value, \"String:\", this.toString());\n        console.debug(\"empty\", this.isEmpty, \"blank\", this.isBlank);\n      });\n    }));\n  }\n\n  #attachToolbar() {\n    if (this.#hasToolbar) {\n      this.toolbarElement.setEditor(this);\n    }\n  }\n\n  #findOrCreateDefaultToolbar() {\n    const toolbarId = this.config.get(\"toolbar\");\n    if (toolbarId && toolbarId !== true) {\n      return document.getElementById(toolbarId)\n    } else {\n      return this.#createDefaultToolbar()\n    }\n  }\n\n  get #hasToolbar() {\n    return this.supportsRichText && this.config.get(\"toolbar\")\n  }\n\n  #createDefaultToolbar() {\n    const toolbar = createElement(\"lexxy-toolbar\");\n    toolbar.innerHTML = LexicalToolbarElement.defaultTemplate;\n    toolbar.setAttribute(\"data-attachments\", this.supportsAttachments); // Drives toolbar CSS styles\n    this.prepend(toolbar);\n    return toolbar\n  }\n\n  #toggleEmptyStatus() {\n    this.classList.toggle(\"lexxy-editor--empty\", this.isEmpty);\n  }\n\n  #setValidity() {\n    if (this.#validationTextArea.validity.valid) {\n      this.internals.setValidity({});\n    } else {\n      this.internals.setValidity(this.#validationTextArea.validity, this.#validationTextArea.validationMessage, this.editorContentElement);\n    }\n  }\n\n  #reset() {\n    this.#unregisterHandlers();\n\n    if (this.editorContentElement) {\n      this.editorContentElement.remove();\n      this.editorContentElement = null;\n    }\n\n    this.contents = null;\n    this.editor = null;\n\n    if (this.toolbar) {\n      if (!this.getAttribute(\"toolbar\")) { this.toolbar.remove(); }\n      this.toolbar = null;\n    }\n\n    if (this.codeLanguagePicker) {\n      this.codeLanguagePicker.remove();\n      this.codeLanguagePicker = null;\n    }\n\n    if (this.tableHandler) {\n      this.tableHandler.remove();\n      this.tableHandler = null;\n    }\n\n    this.selection = null;\n\n    document.removeEventListener(\"turbo:before-cache\", this.#handleTurboBeforeCache);\n  }\n\n  #reconnect() {\n    this.disconnectedCallback();\n    this.valueBeforeDisconnect = null;\n    this.connectedCallback();\n  }\n}\n\ncustomElements.define(\"lexxy-editor\", LexicalEditorElement);\n\nclass ToolbarDropdown extends HTMLElement {\n  connectedCallback() {\n    this.container = this.closest(\"details\");\n\n    this.container.addEventListener(\"toggle\", this.#handleToggle.bind(this));\n    this.container.addEventListener(\"keydown\", this.#handleKeyDown.bind(this));\n\n    this.#onToolbarEditor(this.initialize.bind(this));\n  }\n\n  disconnectedCallback() {\n    this.container.removeEventListener(\"keydown\", this.#handleKeyDown.bind(this));\n  }\n\n  get toolbar() {\n    return this.closest(\"lexxy-toolbar\")\n  }\n\n  get editorElement() {\n    return this.toolbar.editorElement\n  }\n\n  get editor() {\n    return this.toolbar.editor\n  }\n\n  initialize() {\n    // Any post-editor initialization\n  }\n\n  close() {\n    this.editor.focus();\n    this.container.open = false;\n  }\n\n  async #onToolbarEditor(callback) {\n    await this.toolbar.editorConnected;\n    callback();\n  }\n\n  #handleToggle() {\n    if (this.container.open) {\n      this.#handleOpen();\n    }\n  }\n\n  async #handleOpen() {\n    this.#interactiveElements[0].focus();\n    this.#resetTabIndexValues();\n  }\n\n  #handleKeyDown(event) {\n    if (event.key === \"Escape\") {\n      event.stopPropagation();\n      this.close();\n    }\n  }\n\n  async #resetTabIndexValues() {\n    await nextFrame();\n    this.#buttons.forEach((element, index) => {\n      element.setAttribute(\"tabindex\", index === 0 ? 0 : \"-1\");\n    });\n  }\n\n  get #interactiveElements() {\n    return Array.from(this.querySelectorAll(\"button, input\"))\n  }\n\n  get #buttons() {\n    return Array.from(this.querySelectorAll(\"button\"))\n  }\n}\n\nclass LinkDropdown extends ToolbarDropdown {\n  connectedCallback() {\n    super.connectedCallback();\n    this.input = this.querySelector(\"input\");\n\n    this.#registerHandlers();\n  }\n\n  #registerHandlers() {\n    this.container.addEventListener(\"toggle\", this.#handleToggle.bind(this));\n    this.addEventListener(\"submit\", this.#handleSubmit.bind(this));\n    this.querySelector(\"[value='unlink']\").addEventListener(\"click\", this.#handleUnlink.bind(this));\n  }\n\n  #handleToggle({ newState }) {\n    this.input.value = this.#selectedLinkUrl;\n    this.input.required = newState === \"open\";\n  }\n\n  #handleSubmit(event) {\n    const command = event.submitter?.value;\n    this.editor.dispatchCommand(command, this.input.value);\n    this.close();\n  }\n\n  #handleUnlink() {\n    this.editor.dispatchCommand(\"unlink\");\n    this.close();\n  }\n\n  get #selectedLinkUrl() {\n    let url = \"\";\n\n    this.editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return\n\n      let node = selection.getNodes()[0];\n      while (node && node.getParent()) {\n        if ($isLinkNode(node)) {\n          url = node.getURL();\n          break\n        }\n        node = node.getParent();\n      }\n    });\n\n    return url\n  }\n}\n\ncustomElements.define(\"lexxy-link-dropdown\", LinkDropdown);\n\nconst APPLY_HIGHLIGHT_SELECTOR = \"button.lexxy-highlight-button\";\nconst REMOVE_HIGHLIGHT_SELECTOR = \"[data-command='removeHighlight']\";\n\n// Use Symbol instead of null since $getSelectionStyleValueForProperty\n// responds differently for backward selections if null is the default\n// see https://github.com/facebook/lexical/issues/8013\nconst NO_STYLE = Symbol(\"no_style\");\n\nclass HighlightDropdown extends ToolbarDropdown {\n  connectedCallback() {\n    super.connectedCallback();\n    this.#registerToggleHandler();\n  }\n\n  initialize() {\n    this.#setUpButtons();\n    this.#registerButtonHandlers();\n  }\n\n  #registerToggleHandler() {\n    this.container.addEventListener(\"toggle\", this.#handleToggle.bind(this));\n  }\n\n  #registerButtonHandlers() {\n    this.#colorButtons.forEach(button => button.addEventListener(\"click\", this.#handleColorButtonClick.bind(this)));\n    this.querySelector(REMOVE_HIGHLIGHT_SELECTOR).addEventListener(\"click\", this.#handleRemoveHighlightClick.bind(this));\n  }\n\n  #setUpButtons() {\n    const colorGroups = this.editorElement.config.get(\"highlight.buttons\");\n\n    this.#populateButtonGroup(\"color\", colorGroups.color);\n    this.#populateButtonGroup(\"background-color\", colorGroups[\"background-color\"]);\n\n    const maxNumberOfColors = Math.max(colorGroups.color.length, colorGroups[\"background-color\"].length);\n    this.style.setProperty(\"--max-colors\", maxNumberOfColors);\n  }\n\n  #populateButtonGroup(attribute, values) {\n    values.forEach((value, index) => {\n      this.#buttonContainer.appendChild(this.#createButton(attribute, value, index));\n    });\n  }\n\n  #createButton(attribute, value, index) {\n    const button = document.createElement(\"button\");\n    button.dataset.style = attribute;\n    button.style.setProperty(attribute, value);\n    button.dataset.value = value;\n    button.classList.add(\"lexxy-editor__toolbar-button\", \"lexxy-highlight-button\");\n    button.name = attribute + \"-\" + index;\n    return button\n  }\n\n  #handleToggle({ newState }) {\n    if (newState === \"open\") {\n      this.editor.getEditorState().read(() => {\n        this.#updateColorButtonStates($getSelection());\n      });\n    }\n  }\n\n  #handleColorButtonClick(event) {\n    event.preventDefault();\n\n    const button = event.target.closest(APPLY_HIGHLIGHT_SELECTOR);\n    if (!button) return\n\n    const attribute = button.dataset.style;\n    const value = button.dataset.value;\n\n    this.editor.dispatchCommand(\"toggleHighlight\", { [attribute]: value });\n    this.close();\n  }\n\n  #handleRemoveHighlightClick(event) {\n    event.preventDefault();\n\n    this.editor.dispatchCommand(\"removeHighlight\");\n    this.close();\n  }\n\n  #updateColorButtonStates(selection) {\n    if (!$isRangeSelection(selection)) { return }\n\n    // Use non-\"\" default, so \"\" indicates mixed highlighting\n    const textColor = $getSelectionStyleValueForProperty(selection, \"color\", NO_STYLE);\n    const backgroundColor = $getSelectionStyleValueForProperty(selection, \"background-color\", NO_STYLE);\n\n    this.#colorButtons.forEach(button => {\n      const matchesSelection = button.dataset.value === textColor || button.dataset.value === backgroundColor;\n      button.setAttribute(\"aria-pressed\", matchesSelection);\n    });\n\n    const hasHighlight = textColor !== NO_STYLE || backgroundColor !== NO_STYLE;\n    this.querySelector(REMOVE_HIGHLIGHT_SELECTOR).disabled = !hasHighlight;\n  }\n\n  get #buttonContainer() {\n    return this.querySelector(\".lexxy-highlight-colors\")\n  }\n\n  get #colorButtons() {\n    return Array.from(this.querySelectorAll(APPLY_HIGHLIGHT_SELECTOR))\n  }\n}\n\ncustomElements.define(\"lexxy-highlight-dropdown\", HighlightDropdown);\n\nclass TableController {\n  constructor(editorElement) {\n    this.editor = editorElement.editor;\n    this.contents = editorElement.contents;\n    this.selection = editorElement.selection;\n\n    this.currentTableNodeKey = null;\n    this.currentCellKey = null;\n\n    this.#registerKeyHandlers();\n  }\n\n  destroy() {\n    this.currentTableNodeKey = null;\n    this.currentCellKey = null;\n\n    this.#unregisterKeyHandlers();\n  }\n\n  get currentCell() {\n    if (!this.currentCellKey) return null\n\n    return this.editor.getEditorState().read(() => {\n      const cell = $getNodeByKey(this.currentCellKey);\n      return (cell instanceof TableCellNode) ? cell : null\n    })\n  }\n\n  get currentTableNode() {\n    if (!this.currentTableNodeKey) return null\n\n    return this.editor.getEditorState().read(() => {\n      const tableNode = $getNodeByKey(this.currentTableNodeKey);\n      return (tableNode instanceof TableNode) ? tableNode : null\n    })\n  }\n\n  get currentRowCells() {\n    const currentRowIndex = this.currentRowIndex;\n\n    const rows = this.tableRows;\n    if (!rows) return null\n\n    return this.editor.getEditorState().read(() => {\n      return rows[currentRowIndex]?.getChildren() ?? null\n    }) ?? null\n  }\n\n  get currentRowIndex() {\n    const currentCell = this.currentCell;\n    if (!currentCell) return 0\n\n    return this.editor.getEditorState().read(() => {\n      return $getTableRowIndexFromTableCellNode(currentCell)\n    }) ?? 0\n  }\n\n  get currentColumnCells() {\n    const columnIndex = this.currentColumnIndex;\n\n    const rows = this.tableRows;\n    if (!rows) return null\n\n    return this.editor.getEditorState().read(() => {\n      return rows.map(row => row.getChildAtIndex(columnIndex))\n    }) ?? null\n  }\n\n  get currentColumnIndex() {\n    const currentCell = this.currentCell;\n    if (!currentCell) return 0\n\n    return this.editor.getEditorState().read(() => {\n      return $getTableColumnIndexFromTableCellNode(currentCell)\n    }) ?? 0\n  }\n\n  get tableRows() {\n    return this.editor.getEditorState().read(() => {\n      return this.currentTableNode?.getChildren()\n    }) ?? null\n  }\n\n  updateSelectedTable() {\n    let cellNode = null;\n    let tableNode = null;\n\n    this.editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if (!selection || !this.selection.isTableCellSelected) return\n\n      const node = selection.getNodes()[0];\n\n      cellNode = $findCellNode(node);\n      tableNode = $findTableNode(node);\n    });\n\n    this.currentCellKey = cellNode?.getKey() ?? null;\n    this.currentTableNodeKey = tableNode?.getKey() ?? null;\n  }\n\n  executeTableCommand(command, customIndex = null) {\n    if (command.action === \"delete\" && command.childType === \"table\") {\n      this.#deleteTable();\n      return\n    }\n\n    if (command.action === \"toggle\") {\n      this.#executeToggleStyle(command);\n      return\n    }\n\n    this.#executeCommand(command, customIndex);\n  }\n\n  #executeCommand(command, customIndex = null) {\n    this.#selectCellAtSelection();\n    this.editor.dispatchCommand(this.#commandName(command));\n    this.#selectNextBestCell(command, customIndex);\n  }\n\n  #executeToggleStyle(command) {\n    const childType = command.childType;\n\n    let cells = null;\n    let headerState = null;\n\n    if (childType === \"row\") {\n      cells = this.currentRowCells;\n      headerState = TableCellHeaderStates.ROW;\n    } else if (childType === \"column\") {\n      cells = this.currentColumnCells;\n      headerState = TableCellHeaderStates.COLUMN;\n    }\n\n    if (!cells || cells.length === 0) return\n\n    this.editor.update(() => {\n      const firstCell = $getTableCellNodeFromLexicalNode(cells[0]);\n      if (!firstCell) return\n\n      const currentStyle = firstCell.getHeaderStyles();\n      const newStyle = currentStyle ^ headerState;\n\n      cells.forEach(cell => {\n        this.#setHeaderStyle(cell, newStyle, headerState);\n      });\n    });\n  }\n\n  #deleteTable() {\n    this.#selectCellAtSelection();\n    this.editor.dispatchCommand(\"deleteTable\");\n  }\n\n  #selectCellAtSelection() {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!selection) return\n\n      const node = selection.getNodes()[0];\n\n      $findCellNode(node)?.selectEnd();\n    });\n  }\n\n  #commandName(command) {\n    const { action, childType, direction } = command;\n\n    const childTypeSuffix = upcaseFirst(childType);\n    const directionSuffix = action == \"insert\" ? upcaseFirst(direction) : \"\";\n    return `${action}Table${childTypeSuffix}${directionSuffix}`\n  }\n\n  #setHeaderStyle(cell, newStyle, headerState) {\n    const tableCellNode = $getTableCellNodeFromLexicalNode(cell);\n    tableCellNode?.setHeaderStyles(newStyle, headerState);\n  }\n\n  async #selectCellAtIndex(rowIndex, columnIndex) {\n    // We wait for next frame, otherwise table operations might not have completed yet.\n    await nextFrame();\n\n    if (!this.currentTableNode) return\n\n    const rows = this.tableRows;\n    if (!rows) return\n\n    const row = rows[rowIndex];\n    if (!row) return\n\n    this.editor.update(() => {\n      const cell = $getTableCellNodeFromLexicalNode(row.getChildAtIndex(columnIndex));\n      cell?.selectEnd();\n    });\n  }\n\n  #selectNextBestCell(command, customIndex = null) {\n    const { childType, direction } = command;\n\n    let rowIndex = this.currentRowIndex;\n    let columnIndex = customIndex !== null ? customIndex : this.currentColumnIndex;\n\n    const deleteOffset = command.action === \"delete\" ? -1 : 0;\n    const offset = direction === \"after\" ? 1 : deleteOffset;\n\n    if (childType === \"row\") {\n      rowIndex += offset;\n    } else if (childType === \"column\") {\n      columnIndex += offset;\n    }\n\n    this.#selectCellAtIndex(rowIndex, columnIndex);\n  }\n\n  #selectNextRow() {\n    const rows = this.tableRows;\n    if (!rows) return\n\n    const nextRow = rows.at(this.currentRowIndex + 1);\n    if (!nextRow) return\n\n    this.editor.update(() => {\n      nextRow.getChildAtIndex(this.currentColumnIndex)?.selectEnd();\n    });\n  }\n\n  #selectPreviousCell() {\n    const cell = this.currentCell;\n    if (!cell) return\n\n    this.editor.update(() => {\n      cell.selectPrevious();\n    });\n  }\n\n  #insertRowAndSelectFirstCell() {\n    this.executeTableCommand({ action: \"insert\", childType: \"row\", direction: \"after\" }, 0);\n  }\n\n  #deleteRowAndSelectLastCell() {\n    this.executeTableCommand({ action: \"delete\", childType: \"row\" }, -1);\n  }\n\n  #deleteRowAndSelectNextNode() {\n    const tableNode = this.currentTableNode;\n    this.executeTableCommand({ action: \"delete\", childType: \"row\" });\n\n    this.editor.update(() => {\n      const next = tableNode?.getNextSibling();\n      if ($isParagraphNode(next)) {\n        next.selectStart();\n      } else {\n        const newParagraph = $createParagraphNode();\n        this.currentTableNode.insertAfter(newParagraph);\n        newParagraph.selectStart();\n      }\n    });\n  }\n\n  #isCurrentCellEmpty() {\n    if (!this.currentTableNode) return false\n\n    const cell = this.currentCell;\n    if (!cell) return false\n\n    return cell.getTextContent().trim() === \"\"\n  }\n\n  #isCurrentRowLast() {\n    if (!this.currentTableNode) return false\n\n    const rows = this.tableRows;\n    if (!rows) return false\n\n    return rows.length === this.currentRowIndex + 1\n  }\n\n  #isCurrentRowEmpty() {\n    if (!this.currentTableNode) return false\n\n    const cells = this.currentRowCells;\n    if (!cells) return false\n\n    return cells.every(cell => cell.getTextContent().trim() === \"\")\n  }\n\n  #isFirstCellInRow() {\n    if (!this.currentTableNode) return false\n\n    const cells = this.currentRowCells;\n    if (!cells) return false\n\n    return cells.indexOf(this.currentCell) === 0\n  }\n\n  #registerKeyHandlers() {\n    // We can't prevent these externally using regular keydown because Lexical handles it first.\n    this.unregisterBackspaceKeyHandler = this.editor.registerCommand(KEY_BACKSPACE_COMMAND, (event) => this.#handleBackspaceKey(event), COMMAND_PRIORITY_HIGH);\n    this.unregisterEnterKeyHandler = this.editor.registerCommand(KEY_ENTER_COMMAND, (event) => this.#handleEnterKey(event), COMMAND_PRIORITY_HIGH);\n  }\n\n  #unregisterKeyHandlers() {\n    this.unregisterBackspaceKeyHandler?.();\n    this.unregisterEnterKeyHandler?.();\n\n    this.unregisterBackspaceKeyHandler = null;\n    this.unregisterEnterKeyHandler = null;\n  }\n\n  #handleBackspaceKey(event) {\n    if (!this.currentTableNode) return false\n\n    if (this.#isCurrentRowEmpty() && this.#isFirstCellInRow()) {\n      event.preventDefault();\n      this.#deleteRowAndSelectLastCell();\n      return true\n    }\n\n    if (this.#isCurrentCellEmpty() && !this.#isFirstCellInRow()) {\n      event.preventDefault();\n      this.#selectPreviousCell();\n      return true\n    }\n\n    return false\n  }\n\n  #handleEnterKey(event) {\n    if ((event.ctrlKey || event.metaKey) || event.shiftKey || !this.currentTableNode) return false\n\n    if (this.selection.isInsideList || this.selection.isInsideCodeBlock) return false\n\n    event.preventDefault();\n\n    if (this.#isCurrentRowLast() && this.#isCurrentRowEmpty()) {\n      this.#deleteRowAndSelectNextNode();\n    } else if (this.#isCurrentRowLast()) {\n      this.#insertRowAndSelectFirstCell();\n    } else {\n      this.#selectNextRow();\n    }\n\n    return true\n  }\n}\n\nvar TableIcons = {\n  \"insert-row-before\":\n    `<svg  viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.86804e-07 15C8.29055e-07 15.8284 0.671574 16.5 1.5 16.5H15L15.1533 16.4922C15.8593 16.4205 16.4205 15.8593 16.4922 15.1533L16.5 15V4.5L16.4922 4.34668C16.4154 3.59028 15.7767 3 15 3H13.5L13.5 4.5H15V9H1.5L1.5 4.5L3 4.5V3H1.5C0.671574 3 1.20956e-06 3.67157 1.24577e-06 4.5L7.86804e-07 15ZM15 10.5V15H1.5L1.5 10.5H15Z\"/>\n    <path d=\"M4.5 4.5H7.5V7.5H9V4.5H12L12 3L9 3V6.55671e-08L7.5 0V3L4.5 3V4.5Z\"/>\n    </svg>`,\n\n  \"insert-row-after\":\n    `<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.86804e-07 13.5C7.50592e-07 14.3284 0.671574 15 1.5 15H3V13.5H1.5L1.5 9L15 9V13.5H13.5V15H15C15.7767 15 16.4154 14.4097 16.4922 13.6533L16.5 13.5V3L16.4922 2.84668C16.4205 2.14069 15.8593 1.57949 15.1533 1.50781L15 1.5L1.5 1.5C0.671574 1.5 1.28803e-06 2.17157 1.24577e-06 3L7.86804e-07 13.5ZM15 3V7.5L1.5 7.5L1.5 3L15 3Z\"/>\n    <path d=\"M7.5 15V18H9V15H12V13.5H9V10.5H7.5V13.5H4.5V15H7.5Z\"/>\n    </svg>`,\n\n  \"delete-row\":\n    `<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M16.4922 12.1533C16.4154 12.9097 15.7767 13.5 15 13.5L12 13.5V12H15V6L1.5 6L1.5 12H4.5V13.5H1.5C0.723337 13.5 0.0846104 12.9097 0.00781328 12.1533L7.86804e-07 12L1.04907e-06 6C1.17362e-06 5.22334 0.590278 4.58461 1.34668 4.50781L1.5 4.5L15 4.5C15.8284 4.5 16.5 5.17157 16.5 6V12L16.4922 12.1533Z\"/>\n    <path d=\"M10.3711 15.9316L8.25 13.8096L6.12793 15.9316L5.06738 14.8711L7.18945 12.75L5.06738 10.6289L6.12793 9.56836L8.25 11.6895L10.3711 9.56836L11.4316 10.6289L9.31055 12.75L11.4316 14.8711L10.3711 15.9316Z\"/>\n    </svg>`,\n\n  \"toggle-row\":\n    `<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M0.00781328 13.6533C0.0846108 14.4097 0.723337 15 1.5 15L15 15L15.1533 14.9922C15.8593 14.9205 16.4205 14.3593 16.4922 13.6533L16.5 13.5V4.5L16.4922 4.34668C16.4205 3.64069 15.8593 3.07949 15.1533 3.00781L15 3L1.5 3C0.671574 3 1.24863e-06 3.67157 1.18021e-06 4.5L7.86804e-07 13.5L0.00781328 13.6533ZM15 9V13.5L1.5 13.5L1.5 9L15 9Z\"/>\n    </svg>`,\n\n  \"insert-column-before\":\n    `<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.5 0C3.67157 0 3 0.671573 3 1.5V3H4.5V1.5H9V15H4.5V13.5H3V15C3 15.7767 3.59028 16.4154 4.34668 16.4922L4.5 16.5H15L15.1533 16.4922C15.8593 16.4205 16.4205 15.8593 16.4922 15.1533L16.5 15V1.5C16.5 0.671573 15.8284 6.03989e-09 15 0H4.5ZM15 15H10.5V1.5H15V15Z\"/>\n    <path d=\"M3 7.5H0V9H3V12H4.5V9H7.5V7.5H4.5V4.5H3V7.5Z\"/>\n    </svg>`,\n\n  \"insert-column-after\":\n    `<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M13.5 0C14.3284 0 15 0.671573 15 1.5V3H13.5V1.5H9V15H13.5V13.5H15V15C15 15.7767 14.4097 16.4154 13.6533 16.4922L13.5 16.5H3L2.84668 16.4922C2.14069 16.4205 1.57949 15.8593 1.50781 15.1533L1.5 15V1.5C1.5 0.671573 2.17157 6.03989e-09 3 0H13.5ZM3 15H7.5V1.5H3V15Z\"/>\n    <path d=\"M15 7.5H18V9H15V12H13.5V9H10.5V7.5H13.5V4.5H15V7.5Z\"/>\n    </svg>`,\n\n  \"delete-column\":\n    `<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M12.1533 0.0078125C12.9097 0.0846097 13.5 0.723336 13.5 1.5V4.5H12V1.5H6V15H12V12H13.5V15C13.5 15.7767 12.9097 16.4154 12.1533 16.4922L12 16.5H6C5.22334 16.5 4.58461 15.9097 4.50781 15.1533L4.5 15V1.5C4.5 0.671573 5.17157 2.41596e-08 6 0H12L12.1533 0.0078125Z\"/>\n    <path d=\"M15.9316 6.12891L13.8105 8.24902L15.9326 10.3711L14.8711 11.4316L12.75 9.31055L10.6289 11.4316L9.56738 10.3711L11.6885 8.24902L9.56836 6.12891L10.6289 5.06836L12.75 7.18848L14.8711 5.06836L15.9316 6.12891Z\"/>\n    </svg>`,\n\n  \"toggle-column\":\n    `<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M13.6533 17.9922C14.4097 17.9154 15 17.2767 15 16.5L15 3L14.9922 2.84668C14.9205 2.14069 14.3593 1.57949 13.6533 1.50781L13.5 1.5L4.5 1.5L4.34668 1.50781C3.59028 1.58461 3 2.22334 3 3L3 16.5C3 17.2767 3.59028 17.9154 4.34668 17.9922L4.5 18L13.5 18L13.6533 17.9922ZM9 3L13.5 3L13.5 16.5L9 16.5L9 3Z\" />\n    </svg>`,\n\n  \"delete-table\":\n    `<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M18.2129 19.2305C18.0925 20.7933 16.7892 22 15.2217 22H7.77832C6.21084 22 4.90753 20.7933 4.78711 19.2305L4 9H19L18.2129 19.2305Z\"/><path d=\"M13 2C14.1046 2 15 2.89543 15 4H19C19.5523 4 20 4.44772 20 5V6C20 6.55228 19.5523 7 19 7H4C3.44772 7 3 6.55228 3 6V5C3 4.44772 3.44772 4 4 4H8C8 2.89543 8.89543 2 10 2H13Z\"/>\n    </svg>`\n};\n\nclass TableTools extends HTMLElement {\n  connectedCallback() {\n    this.tableController = new TableController(this.#editorElement);\n\n    this.#setUpButtons();\n    this.#monitorForTableSelection();\n    this.#registerKeyboardShortcuts();\n  }\n\n  disconnectedCallback() {\n    this.#unregisterKeyboardShortcuts();\n\n    this.unregisterUpdateListener?.();\n    this.unregisterUpdateListener = null;\n\n    this.removeEventListener(\"keydown\", this.#handleToolsKeydown);\n\n    this.tableController?.destroy();\n    this.tableController = null;\n  }\n\n  get #editor() {\n    return this.#editorElement.editor\n  }\n\n  get #editorElement() {\n    return this.closest(\"lexxy-editor\")\n  }\n\n  get #tableToolsButtons() {\n    return Array.from(this.querySelectorAll(\"button, details > summary\"))\n  }\n\n  #setUpButtons() {\n    this.appendChild(this.#createRowButtonsContainer());\n    this.appendChild(this.#createColumnButtonsContainer());\n\n    this.appendChild(this.#createDeleteTableButton());\n    this.addEventListener(\"keydown\", this.#handleToolsKeydown);\n  }\n\n  #createButtonsContainer(childType, setCountProperty, moreMenu) {\n    const container = createElement(\"div\", { className: `lexxy-table-control lexxy-table-control--${childType}` });\n\n    const plusButton = this.#createButton(`Add ${childType}`, { action: \"insert\", childType, direction: \"after\" }, \"+\");\n    const minusButton = this.#createButton(`Remove ${childType}`, { action: \"delete\", childType }, \"\u2212\");\n\n    const dropdown = createElement(\"details\", { className: \"lexxy-table-control__more-menu\" });\n    dropdown.setAttribute(\"name\", \"lexxy-dropdown\");\n    dropdown.tabIndex = -1;\n\n    const count = createElement(\"summary\", {}, `_ ${childType}s`);\n    setCountProperty(count);\n    dropdown.appendChild(count);\n\n    dropdown.appendChild(moreMenu);\n\n    container.appendChild(minusButton);\n    container.appendChild(dropdown);\n    container.appendChild(plusButton);\n\n    return container\n  }\n\n  #createRowButtonsContainer() {\n    return this.#createButtonsContainer(\n      \"row\",\n      (count) => { this.rowCount = count; },\n      this.#createMoreMenuSection(\"row\")\n    )\n  }\n\n  #createColumnButtonsContainer() {\n    return this.#createButtonsContainer(\n      \"column\",\n      (count) => { this.columnCount = count; },\n      this.#createMoreMenuSection(\"column\")\n    )\n  }\n\n  #createMoreMenuSection(childType) {\n    const section = createElement(\"div\", { className: \"lexxy-table-control__more-menu-details\" });\n    const addBeforeButton = this.#createButton(`Add ${childType} before`, { action: \"insert\", childType, direction: \"before\" });\n    const addAfterButton = this.#createButton(`Add ${childType} after`, { action: \"insert\", childType, direction: \"after\" });\n    const toggleStyleButton = this.#createButton(`Toggle ${childType} style`, { action: \"toggle\", childType });\n    const deleteButton = this.#createButton(`Remove ${childType}`, { action: \"delete\", childType });\n\n    section.appendChild(addBeforeButton);\n    section.appendChild(addAfterButton);\n    section.appendChild(toggleStyleButton);\n    section.appendChild(deleteButton);\n\n    return section\n  }\n\n  #createDeleteTableButton() {\n    const container = createElement(\"div\", { className: \"lexxy-table-control\" });\n\n    const deleteTableButton = this.#createButton(\"Delete this table?\", { action: \"delete\", childType: \"table\" });\n    deleteTableButton.classList.add(\"lexxy-table-control__button--delete-table\");\n\n    container.appendChild(deleteTableButton);\n\n    this.deleteContainer = container;\n\n    return container\n  }\n\n  #createButton(label, command = {}, icon = this.#icon(command)) {\n    const button = createElement(\"button\", {\n      className: \"lexxy-table-control__button\",\n      \"aria-label\": label,\n      type: \"button\"\n    });\n    button.tabIndex = -1;\n    button.innerHTML = `${icon} <span>${label}</span>`;\n\n    button.dataset.action = command.action;\n    button.dataset.childType = command.childType;\n    button.dataset.direction = command.direction;\n\n    button.addEventListener(\"click\", () => this.#executeTableCommand(command));\n\n    button.addEventListener(\"mouseover\", () => this.#handleCommandButtonHover());\n    button.addEventListener(\"focus\", () => this.#handleCommandButtonHover());\n    button.addEventListener(\"mouseout\", () => this.#handleCommandButtonHover());\n\n    return button\n  }\n\n  #registerKeyboardShortcuts() {\n    this.unregisterKeyboardShortcuts = this.#editor.registerCommand(KEY_DOWN_COMMAND, this.#handleAccessibilityShortcutKey, COMMAND_PRIORITY_HIGH);\n  }\n\n  #unregisterKeyboardShortcuts() {\n    this.unregisterKeyboardShortcuts?.();\n    this.unregisterKeyboardShortcuts = null;\n  }\n\n  #handleAccessibilityShortcutKey = (event) => {\n    if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === \"F10\") {\n      const firstButton = this.querySelector(\"button, [tabindex]:not([tabindex='-1'])\");\n      firstButton?.focus();\n    }\n  }\n\n  #handleToolsKeydown = (event) => {\n    if (event.key === \"Escape\") {\n      this.#handleEscapeKey();\n    } else {\n      handleRollingTabIndex(this.#tableToolsButtons, event);\n    }\n  }\n\n  #handleEscapeKey() {\n    const cell = this.tableController.currentCell;\n    if (!cell) return\n\n    this.#editor.update(() => {\n      cell.select();\n      this.#editor.focus();\n    });\n\n    this.#update();\n  }\n\n  async #handleCommandButtonHover() {\n    await nextFrame();\n\n    this.#clearCellStyles();\n\n    const activeElement = this.querySelector(\"button:hover, button:focus\");\n    if (!activeElement) return\n\n    const command = {\n      action: activeElement.dataset.action,\n      childType: activeElement.dataset.childType,\n      direction: activeElement.dataset.direction\n    };\n\n    let cellsToHighlight = null;\n\n    switch (command.childType) {\n      case \"row\":\n        cellsToHighlight = this.tableController.currentRowCells;\n        break\n      case \"column\":\n        cellsToHighlight = this.tableController.currentColumnCells;\n        break\n      case \"table\":\n        cellsToHighlight = this.tableController.tableRows;\n        break\n    }\n\n    if (!cellsToHighlight) return\n\n    cellsToHighlight.forEach(cell => {\n      const cellElement = this.#editor.getElementByKey(cell.getKey());\n      if (!cellElement) return\n\n      cellElement.classList.toggle(theme.tableCellHighlight, true);\n      Object.assign(cellElement.dataset, command);\n    });\n  }\n\n  #monitorForTableSelection() {\n    this.unregisterUpdateListener = this.#editor.registerUpdateListener(() => {\n      this.tableController.updateSelectedTable();\n\n      const tableNode = this.tableController.currentTableNode;\n      if (tableNode) {\n        this.#show();\n      } else {\n        this.#hide();\n      }\n    });\n  }\n\n  #executeTableCommand(command) {\n    this.tableController.executeTableCommand(command);\n    this.#update();\n  }\n\n  #show() {\n    this.style.display = \"flex\";\n    this.#update();\n  }\n\n  #hide() {\n    this.style.display = \"none\";\n    this.#clearCellStyles();\n  }\n\n  #update() {\n    this.#updateButtonsPosition();\n    this.#updateRowColumnCount();\n    this.#closeMoreMenu();\n    this.#handleCommandButtonHover();\n  }\n\n  #closeMoreMenu() {\n    this.querySelector(\"details[open]\")?.removeAttribute(\"open\");\n  }\n\n  #updateButtonsPosition() {\n    const tableNode = this.tableController.currentTableNode;\n    if (!tableNode) return\n\n    const tableElement = this.#editor.getElementByKey(tableNode.getKey());\n    if (!tableElement) return\n\n    const tableRect = tableElement.getBoundingClientRect();\n    const editorRect = this.#editorElement.getBoundingClientRect();\n\n    const relativeTop = tableRect.top - editorRect.top;\n    const relativeCenter = (tableRect.left + tableRect.right) / 2 - editorRect.left;\n    this.style.top = `${relativeTop}px`;\n    this.style.left = `${relativeCenter}px`;\n  }\n\n  #updateRowColumnCount() {\n    const tableNode = this.tableController.currentTableNode;\n    if (!tableNode) return\n\n    const tableElement = $getElementForTableNode(this.#editor, tableNode);\n    if (!tableElement) return\n\n    const rowCount = tableElement.rows;\n    const columnCount = tableElement.columns;\n\n    this.rowCount.textContent = `${rowCount} row${rowCount === 1 ? \"\" : \"s\"}`;\n    this.columnCount.textContent = `${columnCount} column${columnCount === 1 ? \"\" : \"s\"}`;\n  }\n\n  #setTableCellFocus() {\n    const cell = this.tableController.currentCell;\n    if (!cell) return\n\n    const cellElement = this.#editor.getElementByKey(cell.getKey());\n    if (!cellElement) return\n\n    cellElement.classList.add(theme.tableCellFocus);\n  }\n\n  #clearCellStyles() {\n    this.#editorElement.querySelectorAll(`.${theme.tableCellFocus}`)?.forEach(cell => {\n      cell.classList.remove(theme.tableCellFocus);\n    });\n\n    this.#editorElement.querySelectorAll(`.${theme.tableCellHighlight}`)?.forEach(cell => {\n      cell.classList.remove(theme.tableCellHighlight);\n      cell.removeAttribute(\"data-action\");\n      cell.removeAttribute(\"data-child-type\");\n      cell.removeAttribute(\"data-direction\");\n    });\n\n    this.#setTableCellFocus();\n  }\n\n  #icon(command) {\n    const { action, childType } = command;\n    const direction = (action == \"insert\" ? command.direction : null);\n    const iconId = [ action, childType, direction ].filter(Boolean).join(\"-\");\n    return TableIcons[iconId]\n  }\n}\n\ncustomElements.define(\"lexxy-table-tools\", TableTools);\n\nclass BaseSource {\n  // Template method to override\n  async buildListItems(filter = \"\") {\n    return Promise.resolve([])\n  }\n\n  // Template method to override\n  promptItemFor(listItem) {\n    return null\n  }\n\n  // Protected\n\n  buildListItemElementFor(promptItemElement) {\n    const template = promptItemElement.querySelector(\"template[type='menu']\");\n    const fragment = template.content.cloneNode(true);\n    const listItemElement = createElement(\"li\", { role: \"option\", id: generateDomId(\"prompt-item\"), tabindex: \"0\" });\n    listItemElement.classList.add(\"lexxy-prompt-menu__item\");\n    listItemElement.appendChild(fragment);\n    return listItemElement\n  }\n\n  async loadPromptItemsFromUrl(url) {\n    try {\n      const response = await fetch(url);\n      const html = await response.text();\n      const promptItems = parseHtml(html).querySelectorAll(\"lexxy-prompt-item\");\n      return Promise.resolve(Array.from(promptItems))\n    } catch (error) {\n      return Promise.reject(error)\n    }\n  }\n}\n\nclass LocalFilterSource extends BaseSource {\n  async buildListItems(filter = \"\") {\n    const promptItems = await this.fetchPromptItems();\n    return this.#buildListItemsFromPromptItems(promptItems, filter)\n  }\n\n  // Template method to override\n  async fetchPromptItems(filter) {\n    return Promise.resolve([])\n  }\n\n  promptItemFor(listItem) {\n    return this.promptItemByListItem.get(listItem)\n  }\n\n  #buildListItemsFromPromptItems(promptItems, filter) {\n    const listItems = [];\n    this.promptItemByListItem = new WeakMap();\n    promptItems.forEach((promptItem) => {\n      const searchableText = promptItem.getAttribute(\"search\");\n\n      if (!filter || filterMatches(searchableText, filter)) {\n        const listItem = this.buildListItemElementFor(promptItem);\n        this.promptItemByListItem.set(listItem, promptItem);\n        listItems.push(listItem);\n      }\n    });\n\n    return listItems\n  }\n}\n\nclass InlinePromptSource extends LocalFilterSource {\n  constructor(inlinePromptItems) {\n    super();\n    this.inlinePromptItemElements = Array.from(inlinePromptItems);\n  }\n\n  async fetchPromptItems() {\n    return Promise.resolve(this.inlinePromptItemElements)\n  }\n}\n\nclass DeferredPromptSource extends LocalFilterSource {\n  constructor(url) {\n    super();\n    this.url = url;\n\n    this.fetchPromptItems();\n  }\n\n  async fetchPromptItems() {\n    this.promptItems ??= await this.loadPromptItemsFromUrl(this.url);\n\n    return Promise.resolve(this.promptItems)\n  }\n}\n\nconst DEBOUNCE_INTERVAL = 200;\n\nclass RemoteFilterSource extends BaseSource {\n  constructor(url) {\n    super();\n\n    this.baseURL = url;\n    this.loadAndFilterListItems = debounceAsync(this.fetchFilteredListItems.bind(this), DEBOUNCE_INTERVAL);\n  }\n\n  async buildListItems(filter = \"\") {\n    return await this.loadAndFilterListItems(filter)\n  }\n\n  promptItemFor(listItem) {\n    return this.promptItemByListItem.get(listItem)\n  }\n\n  async fetchFilteredListItems(filter) {\n    const promptItems = await this.loadPromptItemsFromUrl(this.#urlFor(filter));\n    return this.#buildListItemsFromPromptItems(promptItems)\n  }\n\n  #urlFor(filter) {\n    const url = new URL(this.baseURL, window.location.origin);\n    url.searchParams.append(\"filter\", filter);\n    return url.toString()\n  }\n\n  #buildListItemsFromPromptItems(promptItems) {\n    const listItems = [];\n    this.promptItemByListItem = new WeakMap();\n\n    for (const promptItem of promptItems) {\n      const listItem = this.buildListItemElementFor(promptItem);\n      this.promptItemByListItem.set(listItem, promptItem);\n      listItems.push(listItem);\n    }\n\n    return listItems\n  }\n}\n\nconst NOTHING_FOUND_DEFAULT_MESSAGE = \"Nothing found\";\n\nclass LexicalPromptElement extends HTMLElement {\n  constructor() {\n    super();\n    this.keyListeners = [];\n  }\n\n  static observedAttributes = [ \"connected\" ]\n\n  connectedCallback() {\n    this.source = this.#createSource();\n\n    this.#addTriggerListener();\n    this.toggleAttribute(\"connected\", true);\n  }\n\n  disconnectedCallback() {\n    this.source = null;\n    this.popoverElement = null;\n  }\n\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"connected\" && this.isConnected && oldValue != null && oldValue !== newValue) {\n      requestAnimationFrame(() => this.#reconnect());\n    }\n  }\n\n  get name() {\n    return this.getAttribute(\"name\")\n  }\n\n  get trigger() {\n    return this.getAttribute(\"trigger\")\n  }\n\n  get supportsSpaceInSearches() {\n    return this.hasAttribute(\"supports-space-in-searches\")\n  }\n\n  get open() {\n    return this.popoverElement?.classList?.contains(\"lexxy-prompt-menu--visible\")\n  }\n\n  get closed() {\n    return !this.open\n  }\n\n  get #doesSpaceSelect() {\n    return !this.supportsSpaceInSearches\n  }\n\n  #createSource() {\n    const src = this.getAttribute(\"src\");\n    if (src) {\n      if (this.hasAttribute(\"remote-filtering\")) {\n        return new RemoteFilterSource(src)\n      } else {\n        return new DeferredPromptSource(src)\n      }\n    } else {\n      return new InlinePromptSource(this.querySelectorAll(\"lexxy-prompt-item\"))\n    }\n  }\n\n  #addTriggerListener() {\n    const unregister = this.#editor.registerUpdateListener(({ editorState }) => {\n      editorState.read(() => {\n        const { node, offset } = this.#selection.selectedNodeWithOffset();\n        if (!node) return\n\n        if ($isTextNode(node)) {\n          const fullText = node.getTextContent();\n          const triggerLength = this.trigger.length;\n\n          // Check if we have enough characters for the trigger\n          if (offset >= triggerLength) {\n            const textBeforeCursor = fullText.slice(offset - triggerLength, offset);\n\n            // Check if trigger is at the start of the text node (new line case) or preceded by space or newline\n            if (textBeforeCursor === this.trigger) {\n              const isAtStart = offset === triggerLength;\n\n              const charBeforeTrigger = offset > triggerLength ? fullText[offset - triggerLength - 1] : null;\n              const isPrecededBySpaceOrNewline = charBeforeTrigger === \" \" || charBeforeTrigger === \"\\n\";\n\n              if (isAtStart || isPrecededBySpaceOrNewline) {\n                unregister();\n                this.#showPopover();\n              }\n            }\n          }\n        }\n      });\n    });\n  }\n\n  #addCursorPositionListener() {\n    this.cursorPositionListener = this.#editor.registerUpdateListener(() => {\n      if (this.closed) return\n\n      this.#editor.read(() => {\n        const { node, offset } = this.#selection.selectedNodeWithOffset();\n        if (!node) return\n\n        if ($isTextNode(node) && offset > 0) {\n          const fullText = node.getTextContent();\n          const textBeforeCursor = fullText.slice(0, offset);\n          const lastTriggerIndex = textBeforeCursor.lastIndexOf(this.trigger);\n          const triggerEndIndex = lastTriggerIndex + this.trigger.length - 1;\n\n          // If trigger is not found, or cursor is at or before the trigger end position, hide popover\n          if (lastTriggerIndex === -1 || offset <= triggerEndIndex) {\n            this.#hidePopover();\n          }\n        } else {\n          // Cursor is not in a text node or at offset 0, hide popover\n          this.#hidePopover();\n        }\n      });\n    });\n  }\n\n  #removeCursorPositionListener() {\n    if (this.cursorPositionListener) {\n      this.cursorPositionListener();\n      this.cursorPositionListener = null;\n    }\n  }\n\n  get #editor() {\n    return this.#editorElement.editor\n  }\n\n  get #editorElement() {\n    return this.closest(\"lexxy-editor\")\n  }\n\n  get #selection() {\n    return this.#editorElement.selection\n  }\n\n  async #showPopover() {\n    this.popoverElement ??= await this.#buildPopover();\n    this.#resetPopoverPosition();\n    await this.#filterOptions();\n    this.popoverElement.classList.toggle(\"lexxy-prompt-menu--visible\", true);\n    this.#selectFirstOption();\n\n    this.#editorElement.addEventListener(\"keydown\", this.#handleKeydownOnPopover);\n    this.#editorElement.addEventListener(\"lexxy:change\", this.#filterOptions);\n\n    this.#registerKeyListeners();\n    this.#addCursorPositionListener();\n  }\n\n  #registerKeyListeners() {\n    // We can't use a regular keydown for Enter as Lexical handles it first\n    this.keyListeners.push(this.#editor.registerCommand(KEY_ENTER_COMMAND, this.#handleSelectedOption.bind(this), COMMAND_PRIORITY_HIGH));\n    this.keyListeners.push(this.#editor.registerCommand(KEY_TAB_COMMAND, this.#handleSelectedOption.bind(this), COMMAND_PRIORITY_HIGH));\n\n    if (this.#doesSpaceSelect) {\n      this.keyListeners.push(this.#editor.registerCommand(KEY_SPACE_COMMAND, this.#handleSelectedOption.bind(this), COMMAND_PRIORITY_HIGH));\n    }\n\n    // Register arrow keys with HIGH priority to prevent Lexical's selection handlers from running\n    this.keyListeners.push(this.#editor.registerCommand(KEY_ARROW_UP_COMMAND, this.#handleArrowUp.bind(this), COMMAND_PRIORITY_HIGH));\n    this.keyListeners.push(this.#editor.registerCommand(KEY_ARROW_DOWN_COMMAND, this.#handleArrowDown.bind(this), COMMAND_PRIORITY_HIGH));\n  }\n\n  #handleArrowUp(event) {\n    this.#moveSelectionUp();\n    event.preventDefault();\n    return true\n  }\n\n  #handleArrowDown(event) {\n    this.#moveSelectionDown();\n    event.preventDefault();\n    return true\n  }\n\n  #selectFirstOption() {\n    const firstOption = this.#listItemElements[0];\n\n    if (firstOption) {\n      this.#selectOption(firstOption);\n    }\n  }\n\n  get #listItemElements() {\n    return Array.from(this.popoverElement.querySelectorAll(\".lexxy-prompt-menu__item\"))\n  }\n\n  #selectOption(listItem) {\n    this.#clearSelection();\n    listItem.toggleAttribute(\"aria-selected\", true);\n    listItem.scrollIntoView({ block: \"nearest\", behavior: \"smooth\" });\n    listItem.focus();\n\n    // Preserve selection to prevent cursor jump\n    this.#selection.preservingSelection(() => {\n      this.#editorElement.focus();\n    });\n\n    this.#editorContentElement.setAttribute(\"aria-controls\", this.popoverElement.id);\n    this.#editorContentElement.setAttribute(\"aria-activedescendant\", listItem.id);\n    this.#editorContentElement.setAttribute(\"aria-haspopup\", \"listbox\");\n  }\n\n  #clearSelection() {\n    this.#listItemElements.forEach((item) => { item.toggleAttribute(\"aria-selected\", false); });\n    this.#editorContentElement.removeAttribute(\"aria-controls\");\n    this.#editorContentElement.removeAttribute(\"aria-activedescendant\");\n    this.#editorContentElement.removeAttribute(\"aria-haspopup\");\n  }\n\n  #positionPopover() {\n    const { x, y, fontSize } = this.#selection.cursorPosition;\n    const editorRect = this.#editorElement.getBoundingClientRect();\n    const contentRect = this.#editorContentElement.getBoundingClientRect();\n    const verticalOffset = contentRect.top - editorRect.top;\n\n    if (!this.popoverElement.hasAttribute(\"data-anchored\")) {\n      this.popoverElement.style.left = `${x}px`;\n      this.popoverElement.toggleAttribute(\"data-anchored\", true);\n    }\n\n    this.popoverElement.style.top = `${y + verticalOffset}px`;\n    this.popoverElement.style.bottom = \"auto\";\n\n    const popoverRect = this.popoverElement.getBoundingClientRect();\n    const isClippedAtBottom = popoverRect.bottom > window.innerHeight;\n\n    if (isClippedAtBottom || this.popoverElement.hasAttribute(\"data-clipped-at-bottom\")) {\n      this.popoverElement.style.top = `${y + verticalOffset - popoverRect.height - fontSize}px`;\n      this.popoverElement.style.bottom = \"auto\";\n      this.popoverElement.toggleAttribute(\"data-clipped-at-bottom\", true);\n    }\n  }\n\n  #resetPopoverPosition() {\n    this.popoverElement.removeAttribute(\"data-clipped-at-bottom\");\n    this.popoverElement.removeAttribute(\"data-anchored\");\n  }\n\n  async #hidePopover() {\n    this.#clearSelection();\n    this.popoverElement.classList.toggle(\"lexxy-prompt-menu--visible\", false);\n    this.#editorElement.removeEventListener(\"lexxy:change\", this.#filterOptions);\n    this.#editorElement.removeEventListener(\"keydown\", this.#handleKeydownOnPopover);\n\n    this.#unregisterKeyListeners();\n    this.#removeCursorPositionListener();\n\n    await nextFrame();\n    this.#addTriggerListener();\n  }\n\n  #unregisterKeyListeners() {\n    this.keyListeners.forEach((unregister) => unregister());\n    this.keyListeners = [];\n  }\n\n  #filterOptions = async () => {\n    if (this.initialPrompt) {\n      this.initialPrompt = false;\n      return\n    }\n\n    if (this.#editorContents.containsTextBackUntil(this.trigger)) {\n      await this.#showFilteredOptions();\n      await nextFrame();\n      this.#positionPopover();\n    } else {\n      this.#hidePopover();\n    }\n  }\n\n  async #showFilteredOptions() {\n    const filter = this.#editorContents.textBackUntil(this.trigger);\n    const filteredListItems = await this.source.buildListItems(filter);\n    this.popoverElement.innerHTML = \"\";\n\n    if (filteredListItems.length > 0) {\n      this.#showResults(filteredListItems);\n    } else {\n      this.#showEmptyResults();\n    }\n    this.#selectFirstOption();\n  }\n\n  #showResults(filteredListItems) {\n    this.popoverElement.classList.remove(\"lexxy-prompt-menu--empty\");\n    this.popoverElement.append(...filteredListItems);\n  }\n\n  #showEmptyResults() {\n    this.popoverElement.classList.add(\"lexxy-prompt-menu--empty\");\n    const el = createElement(\"li\", { innerHTML: this.#emptyResultsMessage });\n    el.classList.add(\"lexxy-prompt-menu__item--empty\");\n    this.popoverElement.append(el);\n  }\n\n  get #emptyResultsMessage() {\n    return this.getAttribute(\"empty-results\") || NOTHING_FOUND_DEFAULT_MESSAGE\n  }\n\n  #handleKeydownOnPopover = (event) => {\n    if (event.key === \"Escape\") {\n      this.#hidePopover();\n      this.#editorElement.focus();\n      event.stopPropagation();\n    }\n    // Arrow keys are now handled via Lexical commands with HIGH priority\n  }\n\n  #moveSelectionDown() {\n    const nextIndex = this.#selectedIndex + 1;\n    if (nextIndex < this.#listItemElements.length) this.#selectOption(this.#listItemElements[nextIndex]);\n  }\n\n  #moveSelectionUp() {\n    const previousIndex = this.#selectedIndex - 1;\n    if (previousIndex >= 0) this.#selectOption(this.#listItemElements[previousIndex]);\n  }\n\n  get #selectedIndex() {\n    return this.#listItemElements.findIndex((item) => item.hasAttribute(\"aria-selected\"))\n  }\n\n  get #selectedListItem() {\n    return this.#listItemElements[this.#selectedIndex]\n  }\n\n  #handleSelectedOption(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    this.#optionWasSelected();\n    return true\n  }\n\n  #optionWasSelected() {\n    this.#replaceTriggerWithSelectedItem();\n    this.#hidePopover();\n    this.#editorElement.focus();\n  }\n\n  #replaceTriggerWithSelectedItem() {\n    const promptItem = this.source.promptItemFor(this.#selectedListItem);\n\n    if (!promptItem) { return }\n\n    const templates = Array.from(promptItem.querySelectorAll(\"template[type='editor']\"));\n    const stringToReplace = `${this.trigger}${this.#editorContents.textBackUntil(this.trigger)}`;\n\n    if (this.hasAttribute(\"insert-editable-text\")) {\n      this.#insertTemplatesAsEditableText(templates, stringToReplace);\n    } else {\n      this.#insertTemplatesAsAttachments(templates, stringToReplace, promptItem.getAttribute(\"sgid\"));\n    }\n  }\n\n  #insertTemplatesAsEditableText(templates, stringToReplace) {\n    this.#editor.update(() => {\n      const nodes = templates.flatMap(template => this.#buildEditableTextNodes(template));\n      this.#editorContents.replaceTextBackUntil(stringToReplace, nodes);\n    });\n  }\n\n  #buildEditableTextNodes(template) {\n    return $generateNodesFromDOM(this.#editor, parseHtml(`${template.innerHTML}`))\n  }\n\n  #insertTemplatesAsAttachments(templates, stringToReplace, fallbackSgid = null) {\n    this.#editor.update(() => {\n      const attachmentNodes = this.#buildAttachmentNodes(templates, fallbackSgid);\n      const spacedAttachmentNodes = attachmentNodes.flatMap(node => [ node, this.#getSpacerTextNode() ]).slice(0, -1);\n      this.#editorContents.replaceTextBackUntil(stringToReplace, spacedAttachmentNodes);\n    });\n  }\n\n  #buildAttachmentNodes(templates, fallbackSgid = null) {\n    return templates.map(\n      template => this.#buildAttachmentNode(\n        template.innerHTML,\n        template.getAttribute(\"content-type\") || this.#defaultPromptContentType,\n        template.getAttribute(\"sgid\") || fallbackSgid\n      ))\n  }\n\n  #getSpacerTextNode() {\n    return $createTextNode(\" \")\n  }\n\n  get #defaultPromptContentType() {\n    const attachmentContentTypeNamespace = Lexxy.global.get(\"attachmentContentTypeNamespace\");\n    return `application/vnd.${attachmentContentTypeNamespace}.${this.name}`\n  }\n\n  #buildAttachmentNode(innerHtml, contentType, sgid) {\n    return new CustomActionTextAttachmentNode({ sgid, contentType, innerHtml })\n  }\n\n  get #editorContents() {\n    return this.#editorElement.contents\n  }\n\n  get #editorContentElement() {\n    return this.#editorElement.editorContentElement\n  }\n\n  async #buildPopover() {\n    const popoverContainer = createElement(\"ul\", { role: \"listbox\", id: generateDomId(\"prompt-popover\") }); // Avoiding [popover] due to not being able to position at an arbitrary X, Y position.\n    popoverContainer.classList.add(\"lexxy-prompt-menu\");\n    popoverContainer.style.position = \"absolute\";\n    popoverContainer.setAttribute(\"nonce\", getNonce());\n    popoverContainer.append(...await this.source.buildListItems());\n    popoverContainer.addEventListener(\"click\", this.#handlePopoverClick);\n    this.#editorElement.appendChild(popoverContainer);\n    return popoverContainer\n  }\n\n  #handlePopoverClick = (event) => {\n    const listItem = event.target.closest(\".lexxy-prompt-menu__item\");\n    if (listItem) {\n      this.#selectOption(listItem);\n      this.#optionWasSelected();\n    }\n  }\n\n  #reconnect() {\n    this.disconnectedCallback();\n    this.connectedCallback();\n  }\n}\n\ncustomElements.define(\"lexxy-prompt\", LexicalPromptElement);\n\nclass CodeLanguagePicker extends HTMLElement {\n  connectedCallback() {\n    this.editorElement = this.closest(\"lexxy-editor\");\n    this.editor = this.editorElement.editor;\n\n    this.#attachLanguagePicker();\n    this.#monitorForCodeBlockSelection();\n  }\n\n  #attachLanguagePicker() {\n    this.languagePickerElement = this.#createLanguagePicker();\n\n    this.languagePickerElement.addEventListener(\"change\", () => {\n      this.#updateCodeBlockLanguage(this.languagePickerElement.value);\n    });\n\n    this.languagePickerElement.setAttribute(\"nonce\", getNonce());\n    this.appendChild(this.languagePickerElement);\n  }\n\n  #createLanguagePicker() {\n    const selectElement = createElement(\"select\", { className: \"lexxy-code-language-picker\", \"aria-label\": \"Pick a language\u2026\", name: \"lexxy-code-language\" });\n\n    for (const [ value, label ] of Object.entries(this.#languages)) {\n      const option = document.createElement(\"option\");\n      option.value = value;\n      option.textContent = label;\n      selectElement.appendChild(option);\n    }\n\n    return selectElement\n  }\n\n  get #languages() {\n    const languages = { ...CODE_LANGUAGE_FRIENDLY_NAME_MAP };\n\n    if (!languages.ruby) languages.ruby = \"Ruby\";\n    if (!languages.php) languages.php = \"PHP\";\n    if (!languages.go) languages.go = \"Go\";\n    if (!languages.bash) languages.bash = \"Bash\";\n    if (!languages.json) languages.json = \"JSON\";\n    if (!languages.diff) languages.diff = \"Diff\";\n\n    const sortedEntries = Object.entries(languages)\n      .sort(([ , a ], [ , b ]) => a.localeCompare(b));\n\n    // Place the \"plain\" entry first, then the rest of language sorted alphabetically\n    const plainIndex = sortedEntries.findIndex(([ key ]) => key === \"plain\");\n    const plainEntry = sortedEntries.splice(plainIndex, 1)[0];\n    return Object.fromEntries([ plainEntry, ...sortedEntries ])\n  }\n\n  #updateCodeBlockLanguage(language) {\n    this.editor.update(() => {\n      const codeNode = this.#getCurrentCodeNode();\n\n      if (codeNode) {\n        codeNode.setLanguage(language);\n      }\n    });\n  }\n\n  #monitorForCodeBlockSelection() {\n    this.editor.registerUpdateListener(() => {\n      this.editor.getEditorState().read(() => {\n        const codeNode = this.#getCurrentCodeNode();\n\n        if (codeNode) {\n          this.#codeNodeWasSelected(codeNode);\n        } else {\n          this.#hideLanguagePicker();\n        }\n      });\n    });\n  }\n\n  #getCurrentCodeNode() {\n    const selection = $getSelection();\n\n    if (!$isRangeSelection(selection)) {\n      return null\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const parentNode = anchorNode.getParent();\n\n    if ($isCodeNode(anchorNode)) {\n      return anchorNode\n    } else if ($isCodeNode(parentNode)) {\n      return parentNode\n    }\n\n    return null\n  }\n\n  #codeNodeWasSelected(codeNode) {\n    const language = codeNode.getLanguage();\n\n    this.#updateLanguagePickerWith(language);\n    this.#showLanguagePicker();\n    this.#positionLanguagePicker(codeNode);\n  }\n\n  #updateLanguagePickerWith(language) {\n    if (this.languagePickerElement && language) {\n      const normalizedLanguage = normalizeCodeLang(language);\n      this.languagePickerElement.value = normalizedLanguage;\n    }\n  }\n\n  #positionLanguagePicker(codeNode) {\n    const codeElement = this.editor.getElementByKey(codeNode.getKey());\n    if (!codeElement) return\n\n    const codeRect = codeElement.getBoundingClientRect();\n    const editorRect = this.editorElement.getBoundingClientRect();\n    const relativeTop = codeRect.top - editorRect.top;\n    const relativeRight = editorRect.right - codeRect.right;\n\n    this.style.top = `${relativeTop}px`;\n    this.style.right = `${relativeRight}px`;\n  }\n\n  #showLanguagePicker() {\n    this.hidden = false;\n  }\n\n  #hideLanguagePicker() {\n    this.hidden = true;\n  }\n}\n\ncustomElements.define(\"lexxy-code-language-picker\", CodeLanguagePicker);\n\nclass LexxyExtension {\n  #editorElement\n\n  constructor(editorElement) {\n    this.#editorElement = editorElement;\n  }\n\n  get editorElement() {\n    return this.#editorElement\n  }\n\n  get editorConfig() {\n    return this.#editorElement.config\n  }\n\n  // optional: defaults to true\n  get enabled() {\n    return true\n  }\n\n  get lexicalExtension() {\n    return null\n  }\n\n  initializeToolbar(_lexxyToolbar) {\n\n  }\n}\n\nconst configure = Lexxy.configure;\n\nexport { ActionTextAttachmentNode, ActionTextAttachmentUploadNode, CustomActionTextAttachmentNode, LexxyExtension as Extension, HorizontalDividerNode, configure };\n", "Prism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n", "Prism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^(\\s*)[\"']|[\"']$/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n", "(function (Prism) {\n\n\t/**\n\t * Returns the placeholder for the given language id and index.\n\t *\n\t * @param {string} language\n\t * @param {string|number} index\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(language, index) {\n\t\treturn '___' + language.toUpperCase() + index + '___';\n\t}\n\n\tObject.defineProperties(Prism.languages['markup-templating'] = {}, {\n\t\tbuildPlaceholders: {\n\t\t\t/**\n\t\t\t * Tokenize all inline templating expressions matching `placeholderPattern`.\n\t\t\t *\n\t\t\t * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n\t\t\t * `true` will be replaced.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `before-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n\t\t\t * @param {(match: string) => boolean} [replaceFilter]\n\t\t\t */\n\t\t\tvalue: function (env, language, placeholderPattern, replaceFilter) {\n\t\t\t\tif (env.language !== language) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar tokenStack = env.tokenStack = [];\n\n\t\t\t\tenv.code = env.code.replace(placeholderPattern, function (match) {\n\t\t\t\t\tif (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\tvar i = tokenStack.length;\n\t\t\t\t\tvar placeholder;\n\n\t\t\t\t\t// Check for existing strings\n\t\t\t\t\twhile (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a sparse array\n\t\t\t\t\ttokenStack[i] = match;\n\n\t\t\t\t\treturn placeholder;\n\t\t\t\t});\n\n\t\t\t\t// Switch the grammar to markup\n\t\t\t\tenv.grammar = Prism.languages.markup;\n\t\t\t}\n\t\t},\n\t\ttokenizePlaceholders: {\n\t\t\t/**\n\t\t\t * Replace placeholders with proper tokens after tokenizing.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `after-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t */\n\t\t\tvalue: function (env, language) {\n\t\t\t\tif (env.language !== language || !env.tokenStack) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Switch the grammar back\n\t\t\t\tenv.grammar = Prism.languages[language];\n\n\t\t\t\tvar j = 0;\n\t\t\t\tvar keys = Object.keys(env.tokenStack);\n\n\t\t\t\tfunction walkTokens(tokens) {\n\t\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\t\t// all placeholders are replaced already\n\t\t\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = tokens[i];\n\t\t\t\t\t\tif (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n\t\t\t\t\t\t\tvar k = keys[j];\n\t\t\t\t\t\t\tvar t = env.tokenStack[k];\n\t\t\t\t\t\t\tvar s = typeof token === 'string' ? token : token.content;\n\t\t\t\t\t\t\tvar placeholder = getPlaceholder(language, k);\n\n\t\t\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\t\t++j;\n\n\t\t\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\t\t\tvar middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n\t\t\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([before]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([after]));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (token.content /* && typeof token.content !== 'string' */) {\n\t\t\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tokens;\n\t\t\t\t}\n\n\t\t\t\twalkTokens(env.tokens);\n\t\t\t}\n\t\t}\n\t});\n\n}(Prism));\n", "/**\n * Original by Samuel Flores\n *\n * Adds the following new token classes:\n *     constant, builtin, variable, symbol, regex\n */\n(function (Prism) {\n\tPrism.languages.ruby = Prism.languages.extend('clike', {\n\t\t'comment': {\n\t\t\tpattern: /#.*|^=begin\\s[\\s\\S]*?^=end/m,\n\t\t\tgreedy: true\n\t\t},\n\t\t'class-name': {\n\t\t\tpattern: /(\\b(?:class|module)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+|\\b[A-Z_]\\w*(?=\\s*\\.\\s*new\\b)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /[.\\\\]/\n\t\t\t}\n\t\t},\n\t\t'keyword': /\\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\\b/,\n\t\t'operator': /\\.{2,3}|&\\.|===|<?=>|[!=]?~|(?:&&|\\|\\||<<|>>|\\*\\*|[+\\-*/%<>!^&|=])=?|[?:]/,\n\t\t'punctuation': /[(){}[\\].,;]/,\n\t});\n\n\tPrism.languages.insertBefore('ruby', 'operator', {\n\t\t'double-colon': {\n\t\t\tpattern: /::/,\n\t\t\talias: 'punctuation'\n\t\t},\n\t});\n\n\tvar interpolation = {\n\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)#\\{(?:[^{}]|\\{[^{}]*\\})*\\}/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'content': {\n\t\t\t\tpattern: /^(#\\{)[\\s\\S]+(?=\\}$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.ruby\n\t\t\t},\n\t\t\t'delimiter': {\n\t\t\t\tpattern: /^#\\{|\\}$/,\n\t\t\t\talias: 'punctuation'\n\t\t\t}\n\t\t}\n\t};\n\n\tdelete Prism.languages.ruby.function;\n\n\tvar percentExpression = '(?:' + [\n\t\t/([^a-zA-Z0-9\\s{(\\[<=])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/.source,\n\t\t/\\((?:[^()\\\\]|\\\\[\\s\\S]|\\((?:[^()\\\\]|\\\\[\\s\\S])*\\))*\\)/.source,\n\t\t/\\{(?:[^{}\\\\]|\\\\[\\s\\S]|\\{(?:[^{}\\\\]|\\\\[\\s\\S])*\\})*\\}/.source,\n\t\t/\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S]|\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S])*\\])*\\]/.source,\n\t\t/<(?:[^<>\\\\]|\\\\[\\s\\S]|<(?:[^<>\\\\]|\\\\[\\s\\S])*>)*>/.source\n\t].join('|') + ')';\n\n\tvar symbolName = /(?:\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|(?:\\b[a-zA-Z_]\\w*|[^\\s\\0-\\x7F]+)[?!]?|\\$.)/.source;\n\n\tPrism.languages.insertBefore('ruby', 'keyword', {\n\t\t'regex-literal': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation,\n\t\t\t\t\t'regex': /[\\s\\S]+/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(^|[^/])\\/(?!\\/)(?:\\[[^\\r\\n\\]]+\\]|\\\\.|[^[/\\\\\\r\\n])+\\/[egimnosux]{0,6}(?=\\s*(?:$|[\\r\\n,.;})#]))/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation,\n\t\t\t\t\t'regex': /[\\s\\S]+/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'variable': /[@$]+[a-zA-Z_]\\w*(?:[?!]|\\b)/,\n\t\t'symbol': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(^|[^:]):/.source + symbolName),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: RegExp(/([\\r\\n{(,][ \\t]*)/.source + symbolName + /(?=:(?!:))/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t],\n\t\t'method-definition': {\n\t\t\tpattern: /(\\bdef\\s+)\\w+(?:\\s*\\.\\s*\\w+)?/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'function': /\\b\\w+$/,\n\t\t\t\t'keyword': /^self\\b/,\n\t\t\t\t'class-name': /^\\w+/,\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('ruby', 'string', {\n\t\t'string-literal': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation,\n\t\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\"|')(?:#\\{[^}]+\\}|#(?!\\{)|\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\#\\r\\n])*\\1/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation,\n\t\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /<<[-~]?([a-z_]\\w*)[\\r\\n](?:.*[\\r\\n])*?[\\t ]*\\1/i,\n\t\t\t\talias: 'heredoc-string',\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'delimiter': {\n\t\t\t\t\t\tpattern: /^<<[-~]?[a-z_]\\w*|\\b[a-z_]\\w*$/i,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'symbol': /\\b\\w+/,\n\t\t\t\t\t\t\t'punctuation': /^<<[-~]?/\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t'interpolation': interpolation,\n\t\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /<<[-~]?'([a-z_]\\w*)'[\\r\\n](?:.*[\\r\\n])*?[\\t ]*\\1/i,\n\t\t\t\talias: 'heredoc-string',\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'delimiter': {\n\t\t\t\t\t\tpattern: /^<<[-~]?'[a-z_]\\w*'|\\b[a-z_]\\w*$/i,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'symbol': /\\b\\w+/,\n\t\t\t\t\t\t\t'punctuation': /^<<[-~]?'|'$/,\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'command-literal': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/%x/.source + percentExpression),\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation,\n\t\t\t\t\t'command': {\n\t\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\t\talias: 'string'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /`(?:#\\{[^}]+\\}|#(?!\\{)|\\\\(?:\\r\\n|[\\s\\S])|[^\\\\`#\\r\\n])*`/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation,\n\t\t\t\t\t'command': {\n\t\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\t\talias: 'string'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t});\n\n\tdelete Prism.languages.ruby.string;\n\n\tPrism.languages.insertBefore('ruby', 'number', {\n\t\t'builtin': /\\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\\b/,\n\t\t'constant': /\\b[A-Z][A-Z0-9_]*(?:[?!]|\\b)/\n\t});\n\n\tPrism.languages.rb = Prism.languages.ruby;\n}(Prism));\n", "/**\n * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/\n * Modified by Miles Johnson: http://milesj.me\n * Rewritten by Tom Pavelec\n *\n * Supports PHP 5.3 - 8.0\n */\n(function (Prism) {\n\tvar comment = /\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*|#(?!\\[).*/;\n\tvar constant = [\n\t\t{\n\t\t\tpattern: /\\b(?:false|true)\\b/i,\n\t\t\talias: 'boolean'\n\t\t},\n\t\t{\n\t\t\tpattern: /(::\\s*)\\b[a-z_]\\w*\\b(?!\\s*\\()/i,\n\t\t\tgreedy: true,\n\t\t\tlookbehind: true,\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\b(?:case|const)\\s+)\\b[a-z_]\\w*(?=\\s*[;=])/i,\n\t\t\tgreedy: true,\n\t\t\tlookbehind: true,\n\t\t},\n\t\t/\\b(?:null)\\b/i,\n\t\t/\\b[A-Z_][A-Z0-9_]*\\b(?!\\s*\\()/,\n\t];\n\tvar number = /\\b0b[01]+(?:_[01]+)*\\b|\\b0o[0-7]+(?:_[0-7]+)*\\b|\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b|(?:\\b\\d+(?:_\\d+)*\\.?(?:\\d+(?:_\\d+)*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i;\n\tvar operator = /<?=>|\\?\\?=?|\\.{3}|\\??->|[!=]=?=?|::|\\*\\*=?|--|\\+\\+|&&|\\|\\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;\n\tvar punctuation = /[{}\\[\\](),:;]/;\n\n\tPrism.languages.php = {\n\t\t'delimiter': {\n\t\t\tpattern: /\\?>$|^<\\?(?:php(?=\\s)|=)?/i,\n\t\t\talias: 'important'\n\t\t},\n\t\t'comment': comment,\n\t\t'variable': /\\$+(?:\\w+\\b|(?=\\{))/,\n\t\t'package': {\n\t\t\tpattern: /(namespace\\s+|use\\s+(?:function\\s+)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /\\\\/\n\t\t\t}\n\t\t},\n\t\t'class-name-definition': {\n\t\t\tpattern: /(\\b(?:class|enum|interface|trait)\\s+)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n\t\t\tlookbehind: true,\n\t\t\talias: 'class-name'\n\t\t},\n\t\t'function-definition': {\n\t\t\tpattern: /(\\bfunction\\s+)[a-z_]\\w*(?=\\s*\\()/i,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function'\n\t\t},\n\t\t'keyword': [\n\t\t\t{\n\t\t\t\tpattern: /(\\(\\s*)\\b(?:array|bool|boolean|float|int|integer|object|string)\\b(?=\\s*\\))/i,\n\t\t\t\talias: 'type-casting',\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /([(,?]\\s*)\\b(?:array(?!\\s*\\()|bool|callable|(?:false|null)(?=\\s*\\|)|float|int|iterable|mixed|object|self|static|string)\\b(?=\\s*\\$)/i,\n\t\t\t\talias: 'type-hint',\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b(?:array(?!\\s*\\()|bool|callable|(?:false|null)(?=\\s*\\|)|float|int|iterable|mixed|never|object|self|static|string|void)\\b/i,\n\t\t\t\talias: 'return-type',\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\b(?:array(?!\\s*\\()|bool|float|int|iterable|mixed|object|string|void)\\b/i,\n\t\t\t\talias: 'type-declaration',\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\|\\s*)(?:false|null)\\b|\\b(?:false|null)(?=\\s*\\|)/i,\n\t\t\t\talias: 'type-declaration',\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\b(?:parent|self|static)(?=\\s*::)/i,\n\t\t\t\talias: 'static-context',\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\t// yield from\n\t\t\t\tpattern: /(\\byield\\s+)from\\b/i,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t// `class` is always a keyword unlike other keywords\n\t\t\t/\\bclass\\b/i,\n\t\t\t{\n\t\t\t\t// https://www.php.net/manual/en/reserved.keywords.php\n\t\t\t\t//\n\t\t\t\t// keywords cannot be preceded by \"->\"\n\t\t\t\t// the complex lookbehind means `(?<!(?:->|::)\\s*)`\n\t\t\t\tpattern: /((?:^|[^\\s>:]|(?:^|[^-])>|(?:^|[^:]):)\\s*)\\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\\b/i,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'argument-name': {\n\t\t\tpattern: /([(,]\\s*)\\b[a-z_]\\w*(?=\\s*:(?!:))/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:extends|implements|instanceof|new(?!\\s+self|\\s+static))\\s+|\\bcatch\\s*\\()\\b[a-z_]\\w*(?!\\\\)\\b/i,\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\|\\s*)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\b[a-z_]\\w*(?!\\\\)\\b(?=\\s*\\|)/i,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\|\\s*)(?:\\\\?\\b[a-z_]\\w*)+\\b/i,\n\t\t\t\talias: 'class-name-fully-qualified',\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\\\/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(?:\\\\?\\b[a-z_]\\w*)+\\b(?=\\s*\\|)/i,\n\t\t\t\talias: 'class-name-fully-qualified',\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\\\/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:extends|implements|instanceof|new(?!\\s+self\\b|\\s+static\\b))\\s+|\\bcatch\\s*\\()(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n\t\t\t\talias: 'class-name-fully-qualified',\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\\\/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\b[a-z_]\\w*(?=\\s*\\$)/i,\n\t\t\t\talias: 'type-declaration',\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n\t\t\t\talias: ['class-name-fully-qualified', 'type-declaration'],\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\\\/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\b[a-z_]\\w*(?=\\s*::)/i,\n\t\t\t\talias: 'static-context',\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*::)/i,\n\t\t\t\talias: ['class-name-fully-qualified', 'static-context'],\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\\\/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /([(,?]\\s*)[a-z_]\\w*(?=\\s*\\$)/i,\n\t\t\t\talias: 'type-hint',\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /([(,?]\\s*)(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n\t\t\t\talias: ['class-name-fully-qualified', 'type-hint'],\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\\\/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n\t\t\t\talias: 'return-type',\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n\t\t\t\talias: ['class-name-fully-qualified', 'return-type'],\n\t\t\t\tgreedy: true,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\\\/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'constant': constant,\n\t\t'function': {\n\t\t\tpattern: /(^|[^\\\\\\w])\\\\?[a-z_](?:[\\w\\\\]*\\w)?(?=\\s*\\()/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /\\\\/\n\t\t\t}\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(->\\s*)\\w+/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'number': number,\n\t\t'operator': operator,\n\t\t'punctuation': punctuation\n\t};\n\n\tvar string_interpolation = {\n\t\tpattern: /\\{\\$(?:\\{(?:\\{[^{}]+\\}|[^{}]+)\\}|[^{}])+\\}|(^|[^\\\\{])\\$+(?:\\w+(?:\\[[^\\r\\n\\[\\]]+\\]|->\\w+)?)/,\n\t\tlookbehind: true,\n\t\tinside: Prism.languages.php\n\t};\n\n\tvar string = [\n\t\t{\n\t\t\tpattern: /<<<'([^']+)'[\\r\\n](?:.*[\\r\\n])*?\\1;/,\n\t\t\talias: 'nowdoc-string',\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^<<<'[^']+'|[a-z_]\\w*;$/i,\n\t\t\t\t\talias: 'symbol',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /^<<<'?|[';]$/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /<<<(?:\"([^\"]+)\"[\\r\\n](?:.*[\\r\\n])*?\\1;|([a-z_]\\w*)[\\r\\n](?:.*[\\r\\n])*?\\2;)/i,\n\t\t\talias: 'heredoc-string',\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^<<<(?:\"[^\"]+\"|[a-z_]\\w*)|[a-z_]\\w*;$/i,\n\t\t\t\t\talias: 'symbol',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /^<<<\"?|[\";]$/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'interpolation': string_interpolation\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n\t\t\talias: 'backtick-quoted-string',\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /'(?:\\\\[\\s\\S]|[^\\\\'])*'/,\n\t\t\talias: 'single-quoted-string',\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"/,\n\t\t\talias: 'double-quoted-string',\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': string_interpolation\n\t\t\t}\n\t\t}\n\t];\n\n\tPrism.languages.insertBefore('php', 'variable', {\n\t\t'string': string,\n\t\t'attribute': {\n\t\t\tpattern: /#\\[(?:[^\"'\\/#]|\\/(?![*/])|\\/\\/.*$|#(?!\\[).*$|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*')+\\](?=\\s*[a-z$#])/im,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'attribute-content': {\n\t\t\t\t\tpattern: /^(#\\[)[\\s\\S]+(?=\\]$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t// inside can appear subset of php\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'comment': comment,\n\t\t\t\t\t\t'string': string,\n\t\t\t\t\t\t'attribute-class-name': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /([^:]|^)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n\t\t\t\t\t\t\t\talias: 'class-name',\n\t\t\t\t\t\t\t\tgreedy: true,\n\t\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /([^:]|^)(?:\\\\?\\b[a-z_]\\w*)+/i,\n\t\t\t\t\t\t\t\talias: [\n\t\t\t\t\t\t\t\t\t'class-name',\n\t\t\t\t\t\t\t\t\t'class-name-fully-qualified'\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\tgreedy: true,\n\t\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t\t\t'punctuation': /\\\\/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t'constant': constant,\n\t\t\t\t\t\t'number': number,\n\t\t\t\t\t\t'operator': operator,\n\t\t\t\t\t\t'punctuation': punctuation\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^#\\[|\\]$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t});\n\n\tPrism.hooks.add('before-tokenize', function (env) {\n\t\tif (!/<\\?/.test(env.code)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar phpPattern = /<\\?(?:[^\"'/#]|\\/(?![*/])|(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|(?:\\/\\/|#(?!\\[))(?:[^?\\n\\r]|\\?(?!>))*(?=$|\\?>|[\\r\\n])|#\\[|\\/\\*(?:[^*]|\\*(?!\\/))*(?:\\*\\/|$))*?(?:\\?>|$)/g;\n\t\tPrism.languages['markup-templating'].buildPlaceholders(env, 'php', phpPattern);\n\t});\n\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tPrism.languages['markup-templating'].tokenizePlaceholders(env, 'php');\n\t});\n\n}(Prism));\n", "Prism.languages.go = Prism.languages.extend('clike', {\n\t'string': {\n\t\tpattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|`[^`]*`/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'keyword': /\\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,\n\t'boolean': /\\b(?:_|false|iota|nil|true)\\b/,\n\t'number': [\n\t\t// binary and octal integers\n\t\t/\\b0(?:b[01_]+|o[0-7_]+)i?\\b/i,\n\t\t// hexadecimal integers and floats\n\t\t/\\b0x(?:[a-f\\d_]+(?:\\.[a-f\\d_]*)?|\\.[a-f\\d_]+)(?:p[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i,\n\t\t// decimal integers and floats\n\t\t/(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?[\\d_]+)?i?(?!\\w)/i\n\t],\n\t'operator': /[*\\/%^!=]=?|\\+[=+]?|-[=-]?|\\|[=|]?|&(?:=|&|\\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\\.\\.\\./,\n\t'builtin': /\\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\\b/\n});\n\nPrism.languages.insertBefore('go', 'string', {\n\t'char': {\n\t\tpattern: /'(?:\\\\.|[^'\\\\\\r\\n]){0,10}'/,\n\t\tgreedy: true\n\t}\n});\n\ndelete Prism.languages.go['class-name'];\n", "(function (Prism) {\n\t// $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\\n' '|'\n\t// + LC_ALL, RANDOM, REPLY, SECONDS.\n\t// + make sure PS1..4 are here as they are not always set,\n\t// - some useless things.\n\tvar envVars = '\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b';\n\n\tvar commandAfterHeredoc = {\n\t\tpattern: /(^([\"']?)\\w+\\2)[ \\t]+\\S.*/,\n\t\tlookbehind: true,\n\t\talias: 'punctuation', // this looks reasonably well in all themes\n\t\tinside: null // see below\n\t};\n\n\tvar insideString = {\n\t\t'bash': commandAfterHeredoc,\n\t\t'environment': {\n\t\t\tpattern: RegExp('\\\\$' + envVars),\n\t\t\talias: 'constant'\n\t\t},\n\t\t'variable': [\n\t\t\t// [0]: Arithmetic Environment\n\t\t\t{\n\t\t\t\tpattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t// If there is a $ sign at the beginning highlight $(( and )) as variable\n\t\t\t\t\t'variable': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t/^\\$\\(\\(/\n\t\t\t\t\t],\n\t\t\t\t\t'number': /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n\t\t\t\t\t// Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic\n\t\t\t\t\t'operator': /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n\t\t\t\t\t// If there is no $ sign at the beginning highlight (( and )) as punctuation\n\t\t\t\t\t'punctuation': /\\(\\(?|\\)\\)?|,|;/\n\t\t\t\t}\n\t\t\t},\n\t\t\t// [1]: Command Substitution\n\t\t\t{\n\t\t\t\tpattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'variable': /^\\$\\(|^`|\\)$|`$/\n\t\t\t\t}\n\t\t\t},\n\t\t\t// [2]: Brace expansion\n\t\t\t{\n\t\t\t\tpattern: /\\$\\{[^}]+\\}/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'operator': /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n\t\t\t\t\t'punctuation': /[\\[\\]]/,\n\t\t\t\t\t'environment': {\n\t\t\t\t\t\tpattern: RegExp('(\\\\{)' + envVars),\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\talias: 'constant'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t/\\$(?:\\w+|[#?*!@$])/\n\t\t],\n\t\t// Escape sequences from echo and printf's manuals, and escaped quotes.\n\t\t'entity': /\\\\(?:[abceEfnrtv\\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/\n\t};\n\n\tPrism.languages.bash = {\n\t\t'shebang': {\n\t\t\tpattern: /^#!\\s*\\/.*/,\n\t\t\talias: 'important'\n\t\t},\n\t\t'comment': {\n\t\t\tpattern: /(^|[^\"{\\\\$])#.*/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'function-name': [\n\t\t\t// a) function foo {\n\t\t\t// b) foo() {\n\t\t\t// c) function foo() {\n\t\t\t// but not \u201Cfoo {\u201D\n\t\t\t{\n\t\t\t\t// a) and c)\n\t\t\t\tpattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'function'\n\t\t\t},\n\t\t\t{\n\t\t\t\t// b)\n\t\t\t\tpattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n\t\t\t\talias: 'function'\n\t\t\t}\n\t\t],\n\t\t// Highlight variable names as variables in for and select beginnings.\n\t\t'for-or-select': {\n\t\t\tpattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n\t\t\talias: 'variable',\n\t\t\tlookbehind: true\n\t\t},\n\t\t// Highlight variable names as variables in the left-hand part\n\t\t// of assignments (\u201C=\u201D and \u201C+=\u201D).\n\t\t'assign-left': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()\\w+(?:\\.\\w+)*(?=\\+?=)/,\n\t\t\tinside: {\n\t\t\t\t'environment': {\n\t\t\t\t\tpattern: RegExp('(^|[\\\\s;|&]|[<>]\\\\()' + envVars),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'constant'\n\t\t\t\t}\n\t\t\t},\n\t\t\talias: 'variable',\n\t\t\tlookbehind: true\n\t\t},\n\t\t// Highlight parameter names as variables\n\t\t'parameter': {\n\t\t\tpattern: /(^|\\s)-{1,2}(?:\\w+:[+-]?)?\\w+(?:\\.\\w+)*(?=[=\\s]|$)/,\n\t\t\talias: 'variable',\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': [\n\t\t\t// Support for Here-documents https://en.wikipedia.org/wiki/Here_document\n\t\t\t{\n\t\t\t\tpattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: insideString\n\t\t\t},\n\t\t\t// Here-document with quotes around the tag\n\t\t\t// \u2192 No expansion (so no \u201Cinside\u201D).\n\t\t\t{\n\t\t\t\tpattern: /((?:^|[^<])<<-?\\s*)([\"'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'bash': commandAfterHeredoc\n\t\t\t\t}\n\t\t\t},\n\t\t\t// \u201CNormal\u201D string\n\t\t\t{\n\t\t\t\t// https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n\t\t\t\tpattern: /(^|[^\\\\](?:\\\\\\\\)*)\"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^\"\\\\`$])*\"/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: insideString\n\t\t\t},\n\t\t\t{\n\t\t\t\t// https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html\n\t\t\t\tpattern: /(^|[^$\\\\])'[^']*'/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\t// https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html\n\t\t\t\tpattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'entity': insideString.entity\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'environment': {\n\t\t\tpattern: RegExp('\\\\$?' + envVars),\n\t\t\talias: 'constant'\n\t\t},\n\t\t'variable': insideString.variable,\n\t\t'function': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'keyword': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t// https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n\t\t'builtin': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,\n\t\t\tlookbehind: true,\n\t\t\t// Alias added to make those easier to distinguish from strings.\n\t\t\talias: 'class-name'\n\t\t},\n\t\t'boolean': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'file-descriptor': {\n\t\t\tpattern: /\\B&\\d\\b/,\n\t\t\talias: 'important'\n\t\t},\n\t\t'operator': {\n\t\t\t// Lots of redirections here, but not just that.\n\t\t\tpattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n\t\t\tinside: {\n\t\t\t\t'file-descriptor': {\n\t\t\t\t\tpattern: /^\\d/,\n\t\t\t\t\talias: 'important'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'punctuation': /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n\t\t'number': {\n\t\t\tpattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n\t\t\tlookbehind: true\n\t\t}\n\t};\n\n\tcommandAfterHeredoc.inside = Prism.languages.bash;\n\n\t/* Patterns in command substitution. */\n\tvar toBeCopied = [\n\t\t'comment',\n\t\t'function-name',\n\t\t'for-or-select',\n\t\t'assign-left',\n\t\t'parameter',\n\t\t'string',\n\t\t'environment',\n\t\t'function',\n\t\t'keyword',\n\t\t'builtin',\n\t\t'boolean',\n\t\t'file-descriptor',\n\t\t'operator',\n\t\t'punctuation',\n\t\t'number'\n\t];\n\tvar inside = insideString.variable[1].inside;\n\tfor (var i = 0; i < toBeCopied.length; i++) {\n\t\tinside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];\n\t}\n\n\tPrism.languages.sh = Prism.languages.bash;\n\tPrism.languages.shell = Prism.languages.bash;\n}(Prism));\n", "// https://www.json.org/json-en.html\nPrism.languages.json = {\n\t'property': {\n\t\tpattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'string': {\n\t\tpattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'comment': {\n\t\tpattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\tgreedy: true\n\t},\n\t'number': /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t'punctuation': /[{}[\\],]/,\n\t'operator': /:/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'null': {\n\t\tpattern: /\\bnull\\b/,\n\t\talias: 'keyword'\n\t}\n};\n\nPrism.languages.webmanifest = Prism.languages.json;\n", "(function (Prism) {\n\n\tPrism.languages.diff = {\n\t\t'coord': [\n\t\t\t// Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n\t\t\t/^(?:\\*{3}|-{3}|\\+{3}).*$/m,\n\t\t\t// Match \"@@ ... @@\" coord lines in unified diff.\n\t\t\t/^@@.*@@$/m,\n\t\t\t// Match coord lines in normal diff (starts with a number).\n\t\t\t/^\\d.*$/m\n\t\t]\n\n\t\t// deleted, inserted, unchanged, diff\n\t};\n\n\t/**\n\t * A map from the name of a block to its line prefix.\n\t *\n\t * @type {Object<string, string>}\n\t */\n\tvar PREFIXES = {\n\t\t'deleted-sign': '-',\n\t\t'deleted-arrow': '<',\n\t\t'inserted-sign': '+',\n\t\t'inserted-arrow': '>',\n\t\t'unchanged': ' ',\n\t\t'diff': '!',\n\t};\n\n\t// add a token for each prefix\n\tObject.keys(PREFIXES).forEach(function (name) {\n\t\tvar prefix = PREFIXES[name];\n\n\t\tvar alias = [];\n\t\tif (!/^\\w+$/.test(name)) { // \"deleted-sign\" -> \"deleted\"\n\t\t\talias.push(/\\w+/.exec(name)[0]);\n\t\t}\n\t\tif (name === 'diff') {\n\t\t\talias.push('bold');\n\t\t}\n\n\t\tPrism.languages.diff[name] = {\n\t\t\tpattern: RegExp('^(?:[' + prefix + '].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+', 'm'),\n\t\t\talias: alias,\n\t\t\tinside: {\n\t\t\t\t'line': {\n\t\t\t\t\tpattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'prefix': {\n\t\t\t\t\tpattern: /[\\s\\S]/,\n\t\t\t\t\talias: /\\w+/.exec(name)[0]\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t});\n\n\t// make prefixes available to Diff plugin\n\tObject.defineProperty(Prism.languages.diff, 'PREFIXES', {\n\t\tvalue: PREFIXES\n\t});\n\n}(Prism));\n", "const {\n  entries,\n  setPrototypeOf,\n  isFrozen,\n  getPrototypeOf,\n  getOwnPropertyDescriptor,\n} = Object;\n\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== 'undefined' && Reflect;\n\nif (!freeze) {\n  freeze = function <T>(x: T): T {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function <T>(x: T): T {\n    return x;\n  };\n}\n\nif (!apply) {\n  apply = function <T>(\n    func: (thisArg: any, ...args: any[]) => T,\n    thisArg: any,\n    ...args: any[]\n  ): T {\n    return func.apply(thisArg, args);\n  };\n}\n\nif (!construct) {\n  construct = function <T>(Func: new (...args: any[]) => T, ...args: any[]): T {\n    return new Func(...args);\n  };\n}\n\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayIndexOf = unapply(Array.prototype.indexOf);\nconst arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySlice = unapply(Array.prototype.slice);\nconst arraySplice = unapply(Array.prototype.splice);\n\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\n\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\n\nconst regExpTest = unapply(RegExp.prototype.test);\n\nconst typeErrorCreate = unconstruct(TypeError);\n\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param func - The function to be wrapped and called.\n * @returns A new function that calls the given function with a specified thisArg and arguments.\n */\nfunction unapply<T>(\n  func: (thisArg: any, ...args: any[]) => T\n): (thisArg: any, ...args: any[]) => T {\n  return (thisArg: any, ...args: any[]): T => {\n    if (thisArg instanceof RegExp) {\n      thisArg.lastIndex = 0;\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param func - The constructor function to be wrapped and called.\n * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n */\nfunction unconstruct<T>(\n  Func: new (...args: any[]) => T\n): (...args: any[]) => T {\n  return (...args: any[]): T => construct(Func, args);\n}\n\n/**\n * Add properties to a lookup table\n *\n * @param set - The set to which elements will be added.\n * @param array - The array containing elements to be added to the set.\n * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns The modified set with added elements.\n */\nfunction addToSet(\n  set: Record<string, any>,\n  array: readonly any[],\n  transformCaseFunc: ReturnType<typeof unapply<string>> = stringToLowerCase\n): Record<string, any> {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  let l = array.length;\n  while (l--) {\n    let element = array[l];\n    if (typeof element === 'string') {\n      const lcElement = transformCaseFunc(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          (array as any[])[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/**\n * Clean up an array to harden against CSPP\n *\n * @param array - The array to be cleaned.\n * @returns The cleaned version of the array\n */\nfunction cleanArray<T>(array: T[]): Array<T | null> {\n  for (let index = 0; index < array.length; index++) {\n    const isPropertyExist = objectHasOwnProperty(array, index);\n\n    if (!isPropertyExist) {\n      array[index] = null;\n    }\n  }\n\n  return array;\n}\n\n/**\n * Shallow clone an object\n *\n * @param object - The object to be cloned.\n * @returns A new object that copies the original.\n */\nfunction clone<T extends Record<string, any>>(object: T): T {\n  const newObject = create(null);\n\n  for (const [property, value] of entries(object)) {\n    const isPropertyExist = objectHasOwnProperty(object, property);\n\n    if (isPropertyExist) {\n      if (Array.isArray(value)) {\n        newObject[property] = cleanArray(value);\n      } else if (\n        value &&\n        typeof value === 'object' &&\n        value.constructor === Object\n      ) {\n        newObject[property] = clone(value);\n      } else {\n        newObject[property] = value;\n      }\n    }\n  }\n\n  return newObject;\n}\n\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param object - The object to look up the getter function in its prototype chain.\n * @param prop - The property name for which to find the getter function.\n * @returns The getter function found in the prototype chain or a fallback function.\n */\nfunction lookupGetter<T extends Record<string, any>>(\n  object: T,\n  prop: string\n): ReturnType<typeof unapply<any>> | (() => null) {\n  while (object !== null) {\n    const desc = getOwnPropertyDescriptor(object, prop);\n\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n\n    object = getPrototypeOf(object);\n  }\n\n  function fallbackValue(): null {\n    return null;\n  }\n\n  return fallbackValue;\n}\n\nexport {\n  // Array\n  arrayForEach,\n  arrayIndexOf,\n  arrayLastIndexOf,\n  arrayPop,\n  arrayPush,\n  arraySlice,\n  arraySplice,\n  // Object\n  entries,\n  freeze,\n  getPrototypeOf,\n  getOwnPropertyDescriptor,\n  isFrozen,\n  setPrototypeOf,\n  seal,\n  clone,\n  create,\n  objectHasOwnProperty,\n  // RegExp\n  regExpTest,\n  // String\n  stringIndexOf,\n  stringMatch,\n  stringReplace,\n  stringToLowerCase,\n  stringToString,\n  stringTrim,\n  // Errors\n  typeErrorCreate,\n  // Other\n  lookupGetter,\n  addToSet,\n  // Reflect\n  unapply,\n  unconstruct,\n};\n", "import { freeze } from './utils.js';\n\nexport const html = freeze([\n  'a',\n  'abbr',\n  'acronym',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'bdi',\n  'bdo',\n  'big',\n  'blink',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'center',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'content',\n  'data',\n  'datalist',\n  'dd',\n  'decorator',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'element',\n  'em',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'font',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'legend',\n  'li',\n  'main',\n  'map',\n  'mark',\n  'marquee',\n  'menu',\n  'menuitem',\n  'meter',\n  'nav',\n  'nobr',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'search',\n  'section',\n  'select',\n  'shadow',\n  'slot',\n  'small',\n  'source',\n  'spacer',\n  'span',\n  'strike',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'template',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'tr',\n  'track',\n  'tt',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n] as const);\n\nexport const svg = freeze([\n  'svg',\n  'a',\n  'altglyph',\n  'altglyphdef',\n  'altglyphitem',\n  'animatecolor',\n  'animatemotion',\n  'animatetransform',\n  'circle',\n  'clippath',\n  'defs',\n  'desc',\n  'ellipse',\n  'enterkeyhint',\n  'exportparts',\n  'filter',\n  'font',\n  'g',\n  'glyph',\n  'glyphref',\n  'hkern',\n  'image',\n  'inputmode',\n  'line',\n  'lineargradient',\n  'marker',\n  'mask',\n  'metadata',\n  'mpath',\n  'part',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'radialgradient',\n  'rect',\n  'stop',\n  'style',\n  'switch',\n  'symbol',\n  'text',\n  'textpath',\n  'title',\n  'tref',\n  'tspan',\n  'view',\n  'vkern',\n] as const);\n\nexport const svgFilters = freeze([\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n] as const);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nexport const svgDisallowed = freeze([\n  'animate',\n  'color-profile',\n  'cursor',\n  'discard',\n  'font-face',\n  'font-face-format',\n  'font-face-name',\n  'font-face-src',\n  'font-face-uri',\n  'foreignobject',\n  'hatch',\n  'hatchpath',\n  'mesh',\n  'meshgradient',\n  'meshpatch',\n  'meshrow',\n  'missing-glyph',\n  'script',\n  'set',\n  'solidcolor',\n  'unknown',\n  'use',\n] as const);\n\nexport const mathMl = freeze([\n  'math',\n  'menclose',\n  'merror',\n  'mfenced',\n  'mfrac',\n  'mglyph',\n  'mi',\n  'mlabeledtr',\n  'mmultiscripts',\n  'mn',\n  'mo',\n  'mover',\n  'mpadded',\n  'mphantom',\n  'mroot',\n  'mrow',\n  'ms',\n  'mspace',\n  'msqrt',\n  'mstyle',\n  'msub',\n  'msup',\n  'msubsup',\n  'mtable',\n  'mtd',\n  'mtext',\n  'mtr',\n  'munder',\n  'munderover',\n  'mprescripts',\n] as const);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nexport const mathMlDisallowed = freeze([\n  'maction',\n  'maligngroup',\n  'malignmark',\n  'mlongdiv',\n  'mscarries',\n  'mscarry',\n  'msgroup',\n  'mstack',\n  'msline',\n  'msrow',\n  'semantics',\n  'annotation',\n  'annotation-xml',\n  'mprescripts',\n  'none',\n] as const);\n\nexport const text = freeze(['#text'] as const);\n", "import { freeze } from './utils.js';\n\nexport const html = freeze([\n  'accept',\n  'action',\n  'align',\n  'alt',\n  'autocapitalize',\n  'autocomplete',\n  'autopictureinpicture',\n  'autoplay',\n  'background',\n  'bgcolor',\n  'border',\n  'capture',\n  'cellpadding',\n  'cellspacing',\n  'checked',\n  'cite',\n  'class',\n  'clear',\n  'color',\n  'cols',\n  'colspan',\n  'controls',\n  'controlslist',\n  'coords',\n  'crossorigin',\n  'datetime',\n  'decoding',\n  'default',\n  'dir',\n  'disabled',\n  'disablepictureinpicture',\n  'disableremoteplayback',\n  'download',\n  'draggable',\n  'enctype',\n  'enterkeyhint',\n  'exportparts',\n  'face',\n  'for',\n  'headers',\n  'height',\n  'hidden',\n  'high',\n  'href',\n  'hreflang',\n  'id',\n  'inert',\n  'inputmode',\n  'integrity',\n  'ismap',\n  'kind',\n  'label',\n  'lang',\n  'list',\n  'loading',\n  'loop',\n  'low',\n  'max',\n  'maxlength',\n  'media',\n  'method',\n  'min',\n  'minlength',\n  'multiple',\n  'muted',\n  'name',\n  'nonce',\n  'noshade',\n  'novalidate',\n  'nowrap',\n  'open',\n  'optimum',\n  'part',\n  'pattern',\n  'placeholder',\n  'playsinline',\n  'popover',\n  'popovertarget',\n  'popovertargetaction',\n  'poster',\n  'preload',\n  'pubdate',\n  'radiogroup',\n  'readonly',\n  'rel',\n  'required',\n  'rev',\n  'reversed',\n  'role',\n  'rows',\n  'rowspan',\n  'spellcheck',\n  'scope',\n  'selected',\n  'shape',\n  'size',\n  'sizes',\n  'slot',\n  'span',\n  'srclang',\n  'start',\n  'src',\n  'srcset',\n  'step',\n  'style',\n  'summary',\n  'tabindex',\n  'title',\n  'translate',\n  'type',\n  'usemap',\n  'valign',\n  'value',\n  'width',\n  'wrap',\n  'xmlns',\n  'slot',\n] as const);\n\nexport const svg = freeze([\n  'accent-height',\n  'accumulate',\n  'additive',\n  'alignment-baseline',\n  'amplitude',\n  'ascent',\n  'attributename',\n  'attributetype',\n  'azimuth',\n  'basefrequency',\n  'baseline-shift',\n  'begin',\n  'bias',\n  'by',\n  'class',\n  'clip',\n  'clippathunits',\n  'clip-path',\n  'clip-rule',\n  'color',\n  'color-interpolation',\n  'color-interpolation-filters',\n  'color-profile',\n  'color-rendering',\n  'cx',\n  'cy',\n  'd',\n  'dx',\n  'dy',\n  'diffuseconstant',\n  'direction',\n  'display',\n  'divisor',\n  'dur',\n  'edgemode',\n  'elevation',\n  'end',\n  'exponent',\n  'fill',\n  'fill-opacity',\n  'fill-rule',\n  'filter',\n  'filterunits',\n  'flood-color',\n  'flood-opacity',\n  'font-family',\n  'font-size',\n  'font-size-adjust',\n  'font-stretch',\n  'font-style',\n  'font-variant',\n  'font-weight',\n  'fx',\n  'fy',\n  'g1',\n  'g2',\n  'glyph-name',\n  'glyphref',\n  'gradientunits',\n  'gradienttransform',\n  'height',\n  'href',\n  'id',\n  'image-rendering',\n  'in',\n  'in2',\n  'intercept',\n  'k',\n  'k1',\n  'k2',\n  'k3',\n  'k4',\n  'kerning',\n  'keypoints',\n  'keysplines',\n  'keytimes',\n  'lang',\n  'lengthadjust',\n  'letter-spacing',\n  'kernelmatrix',\n  'kernelunitlength',\n  'lighting-color',\n  'local',\n  'marker-end',\n  'marker-mid',\n  'marker-start',\n  'markerheight',\n  'markerunits',\n  'markerwidth',\n  'maskcontentunits',\n  'maskunits',\n  'max',\n  'mask',\n  'mask-type',\n  'media',\n  'method',\n  'mode',\n  'min',\n  'name',\n  'numoctaves',\n  'offset',\n  'operator',\n  'opacity',\n  'order',\n  'orient',\n  'orientation',\n  'origin',\n  'overflow',\n  'paint-order',\n  'path',\n  'pathlength',\n  'patterncontentunits',\n  'patterntransform',\n  'patternunits',\n  'points',\n  'preservealpha',\n  'preserveaspectratio',\n  'primitiveunits',\n  'r',\n  'rx',\n  'ry',\n  'radius',\n  'refx',\n  'refy',\n  'repeatcount',\n  'repeatdur',\n  'restart',\n  'result',\n  'rotate',\n  'scale',\n  'seed',\n  'shape-rendering',\n  'slope',\n  'specularconstant',\n  'specularexponent',\n  'spreadmethod',\n  'startoffset',\n  'stddeviation',\n  'stitchtiles',\n  'stop-color',\n  'stop-opacity',\n  'stroke-dasharray',\n  'stroke-dashoffset',\n  'stroke-linecap',\n  'stroke-linejoin',\n  'stroke-miterlimit',\n  'stroke-opacity',\n  'stroke',\n  'stroke-width',\n  'style',\n  'surfacescale',\n  'systemlanguage',\n  'tabindex',\n  'tablevalues',\n  'targetx',\n  'targety',\n  'transform',\n  'transform-origin',\n  'text-anchor',\n  'text-decoration',\n  'text-rendering',\n  'textlength',\n  'type',\n  'u1',\n  'u2',\n  'unicode',\n  'values',\n  'viewbox',\n  'visibility',\n  'version',\n  'vert-adv-y',\n  'vert-origin-x',\n  'vert-origin-y',\n  'width',\n  'word-spacing',\n  'wrap',\n  'writing-mode',\n  'xchannelselector',\n  'ychannelselector',\n  'x',\n  'x1',\n  'x2',\n  'xmlns',\n  'y',\n  'y1',\n  'y2',\n  'z',\n  'zoomandpan',\n] as const);\n\nexport const mathMl = freeze([\n  'accent',\n  'accentunder',\n  'align',\n  'bevelled',\n  'close',\n  'columnsalign',\n  'columnlines',\n  'columnspan',\n  'denomalign',\n  'depth',\n  'dir',\n  'display',\n  'displaystyle',\n  'encoding',\n  'fence',\n  'frame',\n  'height',\n  'href',\n  'id',\n  'largeop',\n  'length',\n  'linethickness',\n  'lspace',\n  'lquote',\n  'mathbackground',\n  'mathcolor',\n  'mathsize',\n  'mathvariant',\n  'maxsize',\n  'minsize',\n  'movablelimits',\n  'notation',\n  'numalign',\n  'open',\n  'rowalign',\n  'rowlines',\n  'rowspacing',\n  'rowspan',\n  'rspace',\n  'rquote',\n  'scriptlevel',\n  'scriptminsize',\n  'scriptsizemultiplier',\n  'selection',\n  'separator',\n  'separators',\n  'stretchy',\n  'subscriptshift',\n  'supscriptshift',\n  'symmetric',\n  'voffset',\n  'width',\n  'xmlns',\n]);\n\nexport const xml = freeze([\n  'xlink:href',\n  'xml:id',\n  'xlink:title',\n  'xml:space',\n  'xmlns:xlink',\n] as const);\n", "import { seal } from './utils.js';\n\n// eslint-disable-next-line unicorn/better-regex\nexport const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nexport const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nexport const TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\nexport const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\nexport const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nexport const IS_ALLOWED_URI = seal(\n  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nexport const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nexport const ATTR_WHITESPACE = seal(\n  /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nexport const DOCTYPE_NAME = seal(/^html$/i);\nexport const CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n", "/* eslint-disable @typescript-eslint/indent */\n\nimport type {\n  TrustedHTML,\n  TrustedTypesWindow,\n} from 'trusted-types/lib/index.js';\nimport type { Config, UseProfilesConfig } from './config';\nimport * as TAGS from './tags.js';\nimport * as ATTRS from './attrs.js';\nimport * as EXPRESSIONS from './regexp.js';\nimport {\n  addToSet,\n  clone,\n  entries,\n  freeze,\n  arrayForEach,\n  arrayLastIndexOf,\n  arrayPop,\n  arrayPush,\n  arraySplice,\n  stringMatch,\n  stringReplace,\n  stringToLowerCase,\n  stringToString,\n  stringIndexOf,\n  stringTrim,\n  regExpTest,\n  typeErrorCreate,\n  lookupGetter,\n  create,\n  objectHasOwnProperty,\n} from './utils.js';\n\nexport type { Config } from './config';\n\ndeclare const VERSION: string;\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n  element: 1,\n  attribute: 2,\n  text: 3,\n  cdataSection: 4,\n  entityReference: 5, // Deprecated\n  entityNode: 6, // Deprecated\n  progressingInstruction: 7,\n  comment: 8,\n  document: 9,\n  documentType: 10,\n  documentFragment: 11,\n  notation: 12, // Deprecated\n};\n\nconst getGlobal = function (): WindowLike {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param trustedTypes The policy factory.\n * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */\nconst _createTrustedTypesPolicy = function (\n  trustedTypes: TrustedTypePolicyFactory,\n  purifyHostElement: HTMLScriptElement\n) {\n  if (\n    typeof trustedTypes !== 'object' ||\n    typeof trustedTypes.createPolicy !== 'function'\n  ) {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  let suffix = null;\n  const ATTR_NAME = 'data-tt-policy-suffix';\n  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n    suffix = purifyHostElement.getAttribute(ATTR_NAME);\n  }\n\n  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML(html) {\n        return html;\n      },\n      createScriptURL(scriptUrl) {\n        return scriptUrl;\n      },\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn(\n      'TrustedTypes policy ' + policyName + ' could not be created.'\n    );\n    return null;\n  }\n};\n\nconst _createHooksMap = function (): HooksMap {\n  return {\n    afterSanitizeAttributes: [],\n    afterSanitizeElements: [],\n    afterSanitizeShadowDOM: [],\n    beforeSanitizeAttributes: [],\n    beforeSanitizeElements: [],\n    beforeSanitizeShadowDOM: [],\n    uponSanitizeAttribute: [],\n    uponSanitizeElement: [],\n    uponSanitizeShadowNode: [],\n  };\n};\n\nfunction createDOMPurify(window: WindowLike = getGlobal()): DOMPurify {\n  const DOMPurify: DOMPurify = (root: WindowLike) => createDOMPurify(root);\n\n  DOMPurify.version = VERSION;\n\n  DOMPurify.removed = [];\n\n  if (\n    !window ||\n    !window.document ||\n    window.document.nodeType !== NODE_TYPE.document ||\n    !window.Element\n  ) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  let { document } = window;\n\n  const originalDocument = document;\n  const currentScript: HTMLScriptElement =\n    originalDocument.currentScript as HTMLScriptElement;\n  const {\n    DocumentFragment,\n    HTMLTemplateElement,\n    Node,\n    Element,\n    NodeFilter,\n    NamedNodeMap = window.NamedNodeMap || (window as any).MozNamedAttrMap,\n    HTMLFormElement,\n    DOMParser,\n    trustedTypes,\n  } = window;\n\n  const ElementPrototype = Element.prototype;\n\n  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  const remove = lookupGetter(ElementPrototype, 'remove');\n  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    const template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  let trustedTypesPolicy;\n  let emptyHTML = '';\n\n  const {\n    implementation,\n    createNodeIterator,\n    createDocumentFragment,\n    getElementsByTagName,\n  } = document;\n  const { importNode } = originalDocument;\n\n  let hooks = _createHooksMap();\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported =\n    typeof entries === 'function' &&\n    typeof getParentNode === 'function' &&\n    implementation &&\n    implementation.createHTMLDocument !== undefined;\n\n  const {\n    MUSTACHE_EXPR,\n    ERB_EXPR,\n    TMPLIT_EXPR,\n    DATA_ATTR,\n    ARIA_ATTR,\n    IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE,\n    CUSTOM_ELEMENT,\n  } = EXPRESSIONS;\n\n  let { IS_ALLOWED_URI } = EXPRESSIONS;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n  let ALLOWED_TAGS = null;\n  const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n    ...TAGS.html,\n    ...TAGS.svg,\n    ...TAGS.svgFilters,\n    ...TAGS.mathMl,\n    ...TAGS.text,\n  ]);\n\n  /* Allowed attribute names */\n  let ALLOWED_ATTR = null;\n  const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n    ...ATTRS.html,\n    ...ATTRS.svg,\n    ...ATTRS.mathMl,\n    ...ATTRS.xml,\n  ]);\n\n  /*\n   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */\n  let CUSTOM_ELEMENT_HANDLING = Object.seal(\n    create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false,\n      },\n    })\n  );\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  let FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  let FORBID_ATTR = null;\n\n  /* Config object to store ADD_TAGS/ADD_ATTR functions (when used as functions) */\n  const EXTRA_ELEMENT_HANDLING = Object.seal(\n    create(null, {\n      tagCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      attributeCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n    })\n  );\n\n  /* Decide if ARIA attributes are okay */\n  let ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  let ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  let ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */\n  let ALLOW_SELF_CLOSE_IN_ATTR = true;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  let SAFE_FOR_TEMPLATES = false;\n\n  /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */\n  let SAFE_FOR_XML = true;\n\n  /* Decide if document with <html>... should be returned */\n  let WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  let SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  let FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  let RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  let RETURN_DOM_FRAGMENT = false;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  let RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */\n  let SANITIZE_DOM = true;\n\n  /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (7.3.3)\n   *   - DOM Tree Accessors (3.1.5)\n   *   - Form Element Parent-Child Relations (4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (4.8.5)\n   *   - HTMLCollection (4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */\n  let SANITIZE_NAMED_PROPS = false;\n  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n\n  /* Keep element content when removing element? */\n  let KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  let IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  let USE_PROFILES: UseProfilesConfig | false = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  let FORBID_CONTENTS = null;\n  const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n    'annotation-xml',\n    'audio',\n    'colgroup',\n    'desc',\n    'foreignobject',\n    'head',\n    'iframe',\n    'math',\n    'mi',\n    'mn',\n    'mo',\n    'ms',\n    'mtext',\n    'noembed',\n    'noframes',\n    'noscript',\n    'plaintext',\n    'script',\n    'style',\n    'svg',\n    'template',\n    'thead',\n    'title',\n    'video',\n    'xmp',\n  ]);\n\n  /* Tags that are safe for data: URIs */\n  let DATA_URI_TAGS = null;\n  const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n    'audio',\n    'video',\n    'img',\n    'source',\n    'image',\n    'track',\n  ]);\n\n  /* Attributes safe for values like \"javascript:\" */\n  let URI_SAFE_ATTRIBUTES = null;\n  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n    'alt',\n    'class',\n    'for',\n    'id',\n    'label',\n    'name',\n    'pattern',\n    'placeholder',\n    'role',\n    'summary',\n    'title',\n    'value',\n    'style',\n    'xmlns',\n  ]);\n\n  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  let NAMESPACE = HTML_NAMESPACE;\n  let IS_EMPTY_INPUT = false;\n\n  /* Allowed XHTML+XML namespaces */\n  let ALLOWED_NAMESPACES = null;\n  const DEFAULT_ALLOWED_NAMESPACES = addToSet(\n    {},\n    [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE],\n    stringToString\n  );\n\n  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n    'mi',\n    'mo',\n    'mn',\n    'ms',\n    'mtext',\n  ]);\n\n  let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);\n\n  // Certain elements are allowed in both SVG and HTML\n  // namespace. We need to specify them explicitly\n  // so that they don't get erroneously deleted from\n  // HTML namespace.\n  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n    'title',\n    'style',\n    'font',\n    'a',\n    'script',\n  ]);\n\n  /* Parsing of strict XHTML documents */\n  let PARSER_MEDIA_TYPE: null | DOMParserSupportedType = null;\n  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n  let transformCaseFunc: null | Parameters<typeof addToSet>[2] = null;\n\n  /* Keep a reference to config to pass to hooks */\n  let CONFIG: Config | null = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  const formElement = document.createElement('form');\n\n  const isRegexOrFunction = function (\n    testValue: unknown\n  ): testValue is Function | RegExp {\n    return testValue instanceof RegExp || testValue instanceof Function;\n  };\n\n  /**\n   * _parseConfig\n   *\n   * @param cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  const _parseConfig = function (cfg: Config = {}): void {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || typeof cfg !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1\n        ? DEFAULT_PARSER_MEDIA_TYPE\n        : cfg.PARSER_MEDIA_TYPE;\n\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc =\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml'\n        ? stringToString\n        : stringToLowerCase;\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS')\n      ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc)\n      : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR')\n      ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc)\n      : DEFAULT_ALLOWED_ATTR;\n    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES')\n      ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString)\n      : DEFAULT_ALLOWED_NAMESPACES;\n    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR')\n      ? addToSet(\n          clone(DEFAULT_URI_SAFE_ATTRIBUTES),\n          cfg.ADD_URI_SAFE_ATTR,\n          transformCaseFunc\n        )\n      : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS')\n      ? addToSet(\n          clone(DEFAULT_DATA_URI_TAGS),\n          cfg.ADD_DATA_URI_TAGS,\n          transformCaseFunc\n        )\n      : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS')\n      ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc)\n      : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS')\n      ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc)\n      : clone({});\n    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR')\n      ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc)\n      : clone({});\n    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES')\n      ? cfg.USE_PROFILES\n      : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI = cfg.ALLOWED_URI_REGEXP || EXPRESSIONS.IS_ALLOWED_URI;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n    MATHML_TEXT_INTEGRATION_POINTS =\n      cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n    HTML_INTEGRATION_POINTS =\n      cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n\n    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)\n    ) {\n      CUSTOM_ELEMENT_HANDLING.tagNameCheck =\n        cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n    }\n\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)\n    ) {\n      CUSTOM_ELEMENT_HANDLING.attributeNameCheck =\n        cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n    }\n\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements ===\n        'boolean'\n    ) {\n      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements =\n        cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n    }\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, TAGS.text);\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, TAGS.html);\n        addToSet(ALLOWED_ATTR, ATTRS.html);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svgFilters);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, TAGS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (typeof cfg.ADD_TAGS === 'function') {\n        EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;\n      } else {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (typeof cfg.ADD_ATTR === 'function') {\n        EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;\n      } else {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n    }\n\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n    }\n\n    if (cfg.ADD_FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    if (cfg.TRUSTED_TYPES_POLICY) {\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n        throw typeErrorCreate(\n          'TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.'\n        );\n      }\n\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n        throw typeErrorCreate(\n          'TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.'\n        );\n      }\n\n      // Overwrite existing TrustedTypes policy.\n      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n\n      // Sign local variables required by `sanitize`.\n      emptyHTML = trustedTypesPolicy.createHTML('');\n    } else {\n      // Uninitialized policy, attempt to initialize the internal dompurify policy.\n      if (trustedTypesPolicy === undefined) {\n        trustedTypesPolicy = _createTrustedTypesPolicy(\n          trustedTypes,\n          currentScript\n        );\n      }\n\n      // If creating the internal policy succeeded sign internal variables.\n      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      }\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  const ALL_SVG_TAGS = addToSet({}, [\n    ...TAGS.svg,\n    ...TAGS.svgFilters,\n    ...TAGS.svgDisallowed,\n  ]);\n  const ALL_MATHML_TAGS = addToSet({}, [\n    ...TAGS.mathMl,\n    ...TAGS.mathMlDisallowed,\n  ]);\n\n  /**\n   * @param element a DOM element whose namespace is being checked\n   * @returns Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  const _checkValidNamespace = function (element: Element): boolean {\n    let parent = getParentNode(element);\n\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: NAMESPACE,\n        tagName: 'template',\n      };\n    }\n\n    const tagName = stringToLowerCase(element.tagName);\n    const parentTagName = stringToLowerCase(parent.tagName);\n\n    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n      return false;\n    }\n\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n\n      // The only way to switch from MathML to SVG is via`\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return (\n          tagName === 'svg' &&\n          (parentTagName === 'annotation-xml' ||\n            MATHML_TEXT_INTEGRATION_POINTS[parentTagName])\n        );\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (\n        parent.namespaceURI === SVG_NAMESPACE &&\n        !HTML_INTEGRATION_POINTS[parentTagName]\n      ) {\n        return false;\n      }\n\n      if (\n        parent.namespaceURI === MATHML_NAMESPACE &&\n        !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]\n      ) {\n        return false;\n      }\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return (\n        !ALL_MATHML_TAGS[tagName] &&\n        (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName])\n      );\n    }\n\n    // For XHTML and XML documents that support custom namespaces\n    if (\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml' &&\n      ALLOWED_NAMESPACES[element.namespaceURI]\n    ) {\n      return true;\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n    // Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param node a DOM node\n   */\n  const _forceRemove = function (node: Node): void {\n    arrayPush(DOMPurify.removed, { element: node });\n\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      getParentNode(node).removeChild(node);\n    } catch (_) {\n      remove(node);\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param name an Attribute name\n   * @param element a DOM node\n   */\n  const _removeAttribute = function (name: string, element: Element): void {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: element.getAttributeNode(name),\n        from: element,\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: element,\n      });\n    }\n\n    element.removeAttribute(name);\n\n    // We void attribute values for unremovable \"is\" attributes\n    if (name === 'is') {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(element);\n        } catch (_) {}\n      } else {\n        try {\n          element.setAttribute(name, '');\n        } catch (_) {}\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param dirty - a string of dirty markup\n   * @return a DOM, filled with the dirty markup\n   */\n  const _initDocument = function (dirty: string): Document {\n    /* Create a HTML document */\n    let doc = null;\n    let leadingWhitespace = null;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    if (\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml' &&\n      NAMESPACE === HTML_NAMESPACE\n    ) {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty =\n        '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' +\n        dirty +\n        '</body></html>';\n    }\n\n    const dirtyPayload = trustedTypesPolicy\n      ? trustedTypesPolicy.createHTML(dirty)\n      : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) {}\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT\n          ? emptyHTML\n          : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n\n    const body = doc.body || doc.documentElement;\n\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(\n        document.createTextNode(leadingWhitespace),\n        body.childNodes[0] || null\n      );\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(\n        doc,\n        WHOLE_DOCUMENT ? 'html' : 'body'\n      )[0];\n    }\n\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param root The root element or node to start traversing on.\n   * @return The created NodeIterator\n   */\n  const _createNodeIterator = function (root: Node): NodeIterator {\n    return createNodeIterator.call(\n      root.ownerDocument || root,\n      root,\n      // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT |\n        NodeFilter.SHOW_COMMENT |\n        NodeFilter.SHOW_TEXT |\n        NodeFilter.SHOW_PROCESSING_INSTRUCTION |\n        NodeFilter.SHOW_CDATA_SECTION,\n      null\n    );\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param element element to check for clobbering attacks\n   * @return true if clobbered, false if safe\n   */\n  const _isClobbered = function (element: Element): boolean {\n    return (\n      element instanceof HTMLFormElement &&\n      (typeof element.nodeName !== 'string' ||\n        typeof element.textContent !== 'string' ||\n        typeof element.removeChild !== 'function' ||\n        !(element.attributes instanceof NamedNodeMap) ||\n        typeof element.removeAttribute !== 'function' ||\n        typeof element.setAttribute !== 'function' ||\n        typeof element.namespaceURI !== 'string' ||\n        typeof element.insertBefore !== 'function' ||\n        typeof element.hasChildNodes !== 'function')\n    );\n  };\n\n  /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param value object to check whether it's a DOM node\n   * @return true is object is a DOM node\n   */\n  const _isNode = function (value: unknown): value is Node {\n    return typeof Node === 'function' && value instanceof Node;\n  };\n\n  function _executeHooks<T extends HookFunction>(\n    hooks: HookFunction[],\n    currentNode: Parameters<T>[0],\n    data: Parameters<T>[1]\n  ): void {\n    arrayForEach(hooks, (hook: T) => {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  }\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   * @param currentNode to check for permission to exist\n   * @return true if node was killed, false if left alive\n   */\n  const _sanitizeElements = function (currentNode: any): boolean {\n    let content = null;\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    const tagName = transformCaseFunc(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.uponSanitizeElement, currentNode, {\n      tagName,\n      allowedTags: ALLOWED_TAGS,\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (\n      SAFE_FOR_XML &&\n      currentNode.hasChildNodes() &&\n      !_isNode(currentNode.firstElementChild) &&\n      regExpTest(/<[/\\w!]/g, currentNode.innerHTML) &&\n      regExpTest(/<[/\\w!]/g, currentNode.textContent)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove any occurrence of processing instructions */\n    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove any kind of possibly harmful comments */\n    if (\n      SAFE_FOR_XML &&\n      currentNode.nodeType === NODE_TYPE.comment &&\n      regExpTest(/<[/\\w]/g, currentNode.data)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (\n      !(\n        EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function &&\n        EXTRA_ELEMENT_HANDLING.tagCheck(tagName)\n      ) &&\n      (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])\n    ) {\n      /* Check if we have a custom element to handle */\n      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n        if (\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n          regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)\n        ) {\n          return false;\n        }\n\n        if (\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)\n        ) {\n          return false;\n        }\n      }\n\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n        if (childNodes && parentNode) {\n          const childCount = childNodes.length;\n\n          for (let i = childCount - 1; i >= 0; --i) {\n            const childClone = cloneNode(childNodes[i], true);\n            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n            parentNode.insertBefore(childClone, getNextSibling(currentNode));\n          }\n        }\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Make sure that older browsers don't get fallback-tag mXSS */\n    if (\n      (tagName === 'noscript' ||\n        tagName === 'noembed' ||\n        tagName === 'noframes') &&\n      regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr: RegExp) => {\n        content = stringReplace(content, expr, ' ');\n      });\n\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param lcTag Lowercase tag name of containing element.\n   * @param lcName Lowercase attribute name.\n   * @param value Attribute value.\n   * @return Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  const _isValidAttribute = function (\n    lcTag: string,\n    lcName: string,\n    value: string\n  ): boolean {\n    /* Make sure attribute cannot clobber */\n    if (\n      SANITIZE_DOM &&\n      (lcName === 'id' || lcName === 'name') &&\n      (value in document || value in formElement)\n    ) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (\n      ALLOW_DATA_ATTR &&\n      !FORBID_ATTR[lcName] &&\n      regExpTest(DATA_ATTR, lcName)\n    ) {\n      // This attribute is safe\n    } else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) {\n      // This attribute is safe\n      /* Check if ADD_ATTR function allows this attribute */\n    } else if (\n      EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function &&\n      EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)\n    ) {\n      // This attribute is safe\n      /* Otherwise, check the name is permitted */\n    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      if (\n        // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        (_isBasicCustomElement(lcTag) &&\n          ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag)) ||\n            (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))) &&\n          ((CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName)) ||\n            (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)))) ||\n        // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        (lcName === 'is' &&\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements &&\n          ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value)) ||\n            (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))))\n      ) {\n        // If user has supplied a regexp or function in CUSTOM_ELEMENT_HANDLING.tagNameCheck, we need to also allow derived custom elements using the same tagName test.\n        // Additionally, we need to allow attributes passing the CUSTOM_ELEMENT_HANDLING.attributeNameCheck user has configured, as custom elements can define these at their own discretion.\n      } else {\n        return false;\n      }\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) {\n      // This attribute is safe\n      /* Check no script, data or unknown possibly unsafe URI\n        unless we know URI values are safe for that attribute */\n    } else if (\n      regExpTest(IS_ALLOWED_URI, stringReplace(value, ATTR_WHITESPACE, ''))\n    ) {\n      // This attribute is safe\n      /* Keep image data URIs alive if src/xlink:href is allowed */\n      /* Further prevent gadget XSS for dynamically built script tags */\n    } else if (\n      (lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') &&\n      lcTag !== 'script' &&\n      stringIndexOf(value, 'data:') === 0 &&\n      DATA_URI_TAGS[lcTag]\n    ) {\n      // This attribute is safe\n      /* Allow unknown protocols: This provides support for links that\n        are handled by protocol handlers which may be unknown ahead of\n        time, e.g. fb:, spotify: */\n    } else if (\n      ALLOW_UNKNOWN_PROTOCOLS &&\n      !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))\n    ) {\n      // This attribute is safe\n      /* Check for binary attributes */\n    } else if (value) {\n      return false;\n    } else {\n      // Binary attributes are safe at this point\n      /* Anything else, presume unsafe, do not add it back */\n    }\n\n    return true;\n  };\n\n  /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param tagName name of the tag of the node to sanitize\n   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */\n  const _isBasicCustomElement = function (tagName: string): RegExpMatchArray {\n    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param currentNode to sanitize\n   */\n  const _sanitizeAttributes = function (currentNode: Element): void {\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n\n    const { attributes } = currentNode;\n\n    /* Check if we have attributes; if not we might have a text node */\n    if (!attributes || _isClobbered(currentNode)) {\n      return;\n    }\n\n    const hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR,\n      forceKeepAttr: undefined,\n    };\n    let l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      const attr = attributes[l];\n      const { name, namespaceURI, value: attrValue } = attr;\n      const lcName = transformCaseFunc(name);\n\n      const initValue = attrValue;\n      let value = name === 'value' ? initValue : stringTrim(initValue);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n      value = hookEvent.attrValue;\n\n      /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */\n      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n        // Remove the attribute with this value\n        _removeAttribute(name, currentNode);\n\n        // Prefix the value and later re-create the attribute with the sanitized value\n        value = SANITIZE_NAMED_PROPS_PREFIX + value;\n      }\n\n      /* Work around a security issue with comments inside attributes */\n      if (\n        SAFE_FOR_XML &&\n        regExpTest(/((--!?|])>)|<\\/(style|title|textarea)/i, value)\n      ) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Make sure we cannot easily use animated hrefs, even if animations are allowed */\n      if (lcName === 'attributename' && stringMatch(value, 'href')) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr: RegExp) => {\n          value = stringReplace(value, expr, ' ');\n        });\n      }\n\n      /* Is `value` valid for this attribute? */\n      const lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Handle attributes that require Trusted Types */\n      if (\n        trustedTypesPolicy &&\n        typeof trustedTypes === 'object' &&\n        typeof trustedTypes.getAttributeType === 'function'\n      ) {\n        if (namespaceURI) {\n          /* Namespaces are not yet supported, see https://bugs.chromium.org/p/chromium/issues/detail?id=1305293 */\n        } else {\n          switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n            case 'TrustedHTML': {\n              value = trustedTypesPolicy.createHTML(value);\n              break;\n            }\n\n            case 'TrustedScriptURL': {\n              value = trustedTypesPolicy.createScriptURL(value);\n              break;\n            }\n\n            default: {\n              break;\n            }\n          }\n        }\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      if (value !== initValue) {\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n          } else {\n            arrayPop(DOMPurify.removed);\n          }\n        } catch (_) {\n          _removeAttribute(name, currentNode);\n        }\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param fragment to iterate over recursively\n   */\n  const _sanitizeShadowDOM = function (fragment: DocumentFragment): void {\n    let shadowNode = null;\n    const shadowIterator = _createNodeIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n\n    while ((shadowNode = shadowIterator.nextNode())) {\n      /* Execute a hook if present */\n      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n\n      /* Sanitize tags and elements */\n      _sanitizeElements(shadowNode);\n\n      /* Check attributes next */\n      _sanitizeAttributes(shadowNode);\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n  };\n\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg = {}) {\n    let body = null;\n    let importedNode = null;\n    let currentNode = null;\n    let returnNode = null;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      if (typeof dirty.toString === 'function') {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      } else {\n        throw typeErrorCreate('toString is not a function');\n      }\n    }\n\n    /* Return dirty HTML if DOMPurify cannot run */\n    if (!DOMPurify.isSupported) {\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) {\n      /* Do some early pre-sanitization to avoid unsafe root nodes */\n      if ((dirty as Node).nodeName) {\n        const tagName = transformCaseFunc((dirty as Node).nodeName);\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          throw typeErrorCreate(\n            'root node is forbidden and cannot be sanitized in-place'\n          );\n        }\n      }\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (\n        importedNode.nodeType === NODE_TYPE.element &&\n        importedNode.nodeName === 'BODY'\n      ) {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (\n        !RETURN_DOM &&\n        !SAFE_FOR_TEMPLATES &&\n        !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1\n      ) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE\n          ? trustedTypesPolicy.createHTML(dirty)\n          : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while ((currentNode = nodeIterator.nextNode())) {\n      /* Sanitize tags and elements */\n      _sanitizeElements(currentNode);\n\n      /* Check attributes next */\n      _sanitizeAttributes(currentNode);\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n    }\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Serialize doctype if allowed */\n    if (\n      WHOLE_DOCUMENT &&\n      ALLOWED_TAGS['!doctype'] &&\n      body.ownerDocument &&\n      body.ownerDocument.doctype &&\n      body.ownerDocument.doctype.name &&\n      regExpTest(EXPRESSIONS.DOCTYPE_NAME, body.ownerDocument.doctype.name)\n    ) {\n      serializedHTML =\n        '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n    }\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr: RegExp) => {\n        serializedHTML = stringReplace(serializedHTML, expr, ' ');\n      });\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE\n      ? trustedTypesPolicy.createHTML(serializedHTML)\n      : serializedHTML;\n  };\n\n  DOMPurify.setConfig = function (cfg = {}) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    const lcTag = transformCaseFunc(tag);\n    const lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  DOMPurify.addHook = function (\n    entryPoint: keyof HooksMap,\n    hookFunction: HookFunction\n  ) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  DOMPurify.removeHook = function (\n    entryPoint: keyof HooksMap,\n    hookFunction: HookFunction\n  ) {\n    if (hookFunction !== undefined) {\n      const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n\n      return index === -1\n        ? undefined\n        : arraySplice(hooks[entryPoint], index, 1)[0];\n    }\n\n    return arrayPop(hooks[entryPoint]);\n  };\n\n  DOMPurify.removeHooks = function (entryPoint: keyof HooksMap) {\n    hooks[entryPoint] = [];\n  };\n\n  DOMPurify.removeAllHooks = function () {\n    hooks = _createHooksMap();\n  };\n\n  return DOMPurify;\n}\n\nexport default createDOMPurify();\n\nexport interface DOMPurify {\n  /**\n   * Creates a DOMPurify instance using the given window-like object. Defaults to `window`.\n   */\n  (root?: WindowLike): DOMPurify;\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  version: string;\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  removed: Array<RemovedElement | RemovedAttribute>;\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  isSupported: boolean;\n\n  /**\n   * Set the configuration once.\n   *\n   * @param cfg configuration object\n   */\n  setConfig(cfg?: Config): void;\n\n  /**\n   * Removes the configuration.\n   */\n  clearConfig(): void;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized TrustedHTML.\n   */\n  sanitize(\n    dirty: string | Node,\n    cfg: Config & { RETURN_TRUSTED_TYPE: true }\n  ): TrustedHTML;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty DOM node\n   * @param cfg object\n   * @returns Sanitized DOM node.\n   */\n  sanitize(dirty: Node, cfg: Config & { IN_PLACE: true }): Node;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized DOM node.\n   */\n  sanitize(dirty: string | Node, cfg: Config & { RETURN_DOM: true }): Node;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized document fragment.\n   */\n  sanitize(\n    dirty: string | Node,\n    cfg: Config & { RETURN_DOM_FRAGMENT: true }\n  ): DocumentFragment;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized string.\n   */\n  sanitize(dirty: string | Node, cfg?: Config): string;\n\n  /**\n   * Checks if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   *\n   * @param tag Tag name of containing element.\n   * @param attr Attribute name.\n   * @param value Attribute value.\n   * @returns Returns true if `value` is valid. Otherwise, returns false.\n   */\n  isValidAttribute(tag: string, attr: string, value: string): boolean;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(entryPoint: BasicHookName, hookFunction: NodeHook): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(entryPoint: ElementHookName, hookFunction: ElementHook): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(\n    entryPoint: DocumentFragmentHookName,\n    hookFunction: DocumentFragmentHook\n  ): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(\n    entryPoint: 'uponSanitizeElement',\n    hookFunction: UponSanitizeElementHook\n  ): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(\n    entryPoint: 'uponSanitizeAttribute',\n    hookFunction: UponSanitizeAttributeHook\n  ): void;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: BasicHookName,\n    hookFunction?: NodeHook\n  ): NodeHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: ElementHookName,\n    hookFunction?: ElementHook\n  ): ElementHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: DocumentFragmentHookName,\n    hookFunction?: DocumentFragmentHook\n  ): DocumentFragmentHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: 'uponSanitizeElement',\n    hookFunction?: UponSanitizeElementHook\n  ): UponSanitizeElementHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: 'uponSanitizeAttribute',\n    hookFunction?: UponSanitizeAttributeHook\n  ): UponSanitizeAttributeHook | undefined;\n\n  /**\n   * Removes all DOMPurify hooks at a given entryPoint\n   *\n   * @param entryPoint entry point for the hooks to remove\n   */\n  removeHooks(entryPoint: HookName): void;\n\n  /**\n   * Removes all DOMPurify hooks.\n   */\n  removeAllHooks(): void;\n}\n\n/**\n * An element removed by DOMPurify.\n */\nexport interface RemovedElement {\n  /**\n   * The element that was removed.\n   */\n  element: Node;\n}\n\n/**\n * An element removed by DOMPurify.\n */\nexport interface RemovedAttribute {\n  /**\n   * The attribute that was removed.\n   */\n  attribute: Attr | null;\n\n  /**\n   * The element that the attribute was removed.\n   */\n  from: Node;\n}\n\ntype BasicHookName =\n  | 'beforeSanitizeElements'\n  | 'afterSanitizeElements'\n  | 'uponSanitizeShadowNode';\ntype ElementHookName = 'beforeSanitizeAttributes' | 'afterSanitizeAttributes';\ntype DocumentFragmentHookName =\n  | 'beforeSanitizeShadowDOM'\n  | 'afterSanitizeShadowDOM';\ntype UponSanitizeElementHookName = 'uponSanitizeElement';\ntype UponSanitizeAttributeHookName = 'uponSanitizeAttribute';\n\ninterface HooksMap {\n  beforeSanitizeElements: NodeHook[];\n  afterSanitizeElements: NodeHook[];\n  beforeSanitizeShadowDOM: DocumentFragmentHook[];\n  uponSanitizeShadowNode: NodeHook[];\n  afterSanitizeShadowDOM: DocumentFragmentHook[];\n  beforeSanitizeAttributes: ElementHook[];\n  afterSanitizeAttributes: ElementHook[];\n  uponSanitizeElement: UponSanitizeElementHook[];\n  uponSanitizeAttribute: UponSanitizeAttributeHook[];\n}\n\ntype ArrayElement<T> = T extends Array<infer U> ? U : never;\n\ntype HookFunction = ArrayElement<HooksMap[keyof HooksMap]>;\n\nexport type HookName =\n  | BasicHookName\n  | ElementHookName\n  | DocumentFragmentHookName\n  | UponSanitizeElementHookName\n  | UponSanitizeAttributeHookName;\n\nexport type NodeHook = (\n  this: DOMPurify,\n  currentNode: Node,\n  hookEvent: null,\n  config: Config\n) => void;\n\nexport type ElementHook = (\n  this: DOMPurify,\n  currentNode: Element,\n  hookEvent: null,\n  config: Config\n) => void;\n\nexport type DocumentFragmentHook = (\n  this: DOMPurify,\n  currentNode: DocumentFragment,\n  hookEvent: null,\n  config: Config\n) => void;\n\nexport type UponSanitizeElementHook = (\n  this: DOMPurify,\n  currentNode: Node,\n  hookEvent: UponSanitizeElementHookEvent,\n  config: Config\n) => void;\n\nexport type UponSanitizeAttributeHook = (\n  this: DOMPurify,\n  currentNode: Element,\n  hookEvent: UponSanitizeAttributeHookEvent,\n  config: Config\n) => void;\n\nexport interface UponSanitizeElementHookEvent {\n  tagName: string;\n  allowedTags: Record<string, boolean>;\n}\n\nexport interface UponSanitizeAttributeHookEvent {\n  attrName: string;\n  attrValue: string;\n  keepAttr: boolean;\n  allowedAttributes: Record<string, boolean>;\n  forceKeepAttr: boolean | undefined;\n}\n\n/**\n * A `Window`-like object containing the properties and types that DOMPurify requires.\n */\nexport type WindowLike = Pick<\n  typeof globalThis,\n  | 'DocumentFragment'\n  | 'HTMLTemplateElement'\n  | 'Node'\n  | 'Element'\n  | 'NodeFilter'\n  | 'NamedNodeMap'\n  | 'HTMLFormElement'\n  | 'DOMParser'\n> & {\n  document?: Document;\n  MozNamedAttrMap?: typeof window.NamedNodeMap;\n} & Pick<TrustedTypesWindow, 'trustedTypes'>;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isTextNode, $getEditor, $isRootNode, $isElementNode, $getNodeByKey, $getPreviousSelection, $createTextNode, $isRangeSelection, $getSelection, $caretRangeFromSelection, $isTokenOrSegmented, $getCharacterOffsets, $cloneWithPropertiesEphemeral, $createRangeSelection, $findMatchingParent, INTERNAL_$isBlock, $setSelection, $caretFromPoint, $isExtendableTextPointCaret, $extendCaretToRange, $isChildCaret, $isDecoratorNode, $isRootOrShadowRoot, $hasAncestor, $isLeafNode } from 'lexical';\nexport { $cloneWithProperties, $selectAll } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (_e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Gets the computed DOM styles of the element.\n * @param element - The node to check the styles for.\n * @returns the computed styles of the element or null if there is no DOM element or no default view for the document.\n */\nfunction $getComputedStyleForElement(element) {\n  const editor = $getEditor();\n  const domElement = editor.getElementByKey(element.getKey());\n  if (domElement === null) {\n    return null;\n  }\n  const view = domElement.ownerDocument.defaultView;\n  if (view === null) {\n    return null;\n  }\n  return view.getComputedStyle(domElement);\n}\n\n/**\n * Gets the computed DOM styles of the parent of the node.\n * @param node - The node to check its parent's styles for.\n * @returns the computed styles of the node or null if there is no DOM element or no default view for the document.\n */\nfunction $getComputedStyleForParent(node) {\n  const parent = $isRootNode(node) ? node : node.getParentOrThrow();\n  return $getComputedStyleForElement(parent);\n}\n\n/**\n * Determines whether a node's parent is RTL.\n * @param node - The node to check whether it is RTL.\n * @returns whether the node is RTL.\n */\nfunction $isParentRTL(node) {\n  const styles = $getComputedStyleForParent(node);\n  return styles !== null && styles.direction === 'rtl';\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @param mutates - 'clone' to return a clone before mutating, 'self' to update in-place\n * @returns The updated TextNode or clone.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode, mutates = 'self') {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !$isTokenOrSegmented(textNode) && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      // NOTE: This mutates __text directly because the primary use case is to\n      // modify a $cloneWithProperties node that should never be added\n      // to the EditorState so we must not call getWritable via setTextContent\n      const text = textNode.__text.slice(startOffset, endOffset);\n      if (text !== textNode.__text) {\n        if (mutates === 'clone') {\n          textNode = $cloneWithPropertiesEphemeral(textNode);\n        }\n        textNode.__text = text;\n      }\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!$isElementNode(node)) {\n    formatDevErrorMessage(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = $getNodeByKey(key);\n        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\n/**\n * Applies the provided styles to the given TextNode, ElementNode, or\n * collapsed RangeSelection.\n *\n * @param target - The TextNode, ElementNode, or collapsed RangeSelection to apply the styles to\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyle(target, patch) {\n  if (!($isRangeSelection(target) ? target.isCollapsed() : $isTextNode(target) || $isElementNode(target))) {\n    formatDevErrorMessage(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);\n  }\n  const prevStyles = getStyleObjectFromCSS($isRangeSelection(target) ? target.style : $isTextNode(target) ? target.getStyle() : target.getTextStyle());\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  });\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  if ($isRangeSelection(target) || $isTextNode(target)) {\n    target.setStyle(newCSSText);\n  } else {\n    target.setTextStyle(newCSSText);\n  }\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    const emptyNode = selection.anchor.getNode();\n    if ($isElementNode(emptyNode) && emptyNode.isEmpty()) {\n      $patchStyle(emptyNode, patch);\n    }\n  }\n  $forEachSelectedTextNode(textNode => {\n    $patchStyle(textNode, patch);\n  });\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = $getSelection();\n  if (!selection) {\n    return;\n  }\n  const slicedTextNodes = new Map();\n  const getSliceIndices = node => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];\n  if ($isRangeSelection(selection)) {\n    for (const slice of $caretRangeFromSelection(selection).getTextSlices()) {\n      if (slice) {\n        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());\n      }\n    }\n  }\n  const selectedNodes = selection.getNodes();\n  for (const selectedNode of selectedNodes) {\n    if (!($isTextNode(selectedNode) && selectedNode.canHaveFormat())) {\n      continue;\n    }\n    const [startOffset, endOffset] = getSliceIndices(selectedNode);\n    // No actual text is selected, so do nothing.\n    if (endOffset === startOffset) {\n      continue;\n    }\n\n    // The entire node is selected or a token/segment, so just format it\n    if ($isTokenOrSegmented(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {\n      fn(selectedNode);\n    } else {\n      // The node is partially selected, so split it into two or three nodes\n      // and style the selected one.\n      const splitNodes = selectedNode.splitText(startOffset, endOffset);\n      const replacement = splitNodes[startOffset === 0 ? 0 : 1];\n      fn(replacement);\n    }\n  }\n  // Prior to NodeCaret #7046 this would have been a side-effect\n  // so we do this for test compatibility.\n  // TODO: we may want to consider simplifying by removing this\n  if ($isRangeSelection(selection) && selection.anchor.type === 'text' && selection.focus.type === 'text' && selection.anchor.key === selection.focus.key) {\n    $ensureForwardRangeSelection(selection);\n  }\n}\n\n/**\n * Ensure that the given RangeSelection is not backwards. If it\n * is backwards, then the anchor and focus points will be swapped\n * in-place. Ensuring that the selection is a writable RangeSelection\n * is the responsibility of the caller (e.g. in a read-only context\n * you will want to clone $getSelection() before using this).\n *\n * @param selection a writable RangeSelection\n */\nfunction $ensureForwardRangeSelection(selection) {\n  if (selection.isBackward()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    // stash for the in-place swap\n    const {\n      key,\n      offset,\n      type\n    } = anchor;\n    anchor.set(focus.key, focus.offset, focus.type);\n    focus.set(key, offset, type);\n  }\n}\n\nfunction $copyBlockFormatIndent(srcNode, destNode) {\n  const format = srcNode.getFormatType();\n  const indent = srcNode.getIndent();\n  if (format !== destNode.getFormatType()) {\n    destNode.setFormat(format);\n  }\n  if (indent !== destNode.getIndent()) {\n    destNode.setIndent(indent);\n  }\n}\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param $createElement - The function that creates the node. eg. $createParagraphNode.\n * @param $afterCreateElement - The function that updates the new node based on the previous one ($copyBlockFormatIndent by default)\n */\nfunction $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {\n  if (selection === null) {\n    return;\n  }\n  // Selections tend to not include their containing blocks so we effectively\n  // expand it here\n  const anchorAndFocus = selection.getStartEndPoints();\n  const blockMap = new Map();\n  let newSelection = null;\n  if (anchorAndFocus) {\n    const [anchor, focus] = anchorAndFocus;\n    newSelection = $createRangeSelection();\n    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);\n    newSelection.focus.set(focus.key, focus.offset, focus.type);\n    const anchorBlock = $findMatchingParent(anchor.getNode(), INTERNAL_$isBlock);\n    const focusBlock = $findMatchingParent(focus.getNode(), INTERNAL_$isBlock);\n    if ($isElementNode(anchorBlock)) {\n      blockMap.set(anchorBlock.getKey(), anchorBlock);\n    }\n    if ($isElementNode(focusBlock)) {\n      blockMap.set(focusBlock.getKey(), focusBlock);\n    }\n  }\n  for (const node of selection.getNodes()) {\n    if ($isElementNode(node) && INTERNAL_$isBlock(node)) {\n      blockMap.set(node.getKey(), node);\n    } else if (anchorAndFocus === null) {\n      const ancestorBlock = $findMatchingParent(node, INTERNAL_$isBlock);\n      if ($isElementNode(ancestorBlock)) {\n        blockMap.set(ancestorBlock.getKey(), ancestorBlock);\n      }\n    }\n  }\n  for (const [key, prevNode] of blockMap) {\n    const element = $createElement();\n    $afterCreateElement(prevNode, element);\n    prevNode.replace(element, true);\n    if (newSelection) {\n      if (key === newSelection.anchor.key) {\n        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);\n      }\n      if (key === newSelection.focus.key) {\n        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);\n      }\n    }\n  }\n  if (newSelection && selection.is($getSelection())) {\n    $setSelection(newSelection);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated In favor of $setBlockTypes\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && $isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!$isElementNode(node)) {\n        formatDevErrorMessage(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = $getPreviousSelection();\n  if ($isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Tests if the selection's parent element has vertical writing mode.\n * @param selection - The selection whose parent to test.\n * @returns true if the selection's parent has vertical writing mode (writing-mode: vertical-rl), false otherwise.\n */\nfunction $isEditorVerticalOrientation(selection) {\n  const computedStyle = $getComputedStyle(selection);\n  return computedStyle !== null && computedStyle.writingMode === 'vertical-rl';\n}\n\n/**\n * Gets the computed DOM styles of the parent of the selection's anchor node.\n * @param selection - The selection to check the styles for.\n * @returns the computed styles of the node or null if there is no DOM element or no default view for the document.\n */\nfunction $getComputedStyle(selection) {\n  const anchorNode = selection.anchor.getNode();\n  if ($isElementNode(anchorNode)) {\n    return $getComputedStyleForElement(anchorNode);\n  }\n  return $getComputedStyleForParent(anchorNode);\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical writing mode, we adjust the direction for correct caret movement\n  let adjustedIsBackward = isVertical ? !isBackward : isBackward;\n\n  // In right-to-left writing mode, we invert the direction for correct caret movement\n  if ($isParentElementRTL(selection)) {\n    adjustedIsBackward = !adjustedIsBackward;\n  }\n  const focusCaret = $caretFromPoint(selection.focus, adjustedIsBackward ? 'previous' : 'next');\n  if ($isExtendableTextPointCaret(focusCaret)) {\n    return false;\n  }\n  for (const nextCaret of $extendCaretToRange(focusCaret)) {\n    if ($isChildCaret(nextCaret)) {\n      return !nextCaret.origin.isInline();\n    } else if ($isElementNode(nextCaret.origin)) {\n      continue;\n    } else if ($isDecoratorNode(nextCaret.origin)) {\n      return true;\n    }\n    break;\n  }\n  return false;\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const computedStyle = $getComputedStyle(selection);\n  return computedStyle !== null && computedStyle.direction === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical-rl writing mode, arrow key directions need to be flipped\n  // to match the visual flow of text (top to bottom, right to left)\n  let adjustedIsBackward;\n  if (isVertical) {\n    // In vertical-rl mode, we need to completely invert the direction\n    // Left arrow (backward) should move down (forward)\n    // Right arrow (forward) should move up (backward)\n    adjustedIsBackward = !isBackward;\n  } else if (isRTL) {\n    // In horizontal RTL mode, use the standard RTL behavior\n    adjustedIsBackward = !isBackward;\n  } else {\n    // Standard LTR horizontal text\n    adjustedIsBackward = isBackward;\n  }\n\n  // Apply the direction adjustment to move the caret\n  $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ($isRangeSelection(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\nexport { $addNodeStyle, $copyBlockFormatIndent, $ensureForwardRangeSelection, $forEachSelectedTextNode, $getComputedStyleForElement, $getComputedStyleForParent, $getSelectionStyleValueForProperty, $isAtNodeEnd, $isParentElementRTL, $isParentRTL, $moveCaretSelection, $moveCharacter, $patchStyleText, $setBlocksType, $shouldOverrideDefaultCharacterSelection, $sliceSelectedTextNodeContent, $trimTextContentFromAnchor, $wrapNodes, createDOMRange, createRectsFromDOMRange, getCSSFromStyleObject, getStyleObjectFromCSS, trimTextContentFromAnchor };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && IS_APPLE && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\nconst DOM_DOCUMENT_TYPE = 9;\nconst DOM_DOCUMENT_FRAGMENT_TYPE = 11;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_LOWERCASE = 1 << 8;\nconst IS_UPPERCASE = 1 << 9;\nconst IS_CAPITALIZE = 1 << 10;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  capitalize: IS_CAPITALIZE,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  lowercase: IS_LOWERCASE,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE,\n  uppercase: IS_UPPERCASE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\nconst NODE_STATE_KEY = '$';\nconst PROTOTYPE_CONFIG_METHOD = '$config';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  const isBR = dom.nodeName === 'BR';\n  const lexicalLineBreak = target.__lexicalLineBreak;\n  return lexicalLineBreak && (dom === lexicalLineBreak || isBR && dom.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom, editor) !== undefined;\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction $handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(getWindow(editor));\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return isDOMTextNode(targetDOM) && targetNode.isAttached();\n}\nfunction $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {\n  for (let dom = startingDOM; dom && !isDOMUnmanaged(dom); dom = getParentElement(dom)) {\n    const key = getNodeKeyFromDOMNode(dom, editor);\n    if (key !== undefined) {\n      const node = $getNodeByKey(key, editorState);\n      if (node) {\n        // All decorator nodes are unmanaged\n        return $isDecoratorNode(node) || !isHTMLElement(dom) ? undefined : [dom, node];\n      }\n    } else if (dom === rootElement) {\n      return [rootElement, internalGetRoot(editorState)];\n    }\n  }\n}\nfunction flushMutations(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditorSync(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);\n        if (!pair) {\n          continue;\n        }\n        const [nodeDOM, targetNode] = pair;\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (\n          // TODO there is an edge case here if a mutation happens too quickly\n          //      after text input, it may never be handled since we do not\n          //      track the ignored mutations in any way\n          shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            $handleTextMutation(targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {\n              if (IS_FIREFOX) {\n                const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              badDOMTargets.set(nodeDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [nodeDOM, targetNode] of badDOMTargets) {\n          targetNode.reconcileObservedMutation(nodeDOM, editor);\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    flushMutations(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    flushMutations(editor, mutations, observer);\n  });\n}\n\n/**\n * Get the value type (V) from a StateConfig\n */\n\n/**\n * Get the key type (K) from a StateConfig\n */\n\n/**\n * A value type, or an updater for that value type. For use with\n * {@link $setState} or any user-defined wrappers around it.\n */\n\n/**\n * A type alias to make it easier to define setter methods on your node class\n *\n * @example\n * ```ts\n * const fooState = createState(\"foo\", { parse: ... });\n * class MyClass extends TextNode {\n *   // ...\n *   setFoo(valueOrUpdater: StateValueOrUpdater<typeof fooState>): this {\n *     return $setState(this, fooState, valueOrUpdater);\n *   }\n * }\n * ```\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * The NodeState JSON produced by this LexicalNode\n */\n\n/**\n * Configure a value to be used with StateConfig.\n *\n * The value type should be inferred from the definition of parse.\n *\n * If the value type is not JSON serializable, then unparse must also be provided.\n *\n * Values should be treated as immutable, much like React.useState. Mutating\n * stored values directly will cause unpredictable behavior, is not supported,\n * and may trigger errors in the future.\n *\n * @example\n * ```ts\n * const numberOrNullState = createState('numberOrNull', {parse: (v) => typeof v === 'number' ? v : null});\n * //    ^? State<'numberOrNull', StateValueConfig<number | null>>\n * const numberState = createState('number', {parse: (v) => typeof v === 'number' ? v : 0});\n * //    ^? State<'number', StateValueConfig<number>>\n * ```\n *\n * Only the parse option is required, it is generally not useful to\n * override `unparse` or `isEqual`. However, if you are using\n * non-primitive types such as Array, Object, Date, or something\n * more exotic then you would want to override this. In these\n * cases you might want to reach for third party libraries.\n *\n * @example\n * ```ts\n * const isoDateState = createState('isoDate', {\n *   parse: (v): null | Date => {\n *     const date = typeof v === 'string' ? new Date(v) : null;\n *     return date && !isNaN(date.valueOf()) ? date : null;\n *   }\n *   isEqual: (a, b) => a === b || (a && b && a.valueOf() === b.valueOf()),\n *   unparse: (v) => v && v.toString()\n * });\n * ```\n *\n * You may find it easier to write a parse function using libraries like\n * zod, valibot, ajv, Effect, TypeBox, etc. perhaps with a wrapper function.\n */\n\n/**\n * The return value of {@link createState}, for use with\n * {@link $getState} and {@link $setState}.\n */\nclass StateConfig {\n  /** The string key used when serializing this state to JSON */\n  key;\n  /** The parse function from the StateValueConfig passed to createState */\n  parse;\n  /**\n   * The unparse function from the StateValueConfig passed to createState,\n   * with a default that is simply a pass-through that assumes the value is\n   * JSON serializable.\n   */\n  unparse;\n  /**\n   * An equality function from the StateValueConfig, with a default of\n   * Object.is.\n   */\n  isEqual;\n  /**\n   * The result of `stateValueConfig.parse(undefined)`, which is computed only\n   * once and used as the default value. When the current value `isEqual` to\n   * the `defaultValue`, it will not be serialized to JSON.\n   */\n  defaultValue;\n  constructor(key, stateValueConfig) {\n    this.key = key;\n    this.parse = stateValueConfig.parse.bind(stateValueConfig);\n    this.unparse = (stateValueConfig.unparse || coerceToJSON).bind(stateValueConfig);\n    this.isEqual = (stateValueConfig.isEqual || Object.is).bind(stateValueConfig);\n    this.defaultValue = this.parse(undefined);\n  }\n}\n\n/**\n * For advanced use cases, using this type is not recommended unless\n * it is required (due to TypeScript's lack of features like\n * higher-kinded types).\n *\n * A {@link StateConfig} type with any key and any value that can be\n * used in situations where the key and value type can not be known,\n * such as in a generic constraint when working with a collection of\n * StateConfig.\n *\n * {@link StateConfigKey} and {@link StateConfigValue} will be\n * useful when this is used as a generic constraint.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Create a StateConfig for the given string key and StateValueConfig.\n *\n * The key must be locally unique. In dev you will get a key collision error\n * when you use two separate StateConfig on the same node with the same key.\n *\n * The returned StateConfig value should be used with {@link $getState} and\n * {@link $setState}.\n *\n * @param key The key to use\n * @param valueConfig Configuration for the value type\n * @returns a StateConfig\n *\n * @__NO_SIDE_EFFECTS__\n */\nfunction createState(key, valueConfig) {\n  return new StateConfig(key, valueConfig);\n}\n\n/**\n * The accessor for working with node state. This will read the value for the\n * state on the given node, and will return `stateConfig.defaultValue` if the\n * state has never been set on this node.\n *\n * The `version` parameter is optional and should generally be `'latest'`,\n * consistent with the behavior of other node methods and functions,\n * but for certain use cases such as `updateDOM` you may have a need to\n * use `'direct'` to read the state from a previous version of the node.\n *\n * For very advanced use cases, you can expect that 'direct' does not\n * require an editor state, just like directly accessing other properties\n * of a node without an accessor (e.g. `textNode.__text`).\n *\n * @param node Any LexicalNode\n * @param stateConfig The configuration of the state to read\n * @param version The default value 'latest' will read the latest version of the node state, 'direct' will read the version that is stored on this LexicalNode which not reflect the version used in the current editor state\n * @returns The current value from the state, or the default value provided by the configuration.\n */\nfunction $getState(node, stateConfig, version = 'latest') {\n  const latestOrDirectNode = version === 'latest' ? node.getLatest() : node;\n  const state = latestOrDirectNode.__state;\n  if (state) {\n    $checkCollision(node, stateConfig, state);\n    return state.getValue(stateConfig);\n  }\n  return stateConfig.defaultValue;\n}\n\n/**\n * Given two versions of a node and a stateConfig, compare their state values\n * using `$getState(nodeVersion, stateConfig, 'direct')`.\n * If the values are equal according to `stateConfig.isEqual`, return `null`,\n * otherwise return `[value, prevValue]`.\n *\n * This is useful for implementing updateDOM. Note that the `'direct'`\n * version argument is used for both nodes.\n *\n * @param node Any LexicalNode\n * @param prevNode A previous version of node\n * @param stateConfig The configuration of the state to read\n * @returns `[value, prevValue]` if changed, otherwise `null`\n */\nfunction $getStateChange(node, prevNode, stateConfig) {\n  const value = $getState(node, stateConfig, 'direct');\n  const prevValue = $getState(prevNode, stateConfig, 'direct');\n  return stateConfig.isEqual(value, prevValue) ? null : [value, prevValue];\n}\n\n/**\n * Set the state defined by stateConfig on node. Like with `React.useState`\n * you may directly specify the value or use an updater function that will\n * be called with the previous value of the state on that node (which will\n * be the `stateConfig.defaultValue` if not set).\n *\n * When an updater function is used, the node will only be marked dirty if\n * `stateConfig.isEqual(prevValue, value)` is false.\n *\n * @example\n * ```ts\n * const toggle = createState('toggle', {parse: Boolean});\n * // set it direction\n * $setState(node, counterState, true);\n * // use an updater\n * $setState(node, counterState, (prev) => !prev);\n * ```\n *\n * @param node The LexicalNode to set the state on\n * @param stateConfig The configuration for this state\n * @param valueOrUpdater The value or updater function\n * @returns node\n */\nfunction $setState(node, stateConfig, valueOrUpdater) {\n  errorOnReadOnly();\n  let value;\n  if (typeof valueOrUpdater === 'function') {\n    const latest = node.getLatest();\n    const prevValue = $getState(latest, stateConfig);\n    value = valueOrUpdater(prevValue);\n    if (stateConfig.isEqual(prevValue, value)) {\n      return latest;\n    }\n  } else {\n    value = valueOrUpdater;\n  }\n  const writable = node.getWritable();\n  const state = $getWritableNodeState(writable);\n  $checkCollision(node, stateConfig, state);\n  state.updateFromKnown(stateConfig, value);\n  return writable;\n}\n\n/**\n * @internal\n *\n * Register the config to this node's sharedConfigMap and throw an exception in\n * `true` when a collision is detected.\n */\nfunction $checkCollision(node, stateConfig, state) {\n  {\n    const collision = state.sharedNodeState.sharedConfigMap.get(stateConfig.key);\n    if (collision !== undefined && collision !== stateConfig) {\n      {\n        formatDevErrorMessage(`$setState: State key collision ${JSON.stringify(stateConfig.key)} detected in ${node.constructor.name} node with type ${node.getType()} and key ${node.getKey()}. Only one StateConfig with a given key should be used on a node.`);\n      }\n    }\n  }\n}\n\n/**\n * @internal\n *\n * Opaque state to be stored on the editor's RegisterNode for use by NodeState\n */\n\n/**\n * @internal\n *\n * Create the state to store on RegisteredNode\n */\nfunction createSharedNodeState(nodeConfig) {\n  const sharedConfigMap = new Map();\n  const flatKeys = new Set();\n  for (let klass = typeof nodeConfig === 'function' ? nodeConfig : nodeConfig.replace; klass.prototype && klass.prototype.getType !== undefined; klass = Object.getPrototypeOf(klass)) {\n    const {\n      ownNodeConfig\n    } = getStaticNodeConfig(klass);\n    if (ownNodeConfig && ownNodeConfig.stateConfigs) {\n      for (const requiredStateConfig of ownNodeConfig.stateConfigs) {\n        let stateConfig;\n        if ('stateConfig' in requiredStateConfig) {\n          stateConfig = requiredStateConfig.stateConfig;\n          if (requiredStateConfig.flat) {\n            flatKeys.add(stateConfig.key);\n          }\n        } else {\n          stateConfig = requiredStateConfig;\n        }\n        sharedConfigMap.set(stateConfig.key, stateConfig);\n      }\n    }\n  }\n  return {\n    flatKeys,\n    sharedConfigMap\n  };\n}\n\n/**\n * @internal\n *\n * A Map of string keys to state configurations to be shared across nodes\n * and/or node versions.\n */\n\n/**\n * @internal\n */\nclass NodeState {\n  /**\n   * @internal\n   *\n   * Track the (versioned) node that this NodeState was created for, to\n   * facilitate copy-on-write for NodeState. When a LexicalNode is cloned,\n   * it will *reference* the NodeState from its prevNode. From the nextNode\n   * you can continue to read state without copying, but the first $setState\n   * will trigger a copy of the prevNode's NodeState with the node property\n   * updated.\n   */\n  node;\n\n  /**\n   * @internal\n   *\n   * State that has already been parsed in a get state, so it is safe. (can be returned with\n   * just a cast since the proof was given before).\n   *\n   * Note that it uses StateConfig, so in addition to (1) the CURRENT VALUE, it has access to\n   * (2) the State key (3) the DEFAULT VALUE and (4) the PARSE FUNCTION\n   */\n  knownState;\n\n  /**\n   * @internal\n   *\n   * A copy of serializedNode[NODE_STATE_KEY] that is made when JSON is\n   * imported but has not been parsed yet.\n   *\n   * It stays here until a get state requires us to parse it, and since we\n   * then know the value is safe we move it to knownState.\n   *\n   * Note that since only string keys are used here, we can only allow this\n   * state to pass-through on export or on the next version since there is\n   * no known value configuration. This pass-through is to support scenarios\n   * where multiple versions of the editor code are working in parallel so\n   * an old version of your code doesnt erase metadata that was\n   * set by a newer version of your code.\n   */\n  unknownState;\n\n  /**\n   * @internal\n   *\n   * This sharedNodeState is preserved across all instances of a given\n   * node type in an editor and remains writable. It is how keys are resolved\n   * to configuration.\n   */\n  sharedNodeState;\n  /**\n   * @internal\n   *\n   * The count of known or unknown keys in this state, ignoring the\n   * intersection between the two sets.\n   */\n  size;\n\n  /**\n   * @internal\n   */\n  constructor(node, sharedNodeState, unknownState = undefined, knownState = new Map(), size = undefined) {\n    this.node = node;\n    this.sharedNodeState = sharedNodeState;\n    this.unknownState = unknownState;\n    this.knownState = knownState;\n    const {\n      sharedConfigMap\n    } = this.sharedNodeState;\n    const computedSize = size !== undefined ? size : computeSize(sharedConfigMap, unknownState, knownState);\n    {\n      if (!(size === undefined || computedSize === size)) {\n        formatDevErrorMessage(`NodeState: size != computedSize (${String(size)} != ${String(computedSize)})`);\n      }\n      for (const stateConfig of knownState.keys()) {\n        if (!sharedConfigMap.has(stateConfig.key)) {\n          formatDevErrorMessage(`NodeState: sharedConfigMap missing knownState key ${stateConfig.key}`);\n        }\n      }\n    }\n    this.size = computedSize;\n  }\n\n  /**\n   * @internal\n   *\n   * Get the value from knownState, or parse it from unknownState\n   * if it contains the given key.\n   *\n   * Updates the sharedConfigMap when no known state is found.\n   * Updates unknownState and knownState when an unknownState is parsed.\n   */\n  getValue(stateConfig) {\n    const known = this.knownState.get(stateConfig);\n    if (known !== undefined) {\n      return known;\n    }\n    this.sharedNodeState.sharedConfigMap.set(stateConfig.key, stateConfig);\n    let parsed = stateConfig.defaultValue;\n    if (this.unknownState && stateConfig.key in this.unknownState) {\n      const jsonValue = this.unknownState[stateConfig.key];\n      if (jsonValue !== undefined) {\n        parsed = stateConfig.parse(jsonValue);\n      }\n      // Only update if the key was unknown\n      this.updateFromKnown(stateConfig, parsed);\n    }\n    return parsed;\n  }\n\n  /**\n   * @internal\n   *\n   * Used only for advanced use cases, such as collab. The intent here is to\n   * allow you to diff states with a more stable interface than the properties\n   * of this class.\n   */\n  getInternalState() {\n    return [this.unknownState, this.knownState];\n  }\n\n  /**\n   * Encode this NodeState to JSON in the format that its node expects.\n   * This returns `{[NODE_STATE_KEY]?: UnknownStateRecord}` rather than\n   * `UnknownStateRecord | undefined` so that we can support flattening\n   * specific entries in the future when nodes can declare what\n   * their required StateConfigs are.\n   */\n  toJSON() {\n    const state = {\n      ...this.unknownState\n    };\n    const flatState = {};\n    for (const [stateConfig, v] of this.knownState) {\n      if (stateConfig.isEqual(v, stateConfig.defaultValue)) {\n        delete state[stateConfig.key];\n      } else {\n        state[stateConfig.key] = stateConfig.unparse(v);\n      }\n    }\n    for (const key of this.sharedNodeState.flatKeys) {\n      if (key in state) {\n        flatState[key] = state[key];\n        delete state[key];\n      }\n    }\n    if (undefinedIfEmpty(state)) {\n      flatState[NODE_STATE_KEY] = state;\n    }\n    return flatState;\n  }\n\n  /**\n   * @internal\n   *\n   * A NodeState is writable when the node to update matches\n   * the node associated with the NodeState. This basically\n   * mirrors how the EditorState NodeMap works, but in a\n   * bottom-up organization rather than a top-down organization.\n   *\n   * This allows us to implement the same \"copy on write\"\n   * pattern for state, without having the state version\n   * update every time the node version changes (e.g. when\n   * its parent or siblings change).\n   *\n   * @param node The node to associate with the state\n   * @returns The next writable state\n   */\n  getWritable(node) {\n    if (this.node === node) {\n      return this;\n    }\n    const {\n      sharedNodeState,\n      unknownState\n    } = this;\n    const nextKnownState = new Map(this.knownState);\n    return new NodeState(node, sharedNodeState, parseAndPruneNextUnknownState(sharedNodeState.sharedConfigMap, nextKnownState, unknownState), nextKnownState, this.size);\n  }\n\n  /** @internal */\n  updateFromKnown(stateConfig, value) {\n    const key = stateConfig.key;\n    this.sharedNodeState.sharedConfigMap.set(key, stateConfig);\n    const {\n      knownState,\n      unknownState\n    } = this;\n    if (!(knownState.has(stateConfig) || unknownState && key in unknownState)) {\n      if (unknownState) {\n        delete unknownState[key];\n        this.unknownState = undefinedIfEmpty(unknownState);\n      }\n      this.size++;\n    }\n    knownState.set(stateConfig, value);\n  }\n\n  /**\n   * @internal\n   *\n   * This is intended for advanced use cases only, such\n   * as collab or dev tools.\n   *\n   * Update a single key value pair from unknown state,\n   * parsing it if the key is known to this node. This is\n   * basically like updateFromJSON, but the effect is\n   * isolated to a single entry.\n   *\n   * @param k The string key from an UnknownStateRecord\n   * @param v The unknown value from an UnknownStateRecord\n   */\n  updateFromUnknown(k, v) {\n    const stateConfig = this.sharedNodeState.sharedConfigMap.get(k);\n    if (stateConfig) {\n      this.updateFromKnown(stateConfig, stateConfig.parse(v));\n    } else {\n      this.unknownState = this.unknownState || {};\n      if (!(k in this.unknownState)) {\n        this.size++;\n      }\n      this.unknownState[k] = v;\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Reset all existing state to default or empty values,\n   * and perform any updates from the given unknownState.\n   *\n   * This is used when initializing a node's state from JSON,\n   * or when resetting a node's state from JSON.\n   *\n   * @param unknownState The new state in serialized form\n   */\n  updateFromJSON(unknownState) {\n    const {\n      knownState\n    } = this;\n    // Reset all known state to defaults\n    for (const stateConfig of knownState.keys()) {\n      knownState.set(stateConfig, stateConfig.defaultValue);\n    }\n    // Since we are resetting all state to this new record,\n    // the size starts at the number of known keys\n    // and will be updated as we traverse the new state\n    this.size = knownState.size;\n    this.unknownState = undefined;\n    if (unknownState) {\n      for (const [k, v] of Object.entries(unknownState)) {\n        this.updateFromUnknown(k, v);\n      }\n    }\n  }\n}\n\n/**\n * @internal\n *\n * Only for direct use in very advanced integrations, such as lexical-yjs.\n * Typically you would only use {@link createState}, {@link $getState}, and\n * {@link $setState}. This is effectively the preamble for {@link $setState}.\n */\nfunction $getWritableNodeState(node) {\n  const writable = node.getWritable();\n  const state = writable.__state ? writable.__state.getWritable(writable) : new NodeState(writable, $getSharedNodeState(writable));\n  writable.__state = state;\n  return state;\n}\n\n/**\n * @internal\n *\n * Get the SharedNodeState for a node on this editor\n */\nfunction $getSharedNodeState(node) {\n  return node.__state ? node.__state.sharedNodeState : getRegisteredNodeOrThrow($getEditor(), node.getType()).sharedNodeState;\n}\n\n/**\n * @internal\n *\n * This is used to implement LexicalNode.updateFromJSON and is\n * not intended to be exported from the package.\n *\n * @param node any LexicalNode\n * @param unknownState undefined or a serialized State\n * @returns A writable version of node, with the state set.\n */\nfunction $updateStateFromJSON(node, serialized) {\n  const writable = node.getWritable();\n  const unknownState = serialized[NODE_STATE_KEY];\n  let parseState = unknownState;\n  for (const k of $getSharedNodeState(writable).flatKeys) {\n    if (k in serialized) {\n      if (parseState === undefined || parseState === unknownState) {\n        parseState = {\n          ...unknownState\n        };\n      }\n      parseState[k] = serialized[k];\n    }\n  }\n  if (writable.__state || parseState) {\n    $getWritableNodeState(node).updateFromJSON(parseState);\n  }\n  return writable;\n}\n\n/**\n * @internal\n *\n * Return true if the two nodes have equivalent NodeState, to be used\n * to determine when TextNode are being merged, not a lot of use cases\n * otherwise.\n */\nfunction nodeStatesAreEquivalent(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a && b && a.size !== b.size) {\n    return false;\n  }\n  const keys = new Set();\n  return !(a && hasUnequalMapEntry(keys, a, b) || b && hasUnequalMapEntry(keys, b, a) || a && hasUnequalRecordEntry(keys, a, b) || b && hasUnequalRecordEntry(keys, b, a));\n}\n\n/**\n * Compute the number of distinct keys that will be in a NodeState\n */\nfunction computeSize(sharedConfigMap, unknownState, knownState) {\n  let size = knownState.size;\n  if (unknownState) {\n    for (const k in unknownState) {\n      const sharedConfig = sharedConfigMap.get(k);\n      if (!sharedConfig || !knownState.has(sharedConfig)) {\n        size++;\n      }\n    }\n  }\n  return size;\n}\n\n/**\n * @internal\n *\n * Return obj if it is an object with at least one property, otherwise\n * return undefined.\n */\nfunction undefinedIfEmpty(obj) {\n  if (obj) {\n    for (const key in obj) {\n      return obj;\n    }\n  }\n  return undefined;\n}\n\n/**\n * @internal\n *\n * Cast the given v to unknown\n */\nfunction coerceToJSON(v) {\n  return v;\n}\n\n/**\n * @internal\n *\n * Parse all knowable values in an UnknownStateRecord into nextKnownState\n * and return the unparsed values in a new UnknownStateRecord. Returns\n * undefined if no unknown values remain.\n */\nfunction parseAndPruneNextUnknownState(sharedConfigMap, nextKnownState, unknownState) {\n  let nextUnknownState = undefined;\n  if (unknownState) {\n    for (const [k, v] of Object.entries(unknownState)) {\n      const stateConfig = sharedConfigMap.get(k);\n      if (stateConfig) {\n        if (!nextKnownState.has(stateConfig)) {\n          nextKnownState.set(stateConfig, stateConfig.parse(v));\n        }\n      } else {\n        nextUnknownState = nextUnknownState || {};\n        nextUnknownState[k] = v;\n      }\n    }\n  }\n  return nextUnknownState;\n}\n\n/**\n * @internal\n *\n * Compare each entry of sourceState.knownState that is not in keys to\n * otherState (or the default value if otherState is undefined.\n * Note that otherState will return the defaultValue as well if it\n * has never been set. Any checked entry's key will be added to keys.\n *\n * @returns true if any difference is found, false otherwise\n */\nfunction hasUnequalMapEntry(keys, sourceState, otherState) {\n  for (const [stateConfig, value] of sourceState.knownState) {\n    if (keys.has(stateConfig.key)) {\n      continue;\n    }\n    keys.add(stateConfig.key);\n    const otherValue = otherState ? otherState.getValue(stateConfig) : stateConfig.defaultValue;\n    if (otherValue !== value && !stateConfig.isEqual(otherValue, value)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @internal\n *\n * Compare each entry of sourceState.unknownState that is not in keys to\n * otherState.unknownState (or undefined if otherState is undefined).\n * Any checked entry's key will be added to keys.\n *\n * Notably since we have already checked hasUnequalMapEntry on both sides,\n * we do not do any parsing or checking of knownState.\n *\n * @returns true if any difference is found, false otherwise\n */\nfunction hasUnequalRecordEntry(keys, sourceState, otherState) {\n  const {\n    unknownState\n  } = sourceState;\n  const otherUnknownState = otherState ? otherState.unknownState : undefined;\n  if (unknownState) {\n    for (const [key, value] of Object.entries(unknownState)) {\n      if (keys.has(key)) {\n        continue;\n      }\n      keys.add(key);\n      const otherValue = otherUnknownState ? otherUnknownState[key] : undefined;\n      if (value !== otherValue) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * @internal\n *\n * Clones the NodeState for a given node. Handles aliasing if the state references the from node.\n */\nfunction $cloneNodeState(from, to) {\n  const state = from.__state;\n  return state && state.node === from ? state.getWritable(to) : state;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  const node1State = node1.__state;\n  const node2State = node2.__state;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style) && (node1.__state === null || node1State === node2State || nodeStatesAreEquivalent(node1State, node2State));\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text', true);\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element', true);\n  }\n}\n\nlet subTreeTextContent = '';\nlet subTreeTextFormat = null;\nlet subTreeTextStyle = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction $getReconciledDirection(node) {\n  const direction = node.__dir;\n  if (direction !== null) {\n    return direction;\n  }\n  if ($isRootNode(node)) {\n    return null;\n  }\n  const parent = node.getParentOrThrow();\n  if (!$isRootNode(parent) || parent.__dir !== null) {\n    return null;\n  }\n  return 'auto';\n}\nfunction $setElementDirection(dom, node) {\n  const direction = $getReconciledDirection(node);\n  if (direction !== null) {\n    dom.dir = direction;\n  } else {\n    dom.removeAttribute('dir');\n  }\n}\nfunction $createNode(key, slot) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      formatDevErrorMessage(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    $setElementDirection(dom, node);\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildren(children, node, 0, endIndex, node.getDOMSlot(dom));\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (slot !== null) {\n    slot.insertChild(dom);\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction $createChildren(children, element, _startIndex, endIndex, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], slot);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  const dom = slot.element;\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(element, nodeMap) {\n  if (element) {\n    const lastKey = element.__last;\n    if (lastKey) {\n      const node = nodeMap.get(lastKey);\n      if (node) {\n        return $isLineBreakNode(node) ? 'line-break' : $isDecoratorNode(node) && node.isInline() ? 'decorator' : null;\n      }\n    }\n    return 'empty';\n  }\n  return null;\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);\n  const nextLineBreak = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);\n  if (prevLineBreak !== nextLineBreak) {\n    nextElement.getDOMSlot(dom).setManagedLineBreak(nextLineBreak);\n  }\n}\nfunction reconcileTextFormat(element) {\n  if (subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {\n    element.setTextFormat(subTreeTextFormat);\n  }\n}\nfunction reconcileTextStyle(element) {\n  if (subTreeTextStyle !== '' && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction $reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  subTreeTextFormat = null;\n  subTreeTextStyle = '';\n  $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom));\n  reconcileTextFormat(nextElement);\n  reconcileTextStyle(nextElement);\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        formatDevErrorMessage(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction $reconcileChildren(prevElement, nextElement, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  const dom = slot.element;\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFirstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFirstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFirstChildKey, null);\n      try {\n        dom.replaceChild(replacementDOM, lastDOM);\n      } catch (error) {\n        if (typeof error === 'object' && error != null) {\n          const msg = `${error.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;\n          throw new Error(msg);\n        } else {\n          throw error;\n        }\n      }\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);\n    if ($isTextNode(nextChildNode)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = nextChildNode.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = nextChildNode.getStyle();\n      }\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (!(prevChildren.length === prevChildrenSize)) {\n      formatDevErrorMessage(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);\n    }\n    if (!(nextChildren.length === nextChildrenSize)) {\n      formatDevErrorMessage(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);\n    }\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction $reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      formatDevErrorMessage(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it was cloned. If it's also dirty, we mark it as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null);\n    if (parentDOM === null) {\n      {\n        formatDevErrorMessage(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    const nextIndent = nextNode.__indent;\n    if (treatAllNodesAsDirty || nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (treatAllNodesAsDirty || nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n    if (treatAllNodesAsDirty || nextNode.__dir !== prevNode.__dir) {\n      $setElementDirection(dom, nextNode);\n      if (\n      // Root node direction changing from set to unset (or vice versa)\n      // changes how children's direction is calculated.\n      $isRootNode(nextNode) &&\n      // Can skip if all children already reconciled.\n      !treatAllNodesAsDirty) {\n        for (const child of nextNode.getChildren()) {\n          if ($isElementNode(child)) {\n            const childDom = getElementByKeyOrThrow(activeEditor$1, child.getKey());\n            $setElementDirection(childDom, child);\n          }\n        }\n      }\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = slot.getFirstChild();\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, slot.element);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, slot.withBefore(siblingDOM));\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n        } else {\n          slot.withBefore(siblingDOM).insertChild(childDOM);\n          $reconcileNode(nextKey, slot.element);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, slot.withBefore(insertDOM));\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, slot.element);\n  }\n}\nfunction $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  setNodeKeyOnDOMNode(dom, editor, key);\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/*@__INLINE__*/\nfunction warnOnlyOnce(message) {\n  {\n    let run = false;\n    return () => {\n      if (!run) {\n        console.warn(message);\n      }\n      run = true;\n    };\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Crete a command that can be used with `editor.dispatchCommand` and\n * `editor.registerCommand`. Commands are used by unique reference, not by\n * name.\n *\n * @param type A string to identify the command, very helpful for debugging\n * @returns A new LexicalCommand\n *\n * @__NO_SIDE_EFFECTS__\n */\nfunction createCommand(type) {\n  return {\n    type\n  };\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\n/**\n * Dispatched to delete a character, the payload will be `true` if the deletion\n * is backwards (backspace or delete on macOS) and `false` if forwards\n * (delete or Fn+Delete on macOS).\n */\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\n/**\n * Dispatched to insert a line break. With a false payload the\n * cursor moves to the new line (Shift+Enter), with a true payload the cursor\n * does not move (Ctrl+O on macOS).\n */\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\n/**\n * Dispatched to delete a word, the payload will be `true` if the deletion is\n * backwards (Ctrl+Backspace or Opt+Delete on macOS), and `false` if\n * forwards (Ctrl+Delete or Fn+Opt+Delete on macOS).\n */\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\n/**\n * Dispatched to delete a line, the payload will be `true` if the deletion is\n * backwards (Cmd+Delete on macOS), and `false` if forwards\n * (Fn+Cmd+Delete on macOS).\n */\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\n/**\n * Dispatched to format the selected text.\n */\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\n/**\n * Dispatched on undo (Cmd+Z on macOS, Ctrl+Z elsewhere).\n */\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\n/**\n * Dispatched on redo (Shift+Cmd+Z on macOS, Shift+Ctrl+Z or Ctrl+Y elsewhere).\n */\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\n/**\n * Dispatched when any key is pressed.\n */\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\n/**\n * Dispatched when the `'ArrowRight'` key is pressed.\n * The shift modifier key may also be down.\n */\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\n/**\n * Dispatched when the move to end keyboard shortcut is pressed,\n * (Cmd+Right on macOS; Ctrl+Right elsewhere).\n */\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\n/**\n * Dispatched when the `'ArrowLeft'` key is pressed.\n * The shift modifier key may also be down.\n */\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\n/**\n * Dispatched when the move to start keyboard shortcut is pressed,\n * (Cmd+Left on macOS; Ctrl+Left elsewhere).\n */\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\n/**\n * Dispatched when the `'ArrowUp'` key is pressed.\n * The shift and/or alt (option) modifier keys may also be down.\n */\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\n/**\n * Dispatched when the `'ArrowDown'` key is pressed.\n * The shift and/or alt (option) modifier keys may also be down.\n */\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\n/**\n * Dispatched when the enter key is pressed, may also be called with a null\n * payload when the intent is to insert a newline. The shift modifier key\n * must be down, any other modifier keys may also be down.\n */\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\n/**\n * Dispatched whenever the space (`' '`) key is pressed, any modifier\n * keys may be down.\n */\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\n/**\n * Dispatched whenever the `'Backspace'` key is pressed, the shift\n * modifier key may be down.\n */\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\n/**\n * Dispatched whenever the `'Escape'` key is pressed, any modifier\n * keys may be down.\n */\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\n/**\n * Dispatched whenever the `'Delete'` key is pressed (Fn+Delete on macOS).\n */\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\n/**\n * Dispatched whenever the `'Tab'` key is pressed. The shift modifier key\n * may be down.\n */\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\n/**\n * Dispatched on a copy event, either via the clipboard or a KeyboardEvent\n * (Cmd+C on macOS, Ctrl+C elsewhere).\n */\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\n/**\n * Dispatched on a cut event, either via the clipboard or a KeyboardEvent\n * (Cmd+X on macOS, Ctrl+X elsewhere).\n */\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\n/**\n * Dispatched on the select all keyboard shortcut\n * (Cmd+A on macOS, Ctrl+A elsehwere).\n */\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\n/**\n * @deprecated in v0.31.0, use KEY_DOWN_COMMAND and check for modifiers\n * directly.\n *\n * Dispatched after any KeyboardEvent when modifiers are pressed\n */\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\n// Node can be moved between documents (for example using createPortal), so we\n// need to track the document each root element was originally registered on.\nconst rootElementToDocument = new WeakMap();\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet isSafariEndingComposition = false;\nlet safariEndCompositionEventData = '';\nlet postDeleteSelectionToRestore = null;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(getWindow(editor));\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 ||\n  // TODO consider if there are other scenarios when multiple code units\n  //      should be addressed here\n  doesContainSurrogatePair(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset) && !postDeleteSelectionToRestore) {\n      return;\n    }\n  }\n  updateEditorSync(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    let selection = $getSelection();\n\n    // Restore selection in the event of incorrect rightward shift after deletion\n    if (postDeleteSelectionToRestore && $isRangeSelection(selection) && selection.isCollapsed()) {\n      const curAnchor = selection.anchor;\n      const prevAnchor = postDeleteSelectionToRestore.anchor;\n      if (\n      // Rightward shift in same node\n      curAnchor.key === prevAnchor.key && curAnchor.offset === prevAnchor.offset + 1 ||\n      // Or rightward shift into sibling node\n      curAnchor.offset === 1 && prevAnchor.getNode().is(curAnchor.getNode().getPreviousSibling())) {\n        // Restore selection\n        selection = postDeleteSelectionToRestore.clone();\n        $setSelection(selection);\n      }\n    }\n    postDeleteSelectionToRestore = null;\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range \u2013 then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          $updateSelectionFormatStyle(selection, lastFormat, lastStyle);\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              formatDevErrorMessage(`Point.getNode() must return TextNode when type is text`);\n            }\n            $updateSelectionFormatStyleFromTextNode(selection, anchorNode);\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            if (!$isElementNode(anchorNode)) {\n              formatDevErrorMessage(`Point.getNode() must return ElementNode when type is element`);\n            }\n            const lastNode = anchor.getNode();\n            if (\n            // This previously applied to all ParagraphNode\n            lastNode.isEmpty()) {\n              $updateSelectionFormatStyleFromElementNode(selection, lastNode);\n            } else {\n              $updateSelectionFormatStyle(selection, 0, '');\n            }\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\nfunction $updateSelectionFormatStyle(selection, format, style) {\n  if (selection.format !== format || selection.style !== style) {\n    selection.format = format;\n    selection.style = style;\n    selection.dirty = true;\n  }\n}\nfunction $updateSelectionFormatStyleFromTextNode(selection, node) {\n  const format = node.getFormat();\n  const style = node.getStyle();\n  $updateSelectionFormatStyle(selection, format, style);\n}\nfunction $updateSelectionFormatStyleFromElementNode(selection, node) {\n  const format = node.getTextFormat();\n  const style = node.getTextStyle();\n  $updateSelectionFormatStyle(selection, format, style);\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(getWindow(editor));\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Triple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            const parentNode = $findMatchingParent(anchorNode, node => $isElementNode(node) && !node.isInline());\n            if ($isElementNode(parentNode)) {\n              parentNode.select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch' || event.pointerType === 'pen') {\n        // This is used to update the selection on touch devices (including Apple Pencil) when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n          $setSelection(newSelection);\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (isDOMNode(target) && pointerType !== 'touch' && pointerType !== 'pen' && event.button === 0) {\n    updateEditorSync(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !$isTokenOrTab(anchorNode) || !$isTokenOrTab(focusNode);\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 'MediaLast' && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditorSync(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            if (!$isTextNode(anchorNode)) {\n              formatDevErrorMessage(`Anchor node must be a TextNode`);\n            }\n            $updateSelectionFormatStyleFromTextNode(selection, anchorNode);\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNode = selection.anchor.getNode();\n          const selectedNodeText = selectedNode.getTextContent();\n          // When the target node has `canInsertTextAfter` set to false, the first deletion\n          // doesn't have an effect, so we need to handle it with Lexical.\n          const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          let shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;\n          // Check if selection is collapsed and if the previous node is a decorator node\n          // If so, the browser will not be able to handle the deletion\n          if (shouldLetBrowserHandleDelete && selection.isCollapsed()) {\n            shouldLetBrowserHandleDelete = !$isDecoratorNode($getAdjacentNode(selection.anchor, true));\n          }\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n            // When deleting across paragraphs, Chrome on Android incorrectly shifts the selection rightwards\n            // We save the correct selection to restore later during handling of selectionchange event\n            const selectionAfterDelete = $getSelection();\n            if (IS_ANDROID_CHROME && $isRangeSelection(selectionAfterDelete) && selectionAfterDelete.isCollapsed()) {\n              postDeleteSelectionToRestore = selectionAfterDelete;\n              // Cleanup in case selectionchange does not fire\n              setTimeout(() => postDeleteSelectionToRestore = null);\n            }\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // Note that the MutationObserver may or may not have already fired,\n  // but the the DOM and selection may have already changed.\n  // See also:\n  // - https://github.com/facebook/lexical/issues/7028\n  // - https://github.com/facebook/lexical/pull/794\n\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditorSync(editor, () => {\n    if (isHTMLElement(event.target) && $isSelectionCapturedInDecorator(event.target)) {\n      return;\n    }\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(getWindow(editor));\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;\n      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  }, {\n    event\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction $onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else if (!IS_IOS && (IS_SAFARI || IS_APPLE_WEBKIT)) {\n    // Fix\uFF1Ahttps://github.com/facebook/lexical/pull/7061\n    // In safari, onCompositionEnd triggers before keydown\n    // This will cause an extra character to be deleted when exiting the IME\n    // Therefore, a flag is used to mark that the keydown event is triggered after onCompositionEnd\n    // Ensure that an extra character is not deleted due to the backspace event being triggered in the keydown event.\n    isSafariEndingComposition = true;\n    safariEndCompositionEventData = event.data;\n  } else {\n    updateEditorSync(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (event.key == null) {\n    return;\n  }\n  if (isSafariEndingComposition && isBackspace(event)) {\n    updateEditorSync(editor, () => {\n      $onCompositionEndImpl(editor, safariEndCompositionEventData);\n    });\n    isSafariEndingComposition = false;\n    safariEndCompositionEventData = '';\n    return;\n  }\n  if (isMoveForward(event)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(event)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(event)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(event)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(event)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(event)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(event)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(event)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(event)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(event)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(event)) {\n    if (isBackspace(event)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(event)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(event)) {\n    if (isDelete(event)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(event)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if (prevSelection !== null && !$isRangeSelection(prevSelection)) {\n      // Only RangeSelection can use the native cut/copy/select all\n      if (isCopy(event)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(event)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(event)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n    } else if (isSelectAll(event)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(event)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const domSelection = getDOMSelectionFromTarget(event.target);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditorSync(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n        $setSelection(newSelection);\n      }\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  rootElementToDocument.set(rootElement, doc);\n  const documentRootElementsCount = rootElementsRegistered.get(doc) ?? 0;\n  if (documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, documentRootElementsCount + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      const isEditable = editor.isEditable();\n      switch (eventName) {\n        case 'cut':\n          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);\n        case 'copy':\n          return dispatchCommand(editor, COPY_COMMAND, event);\n        case 'paste':\n          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);\n        case 'dragstart':\n          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);\n        case 'dragover':\n          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);\n        case 'dragend':\n          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);\n        case 'focus':\n          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);\n        case 'blur':\n          {\n            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);\n          }\n        case 'drop':\n          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nconst rootElementNotRegisteredWarning = warnOnlyOnce('Root element not registered');\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElementToDocument.get(rootElement);\n  if (doc === undefined) {\n    rootElementNotRegisteredWarning();\n    return;\n  }\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined) {\n    // This can happen if setRootElement() failed\n    rootElementNotRegisteredWarning();\n    return;\n  }\n\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  if (!(newCount >= 0)) {\n    formatDevErrorMessage(`Root element count less than 0`);\n  }\n  rootElementToDocument.delete(rootElement);\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  const editor = getEditorPropertyFromDOMNode(rootElement);\n  if (isLexicalEditor(editor)) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  } else if (editor) {\n    {\n      formatDevErrorMessage(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);\n    }\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * The base type for all serialized nodes\n */\n\n/**\n * EXPERIMENTAL\n * The configuration of a node returned by LexicalNode.$config()\n *\n * @example\n * ```ts\n * class CustomText extends TextNode {\n *   $config() {\n *     return this.config('custom-text', {extends: TextNode}};\n *   }\n * }\n * ```\n */\n\n/**\n * This is the type of LexicalNode.$config() that can be\n * overridden by subclasses.\n */\n\n/**\n * Used to extract the node and type from a StaticNodeConfigRecord\n */\n\n/**\n * Any StaticNodeConfigValue (for generics and collections)\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @internal\n *\n * This is the more specific type than BaseStaticNodeConfig that a subclass\n * should return from $config()\n */\n\n/**\n * Extract the type from a node based on its $config\n *\n * @example\n * ```ts\n * type TextNodeType = GetStaticNodeType<TextNode>;\n *      // ? 'text'\n * ```\n */\n\n/**\n * The most precise type we can infer for the JSON that will\n * be produced by T.exportJSON().\n *\n * Do not use this for the return type of T.exportJSON()! It must be\n * a more generic type to be compatible with subclassing.\n */\n\n/**\n * Omit the children, type, and version properties from the given SerializedLexicalNode definition.\n */\n\n/** @internal */\n\nfunction $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && selection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\n/**\n * An identity function that will infer the type of DOM nodes\n * based on tag names to make it easier to construct a\n * DOMConversionMap.\n */\nfunction buildImportMap(importMap) {\n  return importMap;\n}\nconst EPHEMERAL = Symbol.for('ephemeral');\n\n/**\n * @internal\n * @param node any LexicalNode\n * @returns true if the node was created with {@link $cloneWithPropertiesEphemeral}\n */\nfunction $isEphemeral(node) {\n  return node[EPHEMERAL] || false;\n}\n/**\n * @internal\n * Mark this node as ephemeral, its instance always returns this\n * for getLatest and getWritable. It must not be added to an EditorState.\n */\nfunction $markEphemeral(node) {\n  node[EPHEMERAL] = true;\n  return node;\n}\nclass LexicalNode {\n  /** @internal Allow us to look up the type including static props */\n\n  /** @internal */\n  __type;\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n  __key;\n  /** @internal */\n  __parent;\n  /** @internal */\n  __prev;\n  /** @internal */\n  __next;\n  /** @internal */\n  __state;\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    const {\n      ownNodeType\n    } = getStaticNodeConfig(this);\n    if (!(ownNodeType !== undefined)) {\n      formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n    return ownNodeType;\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  /**\n   * Override this to implement the new static node configuration protocol,\n   * this method is called directly on the prototype and must not depend\n   * on anything initialized in the constructor. Generally it should be\n   * a trivial implementation.\n   *\n   * @example\n   * ```ts\n   * class MyNode extends TextNode {\n   *   $config() {\n   *     return this.config('my-node', {extends: TextNode});\n   *   }\n   * }\n   * ```\n   */\n  $config() {\n    return {};\n  }\n\n  /**\n   * This is a convenience method for $config that\n   * aids in type inference. See {@link LexicalNode.$config}\n   * for example usage.\n   */\n  config(type, config) {\n    const parentKlass = config.extends || Object.getPrototypeOf(this.constructor);\n    Object.assign(config, {\n      extends: parentKlass,\n      type\n    });\n    return {\n      [type]: config\n    };\n  }\n\n  /**\n   * Perform any state updates on the clone of prevNode that are not already\n   * handled by the constructor call in the static clone method. If you have\n   * state to update in your clone that is not handled directly by the\n   * constructor, it is advisable to override this method but it is required\n   * to include a call to `super.afterCloneFrom(prevNode)` in your\n   * implementation. This is only intended to be called by\n   * {@link $cloneWithProperties} function or via a super call.\n   *\n   * @example\n   * ```ts\n   * class ClassesTextNode extends TextNode {\n   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM\n   *   __classes = new Set<string>();\n   *   static clone(node: ClassesTextNode): ClassesTextNode {\n   *     // The inherited TextNode constructor is used here, so\n   *     // classes is not set by this method.\n   *     return new ClassesTextNode(node.__text, node.__key);\n   *   }\n   *   afterCloneFrom(node: this): void {\n   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom\n   *     // for necessary state updates\n   *     super.afterCloneFrom(node);\n   *     this.__addClasses(node.__classes);\n   *   }\n   *   // This method is a private implementation detail, it is not\n   *   // suitable for the public API because it does not call getWritable\n   *   __addClasses(classNames: Iterable<string>): this {\n   *     for (const className of classNames) {\n   *       this.__classes.add(className);\n   *     }\n   *     return this;\n   *   }\n   *   addClass(...classNames: string[]): this {\n   *     return this.getWritable().__addClasses(classNames);\n   *   }\n   *   removeClass(...classNames: string[]): this {\n   *     const node = this.getWritable();\n   *     for (const className of classNames) {\n   *       this.__classes.delete(className);\n   *     }\n   *     return this;\n   *   }\n   *   getClasses(): Set<string> {\n   *     return this.getLatest().__classes;\n   *   }\n   * }\n   * ```\n   *\n   */\n  afterCloneFrom(prevNode) {\n    if (this.__key === prevNode.__key) {\n      this.__parent = prevNode.__parent;\n      this.__next = prevNode.__next;\n      this.__prev = prevNode.__prev;\n      this.__state = prevNode.__state;\n    } else if (prevNode.__state) {\n      this.__state = prevNode.__state.getWritable(this);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static importDOM;\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    Object.defineProperty(this, '__state', {\n      configurable: true,\n      enumerable: false,\n      value: undefined,\n      writable: true\n    });\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimately be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element';\n    if (isElementRangeSelection) {\n      if (targetSelection.isCollapsed()) {\n        return false;\n      }\n      const parentNode = this.getParent();\n      if ($isDecoratorNode(this) && this.isInline() && parentNode) {\n        const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;\n        if (parentNode.is(firstPoint.getNode()) && firstPoint.offset === parentNode.getChildrenSize() && this.is(parentNode.getLastChild())) {\n          return false;\n        }\n      }\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        formatDevErrorMessage(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {\n          formatDevErrorMessage(`Children of root nodes must be elements or decorators`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        formatDevErrorMessage(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * @deprecated use {@link $getCommonAncestor}\n   *\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = $isElementNode(this) ? this : this.getParent();\n    const b = $isElementNode(node) ? node : node.getParent();\n    const result = a && b ? $getCommonAncestor(a, b) : null;\n    return result ? result.commonAncestor /* TODO this type cast is a lie, but fixing it would break backwards compatibility */ : null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logically precedes the target node in the\n   * editor state, false otherwise (including if there is no common ancestor).\n   *\n   * Note that this notion of isBefore is based on post-order; a descendant\n   * node is always before its ancestors. See also\n   * {@link $getCommonAncestor} and {@link $comparePointCaretNext} for\n   * more flexible ways to determine the relative positions of nodes.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    const compare = $getCommonAncestor(this, targetNode);\n    if (compare === null) {\n      return false;\n    }\n    if (compare.type === 'descendant') {\n      return true;\n    }\n    if (compare.type === 'branch') {\n      return $getCommonAncestorResultBranchOrder(compare) === -1;\n    }\n    if (!(compare.type === 'same' || compare.type === 'ancestor')) {\n      formatDevErrorMessage(`LexicalNode.isBefore: exhaustiveness check`);\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is an ancestor of and distinct from the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const result = $getCommonAncestor(this, targetNode);\n    return result !== null && result.type === 'ancestor';\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            formatDevErrorMessage(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    if ($isEphemeral(this)) {\n      return this;\n    }\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        formatDevErrorMessage(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node using {@link $cloneWithProperties}\n   * if necessary. Will throw an error if called outside of a Lexical Editor\n   * {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    if ($isEphemeral(this)) {\n      return this;\n    }\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const mutableNode = $cloneWithProperties(latestNode);\n    cloneNotNeeded.add(key);\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecycle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      formatDevErrorMessage(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      formatDevErrorMessage(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    // eslint-disable-next-line dot-notation\n    const state = this.__state ? this.__state.toJSON() : undefined;\n    return {\n      type: this.__type,\n      version: 1,\n      ...state\n    };\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n\n  /**\n   * Update this LexicalNode instance from serialized JSON. It's recommended\n   * to implement as much logic as possible in this method instead of the\n   * static importJSON method, so that the functionality can be inherited in subclasses.\n   *\n   * The LexicalUpdateJSON utility type should be used to ignore any type, version,\n   * or children properties in the JSON so that the extended JSON from subclasses\n   * are acceptable parameters for the super call.\n   *\n   * If overridden, this method must call super.\n   *\n   * @example\n   * ```ts\n   * class MyTextNode extends TextNode {\n   *   // ...\n   *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {\n   *     return $createMyTextNode()\n   *       .updateFromJSON(serializedNode);\n   *   }\n   *   updateFromJSON(\n   *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,\n   *   ): this {\n   *     return super.updateFromJSON(serializedNode)\n   *       .setMyProperty(serializedNode.myProperty);\n   *   }\n   * }\n   * ```\n   **/\n  updateFromJSON(serializedNode) {\n    return $updateStateFromJSON(this, serializedNode);\n  }\n\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n\n  /**\n   * @internal\n   *\n   * When the reconciler detects that a node was mutated, this method\n   * may be called to restore the node to a known good state.\n   */\n  reconcileObservedMutation(dom, editor) {\n    this.markDirty();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getRegisteredNode(getActiveEditor(), type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      formatDevErrorMessage(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      formatDevErrorMessage(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        formatDevErrorMessage(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Common update tags used in Lexical. These tags can be used with editor.update() or $addUpdateTag()\n * to indicate the type/purpose of an update. Multiple tags can be used in a single update.\n */\n\n/**\n * Indicates that the update is related to history operations (undo/redo)\n */\nconst HISTORIC_TAG = 'historic';\n\n/**\n * Indicates that a new history entry should be pushed to the history stack\n */\nconst HISTORY_PUSH_TAG = 'history-push';\n\n/**\n * Indicates that the current update should be merged with the previous history entry\n */\nconst HISTORY_MERGE_TAG = 'history-merge';\n\n/**\n * Indicates that the update is related to a paste operation\n */\nconst PASTE_TAG = 'paste';\n\n/**\n * Indicates that the update is related to collaborative editing\n */\nconst COLLABORATION_TAG = 'collaboration';\n\n/**\n * Indicates that the update should skip collaborative sync\n */\nconst SKIP_COLLAB_TAG = 'skip-collab';\n\n/**\n * Indicates that the update should skip scrolling the selection into view\n */\nconst SKIP_SCROLL_INTO_VIEW_TAG = 'skip-scroll-into-view';\n\n/**\n * Indicates that the update should skip updating the DOM selection\n * This is useful when you want to make updates without changing the selection or focus\n */\nconst SKIP_DOM_SELECTION_TAG = 'skip-dom-selection';\n\n/**\n * Indicates that after changing the selection, the editor should not focus itself\n * This tag is ignored if {@link SKIP_DOM_SELECTION_TAG} is used\n */\nconst SKIP_SELECTION_FOCUS_TAG = 'skip-selection-focus';\n\n/**\n * The update was triggered by editor.focus()\n */\nconst FOCUS_TAG = 'focus';\n\n/**\n * The set of known update tags to help with TypeScript suggestions.\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  /** @internal */\n\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);\n  }\n}\nfunction $convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isLastChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    // check if node is first child, because only child dont count\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      return false;\n    }\n\n    // check if its last child\n    const lastChild = parentElement.lastChild;\n    if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return isDOMTextNode(node) && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  __text;\n  /** @internal */\n  __format;\n  /** @internal */\n  __style;\n  /** @internal */\n  __mode;\n  /** @internal */\n  __detail;\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__text = prevNode.__text;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__mode = prevNode.__mode;\n    this.__detail = prevNode.__detail;\n  }\n  constructor(text = '', key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not individually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segmented\" mode. TextNodes in segmented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  /**\n   * @returns true if the text node is inline, false otherwise.\n   */\n  isInline() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          formatDevErrorMessage(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            formatDevErrorMessage(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      mark: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTextNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!isHTMLElement(element)) {\n      formatDevErrorMessage(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n\n    // Add text-transform styles for capitalization formats\n    if (this.hasFormat('lowercase')) {\n      element.style.textTransform = 'lowercase';\n    } else if (this.hasFormat('uppercase')) {\n      element.style.textTransform = 'uppercase';\n    } else if (this.hasFormat('capitalize')) {\n      element.style.textTransform = 'capitalize';\n    }\n\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    if (textContent === '') {\n      return [];\n    }\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const textLength = textContent.length;\n    splitOffsets.sort((a, b) => a - b);\n    splitOffsets.push(textLength);\n    const parts = [];\n    const splitOffsetsLength = splitOffsets.length;\n    for (let start = 0, offsetIndex = 0; start < textLength && offsetIndex <= splitOffsetsLength; offsetIndex++) {\n      const end = splitOffsets[offsetIndex];\n      if (end > start) {\n        parts.push(textContent.slice(start, end));\n        start = end;\n      }\n    }\n    const partsLength = parts.length;\n    if (partsLength === 1) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParent();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n\n    // Prepare to handle selection\n    let startTextPoint = null;\n    let endTextPoint = null;\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];\n      if (startPoint.type === 'text' && startPoint.key === key) {\n        startTextPoint = startPoint;\n      }\n      if (endPoint.type === 'text' && endPoint.key === key) {\n        endTextPoint = endPoint;\n      }\n    }\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      writableNode.__state = $cloneNodeState(self, writableNode);\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.setTextContent(firstPart);\n    }\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const sibling = $createTextNode(part);\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      sibling.__state = $cloneNodeState(self, sibling);\n      const siblingKey = sibling.__key;\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      splitNodes.push(sibling);\n    }\n\n    // Move the selection to the best location in the split string.\n    // The end point is always left-biased, and the start point is\n    // generally left biased unless the end point would land on a\n    // later node in the split in which case it will prefer the start\n    // of that node so they will tend to be on the same node.\n    const originalStartOffset = startTextPoint ? startTextPoint.offset : null;\n    const originalEndOffset = endTextPoint ? endTextPoint.offset : null;\n    let startOffset = 0;\n    for (const node of splitNodes) {\n      if (!(startTextPoint || endTextPoint)) {\n        break;\n      }\n      const endOffset = startOffset + node.getTextContentSize();\n      if (startTextPoint !== null && originalStartOffset !== null && originalStartOffset <= endOffset && originalStartOffset >= startOffset) {\n        // Set the start point to the first valid node\n        startTextPoint.set(node.getKey(), originalStartOffset - startOffset, 'text');\n        if (originalStartOffset < endOffset) {\n          // The start isn't on a border so we can stop checking\n          startTextPoint = null;\n        }\n      }\n      if (endTextPoint !== null && originalEndOffset !== null && originalEndOffset <= endOffset && originalEndOffset >= startOffset) {\n        endTextPoint.set(node.getKey(), originalEndOffset - startOffset, 'text');\n        break;\n      }\n      startOffset = endOffset;\n    }\n\n    // Insert the nodes into the parent's children\n    if (parent !== null) {\n      internalMarkSiblingsAsDirty(this);\n      const writableParent = parent.getWritable();\n      const insertionIndex = this.getIndexWithinParent();\n      if (hasReplacedSelf) {\n        writableParent.splice(insertionIndex, 0, splitNodes);\n        this.remove();\n      } else {\n        writableParent.splice(insertionIndex, 1, splitNodes);\n      }\n      if ($isRangeSelection(selection)) {\n        $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n      }\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        formatDevErrorMessage(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: applyTextFormatFromStyle(b.style, hasNormalFontWeight ? undefined : 'bold'),\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  if (!isHTMLElement(node)) {\n    return false;\n  } else if (node.nodeName === 'PRE') {\n    return true;\n  }\n  const whiteSpace = node.style.whiteSpace;\n  return typeof whiteSpace === 'string' && whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction $convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    formatDevErrorMessage(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> potential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (isHTMLElement(node)) {\n      const display = node.style.display;\n      if (display === '' && !isInlineDomNode(node) || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (isDOMTextNode(node)) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  mark: 'highlight',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\nfunction applyTextFormatFromStyle(style, shouldApply) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return lexicalNode => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat('strikethrough')) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n    return lexicalNode;\n  };\n}\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    return new TabNode(node.__key);\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  createDOM(config) {\n    const dom = super.createDOM(config);\n    const classNames = getCachedClassNameArray(config.theme, 'tab');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  static importJSON(serializedTabNode) {\n    return $createTabNode().updateFromJSON(serializedTabNode);\n  }\n  setTextContent(text) {\n    if (!(text === '\\t' || text === '')) {\n      formatDevErrorMessage(`TabNode does not support setTextContent`);\n    }\n    return super.setTextContent('\\t');\n  }\n  spliceText(offset, delCount, newText, moveSelection) {\n    if (!(newText === '' && delCount === 0 || newText === '\\t' && delCount === 1)) {\n      formatDevErrorMessage(`TabNode does not support spliceText`);\n    }\n    return this;\n  }\n  setDetail(detail) {\n    if (!(detail === IS_UNMERGEABLE)) {\n      formatDevErrorMessage(`TabNode does not support setDetail`);\n    }\n    return this;\n  }\n  setMode(type) {\n    if (!(type === 'normal')) {\n      formatDevErrorMessage(`TabNode does not support setMode`);\n    }\n    return this;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\nclass Point {\n  key;\n  offset;\n  type;\n  _selection;\n  constructor(key, offset, type) {\n    {\n      // This prevents a circular reference error when serialized as JSON,\n      // which happens on unit test failures\n      Object.defineProperty(this, '_selection', {\n        enumerable: false,\n        writable: true\n      });\n    }\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    if (this.key === b.key) {\n      return this.offset < b.offset;\n    }\n    const aCaret = $normalizeCaret($caretFromPoint(this, 'next'));\n    const bCaret = $normalizeCaret($caretFromPoint(b, 'next'));\n    return $comparePointCaretNext(aCaret, bCaret) < 0;\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        formatDevErrorMessage(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type, onlyIfChanged) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    if (onlyIfChanged && this.key === key && this.offset === offset && this.type === type) {\n      return;\n    }\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    {\n      const node = $getNodeByKey(key);\n      if (!(type === 'text' ? $isTextNode(node) : $isElementNode(node))) {\n        formatDevErrorMessage(`PointType.set: node with key ${key} is ${node ? node.__type : '[not found]'} and can not be used for a ${type} point`);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if ($isParagraphNode(placementNode)) {\n    placementNode.splice(0, 0, [textNode]);\n  } else {\n    const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n    if (placementNode === null) {\n      element.append(target);\n    } else {\n      placementNode.insertBefore(target);\n    }\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nclass NodeSelection {\n  _nodes;\n  _cachedNodes;\n  dirty;\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n\n  /**\n   * Remove all nodes in the NodeSelection. If there were any nodes,\n   * replace the selection with a new RangeSelection at the previous\n   * location of the first node.\n   */\n  deleteNodes() {\n    const nodes = this.getNodes();\n    if (($getSelection() || $getPreviousSelection()) === this && nodes[0]) {\n      const firstCaret = $getSiblingCaret(nodes[0], 'next');\n      $setSelectionFromCaretRange($getCaretRange(firstCaret, firstCaret));\n    }\n    for (const node of nodes) {\n      node.remove();\n    }\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  format;\n  style;\n  anchor;\n  focus;\n  _cachedNodes;\n  dirty;\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * including anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * See also the {@link CaretRange} APIs (starting with\n   * {@link $caretRangeFromSelection}), which are likely to provide a better\n   * foundation for any operation where partial selection is relevant\n   * (e.g. the anchor or focus are inside an ElementNode and TextNode)\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const range = $getCaretRangeInDirection($caretRangeFromSelection(this), 'next');\n    const nodes = $getNodesFromCaretRangeCompat(range);\n    {\n      if (this.isCollapsed() && nodes.length > 1) {\n        {\n          formatDevErrorMessage(`RangeSelection.getNodes() returned ${String(nodes.length)} > 1 nodes in a collapsed selection`);\n        }\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    this.anchor.set(anchorNode.__key, anchorOffset, 'text');\n    this.focus.set(focusNode.__key, focusOffset, 'text');\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    this.anchor.set(anchorPoint.key, anchorPoint.offset, anchorPoint.type, true);\n    this.focus.set(focusPoint.key, focusPoint.offset, focusPoint.type, true);\n    // Firefox will use an element point rather than a text point in some cases,\n    // so we normalize for that\n    $normalizeSelection(this);\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the format property on the Selection\n   *\n   * @param format - the format to set at the value of the format property.\n   */\n  setFormat(format) {\n    this.format = format;\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Insert the provided text into the EditorState at the current Selection.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    // Now that \"removeText\" has been improved and does not depend on\n    // insertText, insertText can be greatly simplified. The next\n    // commented version is a WIP (about 5 tests fail).\n    //\n    // this.removeText();\n    // if (text === '') {\n    //   return;\n    // }\n    // const anchorNode = this.anchor.getNode();\n    // const textNode = $createTextNode(text);\n    // textNode.setFormat(this.format);\n    // textNode.setStyle(this.style);\n    // if ($isTextNode(anchorNode)) {\n    //   const parent = anchorNode.getParentOrThrow();\n    //   if (this.anchor.offset === 0) {\n    //     if (parent.isInline() && !anchorNode.__prev) {\n    //       parent.insertBefore(textNode);\n    //     } else {\n    //       anchorNode.insertBefore(textNode);\n    //     }\n    //   } else if (this.anchor.offset === anchorNode.getTextContentSize()) {\n    //     if (parent.isInline() && !anchorNode.__next) {\n    //       parent.insertAfter(textNode);\n    //     } else {\n    //       anchorNode.insertAfter(textNode);\n    //     }\n    //   } else {\n    //     const [before] = anchorNode.splitText(this.anchor.offset);\n    //     before.insertAfter(textNode);\n    //   }\n    // } else {\n    //   anchorNode.splice(this.anchor.offset, 0, [textNode]);\n    // }\n    // const nodeToSelect = textNode.isAttached() ? textNode : anchorNode;\n    // nodeToSelect.selectEnd();\n    // // When composing, we need to adjust the anchor offset so that\n    // // we correctly replace that right range.\n    // if (\n    //   textNode.isComposing() &&\n    //   this.anchor.type === 'text' &&\n    //   anchorNode.getTextContent() !== ''\n    // ) {\n    //   this.anchor.offset -= text.length;\n    // }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);\n    }\n    if (endPoint.type === 'element') {\n      $setPointFromCaret(endPoint, $normalizeCaret($caretFromPoint(endPoint, 'next')));\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        formatDevErrorMessage(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        nextSibling.setStyle(style);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if ($isTokenOrTab(firstNode)) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !$isTokenOrTab(lastNode) && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!$isTokenOrTab(firstNode)) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    const isCurrentSelection = $getSelection() === this;\n    const newRange = $removeTextFromCaretRange($caretRangeFromSelection(this));\n    $updateRangeSelectionFromCaretRange(this, newRange);\n    if (isCurrentSelection && $getSelection() !== this) {\n      $setSelection(this);\n    }\n  }\n\n  // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   * @param alignWithFormat a 32-bit integer representing formatting flags to align with.\n   */\n  formatText(formatType, alignWithFormat = null) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const applyFormatToElements = alignWith => {\n      selectedNodes.forEach(node => {\n        if ($isElementNode(node)) {\n          const newFormat = node.getFormatFlags(formatType, alignWith);\n          node.setTextFormat(newFormat);\n        }\n      });\n    };\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      applyFormatToElements(alignWithFormat);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);\n    applyFormatToElements(firstNextFormat);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accommodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        formatDevErrorMessage(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstNode = firstPoint.getNode();\n    const firstBlock = $findMatchingParent(firstNode, INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ($isElementNode(firstBlock) && '__language' in firstBlock) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      if (!(firstBlock !== null)) {\n        formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);\n      }\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $findMatchingParent(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $findMatchingParent(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      formatDevErrorMessage(`Expected ancestor to be a block ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = [...this.getNodes()];\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[selectedNodesLength - 1];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    const isBackward = this.isBackward();\n    const [startPoint, endPoint] = isBackward ? [this.focus, this.anchor] : [this.anchor, this.focus];\n    const [startOffset, endOffset] = isBackward ? [focusOffset, anchorOffset] : [anchorOffset, focusOffset];\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        if (node) {\n          startPoint.set(node.getKey(), 0, 'text');\n          endPoint.set(node.getKey(), node.getTextContentSize(), 'text');\n          return [node];\n        }\n        return [];\n      }\n      return [firstNode];\n    }\n    if ($isTextNode(firstNode)) {\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n        startPoint.set(firstNode.getKey(), 0, 'text');\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[selectedNodes.length - 1] = lastNode;\n        endPoint.set(lastNode.getKey(), lastNode.getTextContentSize(), 'text');\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    if ($modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity)) {\n      return;\n    }\n    const collapse = alter === 'move';\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(getWindow(editor));\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    const focusNode = this.focus.getNode();\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(focusNode) && !focusNode.isInline() && !focusNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    if (this.dirty) {\n      let nextAnchorDOM = getElementByKeyOrThrow(editor, this.anchor.key);\n      let nextFocusDOM = getElementByKeyOrThrow(editor, this.focus.key);\n      if (this.anchor.type === 'text') {\n        nextAnchorDOM = getDOMTextNode(nextAnchorDOM);\n      }\n      if (this.focus.type === 'text') {\n        nextFocusDOM = getDOMTextNode(nextFocusDOM);\n      }\n      if (nextAnchorDOM && nextFocusDOM) {\n        setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, this.anchor.offset, nextFocusDOM, this.focus.offset);\n      }\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n    if (granularity === 'lineboundary') {\n      $modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity, 'decorators');\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      const direction = isBackward ? 'previous' : 'next';\n      const initialCaret = $caretFromPoint(anchor, direction);\n      const initialRange = $extendCaretToRange(initialCaret);\n      if (initialRange.getTextSlices().every(slice => slice === null || slice.distance === 0)) {\n        // There's no text in the direction of the deletion so we can explore our options\n        let state = {\n          type: 'initial'\n        };\n        for (const caret of initialRange.iterNodeCarets('shadowRoot')) {\n          if ($isChildCaret(caret)) {\n            if (caret.origin.isInline()) ; else if (caret.origin.isShadowRoot()) {\n              if (state.type === 'merge-block') {\n                break;\n              }\n              // Don't merge with a shadow root block\n              if ($isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {\n                // delete an empty paragraph like the DecoratorNode case\n                const normCaret = $normalizeCaret(caret);\n                $updateRangeSelectionFromCaretRange(this, $getCaretRange(normCaret, normCaret));\n                initialRange.anchor.origin.remove();\n              }\n              return;\n            } else if (state.type === 'merge-next-block' || state.type === 'merge-block') {\n              // Keep descending ChildCaret to find which block to merge with\n              state = {\n                block: state.block,\n                caret,\n                type: 'merge-block'\n              };\n            }\n          } else if (state.type === 'merge-block') {\n            break;\n          } else if ($isSiblingCaret(caret)) {\n            if ($isElementNode(caret.origin)) {\n              if (!caret.origin.isInline()) {\n                state = {\n                  block: caret.origin,\n                  type: 'merge-next-block'\n                };\n              } else if (!caret.origin.isParentOf(initialRange.anchor.origin)) {\n                break;\n              }\n              continue;\n            } else if ($isDecoratorNode(caret.origin)) {\n              if (caret.origin.isIsolated()) ; else if (state.type === 'merge-next-block' && (caret.origin.isKeyboardSelectable() || !caret.origin.isInline()) && $isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {\n                // If the anchor is an empty element that is adjacent to a\n                // decorator then we remove the paragraph and select the\n                // decorator\n                initialRange.anchor.origin.remove();\n                const nodeSelection = $createNodeSelection();\n                nodeSelection.add(caret.origin.getKey());\n                $setSelection(nodeSelection);\n              } else {\n                // When the anchor is not an empty element then the\n                // adjacent decorator is removed\n                caret.origin.remove();\n              }\n              // always stop when a decorator is encountered\n              return;\n            }\n            break;\n          }\n        }\n        if (state.type === 'merge-block') {\n          const {\n            caret,\n            block\n          } = state;\n          $updateRangeSelectionFromCaretRange(this, $getCaretRange(!caret.origin.isEmpty() && block.isEmpty() ? $rewindSiblingCaret($getSiblingCaret(block, caret.direction)) : initialRange.anchor, caret));\n          return this.removeText();\n        }\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        if ($collapseAtStart(this, anchor.getNode())) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getPreviousSibling() === null) {\n        $collapseAtStart(this, anchorNode);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'lineboundary');\n    }\n    if (this.isCollapsed()) {\n      // If the selection was already collapsed at the lineboundary,\n      // use the deleteCharacter operation to handle all of the logic associated\n      // with navigating through the parent element\n      this.deleteCharacter(isBackward);\n    } else {\n      this.removeText();\n    }\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $collapseAtStart(selection, startNode) {\n  for (let node = startNode; node; node = node.getParent()) {\n    if ($isElementNode(node)) {\n      if (node.collapseAtStart(selection)) {\n        return true;\n      }\n      if ($isRootOrShadowRoot(node)) {\n        break;\n      }\n    }\n    if (node.getPreviousSibling()) {\n      break;\n    }\n  }\n  return false;\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  anchor.set(focus.key, focus.offset, focus.type, true);\n  focus.set(anchorKey, anchorOffset, anchorType, true);\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\n\n/**\n * Called by `RangeSelection.deleteCharacter` to determine if\n * `this.modify('extend', isBackward, 'character')` extended the selection\n * further than a user would expect for that operation.\n *\n * A short(?) JavaScript string vs. Unicode primer:\n *\n * Strings in JavaScript use an UTF-16 encoding, and the offsets into a\n * string are based on those UTF-16 *code units*. This is basically a\n * historical mistake (though logical at that time, decades ago), but\n * can never really be fixed for compatibility reasons.\n *\n * In Unicode, a *code point* is the combination of one or more *code units*.\n * and the range of a *code point* can fit into 21 bits.\n *\n * Every valid *code point* can be represented with one or two\n * *UTF-16 code units*. One unit is used when the code point is in the\n * Basic Multilingual Plane (BMP) and is `< 0xFFFF`. Anything outside\n * of that plane is encoded with a *surrogate pair* of *code units* and\n * `/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/` is a regex that you could use to\n * find any valid *surrogate pair*. As far as Unicode is concerned, these\n * pairs represent a single *code point*, but in JavaScript, these pairs\n * have a length of 2 (`pair.charCodeAt(n)` is really returning a\n * UTF-16 *code unit*, not a unicode *code point*). It is possible to request\n * a *code point* with `pair.codePointAt(0)` and enumerate code points\n * in a string with `[...string]` but the offsets we work with, and\n * the string length, are based in *code units* so that functionality\n * is unfortunately not very useful here.\n *\n * This only gets us as far as *code points*. We now know that we must\n * consider that each *code point* can have a length of 1 or 2 in JavaScript\n * string distance. It gets even trickier because the visual representation\n * of a character is a *grapheme* (approximately what the user thinks of\n * as a character). A *grapheme* is one or more *code points*, and can\n * essentially be arbitrarily long, as there are many ways to combine\n * them.\n *\n * The `this.modify(\u2026)` call has already extended our selection by one\n * *grapheme* in the direction we want to delete. Sounds great, it's done\n * a lot of awfully tricky work for us because this functionality has only\n * recently become available in JavaScript via `Intl.Segmenter`. The\n * problem is that in many cases the expected behavior of backspace or\n * delete is *not always to delete a whole grapheme*. In some languages\n * it's always expected that backspace ought to delete one code point, not the\n * whole grapheme. In other situations such as emoji that use variation\n * selectors you *do* want to delete the whole *grapheme*.\n *\n * In a few situations the behavior is even application dependent, such as\n * with latin languages where you have multiple ways to represent the same\n * character visually (e.g. a letter with an accent in one code point, or a\n * letter followed by a combining mark in a second code point); some apps will\n * delete the whole grapheme and others will delete only the combining mark,\n * probably based on whether they perform some sort of *normalization* on their\n * input to ensure that only one form is used when two sequences of code points\n * can represent the same visual character. Lexical currently chooses not\n * to perform any normalization so this type of combining marks will be\n * deleted as a *code point* without deleting the whole *grapheme*.\n *\n * See also:\n * https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-2/#G25564\n * https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-3/#G30602\n * https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-3/#G49537\n * https://mathiasbynens.be/notes/javascript-unicode\n */\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (shouldDeleteExactlyOneCodeUnit(text)) {\n        if (isBackward) {\n          focus.set(focus.key, characterOffset, focus.type);\n        } else {\n          anchor.set(anchor.key, characterOffset, anchor.type);\n        }\n      }\n    }\n  }\n}\nfunction shouldDeleteExactlyOneCodeUnit(text) {\n  {\n    if (!(text.length > 1)) {\n      formatDevErrorMessage(`shouldDeleteExactlyOneCodeUnit: expecting to be called only with sequences of two or more code units`);\n    }\n  }\n  return !(doesContainSurrogatePair(text) || doesContainEmoji(text));\n}\n\n/**\n * Given the wall of text in $updateCaretSelectionForUnicodeCharacter, you'd\n * think that the solution might be complex, but the only currently known\n * cases given the above constraints where we want to delete a whole grapheme\n * are when emoji is involved. Since ES6 we can use unicode character classes\n * in regexp which makes this simple.\n *\n * It may make sense to add to this heuristic in the future if other\n * edge cases are discovered, which is why detailed notes remain.\n *\n * This is implemented with runtime feature detection and will always\n * return false on pre-2020 platforms that do not have unicode character\n * class support.\n */\nconst doesContainEmoji = (() => {\n  try {\n    const re = new RegExp('\\\\p{Emoji}', 'u');\n    const test = re.test.bind(re);\n    // Sanity check a few emoji to make sure the regexp was parsed\n    // and works correctly. Any one of these should be sufficient,\n    // but they're cheap and it only runs once.\n    if (\n    // Emoji in the BMP (heart) with variation selector\n    test('\\u2764\\ufe0f') &&\n    // Emoji in the BMP (#) with variation selector\n    test('#\\ufe0f\\u20e3') &&\n    // Emoji outside the BMP (thumbs up) that is encoded with a surrogate pair\n    test('\\ud83d\\udc4d')) {\n      return test;\n    }\n  } catch (_e) {\n    // SyntaxError\n  }\n  // fallback, surrogate pair already checked\n  return () => false;\n})();\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (isHTMLElement(dom)) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = $getTextNodeOffset(resolvedNode, moveSelectionToEnd ? 'next' : 'previous');\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        const elementDOM = editor.getElementByKey(resolvedElement.getKey());\n        if (!(elementDOM !== null)) {\n          formatDevErrorMessage(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);\n        }\n        const slot = resolvedElement.getDOMSlot(elementDOM);\n        [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom, offset);\n        // This is just a typescript workaround, it is true but lost due to mutability\n        if (!$isElementNode(resolvedElement)) {\n          formatDevErrorMessage(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);\n        }\n        if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {\n          resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);\n        }\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = $getTextNodeOffset(child, moveSelectionToEnd ? 'next' : 'previous');\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          if (!$isElementNode(resolvedElement)) {\n            formatDevErrorMessage(`invariant`);\n          }\n          resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, $getTextNodeOffset(resolvedNode, resolvedOffset, 'clamp'), 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.set(prevSibling.__key, prevSibling.getChildrenSize(), 'element');\n      } else if ($isTextNode(prevSibling)) {\n        point.set(prevSibling.__key, prevSibling.getTextContent().length, 'text');\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.set(parentSibling.__key, parentSibling.getTextContent().length, 'text');\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.set(nextSibling.__key, 0, 'element');\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.set(parentSibling.__key, 0, 'text');\n      }\n    }\n  }\n}\nfunction $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.set(anchor.key, anchor.offset, anchor.type);\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      anchor.set(lastAnchor.key, lastAnchor.offset, lastAnchor.type, true);\n      focus.set(lastFocus.key, lastFocus.offset, lastFocus.type, true);\n    }\n  }\n}\nfunction $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  {\n    $validatePoint('anchor', resolvedAnchorPoint);\n    $validatePoint('focus', resolvedFocusPoint);\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $internalCreateSelection(editor, event) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(getWindow(editor));\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if ((isSelectionChange || eventType === undefined) && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $validatePoint(name, point) {\n  const node = $getNodeByKey(point.key);\n  if (!(node !== undefined)) {\n    formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} not found in current editorState`);\n  }\n  if (point.type === 'text') {\n    if (!$isTextNode(node)) {\n      formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not a TextNode`);\n    }\n    const size = node.getTextContentSize();\n    if (!(point.offset <= size)) {\n      formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getTextContentSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  } else {\n    if (!$isElementNode(node)) {\n      formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not an ElementNode`);\n    }\n    const size = node.getChildrenSize();\n    if (!(point.offset <= size)) {\n      formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getChildrenSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  }\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.set(key, point.offset + (isBefore ? 0 : textLength), 'text');\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.set(point.key, point.offset - 1, 'element');\n  }\n}\nfunction setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset) {\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    {\n      console.warn(error);\n    }\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has(COLLABORATION_TAG) && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      if (!tags.has(SKIP_SELECTION_FOCUS_TAG)) {\n        rootElement.focus({\n          preventScroll: true\n        });\n      }\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  setDOMSelectionBaseAndExtent(domSelection, nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  if (!tags.has(SKIP_SCROLL_INTO_VIEW_TAG) && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction $removeTextAndSplitBlock(selection) {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n  if (!$isRangeSelection(selection_)) {\n    formatDevErrorMessage(`Unexpected dirty selection to be null`);\n  }\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    const prevNode = node;\n    [node, offset] = $splitNodeAtPoint(node, offset);\n    if (prevNode.is(node)) {\n      break;\n    }\n  }\n  return offset;\n}\nfunction $splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Get all nodes in a CaretRange in a way that complies with all of the\n * quirks of the original RangeSelection.getNodes().\n *\n * @param range The CaretRange\n */\nfunction $getNodesFromCaretRangeCompat(\n// getNodes returned nodes in document order\nrange) {\n  const nodes = [];\n  const [beforeSlice, afterSlice] = range.getTextSlices();\n  if (beforeSlice) {\n    nodes.push(beforeSlice.caret.origin);\n  }\n  const seenAncestors = new Set();\n  const seenElements = new Set();\n  for (const caret of range) {\n    if ($isChildCaret(caret)) {\n      // Emulate the leading under-selection behavior of getNodes by\n      // ignoring the 'enter' of any ElementNode until we've seen a\n      // SiblingCaret\n      const {\n        origin\n      } = caret;\n      if (nodes.length === 0) {\n        seenAncestors.add(origin);\n      } else {\n        seenElements.add(origin);\n        nodes.push(origin);\n      }\n    } else {\n      const {\n        origin\n      } = caret;\n      if (!$isElementNode(origin) || !seenElements.has(origin)) {\n        nodes.push(origin);\n      }\n    }\n  }\n  if (afterSlice) {\n    nodes.push(afterSlice.caret.origin);\n  }\n  // Emulate the trailing underselection behavior when the last offset of\n  // an element is selected\n  if ($isSiblingCaret(range.focus) && $isElementNode(range.focus.origin) && range.focus.getNodeAtCaret() === null) {\n    for (let reverseCaret = $getChildCaret(range.focus.origin, 'previous'); $isChildCaret(reverseCaret) && seenAncestors.has(reverseCaret.origin) && !reverseCaret.origin.isEmpty() && reverseCaret.origin.is(nodes[nodes.length - 1]); reverseCaret = $getAdjacentChildCaret(reverseCaret)) {\n      seenAncestors.delete(reverseCaret.origin);\n      nodes.pop();\n    }\n  }\n  while (nodes.length > 1) {\n    const lastIncludedNode = nodes[nodes.length - 1];\n    if ($isElementNode(lastIncludedNode)) {\n      if (seenElements.has(lastIncludedNode) || lastIncludedNode.isEmpty() || seenAncestors.has(lastIncludedNode)) ; else {\n        nodes.pop();\n        continue;\n      }\n    }\n    break;\n  }\n  if (nodes.length === 0 && range.isCollapsed()) {\n    // Emulate the collapsed behavior of getNodes by returning the descendant\n    const normCaret = $normalizeCaret(range.anchor);\n    const flippedNormCaret = $normalizeCaret(range.anchor.getFlipped());\n    const $getCandidate = caret => $isTextPointCaret(caret) ? caret.origin : caret.getNodeAtCaret();\n    const node = $getCandidate(normCaret) || $getCandidate(flippedNormCaret) || (range.anchor.getNodeAtCaret() ? normCaret.origin : flippedNormCaret.origin);\n    nodes.push(node);\n  }\n  return nodes;\n}\n\n/**\n * @internal\n *\n * Modify the focus of the focus around possible decorators and blocks and return true\n * if the movement is done.\n */\nfunction $modifySelectionAroundDecoratorsAndBlocks(selection, alter, isBackward, granularity, mode = 'decorators-and-blocks') {\n  if (alter === 'move' && granularity === 'character' && !selection.isCollapsed()) {\n    // moving left or right when the selection isn't collapsed will\n    // just set the anchor to the focus or vice versa depending on\n    // direction\n    const [src, dst] = isBackward === selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];\n    dst.set(src.key, src.offset, src.type);\n    return true;\n  }\n  const initialFocus = $caretFromPoint(selection.focus, isBackward ? 'previous' : 'next');\n  const isLineBoundary = granularity === 'lineboundary';\n  const collapse = alter === 'move';\n  let focus = initialFocus;\n  let checkForBlock = mode === 'decorators-and-blocks';\n  if (!$isExtendableTextPointCaret(focus)) {\n    for (const siblingCaret of focus) {\n      checkForBlock = false;\n      const {\n        origin\n      } = siblingCaret;\n      if ($isDecoratorNode(origin) && !origin.isIsolated()) {\n        focus = siblingCaret;\n        if (isLineBoundary && origin.isInline()) {\n          continue;\n        }\n      }\n      break;\n    }\n    if (checkForBlock) {\n      for (const nextCaret of $extendCaretToRange(initialFocus).iterNodeCarets(alter === 'extend' ? 'shadowRoot' : 'root')) {\n        if ($isChildCaret(nextCaret)) {\n          if (!nextCaret.origin.isInline()) {\n            focus = nextCaret;\n          }\n        } else if ($isElementNode(nextCaret.origin)) {\n          continue;\n        } else if ($isDecoratorNode(nextCaret.origin) && !nextCaret.origin.isInline()) {\n          focus = nextCaret;\n        }\n        break;\n      }\n    }\n  }\n  if (focus === initialFocus) {\n    return false;\n  }\n  // After this point checkForBlock is true if and only if we moved to a\n  // different block, so we should stop regardless of the granularity\n  if (collapse && !isLineBoundary && $isDecoratorNode(focus.origin) && focus.origin.isKeyboardSelectable()) {\n    // Make it possible to move selection from range selection to\n    // node selection on the node.\n    const nodeSelection = $createNodeSelection();\n    nodeSelection.add(focus.origin.getKey());\n    $setSelection(nodeSelection);\n    return true;\n  }\n  focus = $normalizeCaret(focus);\n  if (collapse) {\n    $setPointFromCaret(selection.anchor, focus);\n  }\n  $setPointFromCaret(selection.focus, focus);\n  return checkForBlock || !isLineBoundary;\n}\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      formatDevErrorMessage(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      formatDevErrorMessage(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      formatDevErrorMessage(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      formatDevErrorMessage(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditor;\n}\nfunction collectBuildInformation() {\n  let compatibleEditors = 0;\n  const incompatibleEditors = new Set();\n  const thisVersion = LexicalEditor.version;\n  if (typeof window !== 'undefined') {\n    for (const node of document.querySelectorAll('[contenteditable]')) {\n      const editor = getEditorPropertyFromDOMNode(node);\n      if (isLexicalEditor(editor)) {\n        compatibleEditors++;\n      } else if (editor) {\n        let version = String(editor.constructor.version || '<0.17.1');\n        if (version === thisVersion) {\n          version += ' (separately built, likely a bundler configuration issue)';\n        }\n        incompatibleEditors.add(version);\n      }\n    }\n  }\n  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;\n  if (incompatibleEditors.size) {\n    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(', ')}`;\n  }\n  return output;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction internalGetActiveEditorState() {\n  return activeEditorState;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\nfunction addTags(editor, tags) {\n  if (!tags) {\n    return;\n  }\n  const updateTags = editor._updateTags;\n  let tags_ = tags;\n  if (!Array.isArray(tags)) {\n    tags_ = [tags];\n  }\n  for (const tag of tags_) {\n    updateTags.add(tag);\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n\n    // The root is always considered intentionally dirty if any attached node\n    // is dirty and by deleting and re-inserting we will apply its transforms\n    // last (e.g. its transform can be used as a sort of \"update finalizer\")\n    const rootDirty = untransformedDirtyElements.delete('root');\n    if (rootDirty) {\n      untransformedDirtyElements.set('root', true);\n    }\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n      if (!intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      formatDevErrorMessage(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  setPendingNodeToClone(null);\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editor, editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = editor;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction $commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(getWindow(editor));\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty || !pendingSelection.is(currentSelection)) && rootElement !== null && !tags.has(SKIP_DOM_SELECTION_TAG)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n    } finally {\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    mutatedNodes,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klassSet] = listeners[i];\n    for (const klass of klassSet) {\n      const mutatedNodesByType = mutatedNodes.get(klass);\n      if (mutatedNodesByType !== undefined) {\n        listener(mutatedNodesByType, {\n          dirtyLeaves,\n          prevEditorState,\n          updateTags\n        });\n      }\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          let returnVal = false;\n          updateEditorSync(currentEditor, () => {\n            for (let j = 0; j < listenersLength; j++) {\n              if (listeners[j](payload, editor)) {\n                returnVal = true;\n                return;\n              }\n            }\n          });\n          if (returnVal) {\n            return returnVal;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction $triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction $processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      const pendingEditorState = editor._pendingEditorState;\n      let onUpdate;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (options.discrete) {\n          if (!(pendingEditorState !== null)) {\n            formatDevErrorMessage(`Unexpected empty pending editor state on discrete nested update`);\n          }\n          pendingEditorState._flushSync = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        addTags(editor, options.tag);\n      }\n      if (pendingEditorState == null) {\n        $beginUpdate(editor, nextUpdateFn, options);\n      } else {\n        nextUpdateFn();\n      }\n    }\n  }\n  return skipTransforms;\n}\nfunction $beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    addTags(editor, options.tag);\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  const headless = editor._headless || editor.getRootElement() === null;\n  setPendingNodeToClone(null);\n  try {\n    if (editorStateWasCloned) {\n      if (headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor, options && options.event || null);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = $processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      $processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          formatDevErrorMessage(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\n/**\n * A variant of updateEditor that will not defer if it is nested in an update\n * to the same editor, much like if it was an editor.dispatchCommand issued\n * within an update\n */\nfunction updateEditorSync(editor, updateFn, options) {\n  if (activeEditor === editor && options === undefined) {\n    updateFn();\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/**\n * A utility class for managing the DOM children of an ElementNode\n */\nclass ElementDOMSlot {\n  element;\n  before;\n  after;\n  constructor(/** The element returned by createDOM */\n  element, /** All managed children will be inserted before this node, if defined */\n  before, /** All managed children will be inserted after this node, if defined */\n  after) {\n    this.element = element;\n    this.before = before || null;\n    this.after = after || null;\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted before this node\n   */\n  withBefore(before) {\n    return new ElementDOMSlot(this.element, before, this.after);\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted after this node\n   */\n  withAfter(after) {\n    return new ElementDOMSlot(this.element, this.before, after);\n  }\n  /**\n   * Return a new ElementDOMSlot with an updated root element\n   */\n  withElement(element) {\n    if (this.element === element) {\n      return this;\n    }\n    return new ElementDOMSlot(element, this.before, this.after);\n  }\n  /**\n   * Insert the given child before this.before and any reconciler managed line break node,\n   * or append it if this.before is not defined\n   */\n  insertChild(dom) {\n    const before = this.before || this.getManagedLineBreak();\n    if (!(before === null || before.parentElement === this.element)) {\n      formatDevErrorMessage(`ElementDOMSlot.insertChild: before is not in element`);\n    }\n    this.element.insertBefore(dom, before);\n    return this;\n  }\n  /**\n   * Remove the managed child from this container, will throw if it was not already there\n   */\n  removeChild(dom) {\n    if (!(dom.parentElement === this.element)) {\n      formatDevErrorMessage(`ElementDOMSlot.removeChild: dom is not in element`);\n    }\n    this.element.removeChild(dom);\n    return this;\n  }\n  /**\n   * Replace managed child prevDom with dom. Will throw if prevDom is not a child\n   *\n   * @param dom The new node to replace prevDom\n   * @param prevDom the node that will be replaced\n   */\n  replaceChild(dom, prevDom) {\n    if (!(prevDom.parentElement === this.element)) {\n      formatDevErrorMessage(`ElementDOMSlot.replaceChild: prevDom is not in element`);\n    }\n    this.element.replaceChild(dom, prevDom);\n    return this;\n  }\n  /**\n   * Returns the first managed child of this node,\n   * which will either be this.after.nextSibling or this.element.firstChild,\n   * and will never be this.before if it is defined.\n   */\n  getFirstChild() {\n    const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;\n    return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;\n  }\n  /**\n   * @internal\n   */\n  getManagedLineBreak() {\n    const element = this.element;\n    return element.__lexicalLineBreak || null;\n  }\n  /** @internal */\n  setManagedLineBreak(lineBreakType) {\n    if (lineBreakType === null) {\n      this.removeManagedLineBreak();\n    } else {\n      const webkitHack = lineBreakType === 'decorator' && (IS_APPLE_WEBKIT || IS_IOS || IS_SAFARI);\n      this.insertManagedLineBreak(webkitHack);\n    }\n  }\n\n  /** @internal */\n  removeManagedLineBreak() {\n    const br = this.getManagedLineBreak();\n    if (br) {\n      const element = this.element;\n      const sibling = br.nodeName === 'IMG' ? br.nextSibling : null;\n      if (sibling) {\n        element.removeChild(sibling);\n      }\n      element.removeChild(br);\n      element.__lexicalLineBreak = undefined;\n    }\n  }\n  /** @internal */\n  insertManagedLineBreak(webkitHack) {\n    const prevBreak = this.getManagedLineBreak();\n    if (prevBreak) {\n      if (webkitHack === (prevBreak.nodeName === 'IMG')) {\n        return;\n      }\n      this.removeManagedLineBreak();\n    }\n    const element = this.element;\n    const before = this.before;\n    const br = document.createElement('br');\n    element.insertBefore(br, before);\n    if (webkitHack) {\n      const img = document.createElement('img');\n      img.setAttribute('data-lexical-linebreak', 'true');\n      img.style.cssText = 'display: inline !important; border: 0px !important; margin: 0px !important;';\n      img.alt = '';\n      element.insertBefore(img, br);\n      element.__lexicalLineBreak = img;\n    } else {\n      element.__lexicalLineBreak = br;\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Returns the offset of the first child\n   */\n  getFirstChildOffset() {\n    let i = 0;\n    for (let node = this.after; node !== null; node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * @internal\n   */\n  resolveChildIndex(element, elementDOM, initialDOM, initialOffset) {\n    if (initialDOM === this.element) {\n      const firstChildOffset = this.getFirstChildOffset();\n      return [element, Math.min(firstChildOffset + element.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];\n    }\n    // The resolved offset must be before or after the children\n    const initialPath = indexPath(elementDOM, initialDOM);\n    initialPath.push(initialOffset);\n    const elementPath = indexPath(elementDOM, this.element);\n    let offset = element.getIndexWithinParent();\n    for (let i = 0; i < elementPath.length; i++) {\n      const target = initialPath[i];\n      const source = elementPath[i];\n      if (target === undefined || target < source) {\n        break;\n      } else if (target > source) {\n        offset += 1;\n        break;\n      }\n    }\n    return [element.getParentOrThrow(), offset];\n  }\n}\nfunction indexPath(root, child) {\n  const path = [];\n  let node = child;\n  for (; node !== root && node !== null; node = node.parentNode) {\n    let i = 0;\n    for (let sibling = node.previousSibling; sibling !== null; sibling = sibling.previousSibling) {\n      i++;\n    }\n    path.push(i);\n  }\n  if (!(node === root)) {\n    formatDevErrorMessage(`indexPath: root is not a parent of child`);\n  }\n  return path.reverse();\n}\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n  __first;\n  /** @internal */\n  __last;\n  /** @internal */\n  __size;\n  /** @internal */\n  __format;\n  /** @internal */\n  __style;\n  /** @internal */\n  __indent;\n  /** @internal */\n  __dir;\n  /** @internal */\n  __textFormat;\n  /** @internal */\n  __textStyle;\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__style = '';\n    this.__indent = 0;\n    this.__dir = null;\n    this.__textFormat = 0;\n    this.__textStyle = '';\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    if (this.__key === prevNode.__key) {\n      this.__first = prevNode.__first;\n      this.__last = prevNode.__last;\n      this.__size = prevNode.__size;\n    }\n    this.__indent = prevNode.__indent;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__dir = prevNode.__dir;\n    this.__textFormat = prevNode.__textFormat;\n    this.__textStyle = prevNode.__textStyle;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        formatDevErrorMessage(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        formatDevErrorMessage(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__textFormat;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n  getTextStyle() {\n    const self = this.getLatest();\n    return self.__textStyle;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style || '';\n    return this;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  setTextStyle(style) {\n    const self = this.getWritable();\n    self.__textStyle = style;\n    return self;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    if (!!$isEphemeral(this)) {\n      formatDevErrorMessage(`ElementNode.splice: Ephemeral nodes can not mutate their children (key ${this.__key} type ${this.__type})`);\n    }\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    if (!(start + deleteCount <= oldSize)) {\n      formatDevErrorMessage(`ElementNode.splice: start + deleteCount > oldSize (${String(start)} + ${String(deleteCount)} > ${String(oldSize)})`);\n    }\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsert.length;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            formatDevErrorMessage(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (const nodeToInsert of nodesToInsert) {\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          formatDevErrorMessage(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  /**\n   * @internal\n   *\n   * An experimental API that an ElementNode can override to control where its\n   * children are inserted into the DOM, this is useful to add a wrapping node\n   * or accessory nodes before or after the children. The root of the node returned\n   * by createDOM must still be exactly one HTMLElement.\n   */\n  getDOMSlot(element) {\n    return new ElementDOMSlot(element);\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML\n        // (see https://www.caniemail.com/features/css-padding-inline-start-end/),\n        // If you want to use HTML output for email, consider overriding the serialization\n        // to use `padding-right` in RTL languages, `padding-left` in `LTR` languages, or\n        // `text-indent` if you are ok with first-line indents.\n        // We recommend keeping multiples of 40px to maintain consistency with list-items\n        // (see https://github.com/facebook/lexical/pull/4025)\n        element.style.paddingInlineStart = `${indent * 40}px`;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  // JSON serialization\n  exportJSON() {\n    const json = {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n    const textFormat = this.getTextFormat();\n    const textStyle = this.getTextStyle();\n    if (textFormat !== 0) {\n      json.textFormat = textFormat;\n    }\n    if (textStyle !== '') {\n      json.textStyle = textStyle;\n    }\n    return json;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || '');\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0). You may use this to have the node replace\n   * itself, change its state, or do nothing. When you do make such\n   * a change, you should return true.\n   *\n   * When true is returned, the collapse phase will stop.\n   * When false is returned, and isInline() is true, and getPreviousSibling() is null,\n   * then this function will be called on its parent.\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hierarchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n  /**\n   * Determines whether this node, when empty, can merge with a first block\n   * of nodes being inserted.\n   *\n   * This method is specifically called in {@link RangeSelection.insertNodes}\n   * to determine merging behavior during nodes insertion.\n   *\n   * @example\n   * // In a ListItemNode or QuoteNode implementation:\n   * canMergeWhenEmpty(): true {\n   *  return true;\n   * }\n   */\n  canMergeWhenEmpty() {\n    return false;\n  }\n\n  /** @internal */\n  reconcileObservedMutation(dom, editor) {\n    const slot = this.getDOMSlot(dom);\n    let currentDOM = slot.getFirstChild();\n    for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {\n      const correctDOM = editor.getElementByKey(currentNode.getKey());\n      if (correctDOM === null) {\n        continue;\n      }\n      if (currentDOM == null) {\n        slot.insertChild(correctDOM);\n        currentDOM = correctDOM;\n      } else if (currentDOM !== correctDOM) {\n        slot.replaceChild(correctDOM, currentDOM);\n      }\n      currentDOM = currentDOM.nextSibling;\n    }\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass DecoratorNode extends LexicalNode {\n  /** @internal */\n\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    return null;\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n  __cachedText;\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      formatDevErrorMessage(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      formatDevErrorMessage(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      formatDevErrorMessage(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      formatDevErrorMessage(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      formatDevErrorMessage(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n  splice(start, deleteCount, nodesToInsert) {\n    for (const node of nodesToInsert) {\n      if (!($isElementNode(node) || $isDecoratorNode(node))) {\n        formatDevErrorMessage(`rootNode.splice: Only element or decorator nodes can be inserted to the root node`);\n      }\n    }\n    return super.splice(start, deleteCount, nodesToInsert);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    return $getRoot().updateFromJSON(serializedNode);\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\n/**\n * Type guard that returns true if the argument is an EditorState\n */\nfunction $isEditorState(x) {\n  return x instanceof EditorState;\n}\nclass EditorState {\n  _nodeMap;\n  _selection;\n  _flushSync;\n  _readOnly;\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn, options) {\n    return readEditorState(options && options.editor || null, this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(null, this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\n/** @internal */\nclass ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType() {\n    return 'artificial';\n  }\n  createDOM(config) {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: $convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createParagraphNode().updateFromJSON(serializedNode);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      // These are included explicitly for backwards compatibility\n      textFormat: this.getTextFormat(),\n      textStyle: this.getTextStyle()\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    newElement.setTextStyle(rangeSelection.style);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    newElement.setStyle(this.getStyle());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction $convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * A LexicalNode class or LexicalNodeReplacement configuration\n */\n\nconst DEFAULT_SKIP_INITIALIZATION = false;\n\n/**\n * The payload passed to an UpdateListener\n */\n\n/**\n * A listener that gets called after the editor is updated\n */\n\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   $handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function $handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/** @internal */\nfunction getTransformSetFromKlass(klass) {\n  const transforms = new Set();\n  const staticTransforms = new Set();\n  let currentKlass = klass;\n  while (currentKlass) {\n    const {\n      ownNodeConfig\n    } = getStaticNodeConfig(currentKlass);\n    const staticTransform = currentKlass.transform;\n    if (!staticTransforms.has(staticTransform)) {\n      staticTransforms.add(staticTransform);\n      const transform = currentKlass.transform();\n      if (transform) {\n        transforms.add(transform);\n      }\n    }\n    if (ownNodeConfig) {\n      const $transform = ownNodeConfig.$transform;\n      if ($transform) {\n        transforms.add($transform);\n      }\n      currentKlass = ownNodeConfig.extends;\n    } else {\n      const parent = Object.getPrototypeOf(currentKlass);\n      currentKlass = parent.prototype instanceof LexicalNode && parent !== LexicalNode ? parent : undefined;\n    }\n  }\n  return transforms;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // For the side-effect of filling in the static methods\n      void getStaticNodeConfig(klass);\n\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const name = klass.name;\n        const nodeType = hasOwnStaticMethod(klass, 'getType') && klass.getType();\n        if (replaceWithKlass) {\n          if (!(replaceWithKlass.prototype instanceof klass)) {\n            formatDevErrorMessage(`${replaceWithKlass.name} doesn't extend the ${name}`);\n          }\n        } else if (replace) {\n          console.warn(`Override for ${name} specifies 'replace' without 'withKlass'. 'withKlass' will be required in a future version.`);\n        }\n        if (name !== 'RootNode' && nodeType !== 'root' && nodeType !== 'artificial' &&\n        // This is mostly for the unit test suite which\n        // uses LexicalNode in an otherwise incorrect way\n        // by mocking its static getType\n        klass !== LexicalNode) {\n          ['getType', 'clone'].forEach(method => {\n            if (!hasOwnStaticMethod(klass, method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (!hasOwnStaticMethod(klass, 'importDOM') && hasOwnExportDOM(klass)) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (!hasOwnStaticMethod(klass, 'importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transforms = getTransformSetFromKlass(klass);\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        sharedNodeState: createSharedNodeState(nodes[i]),\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable, editorConfig);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** The version with build identifiers for this editor (since 0.17.1) */\n  static version;\n\n  /** @internal */\n  _headless;\n  /** @internal */\n  _parentEditor;\n  /** @internal */\n  _rootElement;\n  /** @internal */\n  _editorState;\n  /** @internal */\n  _pendingEditorState;\n  /** @internal */\n  _compositionKey;\n  /** @internal */\n  _deferred;\n  /** @internal */\n  _keyToDOMMap;\n  /** @internal */\n  _updates;\n  /** @internal */\n  _updating;\n  /** @internal */\n  _listeners;\n  /** @internal */\n  _commands;\n  /** @internal */\n  _nodes;\n  /** @internal */\n  _decorators;\n  /** @internal */\n  _pendingDecorators;\n  /** @internal */\n  _config;\n  /** @internal */\n  _dirtyType;\n  /** @internal */\n  _cloneNotNeeded;\n  /** @internal */\n  _dirtyLeaves;\n  /** @internal */\n  _dirtyElements;\n  /** @internal */\n  _normalizedNodes;\n  /** @internal */\n  _updateTags;\n  /** @internal */\n  _observer;\n  /** @internal */\n  _key;\n  /** @internal */\n  _onError;\n  /** @internal */\n  _htmlConversions;\n  /** @internal */\n  _window;\n  /** @internal */\n  _editable;\n  /** @internal */\n  _blockCursorElement;\n  /** @internal */\n  _createEditorArgs;\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable, createEditorArgs) {\n    this._createEditorArgs = createEditorArgs;\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.\n   * Listeners that run at a higher priority can \"intercept\" commands and\n   * prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners are always invoked in an {@link LexicalEditor.update} and can\n   * call dollar functions.\n   *\n   * Listeners registered at the same priority level will run\n   * deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   *   (or {@link COMMAND_PRIORITY_EDITOR} |\n   *     {@link COMMAND_PRIORITY_LOW} |\n   *     {@link COMMAND_PRIORITY_NORMAL} |\n   *     {@link COMMAND_PRIORITY_HIGH} |\n   *     {@link COMMAND_PRIORITY_CRITICAL})\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        formatDevErrorMessage(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        formatDevErrorMessage(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener\n   * will be called immediately with an updateTag of 'registerMutationListener' where all\n   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option\n   * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @param options - see {@link MutationListenerOptions}\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener, options) {\n    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;\n    const mutations = this._listeners.mutation;\n    let klassSet = mutations.get(listener);\n    if (klassSet === undefined) {\n      klassSet = new Set();\n      mutations.set(listener, klassSet);\n    }\n    klassSet.add(klassToMutate);\n    const skipInitialization = options && options.skipInitialization;\n    if (!(skipInitialization === undefined ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {\n      this.initializeMutationListener(listener, klassToMutate);\n    }\n    return () => {\n      klassSet.delete(klassToMutate);\n      if (klassSet.size === 0) {\n        mutations.delete(listener);\n      }\n    };\n  }\n\n  /** @internal */\n  getRegisteredNode(klass) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        formatDevErrorMessage(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  resolveRegisteredNodeAfterReplacements(registeredNode) {\n    while (registeredNode.replaceWithKlass) {\n      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  initializeMutationListener(listener, klass) {\n    const prevEditorState = this._editorState;\n    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());\n    if (!nodeMap) {\n      return;\n    }\n    const nodeMutationMap = new Map();\n    for (const k of nodeMap.keys()) {\n      nodeMutationMap.set(k, 'created');\n    }\n    if (nodeMutationMap.size > 0) {\n      listener(nodeMutationMap, {\n        dirtyLeaves: new Set(),\n        prevEditorState,\n        updateTags: new Set(['registerMutationListener'])\n      });\n    }\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const registeredNode = this.getRegisteredNode(klass);\n    registeredNode.transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markNodesWithTypesAsDirty(this, registeredNodes.map(node => node.klass.getType()));\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload. The command listeners\n   * will be triggered in an implicit {@link LexicalEditor.update}, unless\n   * this was invoked from inside an update in which case that update context\n   * will be re-used (as if this was a dollar function itself).\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add(HISTORY_MERGE_TAG);\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n        {\n          const nextRootElementParent = nextRootElement.parentElement;\n          if (nextRootElementParent != null && ['flex', 'inline-flex'].includes(getComputedStyle(nextRootElementParent).display)) {\n            console.warn(`When using \"display: flex\" or \"display: inline-flex\" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);\n          }\n        }\n      } else {\n        // When the content editable is unmounted we will still trigger a\n        // reconciliation so that any pending updates are flushed,\n        // to match the previous state change when\n        // `_editorState = pendingEditorState` was used, but by\n        // using a commit we preserve the readOnly invariant\n        // for editor.getEditorState().\n        this._window = null;\n        this._updateTags.add(HISTORY_MERGE_TAG);\n        $commitPendingUpdates(this);\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        formatDevErrorMessage(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    // Ensure that we have a writable EditorState so that transforms can run\n    // during a historic operation\n    let writableEditorState = editorState;\n    if (writableEditorState._readOnly) {\n      writableEditorState = cloneEditorState(editorState);\n      writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;\n    }\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      $commitPendingUpdates(this);\n    }\n    this._pendingEditorState = writableEditorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    // Only commit pending updates if not already in an editor.update\n    // (e.g. dispatchCommand) otherwise this will cause a second commit\n    // with an already read-only state and selection\n    if (!this._updating) {\n      $commitPendingUpdates(this);\n    }\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserialization from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes a read of the editor's state, with the\n   * editor context available (useful for exporting and read-only DOM\n   * operations). Much like update, but prevents any mutation of the\n   * editor's state. Any pending updates will be flushed immediately before\n   * the read.\n   * @param callbackFn - A function that has access to read-only editor state.\n   */\n  read(callbackFn) {\n    $commitPendingUpdates(this);\n    return this.getEditorState().read(callbackFn, {\n      editor: this\n    });\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor by marking the existing selection as dirty, or by\n   * creating a new selection at `defaultSelection` if one does not already\n   * exist. If you want to force a specific selection, you should call\n   * `root.selectStart()` or `root.selectEnd()` in an update.\n   *\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditorSync(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          if (!selection.dirty) {\n            $setSelection(selection.clone());\n          }\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n        $addUpdateTag(FOCUS_TAG);\n        $onUpdate(() => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        });\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occurring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\nLexicalEditor.version = \"0.38.2+dev.esm\";\n\nlet pendingNodeToClone = null;\nfunction setPendingNodeToClone(pendingNode) {\n  pendingNodeToClone = pendingNode;\n}\nfunction getPendingNodeToClone() {\n  const node = pendingNodeToClone;\n  pendingNodeToClone = null;\n  return node;\n}\nlet keyCounter = 1;\nfunction resetRandomKey() {\n  keyCounter = 1;\n}\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\n\n/**\n * @internal\n */\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = getRegisteredNode(editor, nodeType);\n  if (registeredNode === undefined) {\n    {\n      formatDevErrorMessage(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\n\n/**\n * @internal\n */\nfunction getRegisteredNode(editor, nodeType) {\n  return editor._nodes.get(nodeType);\n}\n\n/** @internal */\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (!isHTMLElement(activeElement)) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && getEditorPropertyFromDOMNode(activeElement) == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (_error) {\n    return false;\n  }\n}\n\n/**\n * @returns true if the given argument is a LexicalEditor instance from this build of Lexical\n */\nfunction isLexicalEditor(editor) {\n  // Check instanceof to prevent issues with multiple embedded Lexical installations\n  return editor instanceof LexicalEditor;\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const editor = getEditorPropertyFromDOMNode(currentNode);\n    if (isLexicalEditor(editor)) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\n\n/** @internal */\nfunction getEditorPropertyFromDOMNode(node) {\n  // @ts-expect-error: internal field\n  return node ? node.__lexicalEditor : null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\n\n/**\n * Return true if the TextNode is a TabNode or is in token mode.\n */\nfunction $isTokenOrTab(node) {\n  return $isTabNode(node) || node.isToken();\n}\n\n/**\n * Return true if the TextNode is a TabNode, or is in token or segmented mode.\n */\nfunction $isTokenOrSegmented(node) {\n  return $isTokenOrTab(node) || node.isSegmented();\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Text node, false otherwise.\n */\nfunction isDOMTextNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_TEXT_TYPE;\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Document node, false otherwise.\n */\nfunction isDOMDocumentNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_DOCUMENT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  } else if (type === 'lowercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'uppercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'capitalize') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  const pendingNode = getPendingNodeToClone();\n  existingKey = existingKey || pendingNode && pendingNode.__key;\n  if (existingKey != null) {\n    {\n      errorOnNodeKeyConstructorMismatch(node, existingKey, pendingNode);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction errorOnNodeKeyConstructorMismatch(node, existingKey, pendingNode) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (pendingNode) {\n    if (!(existingKey === pendingNode.__key)) {\n      formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} (type ${node.getType()}) has an incorrect clone implementation, got ${String(existingKey)} for nodeKey when expecting ${pendingNode.__key}`);\n    }\n  }\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      {\n        formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);\n      }\n    } else {\n      {\n        formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);\n      }\n    }\n  }\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\n/**\n * Removes a node from its parent, updating all necessary pointers and links.\n * @internal\n *\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n\n    // Store sibling keys\n    const nextSiblingKey = nextSibling !== null ? nextSibling.__key : null;\n    const prevSiblingKey = prevSibling !== null ? prevSibling.__key : null;\n\n    // Get writable siblings once\n    const writablePrevSibling = prevSibling !== null ? prevSibling.getWritable() : null;\n    const writableNextSibling = nextSibling !== null ? nextSibling.getWritable() : null;\n\n    // Update parent's first/last pointers\n    if (prevSibling === null) {\n      writableParent.__first = nextSiblingKey;\n    }\n    if (nextSibling === null) {\n      writableParent.__last = prevSiblingKey;\n    }\n\n    // Update sibling links\n    if (writablePrevSibling !== null) {\n      writablePrevSibling.__next = nextSiblingKey;\n    }\n    if (writableNextSibling !== null) {\n      writableNextSibling.__prev = prevSiblingKey;\n    }\n\n    // Clear node's links\n    writableNode.__prev = null;\n    writableNode.__next = null;\n    writableNode.__parent = null;\n\n    // Update parent size\n    writableParent.__size--;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  if (!!$isEphemeral(node)) {\n    formatDevErrorMessage(`internalMarkNodeAsDirty: Ephemeral nodes must not be marked as dirty (key ${node.__key} type ${node.__type})`);\n  }\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction $getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  const key = getNodeKeyFromDOMNode(dom, editor);\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction setNodeKeyOnDOMNode(dom, editor, key) {\n  const prop = `__lexicalKey_${editor._key}`;\n  dom[prop] = key;\n}\nfunction getNodeKeyFromDOMNode(dom, editor) {\n  const prop = `__lexicalKey_${editor._key}`;\n  return dom[prop];\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markNodesWithTypesAsDirty(editor, types) {\n  // We only need to mark nodes dirty if they were in the previous state.\n  // If they aren't, then they are by definition dirty already.\n  const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());\n  const dirtyNodeMaps = [];\n  for (const type of types) {\n    const nodeMap = cachedMap.get(type);\n    if (nodeMap) {\n      // By construction these are non-empty\n      dirtyNodeMaps.push(nodeMap);\n    }\n  }\n  // Nothing to mark dirty, no update necessary\n  if (dirtyNodeMaps.length === 0) {\n    return;\n  }\n  editor.update(() => {\n    for (const nodeMap of dirtyNodeMaps) {\n      for (const nodeKey of nodeMap.keys()) {\n        // We are only concerned with nodes that are still in the latest NodeMap,\n        // if they no longer exist then markDirty would raise an exception\n        const latest = $getNodeByKey(nodeKey);\n        if (latest) {\n          latest.markDirty();\n        }\n      }\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: HISTORY_MERGE_TAG\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          formatDevErrorMessage(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction $getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOMTree(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getNodeKeyFromDOMTree(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    const key = getNodeKeyFromDOMNode(node, editor);\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\n\n/**\n * Return true if `str` contains any valid surrogate pair.\n *\n * See also $updateCaretSelectionForUnicodeCharacter for\n * a discussion on when and why this is useful.\n */\nfunction doesContainSurrogatePair(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substring(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(getWindow(editor));\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        $setTextContentWithSelection(node, normalizedTextContent, selection);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      $setTextContentWithSelection(node, normalizedTextContent, selection);\n    }\n  }\n}\nfunction $setTextContentWithSelection(node, textContent, selection) {\n  node.setTextContent(textContent);\n  if ($isRangeSelection(selection)) {\n    const key = node.getKey();\n    for (const k of ['anchor', 'focus']) {\n      const pt = selection[k];\n      if (pt.type === 'text' && pt.key === key) {\n        pt.offset = $getTextNodeOffset(node, pt.offset, 'clamp');\n      }\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = $isTokenOrTab(node);\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\n\n/**\n * A KeyboardEvent or structurally similar object with a string `key` as well\n * as `altKey`, `ctrlKey`, `metaKey`, and `shiftKey` boolean properties.\n */\n\n/**\n * A record of keyboard modifiers that must be enabled.\n * If the value is `'any'` then the modifier key's state is ignored.\n * If the value is `true` then the modifier key must be pressed.\n * If the value is `false` or the property is omitted then the modifier key must\n * not be pressed.\n */\n\nfunction matchModifier(event, mask, prop) {\n  const expected = mask[prop] || false;\n  return expected === 'any' || expected === event[prop];\n}\n\n/**\n * Match a KeyboardEvent with its expected modifier state\n *\n * @param event A KeyboardEvent, or structurally similar object\n * @param mask An object specifying the expected state of the modifiers\n * @returns true if the event matches\n */\nfunction isModifierMatch(event, mask) {\n  return matchModifier(event, mask, 'altKey') && matchModifier(event, mask, 'ctrlKey') && matchModifier(event, mask, 'shiftKey') && matchModifier(event, mask, 'metaKey');\n}\n\n/**\n * Match a KeyboardEvent with its expected state\n *\n * @param event A KeyboardEvent, or structurally similar object\n * @param expectedKey The string to compare with event.key (case insensitive)\n * @param mask An object specifying the expected state of the modifiers\n * @returns true if the event matches\n */\nfunction isExactShortcutMatch(event, expectedKey, mask) {\n  return isModifierMatch(event, mask) && event.key.toLowerCase() === expectedKey.toLowerCase();\n}\nconst CONTROL_OR_META = {\n  ctrlKey: !IS_APPLE,\n  metaKey: IS_APPLE\n};\nconst CONTROL_OR_ALT = {\n  altKey: IS_APPLE,\n  ctrlKey: !IS_APPLE\n};\nfunction isTab(event) {\n  return isExactShortcutMatch(event, 'Tab', {\n    shiftKey: 'any'\n  });\n}\nfunction isBold(event) {\n  return isExactShortcutMatch(event, 'b', CONTROL_OR_META);\n}\nfunction isItalic(event) {\n  return isExactShortcutMatch(event, 'i', CONTROL_OR_META);\n}\nfunction isUnderline(event) {\n  return isExactShortcutMatch(event, 'u', CONTROL_OR_META);\n}\nfunction isParagraph(event) {\n  return isExactShortcutMatch(event, 'Enter', {\n    altKey: 'any',\n    ctrlKey: 'any',\n    metaKey: 'any'\n  });\n}\nfunction isLineBreak(event) {\n  return isExactShortcutMatch(event, 'Enter', {\n    altKey: 'any',\n    ctrlKey: 'any',\n    metaKey: 'any',\n    shiftKey: true\n  });\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(event) {\n  // 79 = KeyO\n  return IS_APPLE && isExactShortcutMatch(event, 'o', {\n    ctrlKey: true\n  });\n}\nfunction isDeleteWordBackward(event) {\n  return isExactShortcutMatch(event, 'Backspace', CONTROL_OR_ALT);\n}\nfunction isDeleteWordForward(event) {\n  return isExactShortcutMatch(event, 'Delete', CONTROL_OR_ALT);\n}\nfunction isDeleteLineBackward(event) {\n  return IS_APPLE && isExactShortcutMatch(event, 'Backspace', {\n    metaKey: true\n  });\n}\nfunction isDeleteLineForward(event) {\n  return IS_APPLE && (isExactShortcutMatch(event, 'Delete', {\n    metaKey: true\n  }) || isExactShortcutMatch(event, 'k', {\n    ctrlKey: true\n  }));\n}\nfunction isDeleteBackward(event) {\n  return isExactShortcutMatch(event, 'Backspace', {\n    shiftKey: 'any'\n  }) || IS_APPLE && isExactShortcutMatch(event, 'h', {\n    ctrlKey: true\n  });\n}\nfunction isDeleteForward(event) {\n  return isExactShortcutMatch(event, 'Delete', {}) || IS_APPLE && isExactShortcutMatch(event, 'd', {\n    ctrlKey: true\n  });\n}\nfunction isUndo(event) {\n  return isExactShortcutMatch(event, 'z', CONTROL_OR_META);\n}\nfunction isRedo(event) {\n  if (IS_APPLE) {\n    return isExactShortcutMatch(event, 'z', {\n      metaKey: true,\n      shiftKey: true\n    });\n  }\n  return isExactShortcutMatch(event, 'y', {\n    ctrlKey: true\n  }) || isExactShortcutMatch(event, 'z', {\n    ctrlKey: true,\n    shiftKey: true\n  });\n}\nfunction isCopy(event) {\n  return isExactShortcutMatch(event, 'c', CONTROL_OR_META);\n}\nfunction isCut(event) {\n  return isExactShortcutMatch(event, 'x', CONTROL_OR_META);\n}\nfunction isMoveBackward(event) {\n  return isExactShortcutMatch(event, 'ArrowLeft', {\n    shiftKey: 'any'\n  });\n}\nfunction isMoveToStart(event) {\n  return isExactShortcutMatch(event, 'ArrowLeft', CONTROL_OR_META);\n}\nfunction isMoveForward(event) {\n  return isExactShortcutMatch(event, 'ArrowRight', {\n    shiftKey: 'any'\n  });\n}\nfunction isMoveToEnd(event) {\n  return isExactShortcutMatch(event, 'ArrowRight', CONTROL_OR_META);\n}\nfunction isMoveUp(event) {\n  return isExactShortcutMatch(event, 'ArrowUp', {\n    altKey: 'any',\n    shiftKey: 'any'\n  });\n}\nfunction isMoveDown(event) {\n  return isExactShortcutMatch(event, 'ArrowDown', {\n    altKey: 'any',\n    shiftKey: 'any'\n  });\n}\nfunction isModifier(event) {\n  return event.ctrlKey || event.shiftKey || event.altKey || event.metaKey;\n}\nfunction isSpace(event) {\n  return event.key === ' ';\n}\nfunction isBackspace(event) {\n  return event.key === 'Backspace';\n}\nfunction isEscape(event) {\n  return event.key === 'Escape';\n}\nfunction isDelete(event) {\n  return event.key === 'Delete';\n}\nfunction isSelectAll(event) {\n  return isExactShortcutMatch(event, 'a', CONTROL_OR_META);\n}\nfunction $selectAll(selection) {\n  const root = $getRoot();\n  if ($isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const topParent = anchorNode.getTopLevelElementOrThrow();\n    const rootNode = topParent.getParentOrThrow();\n    anchor.set(rootNode.getKey(), 0, 'element');\n    focus.set(rootNode.getKey(), rootNode.getChildrenSize(), 'element');\n    $normalizeSelection(selection);\n    return selection;\n  } else {\n    // Create a new RangeSelection\n    const newSelection = root.select(0, root.getChildrenSize());\n    $setSelection($normalizeSelection(newSelection));\n    return newSelection;\n  }\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      formatDevErrorMessage(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\n/**\n * @deprecated Use {@link LexicalEditor.registerMutationListener} with `skipInitialization: false` instead.\n */\nfunction $nodesOfType(klass) {\n  const klassType = klass.getType();\n  const editorState = getActiveEditorState();\n  if (editorState._readOnly) {\n    const nodes = getCachedTypeToNodeMap(editorState).get(klassType);\n    return nodes ? Array.from(nodes.values()) : [];\n  }\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && node.isAttached()) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return isDocumentFragment(parentElement) ? parentElement.host : parentElement;\n}\nfunction getDOMOwnerDocument(target) {\n  return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = getDOMOwnerDocument(rootElement);\n  const defaultView = getDefaultView(doc);\n  if (doc === null || defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\n\n/**\n * Add a function to run after the current update. This will run after any\n * `onUpdate` function already supplied to `editor.update()`, as well as any\n * functions added with previous calls to `$onUpdate`.\n *\n * @param updateFn The function to run after the current update.\n */\nfunction $onUpdate(updateFn) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._deferred.push(updateFn);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = getDOMOwnerDocument(domElem);\n  return ownerDoc ? ownerDoc.defaultView : null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      formatDevErrorMessage(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\n\n/**\n * Returns a shallow clone of node with a new key. All properties of the node\n * will be copied to the new node (by `clone` and then `afterCloneFrom`),\n * except those related to parent/sibling/child\n * relationships in the `EditorState`. This means that the copy must be\n * separately added to the document, and it will not have any children.\n *\n * @param node - The node to be copied.\n * @returns The copy of the node.\n */\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  copy.afterCloneFrom(node);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.getType();\n  const registeredNode = getRegisteredNode(editor, nodeType);\n  if (!(registeredNode !== undefined)) {\n    formatDevErrorMessage(`$applyNodeReplacement node ${node.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n  }\n  const {\n    replace,\n    replaceWithKlass\n  } = registeredNode;\n  if (replace !== null) {\n    const replacementNode = replace(node);\n    const replacementNodeKlass = replacementNode.constructor;\n    if (replaceWithKlass !== null) {\n      if (!(replacementNode instanceof replaceWithKlass)) {\n        formatDevErrorMessage(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node.constructor.name} with type ${nodeType}`);\n      }\n    } else {\n      if (!(replacementNode instanceof node.constructor && replacementNodeKlass !== node.constructor)) {\n        formatDevErrorMessage(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node.constructor.name} with type ${nodeType}.`);\n      }\n    }\n    if (!(replacementNode.__key !== node.__key)) {\n      formatDevErrorMessage(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      formatDevErrorMessage(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n  if (node === null) {\n    {\n      formatDevErrorMessage(`Expected node with key ${key} to exist but it's not in the nodeMap.`);\n    }\n  }\n  return node;\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (child !== null && needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\n\n/**\n * Returns the selection for the given window, or the global window if null.\n * Will return null if {@link CAN_USE_DOM} is false.\n *\n * @param targetWindow The window to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\n\n/**\n * Returns the selection for the defaultView of the ownerDocument of given EventTarget.\n *\n * @param eventTarget The node to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelectionFromTarget(eventTarget) {\n  const defaultView = getDefaultView(eventTarget);\n  return defaultView ? defaultView.getSelection() : null;\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    formatDevErrorMessage(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        formatDevErrorMessage(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  return isDOMNode(x) && x.nodeType === DOM_ELEMENT_TYPE;\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is a DOM Node, false otherwise.\n */\nfunction isDOMNode(x) {\n  return typeof x === 'object' && x !== null && 'nodeType' in x && typeof x.nodeType === 'number';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is a document fragment, false otherwise.\n */\nfunction isDocumentFragment(x) {\n  return isDOMNode(x) && x.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nfunction isInlineDomNode(node) {\n  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|mark|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, 'i');\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nfunction isBlockDomNode(node) {\n  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, 'i');\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * @internal\n *\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n *\n * This function returns true for a DecoratorNode that is not inline OR\n * an ElementNode that is:\n * - not a root or shadow root\n * - not inline\n * - can't be empty\n * - has no children or an inline first child\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/** @internal */\n\n/**\n * @internal\n * Compute a cached Map of node type to nodes for a frozen EditorState\n */\nconst cachedNodeMaps = new WeakMap();\nconst EMPTY_TYPE_TO_NODE_MAP = new Map();\nfunction getCachedTypeToNodeMap(editorState) {\n  // If this is a new Editor it may have a writable this._editorState\n  // with only a 'root' entry.\n  if (!editorState._readOnly && editorState.isEmpty()) {\n    return EMPTY_TYPE_TO_NODE_MAP;\n  }\n  if (!editorState._readOnly) {\n    formatDevErrorMessage(`getCachedTypeToNodeMap called with a writable EditorState`);\n  }\n  let typeToNodeMap = cachedNodeMaps.get(editorState);\n  if (!typeToNodeMap) {\n    typeToNodeMap = computeTypeToNodeMap(editorState);\n    cachedNodeMaps.set(editorState, typeToNodeMap);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * @internal\n * Compute a Map of node type to nodes for an EditorState\n */\nfunction computeTypeToNodeMap(editorState) {\n  const typeToNodeMap = new Map();\n  for (const [nodeKey, node] of editorState._nodeMap) {\n    const nodeType = node.__type;\n    let nodeMap = typeToNodeMap.get(nodeType);\n    if (!nodeMap) {\n      nodeMap = new Map();\n      typeToNodeMap.set(nodeType, nodeMap);\n    }\n    nodeMap.set(nodeKey, node);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * Returns a clone of a node using `node.constructor.clone()` followed by\n * `clone.afterCloneFrom(node)`. The resulting clone must have the same key,\n * parent/next/prev pointers, and other properties that are not set by\n * `node.constructor.clone` (format, style, etc.). This is primarily used by\n * {@link LexicalNode.getWritable} to create a writable version of an\n * existing node. The clone is the same logical node as the original node,\n * do not try and use this function to duplicate or copy an existing node.\n *\n * Does not mutate the EditorState.\n * @param latestNode - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(latestNode) {\n  const constructor = latestNode.constructor;\n  const mutableNode = constructor.clone(latestNode);\n  mutableNode.afterCloneFrom(latestNode);\n  {\n    if (!(mutableNode.__key === latestNode.__key)) {\n      formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);\n    }\n    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {\n      formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrode afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);\n    }\n  }\n  return mutableNode;\n}\n\n/**\n * Returns a clone with {@link $cloneWithProperties} and then \"detaches\"\n * it from the state by overriding its getLatest and getWritable to always\n * return this. This node can not be added to an EditorState or become the\n * parent, child, or sibling of another node. It is primarily only useful\n * for making in-place temporary modifications to a TextNode when\n * serializing a partial slice.\n *\n * Does not mutate the EditorState.\n * @param latestNode - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithPropertiesEphemeral(latestNode) {\n  return $markEphemeral($cloneWithProperties(latestNode));\n}\nfunction setNodeIndentFromDOM(elementDom, elementNode) {\n  const indentSize = parseInt(elementDom.style.paddingInlineStart, 10) || 0;\n  const indent = Math.round(indentSize / 40);\n  elementNode.setIndent(indent);\n}\n\n/**\n * @internal\n *\n * Mark this node as unmanaged by lexical's mutation observer like\n * decorator nodes\n */\nfunction setDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  el.__lexicalUnmanaged = true;\n}\n\n/**\n * @internal\n *\n * True if this DOM node was marked with {@link setDOMUnmanaged}\n */\nfunction isDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  return el.__lexicalUnmanaged === true;\n}\n\n/**\n * @internal\n *\n * Object.hasOwn ponyfill\n */\nfunction hasOwn(o, k) {\n  return Object.prototype.hasOwnProperty.call(o, k);\n}\n\n/**\n * @internal\n */\nfunction hasOwnStaticMethod(klass, k) {\n  return hasOwn(klass, k) && klass[k] !== LexicalNode[k];\n}\n\n/**\n * @internal\n */\nfunction hasOwnExportDOM(klass) {\n  return hasOwn(klass.prototype, 'exportDOM');\n}\n\n/** @internal */\nfunction isAbstractNodeClass(klass) {\n  if (!(klass === LexicalNode || klass.prototype instanceof LexicalNode)) {\n    let ownNodeType = '<unknown>';\n    let version = '<unknown>';\n    try {\n      ownNodeType = klass.getType();\n    } catch (_err) {\n      // ignore\n    }\n    try {\n      if (LexicalEditor.version) {\n        version = JSON.parse(LexicalEditor.version);\n      }\n    } catch (_err) {\n      // ignore\n    }\n    {\n      formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) does not subclass LexicalNode from the lexical package used by this editor (version ${version}). All lexical and @lexical/* packages used by an editor must have identical versions. If you suspect the version does match, then the problem may be caused by multiple copies of the same lexical module (e.g. both esm and cjs, or included directly in multiple entrypoints).`);\n    }\n  }\n  return klass === DecoratorNode || klass === ElementNode || klass === LexicalNode;\n}\n\n/** @internal */\nfunction getStaticNodeConfig(klass) {\n  const nodeConfigRecord = PROTOTYPE_CONFIG_METHOD in klass.prototype ? klass.prototype[PROTOTYPE_CONFIG_METHOD]() : undefined;\n  const isAbstract = isAbstractNodeClass(klass);\n  const nodeType = !isAbstract && hasOwnStaticMethod(klass, 'getType') ? klass.getType() : undefined;\n  let ownNodeConfig;\n  let ownNodeType = nodeType;\n  if (nodeConfigRecord) {\n    if (nodeType) {\n      ownNodeConfig = nodeConfigRecord[nodeType];\n    } else {\n      for (const [k, v] of Object.entries(nodeConfigRecord)) {\n        ownNodeType = k;\n        ownNodeConfig = v;\n      }\n    }\n  }\n  if (!isAbstract && ownNodeType) {\n    if (!hasOwnStaticMethod(klass, 'getType')) {\n      klass.getType = () => ownNodeType;\n    }\n    if (!hasOwnStaticMethod(klass, 'clone')) {\n      // TextNode.length > 0 will only be true if the compiler output\n      // is not ES6 compliant, in which case we can not provide this\n      // warning\n      if (TextNode.length === 0) {\n        if (!(klass.length === 0)) {\n          formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) must implement a static clone method since its constructor has ${String(klass.length)} required arguments (expecting 0). Use an explicit default in the first argument of your constructor(prop: T=X, nodeKey?: NodeKey).`);\n        }\n      }\n      klass.clone = prevNode => {\n        setPendingNodeToClone(prevNode);\n        return new klass();\n      };\n    }\n    if (!hasOwnStaticMethod(klass, 'importJSON')) {\n      if (TextNode.length === 0) {\n        if (!(klass.length === 0)) {\n          formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) must implement a static importJSON method since its constructor has ${String(klass.length)} required arguments (expecting 0). Use an explicit default in the first argument of your constructor(prop: T=X, nodeKey?: NodeKey).`);\n        }\n      }\n      klass.importJSON = ownNodeConfig && ownNodeConfig.$importJSON || (serializedNode => new klass().updateFromJSON(serializedNode));\n    }\n    if (!hasOwnStaticMethod(klass, 'importDOM') && ownNodeConfig) {\n      const {\n        importDOM\n      } = ownNodeConfig;\n      if (importDOM) {\n        klass.importDOM = () => importDOM;\n      }\n    }\n  }\n  return {\n    ownNodeConfig,\n    ownNodeType\n  };\n}\n\n/**\n * Create an node from its class.\n *\n * Note that this will directly construct the final `withKlass` node type,\n * and will ignore the deprecated `with` functions. This allows `$create` to\n * skip any intermediate steps where the replaced node would be created and\n * then immediately discarded (once per configured replacement of that node).\n *\n * This does not support any arguments to the constructor.\n * Setters can be used to initialize your node, and they can\n * be chained. You can of course write your own mutliple-argument functions\n * to wrap that.\n *\n * @example\n * ```ts\n * function $createTokenText(text: string): TextNode {\n *   return $create(TextNode).setTextContent(text).setMode('token');\n * }\n * ```\n */\nfunction $create(klass) {\n  const editor = $getEditor();\n  errorOnReadOnly();\n  const registeredNode = editor.resolveRegisteredNodeAfterReplacements(editor.getRegisteredNode(klass));\n  return new registeredNode.klass();\n}\n\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns `startingNode` or one of its ancestors that matches the `findFn` predicate and is not the `RootNode`, or `null` if no match was found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr != null && !$isRootNode(curr)) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * The direction of a caret, 'next' points towards the end of the document\n * and 'previous' points towards the beginning\n */\n\n/**\n * A type utility to flip next and previous\n */\n\n/**\n * A sibling caret type points from a LexicalNode origin to its next or previous sibling,\n * and a child caret type points from an ElementNode origin to its first or last child.\n */\n\n/**\n * The RootMode is specified in all caret traversals where the traversal can go up\n * towards the root. 'root' means that it will stop at the document root,\n * and 'shadowRoot' will stop at the document root or any shadow root\n * (per {@link $isRootOrShadowRoot}).\n */\n\nconst FLIP_DIRECTION = {\n  next: 'previous',\n  previous: 'next'\n};\n\n/** @noInheritDoc */\n\n/**\n * A RangeSelection expressed as a pair of Carets\n */\n\n/**\n * A NodeCaret is the combination of an origin node and a direction\n * that points towards where a connected node will be fetched, inserted,\n * or replaced. A SiblingCaret points from a node to its next or previous\n * sibling, and a ChildCaret points to its first or last child\n * (using next or previous as direction, for symmetry with SiblingCaret).\n *\n * The differences between NodeCaret and PointType are:\n * - NodeCaret can only be used to refer to an entire node (PointCaret is used when a full analog is needed). A PointType of text type can be used to refer to a specific location inside of a TextNode.\n * - NodeCaret stores an origin node, type (sibling or child), and direction (next or previous). A PointType stores a type (text or element), the key of a node, and a text or child offset within that node.\n * - NodeCaret is directional and always refers to a very specific node, eliminating all ambiguity. PointType can refer to the location before or at a node depending on context.\n * - NodeCaret is more robust to nearby mutations, as it relies only on a node's direct connections. An element Any change to the count of previous siblings in an element PointType will invalidate it.\n * - NodeCaret is designed to work more directly with the internal representation of the document tree, making it suitable for use in traversals without performing any redundant work.\n *\n * The caret does *not* update in response to any mutations, you should\n * not persist it across editor updates, and using a caret after its origin\n * node has been removed or replaced may result in runtime errors.\n */\n\n/**\n * A PointCaret is a NodeCaret that also includes a\n * TextPointCaret type which refers to a specific offset of a TextNode.\n * This type is separate because it is not relevant to general node traversal\n * so it doesn't make sense to have it show up except when defining\n * a CaretRange and in those cases there will be at most two of them only\n * at the boundaries.\n *\n * The addition of TextPointCaret allows this type to represent any location\n * that is representable by PointType, as the TextPointCaret refers to a\n * specific offset within a TextNode.\n */\n\n/**\n * A SiblingCaret points from an origin LexicalNode towards its next or previous sibling.\n */\n\n/**\n * A ChildCaret points from an origin ElementNode towards its first or last child.\n */\n\n/**\n * A TextPointCaret is a special case of a SiblingCaret that also carries\n * an offset used for representing partially selected TextNode at the edges\n * of a CaretRange.\n *\n * The direction determines which part of the text is adjacent to the caret,\n * if next it's all of the text after offset. If previous, it's all of the\n * text before offset.\n *\n * While this can be used in place of any SiblingCaret of a TextNode,\n * the offset into the text will be ignored except in contexts that\n * specifically use the TextPointCaret or PointCaret types.\n */\n\n/**\n * A TextPointCaretSlice is a wrapper for a TextPointCaret that carries a signed\n * distance representing the direction and amount of text selected from the given\n * caret. A negative distance means that text before offset is selected, a\n * positive distance means that text after offset is selected. The offset+distance\n * pair is not affected in any way by the direction of the caret.\n */\n\n/**\n * A utility type to specify that a CaretRange may have zero,\n * one, or two associated TextPointCaretSlice. If the anchor\n * and focus are on the same node, the anchorSlice will contain\n * the slice and focusSlie will be null.\n */\n\nclass AbstractCaret {\n  origin;\n  constructor(origin) {\n    this.origin = origin;\n  }\n  [Symbol.iterator]() {\n    return makeStepwiseIterator({\n      hasNext: $isSiblingCaret,\n      initial: this.getAdjacentCaret(),\n      map: caret => caret,\n      step: caret => caret.getAdjacentCaret()\n    });\n  }\n  getAdjacentCaret() {\n    return $getSiblingCaret(this.getNodeAtCaret(), this.direction);\n  }\n  getSiblingCaret() {\n    return $getSiblingCaret(this.origin, this.direction);\n  }\n  remove() {\n    const node = this.getNodeAtCaret();\n    if (node) {\n      node.remove();\n    }\n    return this;\n  }\n  replaceOrInsert(node, includeChildren) {\n    const target = this.getNodeAtCaret();\n    if (node.is(this.origin) || node.is(target)) ; else if (target === null) {\n      this.insert(node);\n    } else {\n      target.replace(node, includeChildren);\n    }\n    return this;\n  }\n  splice(deleteCount, nodes, nodesDirection = 'next') {\n    const nodeIter = nodesDirection === this.direction ? nodes : Array.from(nodes).reverse();\n    let caret = this;\n    const parent = this.getParentAtCaret();\n    const nodesToRemove = new Map();\n    // Find all of the nodes we expect to remove first, so\n    // we don't have to worry about the cases where there is\n    // overlap between the nodes to insert and the nodes to\n    // remove\n    for (let removeCaret = caret.getAdjacentCaret(); removeCaret !== null && nodesToRemove.size < deleteCount; removeCaret = removeCaret.getAdjacentCaret()) {\n      const writableNode = removeCaret.origin.getWritable();\n      nodesToRemove.set(writableNode.getKey(), writableNode);\n    }\n    // TODO: Optimize this to work directly with node internals\n    for (const node of nodeIter) {\n      if (nodesToRemove.size > 0) {\n        // For some reason `npm run tsc-extension` needs this annotation?\n        const target = caret.getNodeAtCaret();\n        if (target) {\n          nodesToRemove.delete(target.getKey());\n          nodesToRemove.delete(node.getKey());\n          if (target.is(node) || caret.origin.is(node)) ; else {\n            const nodeParent = node.getParent();\n            if (nodeParent && nodeParent.is(parent)) {\n              // It's a sibling somewhere else in this node, so unparent it first\n              node.remove();\n            }\n            target.replace(node);\n          }\n        } else {\n          if (!(target !== null)) {\n            formatDevErrorMessage(`NodeCaret.splice: Underflow of expected nodesToRemove during splice (keys: ${Array.from(nodesToRemove).join(' ')})`);\n          }\n        }\n      } else {\n        caret.insert(node);\n      }\n      caret = $getSiblingCaret(node, this.direction);\n    }\n    for (const node of nodesToRemove.values()) {\n      node.remove();\n    }\n    return this;\n  }\n}\nclass AbstractChildCaret extends AbstractCaret {\n  type = 'child';\n  getLatest() {\n    const origin = this.origin.getLatest();\n    return origin === this.origin ? this : $getChildCaret(origin, this.direction);\n  }\n  /**\n   * Get the SiblingCaret from this origin in the same direction.\n   *\n   * @param mode 'root' to return null at the root, 'shadowRoot' to return null at the root or any shadow root\n   * @returns A SiblingCaret with this origin, or null if origin is a root according to mode.\n   */\n  getParentCaret(mode = 'root') {\n    return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);\n  }\n  getFlipped() {\n    const dir = flipDirection(this.direction);\n    return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin, dir);\n  }\n  getParentAtCaret() {\n    return this.origin;\n  }\n  getChildCaret() {\n    return this;\n  }\n  isSameNodeCaret(other) {\n    return other instanceof AbstractChildCaret && this.direction === other.direction && this.origin.is(other.origin);\n  }\n  isSamePointCaret(other) {\n    return this.isSameNodeCaret(other);\n  }\n}\nclass ChildCaretFirst extends AbstractChildCaret {\n  direction = 'next';\n  getNodeAtCaret() {\n    return this.origin.getFirstChild();\n  }\n  insert(node) {\n    this.origin.splice(0, 0, [node]);\n    return this;\n  }\n}\nclass ChildCaretLast extends AbstractChildCaret {\n  direction = 'previous';\n  getNodeAtCaret() {\n    return this.origin.getLastChild();\n  }\n  insert(node) {\n    this.origin.splice(this.origin.getChildrenSize(), 0, [node]);\n    return this;\n  }\n}\nconst MODE_PREDICATE = {\n  root: $isRootNode,\n  shadowRoot: $isRootOrShadowRoot\n};\n\n/**\n * Flip a direction ('next' -> 'previous'; 'previous' -> 'next').\n *\n * Note that TypeScript can't prove that FlipDirection is its own\n * inverse (but if you have a concrete 'next' or 'previous' it will\n * simplify accordingly).\n *\n * @param direction A direction\n * @returns The opposite direction\n */\nfunction flipDirection(direction) {\n  return FLIP_DIRECTION[direction];\n}\nfunction $filterByMode(node, mode = 'root') {\n  return MODE_PREDICATE[mode](node) ? null : node;\n}\nclass AbstractSiblingCaret extends AbstractCaret {\n  type = 'sibling';\n  getLatest() {\n    const origin = this.origin.getLatest();\n    return origin === this.origin ? this : $getSiblingCaret(origin, this.direction);\n  }\n  getSiblingCaret() {\n    return this;\n  }\n  getParentAtCaret() {\n    return this.origin.getParent();\n  }\n  getChildCaret() {\n    return $isElementNode(this.origin) ? $getChildCaret(this.origin, this.direction) : null;\n  }\n  getParentCaret(mode = 'root') {\n    return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);\n  }\n  getFlipped() {\n    const dir = flipDirection(this.direction);\n    return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin.getParentOrThrow(), dir);\n  }\n  isSamePointCaret(other) {\n    return other instanceof AbstractSiblingCaret && this.direction === other.direction && this.origin.is(other.origin);\n  }\n  isSameNodeCaret(other) {\n    return (other instanceof AbstractSiblingCaret || other instanceof AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);\n  }\n}\nclass AbstractTextPointCaret extends AbstractCaret {\n  type = 'text';\n  offset;\n  constructor(origin, offset) {\n    super(origin);\n    this.offset = offset;\n  }\n  getLatest() {\n    const origin = this.origin.getLatest();\n    return origin === this.origin ? this : $getTextPointCaret(origin, this.direction, this.offset);\n  }\n  getParentAtCaret() {\n    return this.origin.getParent();\n  }\n  getChildCaret() {\n    return null;\n  }\n  getParentCaret(mode = 'root') {\n    return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);\n  }\n  getFlipped() {\n    return $getTextPointCaret(this.origin, flipDirection(this.direction), this.offset);\n  }\n  isSamePointCaret(other) {\n    return other instanceof AbstractTextPointCaret && this.direction === other.direction && this.origin.is(other.origin) && this.offset === other.offset;\n  }\n  isSameNodeCaret(other) {\n    return (other instanceof AbstractSiblingCaret || other instanceof AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);\n  }\n  getSiblingCaret() {\n    return $getSiblingCaret(this.origin, this.direction);\n  }\n}\n/**\n * Guard to check if the given caret is specifically a TextPointCaret\n *\n * @param caret Any caret\n * @returns true if it is a TextPointCaret\n */\nfunction $isTextPointCaret(caret) {\n  return caret instanceof AbstractTextPointCaret;\n}\n\n/**\n * Guard to check if the given argument is any type of caret\n *\n * @param caret\n * @returns true if caret is any type of caret\n */\nfunction $isNodeCaret(caret) {\n  return caret instanceof AbstractCaret;\n}\n\n/**\n * Guard to check if the given argument is specifically a SiblingCaret (or TextPointCaret)\n *\n * @param caret\n * @returns true if caret is a SiblingCaret\n */\nfunction $isSiblingCaret(caret) {\n  return caret instanceof AbstractSiblingCaret;\n}\n\n/**\n * Guard to check if the given argument is specifically a ChildCaret\n\n * @param caret \n * @returns true if caret is a ChildCaret\n */\nfunction $isChildCaret(caret) {\n  return caret instanceof AbstractChildCaret;\n}\nclass SiblingCaretNext extends AbstractSiblingCaret {\n  direction = 'next';\n  getNodeAtCaret() {\n    return this.origin.getNextSibling();\n  }\n  insert(node) {\n    this.origin.insertAfter(node);\n    return this;\n  }\n}\nclass SiblingCaretPrevious extends AbstractSiblingCaret {\n  direction = 'previous';\n  getNodeAtCaret() {\n    return this.origin.getPreviousSibling();\n  }\n  insert(node) {\n    this.origin.insertBefore(node);\n    return this;\n  }\n}\nclass TextPointCaretNext extends AbstractTextPointCaret {\n  direction = 'next';\n  getNodeAtCaret() {\n    return this.origin.getNextSibling();\n  }\n  insert(node) {\n    this.origin.insertAfter(node);\n    return this;\n  }\n}\nclass TextPointCaretPrevious extends AbstractTextPointCaret {\n  direction = 'previous';\n  getNodeAtCaret() {\n    return this.origin.getPreviousSibling();\n  }\n  insert(node) {\n    this.origin.insertBefore(node);\n    return this;\n  }\n}\nconst TEXT_CTOR = {\n  next: TextPointCaretNext,\n  previous: TextPointCaretPrevious\n};\nconst SIBLING_CTOR = {\n  next: SiblingCaretNext,\n  previous: SiblingCaretPrevious\n};\nconst CHILD_CTOR = {\n  next: ChildCaretFirst,\n  previous: ChildCaretLast\n};\n\n/**\n * Get a caret that points at the next or previous sibling of the given origin node.\n *\n * @param origin The origin node\n * @param direction 'next' or 'previous'\n * @returns null if origin is null, otherwise a SiblingCaret for this origin and direction\n */\n\nfunction $getSiblingCaret(origin, direction) {\n  return origin ? new SIBLING_CTOR[direction](origin) : null;\n}\n\n/**\n * Construct a TextPointCaret\n *\n * @param origin The TextNode\n * @param direction The direction (next points to the end of the text, previous points to the beginning)\n * @param offset The offset into the text in absolute positive string coordinates (0 is the start)\n * @returns a TextPointCaret\n */\n\nfunction $getTextPointCaret(origin, direction, offset) {\n  return origin ? new TEXT_CTOR[direction](origin, $getTextNodeOffset(origin, offset)) : null;\n}\n\n/**\n * Get a normalized offset into a TextNode given a numeric offset or a\n * direction for which end of the string to use. Throws in dev if the offset\n * is not in the bounds of the text content size.\n *\n * @param origin a TextNode\n * @param offset An absolute offset into the TextNode string, or a direction for which end to use as the offset\n * @param mode If 'error' (the default) out of bounds offsets will be an error in dev. Otherwise it will clamp to a valid offset.\n * @returns An absolute offset into the TextNode string\n */\nfunction $getTextNodeOffset(origin, offset, mode = 'error') {\n  const size = origin.getTextContentSize();\n  let numericOffset = offset === 'next' ? size : offset === 'previous' ? 0 : offset;\n  if (numericOffset < 0 || numericOffset > size) {\n    if (!(mode === 'clamp')) {\n      formatDevErrorMessage(`$getTextNodeOffset: invalid offset ${String(offset)} for size ${String(size)} at key ${origin.getKey()}`);\n    } // Clamp invalid offsets in prod\n    numericOffset = numericOffset < 0 ? 0 : size;\n  }\n  return numericOffset;\n}\n\n/**\n * Construct a TextPointCaretSlice given a TextPointCaret and a signed distance. The\n * distance should be negative to slice text before the caret's offset, and positive\n * to slice text after the offset. The direction of the caret itself is not\n * relevant to the string coordinates when working with a TextPointCaretSlice\n * but mutation operations will preserve the direction.\n *\n * @param caret\n * @param distance\n * @returns TextPointCaretSlice\n */\nfunction $getTextPointCaretSlice(caret, distance) {\n  return new TextPointCaretSliceImpl(caret, distance);\n}\n\n/**\n * Get a caret that points at the first or last child of the given origin node,\n * which must be an ElementNode.\n *\n * @param origin The origin ElementNode\n * @param direction 'next' for first child or 'previous' for last child\n * @returns null if origin is null or not an ElementNode, otherwise a ChildCaret for this origin and direction\n */\n\nfunction $getChildCaret(origin, direction) {\n  return $isElementNode(origin) ? new CHILD_CTOR[direction](origin) : null;\n}\n\n/**\n * Gets the ChildCaret if one is possible at this caret origin, otherwise return the caret\n */\nfunction $getChildCaretOrSelf(caret) {\n  return caret && caret.getChildCaret() || caret;\n}\n\n/**\n * Gets the adjacent caret, if not-null and if the origin of the adjacent caret is an ElementNode, then return\n * the ChildCaret. This can be used along with the getParentAdjacentCaret method to perform a full DFS\n * style traversal of the tree.\n *\n * @param caret The caret to start at\n */\nfunction $getAdjacentChildCaret(caret) {\n  return caret && $getChildCaretOrSelf(caret.getAdjacentCaret());\n}\nclass CaretRangeImpl {\n  type = 'node-caret-range';\n  direction;\n  anchor;\n  focus;\n  constructor(anchor, focus, direction) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.direction = direction;\n  }\n  getLatest() {\n    const anchor = this.anchor.getLatest();\n    const focus = this.focus.getLatest();\n    return anchor === this.anchor && focus === this.focus ? this : new CaretRangeImpl(anchor, focus, this.direction);\n  }\n  isCollapsed() {\n    return this.anchor.isSamePointCaret(this.focus);\n  }\n  getTextSlices() {\n    const getSlice = k => {\n      const caret = this[k].getLatest();\n      return $isTextPointCaret(caret) ? $getSliceFromTextPointCaret(caret, k) : null;\n    };\n    const anchorSlice = getSlice('anchor');\n    const focusSlice = getSlice('focus');\n    if (anchorSlice && focusSlice) {\n      const {\n        caret: anchorCaret\n      } = anchorSlice;\n      const {\n        caret: focusCaret\n      } = focusSlice;\n      if (anchorCaret.isSameNodeCaret(focusCaret)) {\n        return [$getTextPointCaretSlice(anchorCaret, focusCaret.offset - anchorCaret.offset), null];\n      }\n    }\n    return [anchorSlice, focusSlice];\n  }\n  iterNodeCarets(rootMode = 'root') {\n    const anchor = $isTextPointCaret(this.anchor) ? this.anchor.getSiblingCaret() : this.anchor.getLatest();\n    const focus = this.focus.getLatest();\n    const isTextFocus = $isTextPointCaret(focus);\n    const step = state => state.isSameNodeCaret(focus) ? null : $getAdjacentChildCaret(state) || state.getParentCaret(rootMode);\n    return makeStepwiseIterator({\n      hasNext: state => state !== null && !(isTextFocus && focus.isSameNodeCaret(state)),\n      initial: anchor.isSameNodeCaret(focus) ? null : step(anchor),\n      map: state => state,\n      step\n    });\n  }\n  [Symbol.iterator]() {\n    return this.iterNodeCarets('root');\n  }\n}\nclass TextPointCaretSliceImpl {\n  type = 'slice';\n  caret;\n  distance;\n  constructor(caret, distance) {\n    this.caret = caret;\n    this.distance = distance;\n  }\n  getSliceIndices() {\n    const {\n      distance,\n      caret: {\n        offset\n      }\n    } = this;\n    const offsetB = offset + distance;\n    return offsetB < offset ? [offsetB, offset] : [offset, offsetB];\n  }\n  getTextContent() {\n    const [startIndex, endIndex] = this.getSliceIndices();\n    return this.caret.origin.getTextContent().slice(startIndex, endIndex);\n  }\n  getTextContentSize() {\n    return Math.abs(this.distance);\n  }\n  removeTextSlice() {\n    const {\n      caret: {\n        origin,\n        direction\n      }\n    } = this;\n    const [indexStart, indexEnd] = this.getSliceIndices();\n    const text = origin.getTextContent();\n    return $getTextPointCaret(origin.setTextContent(text.slice(0, indexStart) + text.slice(indexEnd)), direction, indexStart);\n  }\n}\nfunction $getSliceFromTextPointCaret(caret, anchorOrFocus) {\n  const {\n    direction,\n    origin\n  } = caret;\n  const offsetB = $getTextNodeOffset(origin, anchorOrFocus === 'focus' ? flipDirection(direction) : direction);\n  return $getTextPointCaretSlice(caret, offsetB - caret.offset);\n}\n\n/**\n * Guard to check for a TextPointCaretSlice\n *\n * @param caretOrSlice A caret or slice\n * @returns true if caretOrSlice is a TextPointCaretSlice\n */\nfunction $isTextPointCaretSlice(caretOrSlice) {\n  return caretOrSlice instanceof TextPointCaretSliceImpl;\n}\n\n/**\n * Construct a CaretRange that starts at anchor and goes to the end of the\n * document in the anchor caret's direction.\n */\nfunction $extendCaretToRange(anchor) {\n  return $getCaretRange(anchor, $getSiblingCaret($getRoot(), anchor.direction));\n}\n\n/**\n * Construct a collapsed CaretRange that starts and ends at anchor.\n */\nfunction $getCollapsedCaretRange(anchor) {\n  return $getCaretRange(anchor, anchor);\n}\n\n/**\n * Construct a CaretRange from anchor and focus carets pointing in the\n * same direction. In order to get the expected behavior,\n * the anchor must point towards the focus or be the same point.\n *\n * In the 'next' direction the anchor should be at or before the\n * focus in the document. In the 'previous' direction the anchor\n * should be at or after the focus in the document\n * (similar to a backwards RangeSelection).\n *\n * @param anchor\n * @param focus\n * @returns a CaretRange\n */\nfunction $getCaretRange(anchor, focus) {\n  if (!(anchor.direction === focus.direction)) {\n    formatDevErrorMessage(`$getCaretRange: anchor and focus must be in the same direction`);\n  }\n  return new CaretRangeImpl(anchor, focus, anchor.direction);\n}\n\n/**\n * A generalized utility for creating a stepwise iterator\n * based on:\n *\n * - an initial state\n * - a stop guard that returns true if the iteration is over, this\n *   is typically used to detect a sentinel value such as null or\n *   undefined from the state but may return true for other conditions\n *   as well\n * - a step function that advances the state (this will be called\n *   after map each time next() is called to prepare the next state)\n * - a map function that will be called that may transform the state\n *   before returning it. It will only be called once for each next()\n *   call when stop(state) === false\n *\n * @param config\n * @returns An IterableIterator\n */\nfunction makeStepwiseIterator(config) {\n  const {\n    initial,\n    hasNext,\n    step,\n    map\n  } = config;\n  let state = initial;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      if (!hasNext(state)) {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n      const rval = {\n        done: false,\n        value: map(state)\n      };\n      state = step(state);\n      return rval;\n    }\n  };\n}\nfunction compareNumber(a, b) {\n  return Math.sign(a - b);\n}\n\n/**\n * A total ordering for `PointCaret<'next'>`, based on\n * the same order that a {@link CaretRange} would iterate\n * them.\n *\n * For a given origin node:\n * - ChildCaret comes before SiblingCaret\n * - TextPointCaret comes before SiblingCaret\n *\n * An exception is thrown when a and b do not have any\n * common ancestor.\n *\n * This ordering is a sort of mix of pre-order and post-order\n * because each ElementNode will show up as a ChildCaret\n * on 'enter' (pre-order) and a SiblingCaret on 'leave' (post-order).\n *\n * @param a\n * @param b\n * @returns -1 if a comes before b, 0 if a and b are the same, or 1 if a comes after b\n */\nfunction $comparePointCaretNext(a, b) {\n  const compare = $getCommonAncestor(a.origin, b.origin);\n  if (!(compare !== null)) {\n    formatDevErrorMessage(`$comparePointCaretNext: a (key ${a.origin.getKey()}) and b (key ${b.origin.getKey()}) do not have a common ancestor`);\n  }\n  switch (compare.type) {\n    case 'same':\n      {\n        const aIsText = a.type === 'text';\n        const bIsText = b.type === 'text';\n        return aIsText && bIsText ? compareNumber(a.offset, b.offset) : a.type === b.type ? 0 : aIsText ? -1 : bIsText ? 1 : a.type === 'child' ? -1 : 1;\n      }\n    case 'ancestor':\n      {\n        return a.type === 'child' ? -1 : 1;\n      }\n    case 'descendant':\n      {\n        return b.type === 'child' ? 1 : -1;\n      }\n    case 'branch':\n      {\n        return $getCommonAncestorResultBranchOrder(compare);\n      }\n  }\n}\n\n/**\n * Return the ordering of siblings in a {@link CommonAncestorResultBranch}\n * @param compare Returns -1 if a precedes b, 1 otherwise\n */\nfunction $getCommonAncestorResultBranchOrder(compare) {\n  const {\n    a,\n    b\n  } = compare;\n  const aKey = a.__key;\n  const bKey = b.__key;\n  let na = a;\n  let nb = b;\n  for (; na && nb; na = na.getNextSibling(), nb = nb.getNextSibling()) {\n    if (na.__key === bKey) {\n      return -1;\n    } else if (nb.__key === aKey) {\n      return 1;\n    }\n  }\n  return na === null ? 1 : -1;\n}\n\n/**\n * The two compared nodes are the same\n */\n\n/**\n * Node a was a descendant of node b, and not the same node\n */\n\n/**\n * Node a is an ancestor of node b, and not the same node\n */\n\n/**\n * Node a and node b have a common ancestor but are on different branches,\n * the `a` and `b` properties of this result are the ancestors of a and b\n * that are children of the commonAncestor. Since they are siblings, their\n * positions are comparable to determine order in the document.\n */\n\n/**\n * The result of comparing two nodes that share some common ancestor\n */\n\nfunction $isSameNode(reference, other) {\n  return other.is(reference);\n}\nfunction $initialElementTuple(node) {\n  return $isElementNode(node) ? [node.getLatest(), null] : [node.getParent(), node.getLatest()];\n}\n\n/**\n * Find a common ancestor of a and b and return a detailed result object,\n * or null if there is no common ancestor between the two nodes.\n *\n * The result object will have a commonAncestor property, and the other\n * properties can be used to quickly compare these positions in the tree.\n *\n * @param a A LexicalNode\n * @param b A LexicalNode\n * @returns A comparison result between the two nodes or null if they have no common ancestor\n */\nfunction $getCommonAncestor(a, b) {\n  if (a.is(b)) {\n    return {\n      commonAncestor: a,\n      type: 'same'\n    };\n  }\n  // Map of parent -> child entries based on a and its ancestors\n  const aMap = new Map();\n  for (let [parent, child] = $initialElementTuple(a); parent; child = parent, parent = parent.getParent()) {\n    aMap.set(parent, child);\n  }\n  for (let [parent, child] = $initialElementTuple(b); parent; child = parent, parent = parent.getParent()) {\n    const aChild = aMap.get(parent);\n    if (aChild === undefined) ; else if (aChild === null) {\n      // a is the ancestor\n      if (!$isSameNode(a, parent)) {\n        formatDevErrorMessage(`$originComparison: ancestor logic error`);\n      }\n      return {\n        commonAncestor: parent,\n        type: 'ancestor'\n      };\n    } else if (child === null) {\n      // b is the ancestor\n      if (!$isSameNode(b, parent)) {\n        formatDevErrorMessage(`$originComparison: descendant logic error`);\n      }\n      return {\n        commonAncestor: parent,\n        type: 'descendant'\n      };\n    } else {\n      if (!(($isElementNode(aChild) || $isSameNode(a, aChild)) && ($isElementNode(child) || $isSameNode(b, child)) && parent.is(aChild.getParent()) && parent.is(child.getParent()))) {\n        formatDevErrorMessage(`$originComparison: branch logic error`);\n      }\n      return {\n        a: aChild,\n        b: child,\n        commonAncestor: parent,\n        type: 'branch'\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * @param point\n * @returns a PointCaret for the point\n */\nfunction $caretFromPoint(point, direction) {\n  const {\n    type,\n    key,\n    offset\n  } = point;\n  const node = $getNodeByKeyOrThrow(point.key);\n  if (type === 'text') {\n    if (!$isTextNode(node)) {\n      formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key} that does not inherit from TextNode encountered for text point`);\n    }\n    return $getTextPointCaret(node, direction, offset);\n  }\n  if (!$isElementNode(node)) {\n    formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key} that does not inherit from ElementNode encountered for element point`);\n  }\n  return $getChildCaretAtIndex(node, point.offset, direction);\n}\n\n/**\n * Update the given point in-place from the PointCaret\n *\n * @param point the point to set\n * @param caret the caret to set the point from\n */\nfunction $setPointFromCaret(point, caret) {\n  const {\n    origin,\n    direction\n  } = caret;\n  const isNext = direction === 'next';\n  if ($isTextPointCaret(caret)) {\n    point.set(origin.getKey(), caret.offset, 'text');\n  } else if ($isSiblingCaret(caret)) {\n    if ($isTextNode(origin)) {\n      point.set(origin.getKey(), $getTextNodeOffset(origin, direction), 'text');\n    } else {\n      point.set(origin.getParentOrThrow().getKey(), origin.getIndexWithinParent() + (isNext ? 1 : 0), 'element');\n    }\n  } else {\n    if (!($isChildCaret(caret) && $isElementNode(origin))) {\n      formatDevErrorMessage(`$setPointFromCaret: exhaustiveness check`);\n    }\n    point.set(origin.getKey(), isNext ? 0 : origin.getChildrenSize(), 'element');\n  }\n}\n\n/**\n * Set a RangeSelection on the editor from the given CaretRange\n *\n * @returns The new RangeSelection\n */\nfunction $setSelectionFromCaretRange(caretRange) {\n  const currentSelection = $getSelection();\n  const selection = $isRangeSelection(currentSelection) ? currentSelection : $createRangeSelection();\n  $updateRangeSelectionFromCaretRange(selection, caretRange);\n  $setSelection(selection);\n  return selection;\n}\n\n/**\n * Update the points of a RangeSelection based on the given PointCaret.\n */\nfunction $updateRangeSelectionFromCaretRange(selection, caretRange) {\n  $setPointFromCaret(selection.anchor, caretRange.anchor);\n  $setPointFromCaret(selection.focus, caretRange.focus);\n}\n\n/**\n * Get a pair of carets for a RangeSelection.\n *\n * If the focus is before the anchor, then the direction will be\n * 'previous', otherwise the direction will be 'next'.\n */\nfunction $caretRangeFromSelection(selection) {\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorCaret = $caretFromPoint(anchor, 'next');\n  const focusCaret = $caretFromPoint(focus, 'next');\n  const direction = $comparePointCaretNext(anchorCaret, focusCaret) <= 0 ? 'next' : 'previous';\n  return $getCaretRange($getCaretInDirection(anchorCaret, direction), $getCaretInDirection(focusCaret, direction));\n}\n\n/**\n * Given a SiblingCaret we can always compute a caret that points to the\n * origin of that caret in the same direction. The adjacent caret of the\n * returned caret will be equivalent to the given caret.\n *\n * @example\n * ```ts\n * siblingCaret.is($rewindSiblingCaret(siblingCaret).getAdjacentCaret())\n * ```\n *\n * @param caret The caret to \"rewind\"\n * @returns A new caret (ChildCaret or SiblingCaret) with the same direction\n */\nfunction $rewindSiblingCaret(caret) {\n  const {\n    direction,\n    origin\n  } = caret;\n  // Rotate the direction around the origin and get the adjacent node\n  const rewindOrigin = $getSiblingCaret(origin, flipDirection(direction)).getNodeAtCaret();\n  return rewindOrigin ? $getSiblingCaret(rewindOrigin, direction) : $getChildCaret(origin.getParentOrThrow(), direction);\n}\nfunction $getAnchorCandidates(anchor, rootMode = 'root') {\n  // These candidates will be the anchor itself, the pointer to the anchor (if different), and then any parents of that\n  const carets = [anchor];\n  for (let parent = $isChildCaret(anchor) ? anchor.getParentCaret(rootMode) : anchor.getSiblingCaret(); parent !== null; parent = parent.getParentCaret(rootMode)) {\n    carets.push($rewindSiblingCaret(parent));\n  }\n  return carets;\n}\nfunction $isCaretAttached(caret) {\n  return !!caret && caret.origin.isAttached();\n}\n\n/**\n * Remove all text and nodes in the given range. If the range spans multiple\n * blocks then the remaining contents of the later block will be merged with\n * the earlier block.\n *\n * @param initialRange The range to remove text and nodes from\n * @param sliceMode If 'preserveEmptyTextPointCaret' it will leave an empty TextPointCaret at the anchor for insert if one exists, otherwise empty slices will be removed\n * @returns The new collapsed range (biased towards the earlier node)\n */\nfunction $removeTextFromCaretRange(initialRange, sliceMode = 'removeEmptySlices') {\n  if (initialRange.isCollapsed()) {\n    return initialRange;\n  }\n  // Always process removals in document order\n  const rootMode = 'root';\n  const nextDirection = 'next';\n  let sliceState = sliceMode;\n  const range = $getCaretRangeInDirection(initialRange, nextDirection);\n  const anchorCandidates = $getAnchorCandidates(range.anchor, rootMode);\n  const focusCandidates = $getAnchorCandidates(range.focus.getFlipped(), rootMode);\n\n  // Mark the start of each ElementNode\n  const seenStart = new Set();\n  // Queue removals since removing the only child can cascade to having\n  // a parent remove itself which will affect iteration\n  const removedNodes = [];\n  for (const caret of range.iterNodeCarets(rootMode)) {\n    if ($isChildCaret(caret)) {\n      seenStart.add(caret.origin.getKey());\n    } else if ($isSiblingCaret(caret)) {\n      const {\n        origin\n      } = caret;\n      if (!$isElementNode(origin) || seenStart.has(origin.getKey())) {\n        removedNodes.push(origin);\n      }\n    }\n  }\n  for (const node of removedNodes) {\n    node.remove();\n  }\n\n  // Splice text at the anchor and/or origin.\n  // If the text is entirely selected then it is removed (unless it is the first slice and sliceMode is preserveEmptyTextSliceCaret).\n  // If it's a token with a non-empty selection then it is removed.\n  // Segmented nodes will be copied to a plain text node with the same format\n  // and style and set to normal mode.\n  for (const slice of range.getTextSlices()) {\n    if (!slice) {\n      continue;\n    }\n    const {\n      origin\n    } = slice.caret;\n    const contentSize = origin.getTextContentSize();\n    const caretBefore = $rewindSiblingCaret($getSiblingCaret(origin, nextDirection));\n    const mode = origin.getMode();\n    if (Math.abs(slice.distance) === contentSize && sliceState === 'removeEmptySlices' || mode === 'token' && slice.distance !== 0) {\n      // anchorCandidates[1] should still be valid, it is caretBefore\n      caretBefore.remove();\n    } else if (slice.distance !== 0) {\n      sliceState = 'removeEmptySlices';\n      let nextCaret = slice.removeTextSlice();\n      const sliceOrigin = slice.caret.origin;\n      if (mode === 'segmented') {\n        const src = nextCaret.origin;\n        const plainTextNode = $createTextNode(src.getTextContent()).setStyle(src.getStyle()).setFormat(src.getFormat());\n        caretBefore.replaceOrInsert(plainTextNode);\n        nextCaret = $getTextPointCaret(plainTextNode, nextDirection, nextCaret.offset);\n      }\n      if (sliceOrigin.is(anchorCandidates[0].origin)) {\n        anchorCandidates[0] = nextCaret;\n      }\n      if (sliceOrigin.is(focusCandidates[0].origin)) {\n        focusCandidates[0] = nextCaret.getFlipped();\n      }\n    }\n  }\n\n  // Find the deepest anchor and focus candidates that are\n  // still attached\n  let anchorCandidate;\n  let focusCandidate;\n  for (const candidate of anchorCandidates) {\n    if ($isCaretAttached(candidate)) {\n      anchorCandidate = $normalizeCaret(candidate);\n      break;\n    }\n  }\n  for (const candidate of focusCandidates) {\n    if ($isCaretAttached(candidate)) {\n      focusCandidate = $normalizeCaret(candidate);\n      break;\n    }\n  }\n\n  // Merge blocks if necessary\n  const mergeTargets = $getBlockMergeTargets(anchorCandidate, focusCandidate, seenStart);\n  if (mergeTargets) {\n    const [anchorBlock, focusBlock] = mergeTargets;\n    // always merge blocks later in the document with\n    // blocks earlier in the document\n    $getChildCaret(anchorBlock, 'previous').splice(0, focusBlock.getChildren());\n    focusBlock.remove();\n  }\n\n  // note this caret can be in either direction\n  const bestCandidate = [anchorCandidate, focusCandidate, ...anchorCandidates, ...focusCandidates].find($isCaretAttached);\n  if (bestCandidate) {\n    const anchor = $getCaretInDirection($normalizeCaret(bestCandidate), initialRange.direction);\n    return $getCollapsedCaretRange(anchor);\n  }\n  {\n    formatDevErrorMessage(`$removeTextFromCaretRange: selection was lost, could not find a new anchor given candidates with keys: ${JSON.stringify(anchorCandidates.map(n => n.origin.__key))}`);\n  }\n}\n\n/**\n * Determine if the two caret origins are in distinct blocks that\n * should be merged.\n *\n * The returned block pair will be the closest blocks to their\n * common ancestor, and must be no shadow roots between\n * the blocks and their respective carets. If two distinct\n * blocks matching this criteria are not found, this will return\n * null.\n */\nfunction $getBlockMergeTargets(anchor, focus, seenStart) {\n  if (!anchor || !focus) {\n    return null;\n  }\n  const anchorParent = anchor.getParentAtCaret();\n  const focusParent = focus.getParentAtCaret();\n  if (!anchorParent || !focusParent) {\n    return null;\n  }\n  // TODO refactor when we have a better primitive for common ancestor\n  const anchorElements = anchorParent.getParents().reverse();\n  anchorElements.push(anchorParent);\n  const focusElements = focusParent.getParents().reverse();\n  focusElements.push(focusParent);\n  const maxLen = Math.min(anchorElements.length, focusElements.length);\n  let commonAncestorCount;\n  for (commonAncestorCount = 0; commonAncestorCount < maxLen && anchorElements[commonAncestorCount] === focusElements[commonAncestorCount]; commonAncestorCount++) {\n    // just traverse the ancestors\n  }\n  const $getBlock = (arr, predicate) => {\n    let block;\n    for (let i = commonAncestorCount; i < arr.length; i++) {\n      const ancestor = arr[i];\n      if ($isRootOrShadowRoot(ancestor)) {\n        return;\n      } else if (!block && predicate(ancestor)) {\n        block = ancestor;\n      }\n    }\n    return block;\n  };\n  const anchorBlock = $getBlock(anchorElements, INTERNAL_$isBlock);\n  const focusBlock = anchorBlock && $getBlock(focusElements, node => seenStart.has(node.getKey()) && INTERNAL_$isBlock(node));\n  return anchorBlock && focusBlock ? [anchorBlock, focusBlock] : null;\n}\n\n/**\n * Return the deepest ChildCaret that has initialCaret's origin\n * as an ancestor, or initialCaret if the origin is not an ElementNode\n * or is already the deepest ChildCaret.\n *\n * This is generally used when normalizing because there is\n * \"zero distance\" between these locations.\n *\n * @param initialCaret\n * @returns Either a deeper ChildCaret or the given initialCaret\n */\nfunction $getDeepestChildOrSelf(initialCaret) {\n  let caret = initialCaret;\n  while ($isChildCaret(caret)) {\n    const adjacent = $getAdjacentChildCaret(caret);\n    if (!$isChildCaret(adjacent)) {\n      break;\n    }\n    caret = adjacent;\n  }\n  return caret;\n}\n\n/**\n * Normalize a caret to the deepest equivalent PointCaret.\n * This will return a TextPointCaret with the offset set according\n * to the direction if given a caret with a TextNode origin\n * or a caret with an ElementNode origin with the deepest ChildCaret\n * having an adjacent TextNode.\n *\n * If given a TextPointCaret, it will be returned, as no normalization\n * is required when an offset is already present.\n *\n * @param initialCaret\n * @returns The normalized PointCaret\n */\nfunction $normalizeCaret(initialCaret) {\n  const caret = $getDeepestChildOrSelf(initialCaret.getLatest());\n  const {\n    direction\n  } = caret;\n  if ($isTextNode(caret.origin)) {\n    return $isTextPointCaret(caret) ? caret : $getTextPointCaret(caret.origin, direction, direction);\n  }\n  const adj = caret.getAdjacentCaret();\n  return $isSiblingCaret(adj) && $isTextNode(adj.origin) ? $getTextPointCaret(adj.origin, direction, flipDirection(direction)) : caret;\n}\n/**\n * Determine whether the TextPointCaret's offset can be extended further without leaving the TextNode.\n * Returns false if the given caret is not a TextPointCaret or the offset can not be moved further in\n * direction.\n *\n * @param caret A PointCaret\n * @returns true if caret is a TextPointCaret with an offset that is not at the end of the text given the direction.\n */\nfunction $isExtendableTextPointCaret(caret) {\n  return $isTextPointCaret(caret) && caret.offset !== $getTextNodeOffset(caret.origin, caret.direction);\n}\n\n/**\n * Return the caret if it's in the given direction, otherwise return\n * caret.getFlipped().\n *\n * @param caret Any PointCaret\n * @param direction The desired direction\n * @returns A PointCaret in direction\n */\nfunction $getCaretInDirection(caret, direction) {\n  return caret.direction === direction ? caret : caret.getFlipped();\n}\n\n/**\n * Return the range if it's in the given direction, otherwise\n * construct a new range using a flipped focus as the anchor\n * and a flipped anchor as the focus. This transformation\n * preserves the section of the document that it's working\n * with, but reverses the order of iteration.\n *\n * @param range Any CaretRange\n * @param direction The desired direction\n * @returns A CaretRange in direction\n */\nfunction $getCaretRangeInDirection(range, direction) {\n  if (range.direction === direction) {\n    return range;\n  }\n  return $getCaretRange(\n  // focus and anchor get flipped here\n  $getCaretInDirection(range.focus, direction), $getCaretInDirection(range.anchor, direction));\n}\n\n/**\n * Get a caret pointing at the child at the given index, or the last\n * caret in that node if out of bounds.\n *\n * @param parent An ElementNode\n * @param index The index of the origin for the caret\n * @returns A caret pointing towards the node at that index\n */\nfunction $getChildCaretAtIndex(parent, index, direction) {\n  let caret = $getChildCaret(parent, 'next');\n  for (let i = 0; i < index; i++) {\n    const nextCaret = caret.getAdjacentCaret();\n    if (nextCaret === null) {\n      break;\n    }\n    caret = nextCaret;\n  }\n  return $getCaretInDirection(caret, direction);\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param startCaret The initial caret\n * @param rootMode The root mode, 'root' (default) or 'shadowRoot'\n * @returns An array (tuple) containing the found caret and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {\n  let depthDiff = 0;\n  let caret = startCaret;\n  let nextCaret = $getAdjacentChildCaret(caret);\n  while (nextCaret === null) {\n    depthDiff--;\n    nextCaret = caret.getParentCaret(rootMode);\n    if (!nextCaret) {\n      return null;\n    }\n    caret = nextCaret;\n    nextCaret = $getAdjacentChildCaret(caret);\n  }\n  return nextCaret && [nextCaret, depthDiff];\n}\n\n/**\n * Get the adjacent nodes to initialCaret in the given direction.\n *\n * @example\n * ```ts\n * expect($getAdjacentNodes($getChildCaret(parent, 'next'))).toEqual(parent.getChildren());\n * expect($getAdjacentNodes($getChildCaret(parent, 'previous'))).toEqual(parent.getChildren().reverse());\n * expect($getAdjacentNodes($getSiblingCaret(node, 'next'))).toEqual(node.getNextSiblings());\n * expect($getAdjacentNodes($getSiblingCaret(node, 'previous'))).toEqual(node.getPreviousSiblings().reverse());\n * ```\n *\n * @param initialCaret The caret to start at (the origin will not be included)\n * @returns An array of siblings.\n */\nfunction $getAdjacentNodes(initialCaret) {\n  const siblings = [];\n  for (let caret = initialCaret.getAdjacentCaret(); caret; caret = caret.getAdjacentCaret()) {\n    siblings.push(caret.origin);\n  }\n  return siblings;\n}\nfunction $splitTextPointCaret(textPointCaret) {\n  const {\n    origin,\n    offset,\n    direction\n  } = textPointCaret;\n  if (offset === $getTextNodeOffset(origin, direction)) {\n    return textPointCaret.getSiblingCaret();\n  } else if (offset === $getTextNodeOffset(origin, flipDirection(direction))) {\n    return $rewindSiblingCaret(textPointCaret.getSiblingCaret());\n  }\n  const [textNode] = origin.splitText(offset);\n  if (!$isTextNode(textNode)) {\n    formatDevErrorMessage(`$splitTextPointCaret: splitText must return at least one TextNode`);\n  }\n  return $getCaretInDirection($getSiblingCaret(textNode, 'next'), direction);\n}\nfunction $alwaysSplit(_node, _edge) {\n  return true;\n}\n\n/**\n * Split a node at a PointCaret and return a NodeCaret at that point, or null if the\n * node can't be split. This is non-recursive and will only perform at most one split.\n *\n * @returns The NodeCaret pointing to the location of the split (or null if a split is not possible)\n */\nfunction $splitAtPointCaretNext(pointCaret, {\n  $copyElementNode = $copyNode,\n  $splitTextPointCaretNext = $splitTextPointCaret,\n  rootMode = 'shadowRoot',\n  $shouldSplit = $alwaysSplit\n} = {}) {\n  if ($isTextPointCaret(pointCaret)) {\n    return $splitTextPointCaretNext(pointCaret);\n  }\n  const parentCaret = pointCaret.getParentCaret(rootMode);\n  if (parentCaret) {\n    const {\n      origin\n    } = parentCaret;\n    if ($isChildCaret(pointCaret) && !(origin.canBeEmpty() && $shouldSplit(origin, 'first'))) {\n      // No split necessary, the left side would be empty\n      return $rewindSiblingCaret(parentCaret);\n    }\n    const siblings = $getAdjacentNodes(pointCaret);\n    if (siblings.length > 0 || origin.canBeEmpty() && $shouldSplit(origin, 'last')) {\n      // Split and insert the siblings into the new tree\n      parentCaret.insert($copyElementNode(origin).splice(0, 0, siblings));\n    }\n  }\n  return parentCaret;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * @experimental\n * Define a LexicalExtension from the given object literal. TypeScript will\n * infer Config and Name in most cases, but you may want to use\n * {@link safeCast} for config if there are default fields or varying types.\n *\n * @param extension - The LexicalExtension\n * @returns The unmodified extension argument (this is only an inference helper)\n *\n * @example\n * Basic example\n * ```ts\n * export const MyExtension = defineExtension({\n *   // Extension names must be unique in an editor\n *   name: \"my\",\n *   nodes: [MyNode],\n * });\n * ```\n *\n * @example\n * Extension with optional configuration\n * ```ts\n * export interface ConfigurableConfig {\n *   optional?: string;\n *   required: number;\n * }\n * export const ConfigurableExtension = defineExtension({\n *   name: \"configurable\",\n *   // The Extension's config must satisfy the full config type,\n *   // but using the Extension as a dependency never requires\n *   // configuration and any partial of the config can be specified\n *   config: safeCast<ConfigurableConfig>({ required: 1 }),\n * });\n * ```\n *\n * @__NO_SIDE_EFFECTS__\n */\nfunction defineExtension(extension) {\n  return extension;\n}\n\n/**\n * @experimental\n * Override a partial of the configuration of an Extension, to be used\n * in the dependencies array of another extension, or as\n * an argument to {@link buildEditorFromExtensions}.\n *\n * Before building the editor, configurations will be merged using\n * `extension.mergeConfig(extension, config)` or {@link shallowMergeConfig} if\n * this is not directly implemented by the Extension.\n *\n * @param args - An extension followed by one or more config partials for that extension\n * @returns `[extension, config, ...configs]`\n *\n * @example\n * ```ts\n * export const ReactDecoratorExtension = defineExtension({\n *   name: \"react-decorator\",\n *   dependencies: [\n *     configExtension(ReactExtension, {\n *       decorators: [<ReactDecorator />]\n *     }),\n *   ],\n * });\n * ```\n *\n * @__NO_SIDE_EFFECTS__\n */\nfunction configExtension(...args) {\n  return args;\n}\n\n/**\n * @experimental\n * Used to declare a peer dependency of an extension in a type-safe way,\n * requires the type parameter. The most common use case for peer dependencies\n * is to avoid a direct import dependency, so you would want to use a\n * type import or the import type (shown in below examples).\n *\n * @param name - The extension's name\n * @param config - An optional config override\n * @returns NormalizedPeerDependency\n *\n * @example\n * ```ts\n * import type {FooExtension} from \"foo\";\n *\n * export const PeerExtension = defineExtension({\n *   name: 'PeerExtension',\n *   peerDependencies: [\n *     declarePeerDependency<FooExtension>(\"foo\"),\n *     declarePeerDependency<typeof import(\"bar\").BarExtension>(\"bar\", {config: \"bar\"}),\n *   ],\n * });\n * ```\n *\n * @__NO_SIDE_EFFECTS__\n */\nfunction declarePeerDependency(name, config) {\n  return [name, config];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Explicitly and safely cast a value to a specific type when inference or\n * satisfies isn't going to work as expected (often useful for the config\n * property with {@link defineExtension})\n *\n * @__NO_SIDE_EFFECTS__\n */\nfunction safeCast(value) {\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * The default merge strategy for extension configuration is a shallow merge.\n *\n * @param config - A full config\n * @param overrides - A partial config of overrides\n * @returns config if there are no overrides, otherwise `{...config, ...overrides}`\n */\nfunction shallowMergeConfig(config, overrides) {\n  if (!overrides || config === overrides) {\n    return config;\n  }\n  for (const k in overrides) {\n    if (config[k] !== overrides[k]) {\n      return {\n        ...config,\n        ...overrides\n      };\n    }\n  }\n  return config;\n}\n\nexport { $addUpdateTag, $applyNodeReplacement, $caretFromPoint, $caretRangeFromSelection, $cloneWithProperties, $cloneWithPropertiesEphemeral, $comparePointCaretNext, $copyNode, $create, $createLineBreakNode, $createNodeSelection, $createParagraphNode, $createPoint, $createRangeSelection, $createRangeSelectionFromDom, $createTabNode, $createTextNode, $extendCaretToRange, $findMatchingParent, $getAdjacentChildCaret, $getAdjacentNode, $getAdjacentSiblingOrParentSiblingCaret, $getCaretInDirection, $getCaretRange, $getCaretRangeInDirection, $getCharacterOffsets, $getChildCaret, $getChildCaretAtIndex, $getChildCaretOrSelf, $getCollapsedCaretRange, $getCommonAncestor, $getCommonAncestorResultBranchOrder, $getEditor, $getNearestNodeFromDOMNode, $getNearestRootOrShadowRoot, $getNodeByKey, $getNodeByKeyOrThrow, $getNodeFromDOMNode, $getPreviousSelection, $getRoot, $getSelection, $getSiblingCaret, $getState, $getStateChange, $getTextContent, $getTextNodeOffset, $getTextPointCaret, $getTextPointCaretSlice, $getWritableNodeState, $hasAncestor, $hasUpdateTag, $insertNodes, $isBlockElementNode, $isChildCaret, $isDecoratorNode, $isEditorState, $isElementNode, $isExtendableTextPointCaret, $isInlineElementOrDecoratorNode, $isLeafNode, $isLineBreakNode, $isNodeCaret, $isNodeSelection, $isParagraphNode, $isRangeSelection, $isRootNode, $isRootOrShadowRoot, $isSiblingCaret, $isTabNode, $isTextNode, $isTextPointCaret, $isTextPointCaretSlice, $isTokenOrSegmented, $isTokenOrTab, $nodesOfType, $normalizeCaret, $normalizeSelection as $normalizeSelection__EXPERIMENTAL, $onUpdate, $parseSerializedNode, $removeTextFromCaretRange, $rewindSiblingCaret, $selectAll, $setCompositionKey, $setPointFromCaret, $setSelection, $setSelectionFromCaretRange, $setState, $splitAtPointCaretNext, $splitNode, $updateRangeSelectionFromCaretRange, ArtificialNode__DO_NOT_USE, BLUR_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CLICK_COMMAND, COLLABORATION_TAG, COMMAND_PRIORITY_CRITICAL, COMMAND_PRIORITY_EDITOR, COMMAND_PRIORITY_HIGH, COMMAND_PRIORITY_LOW, COMMAND_PRIORITY_NORMAL, CONTROLLED_TEXT_INSERTION_COMMAND, COPY_COMMAND, CUT_COMMAND, DELETE_CHARACTER_COMMAND, DELETE_LINE_COMMAND, DELETE_WORD_COMMAND, DRAGEND_COMMAND, DRAGOVER_COMMAND, DRAGSTART_COMMAND, DROP_COMMAND, DecoratorNode, ElementNode, FOCUS_COMMAND, FORMAT_ELEMENT_COMMAND, FORMAT_TEXT_COMMAND, HISTORIC_TAG, HISTORY_MERGE_TAG, HISTORY_PUSH_TAG, INDENT_CONTENT_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, INTERNAL_$isBlock, IS_ALL_FORMATTING, IS_BOLD, IS_CODE, IS_HIGHLIGHT, IS_ITALIC, IS_STRIKETHROUGH, IS_SUBSCRIPT, IS_SUPERSCRIPT, IS_UNDERLINE, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ARROW_UP_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_DOWN_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, KEY_MODIFIER_COMMAND, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, LineBreakNode, MOVE_TO_END, MOVE_TO_START, NODE_STATE_KEY, OUTDENT_CONTENT_COMMAND, PASTE_COMMAND, PASTE_TAG, ParagraphNode, REDO_COMMAND, REMOVE_TEXT_COMMAND, RootNode, SELECTION_CHANGE_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, SELECT_ALL_COMMAND, SKIP_COLLAB_TAG, SKIP_DOM_SELECTION_TAG, SKIP_SCROLL_INTO_VIEW_TAG, SKIP_SELECTION_FOCUS_TAG, TEXT_TYPE_TO_FORMAT, TabNode, TextNode, UNDO_COMMAND, buildImportMap, configExtension, createCommand, createEditor, createSharedNodeState, createState, declarePeerDependency, defineExtension, flipDirection, getDOMOwnerDocument, getDOMSelection, getDOMSelectionFromTarget, getDOMTextNode, getEditorPropertyFromDOMNode, getNearestEditorFromDOMNode, getRegisteredNode, getRegisteredNodeOrThrow, getStaticNodeConfig, getTextDirection, getTransformSetFromKlass, isBlockDomNode, isCurrentlyReadOnlyMode, isDOMDocumentNode, isDOMNode, isDOMTextNode, isDOMUnmanaged, isDocumentFragment, isExactShortcutMatch, isHTMLAnchorElement, isHTMLElement, isInlineDomNode, isLexicalEditor, isModifierMatch, isSelectionCapturedInDecoratorInput, isSelectionWithinEditor, makeStepwiseIterator, removeFromParent, resetRandomKey, safeCast, setDOMUnmanaged, setNodeIndentFromDOM, shallowMergeConfig };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './Lexical.dev.mjs';\nimport * as modProd from './Lexical.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $addUpdateTag = mod.$addUpdateTag;\nexport const $applyNodeReplacement = mod.$applyNodeReplacement;\nexport const $caretFromPoint = mod.$caretFromPoint;\nexport const $caretRangeFromSelection = mod.$caretRangeFromSelection;\nexport const $cloneWithProperties = mod.$cloneWithProperties;\nexport const $cloneWithPropertiesEphemeral = mod.$cloneWithPropertiesEphemeral;\nexport const $comparePointCaretNext = mod.$comparePointCaretNext;\nexport const $copyNode = mod.$copyNode;\nexport const $create = mod.$create;\nexport const $createLineBreakNode = mod.$createLineBreakNode;\nexport const $createNodeSelection = mod.$createNodeSelection;\nexport const $createParagraphNode = mod.$createParagraphNode;\nexport const $createPoint = mod.$createPoint;\nexport const $createRangeSelection = mod.$createRangeSelection;\nexport const $createRangeSelectionFromDom = mod.$createRangeSelectionFromDom;\nexport const $createTabNode = mod.$createTabNode;\nexport const $createTextNode = mod.$createTextNode;\nexport const $extendCaretToRange = mod.$extendCaretToRange;\nexport const $findMatchingParent = mod.$findMatchingParent;\nexport const $getAdjacentChildCaret = mod.$getAdjacentChildCaret;\nexport const $getAdjacentNode = mod.$getAdjacentNode;\nexport const $getAdjacentSiblingOrParentSiblingCaret = mod.$getAdjacentSiblingOrParentSiblingCaret;\nexport const $getCaretInDirection = mod.$getCaretInDirection;\nexport const $getCaretRange = mod.$getCaretRange;\nexport const $getCaretRangeInDirection = mod.$getCaretRangeInDirection;\nexport const $getCharacterOffsets = mod.$getCharacterOffsets;\nexport const $getChildCaret = mod.$getChildCaret;\nexport const $getChildCaretAtIndex = mod.$getChildCaretAtIndex;\nexport const $getChildCaretOrSelf = mod.$getChildCaretOrSelf;\nexport const $getCollapsedCaretRange = mod.$getCollapsedCaretRange;\nexport const $getCommonAncestor = mod.$getCommonAncestor;\nexport const $getCommonAncestorResultBranchOrder = mod.$getCommonAncestorResultBranchOrder;\nexport const $getEditor = mod.$getEditor;\nexport const $getNearestNodeFromDOMNode = mod.$getNearestNodeFromDOMNode;\nexport const $getNearestRootOrShadowRoot = mod.$getNearestRootOrShadowRoot;\nexport const $getNodeByKey = mod.$getNodeByKey;\nexport const $getNodeByKeyOrThrow = mod.$getNodeByKeyOrThrow;\nexport const $getNodeFromDOMNode = mod.$getNodeFromDOMNode;\nexport const $getPreviousSelection = mod.$getPreviousSelection;\nexport const $getRoot = mod.$getRoot;\nexport const $getSelection = mod.$getSelection;\nexport const $getSiblingCaret = mod.$getSiblingCaret;\nexport const $getState = mod.$getState;\nexport const $getStateChange = mod.$getStateChange;\nexport const $getTextContent = mod.$getTextContent;\nexport const $getTextNodeOffset = mod.$getTextNodeOffset;\nexport const $getTextPointCaret = mod.$getTextPointCaret;\nexport const $getTextPointCaretSlice = mod.$getTextPointCaretSlice;\nexport const $getWritableNodeState = mod.$getWritableNodeState;\nexport const $hasAncestor = mod.$hasAncestor;\nexport const $hasUpdateTag = mod.$hasUpdateTag;\nexport const $insertNodes = mod.$insertNodes;\nexport const $isBlockElementNode = mod.$isBlockElementNode;\nexport const $isChildCaret = mod.$isChildCaret;\nexport const $isDecoratorNode = mod.$isDecoratorNode;\nexport const $isEditorState = mod.$isEditorState;\nexport const $isElementNode = mod.$isElementNode;\nexport const $isExtendableTextPointCaret = mod.$isExtendableTextPointCaret;\nexport const $isInlineElementOrDecoratorNode = mod.$isInlineElementOrDecoratorNode;\nexport const $isLeafNode = mod.$isLeafNode;\nexport const $isLineBreakNode = mod.$isLineBreakNode;\nexport const $isNodeCaret = mod.$isNodeCaret;\nexport const $isNodeSelection = mod.$isNodeSelection;\nexport const $isParagraphNode = mod.$isParagraphNode;\nexport const $isRangeSelection = mod.$isRangeSelection;\nexport const $isRootNode = mod.$isRootNode;\nexport const $isRootOrShadowRoot = mod.$isRootOrShadowRoot;\nexport const $isSiblingCaret = mod.$isSiblingCaret;\nexport const $isTabNode = mod.$isTabNode;\nexport const $isTextNode = mod.$isTextNode;\nexport const $isTextPointCaret = mod.$isTextPointCaret;\nexport const $isTextPointCaretSlice = mod.$isTextPointCaretSlice;\nexport const $isTokenOrSegmented = mod.$isTokenOrSegmented;\nexport const $isTokenOrTab = mod.$isTokenOrTab;\nexport const $nodesOfType = mod.$nodesOfType;\nexport const $normalizeCaret = mod.$normalizeCaret;\nexport const $normalizeSelection__EXPERIMENTAL = mod.$normalizeSelection__EXPERIMENTAL;\nexport const $onUpdate = mod.$onUpdate;\nexport const $parseSerializedNode = mod.$parseSerializedNode;\nexport const $removeTextFromCaretRange = mod.$removeTextFromCaretRange;\nexport const $rewindSiblingCaret = mod.$rewindSiblingCaret;\nexport const $selectAll = mod.$selectAll;\nexport const $setCompositionKey = mod.$setCompositionKey;\nexport const $setPointFromCaret = mod.$setPointFromCaret;\nexport const $setSelection = mod.$setSelection;\nexport const $setSelectionFromCaretRange = mod.$setSelectionFromCaretRange;\nexport const $setState = mod.$setState;\nexport const $splitAtPointCaretNext = mod.$splitAtPointCaretNext;\nexport const $splitNode = mod.$splitNode;\nexport const $updateRangeSelectionFromCaretRange = mod.$updateRangeSelectionFromCaretRange;\nexport const ArtificialNode__DO_NOT_USE = mod.ArtificialNode__DO_NOT_USE;\nexport const BLUR_COMMAND = mod.BLUR_COMMAND;\nexport const CAN_REDO_COMMAND = mod.CAN_REDO_COMMAND;\nexport const CAN_UNDO_COMMAND = mod.CAN_UNDO_COMMAND;\nexport const CLEAR_EDITOR_COMMAND = mod.CLEAR_EDITOR_COMMAND;\nexport const CLEAR_HISTORY_COMMAND = mod.CLEAR_HISTORY_COMMAND;\nexport const CLICK_COMMAND = mod.CLICK_COMMAND;\nexport const COLLABORATION_TAG = mod.COLLABORATION_TAG;\nexport const COMMAND_PRIORITY_CRITICAL = mod.COMMAND_PRIORITY_CRITICAL;\nexport const COMMAND_PRIORITY_EDITOR = mod.COMMAND_PRIORITY_EDITOR;\nexport const COMMAND_PRIORITY_HIGH = mod.COMMAND_PRIORITY_HIGH;\nexport const COMMAND_PRIORITY_LOW = mod.COMMAND_PRIORITY_LOW;\nexport const COMMAND_PRIORITY_NORMAL = mod.COMMAND_PRIORITY_NORMAL;\nexport const CONTROLLED_TEXT_INSERTION_COMMAND = mod.CONTROLLED_TEXT_INSERTION_COMMAND;\nexport const COPY_COMMAND = mod.COPY_COMMAND;\nexport const CUT_COMMAND = mod.CUT_COMMAND;\nexport const DELETE_CHARACTER_COMMAND = mod.DELETE_CHARACTER_COMMAND;\nexport const DELETE_LINE_COMMAND = mod.DELETE_LINE_COMMAND;\nexport const DELETE_WORD_COMMAND = mod.DELETE_WORD_COMMAND;\nexport const DRAGEND_COMMAND = mod.DRAGEND_COMMAND;\nexport const DRAGOVER_COMMAND = mod.DRAGOVER_COMMAND;\nexport const DRAGSTART_COMMAND = mod.DRAGSTART_COMMAND;\nexport const DROP_COMMAND = mod.DROP_COMMAND;\nexport const DecoratorNode = mod.DecoratorNode;\nexport const ElementNode = mod.ElementNode;\nexport const FOCUS_COMMAND = mod.FOCUS_COMMAND;\nexport const FORMAT_ELEMENT_COMMAND = mod.FORMAT_ELEMENT_COMMAND;\nexport const FORMAT_TEXT_COMMAND = mod.FORMAT_TEXT_COMMAND;\nexport const HISTORIC_TAG = mod.HISTORIC_TAG;\nexport const HISTORY_MERGE_TAG = mod.HISTORY_MERGE_TAG;\nexport const HISTORY_PUSH_TAG = mod.HISTORY_PUSH_TAG;\nexport const INDENT_CONTENT_COMMAND = mod.INDENT_CONTENT_COMMAND;\nexport const INSERT_LINE_BREAK_COMMAND = mod.INSERT_LINE_BREAK_COMMAND;\nexport const INSERT_PARAGRAPH_COMMAND = mod.INSERT_PARAGRAPH_COMMAND;\nexport const INSERT_TAB_COMMAND = mod.INSERT_TAB_COMMAND;\nexport const INTERNAL_$isBlock = mod.INTERNAL_$isBlock;\nexport const IS_ALL_FORMATTING = mod.IS_ALL_FORMATTING;\nexport const IS_BOLD = mod.IS_BOLD;\nexport const IS_CODE = mod.IS_CODE;\nexport const IS_HIGHLIGHT = mod.IS_HIGHLIGHT;\nexport const IS_ITALIC = mod.IS_ITALIC;\nexport const IS_STRIKETHROUGH = mod.IS_STRIKETHROUGH;\nexport const IS_SUBSCRIPT = mod.IS_SUBSCRIPT;\nexport const IS_SUPERSCRIPT = mod.IS_SUPERSCRIPT;\nexport const IS_UNDERLINE = mod.IS_UNDERLINE;\nexport const KEY_ARROW_DOWN_COMMAND = mod.KEY_ARROW_DOWN_COMMAND;\nexport const KEY_ARROW_LEFT_COMMAND = mod.KEY_ARROW_LEFT_COMMAND;\nexport const KEY_ARROW_RIGHT_COMMAND = mod.KEY_ARROW_RIGHT_COMMAND;\nexport const KEY_ARROW_UP_COMMAND = mod.KEY_ARROW_UP_COMMAND;\nexport const KEY_BACKSPACE_COMMAND = mod.KEY_BACKSPACE_COMMAND;\nexport const KEY_DELETE_COMMAND = mod.KEY_DELETE_COMMAND;\nexport const KEY_DOWN_COMMAND = mod.KEY_DOWN_COMMAND;\nexport const KEY_ENTER_COMMAND = mod.KEY_ENTER_COMMAND;\nexport const KEY_ESCAPE_COMMAND = mod.KEY_ESCAPE_COMMAND;\nexport const KEY_MODIFIER_COMMAND = mod.KEY_MODIFIER_COMMAND;\nexport const KEY_SPACE_COMMAND = mod.KEY_SPACE_COMMAND;\nexport const KEY_TAB_COMMAND = mod.KEY_TAB_COMMAND;\nexport const LineBreakNode = mod.LineBreakNode;\nexport const MOVE_TO_END = mod.MOVE_TO_END;\nexport const MOVE_TO_START = mod.MOVE_TO_START;\nexport const NODE_STATE_KEY = mod.NODE_STATE_KEY;\nexport const OUTDENT_CONTENT_COMMAND = mod.OUTDENT_CONTENT_COMMAND;\nexport const PASTE_COMMAND = mod.PASTE_COMMAND;\nexport const PASTE_TAG = mod.PASTE_TAG;\nexport const ParagraphNode = mod.ParagraphNode;\nexport const REDO_COMMAND = mod.REDO_COMMAND;\nexport const REMOVE_TEXT_COMMAND = mod.REMOVE_TEXT_COMMAND;\nexport const RootNode = mod.RootNode;\nexport const SELECTION_CHANGE_COMMAND = mod.SELECTION_CHANGE_COMMAND;\nexport const SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = mod.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;\nexport const SELECT_ALL_COMMAND = mod.SELECT_ALL_COMMAND;\nexport const SKIP_COLLAB_TAG = mod.SKIP_COLLAB_TAG;\nexport const SKIP_DOM_SELECTION_TAG = mod.SKIP_DOM_SELECTION_TAG;\nexport const SKIP_SCROLL_INTO_VIEW_TAG = mod.SKIP_SCROLL_INTO_VIEW_TAG;\nexport const SKIP_SELECTION_FOCUS_TAG = mod.SKIP_SELECTION_FOCUS_TAG;\nexport const TEXT_TYPE_TO_FORMAT = mod.TEXT_TYPE_TO_FORMAT;\nexport const TabNode = mod.TabNode;\nexport const TextNode = mod.TextNode;\nexport const UNDO_COMMAND = mod.UNDO_COMMAND;\nexport const buildImportMap = mod.buildImportMap;\nexport const configExtension = mod.configExtension;\nexport const createCommand = mod.createCommand;\nexport const createEditor = mod.createEditor;\nexport const createSharedNodeState = mod.createSharedNodeState;\nexport const createState = mod.createState;\nexport const declarePeerDependency = mod.declarePeerDependency;\nexport const defineExtension = mod.defineExtension;\nexport const flipDirection = mod.flipDirection;\nexport const getDOMOwnerDocument = mod.getDOMOwnerDocument;\nexport const getDOMSelection = mod.getDOMSelection;\nexport const getDOMSelectionFromTarget = mod.getDOMSelectionFromTarget;\nexport const getDOMTextNode = mod.getDOMTextNode;\nexport const getEditorPropertyFromDOMNode = mod.getEditorPropertyFromDOMNode;\nexport const getNearestEditorFromDOMNode = mod.getNearestEditorFromDOMNode;\nexport const getRegisteredNode = mod.getRegisteredNode;\nexport const getRegisteredNodeOrThrow = mod.getRegisteredNodeOrThrow;\nexport const getStaticNodeConfig = mod.getStaticNodeConfig;\nexport const getTextDirection = mod.getTextDirection;\nexport const getTransformSetFromKlass = mod.getTransformSetFromKlass;\nexport const isBlockDomNode = mod.isBlockDomNode;\nexport const isCurrentlyReadOnlyMode = mod.isCurrentlyReadOnlyMode;\nexport const isDOMDocumentNode = mod.isDOMDocumentNode;\nexport const isDOMNode = mod.isDOMNode;\nexport const isDOMTextNode = mod.isDOMTextNode;\nexport const isDOMUnmanaged = mod.isDOMUnmanaged;\nexport const isDocumentFragment = mod.isDocumentFragment;\nexport const isExactShortcutMatch = mod.isExactShortcutMatch;\nexport const isHTMLAnchorElement = mod.isHTMLAnchorElement;\nexport const isHTMLElement = mod.isHTMLElement;\nexport const isInlineDomNode = mod.isInlineDomNode;\nexport const isLexicalEditor = mod.isLexicalEditor;\nexport const isModifierMatch = mod.isModifierMatch;\nexport const isSelectionCapturedInDecoratorInput = mod.isSelectionCapturedInDecoratorInput;\nexport const isSelectionWithinEditor = mod.isSelectionWithinEditor;\nexport const makeStepwiseIterator = mod.makeStepwiseIterator;\nexport const removeFromParent = mod.removeFromParent;\nexport const resetRandomKey = mod.resetRandomKey;\nexport const safeCast = mod.safeCast;\nexport const setDOMUnmanaged = mod.setDOMUnmanaged;\nexport const setNodeIndentFromDOM = mod.setNodeIndentFromDOM;\nexport const shallowMergeConfig = mod.shallowMergeConfig;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalSelection.dev.mjs';\nimport * as modProd from './LexicalSelection.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $addNodeStyle = mod.$addNodeStyle;\nexport const $cloneWithProperties = mod.$cloneWithProperties;\nexport const $copyBlockFormatIndent = mod.$copyBlockFormatIndent;\nexport const $ensureForwardRangeSelection = mod.$ensureForwardRangeSelection;\nexport const $forEachSelectedTextNode = mod.$forEachSelectedTextNode;\nexport const $getComputedStyleForElement = mod.$getComputedStyleForElement;\nexport const $getComputedStyleForParent = mod.$getComputedStyleForParent;\nexport const $getSelectionStyleValueForProperty = mod.$getSelectionStyleValueForProperty;\nexport const $isAtNodeEnd = mod.$isAtNodeEnd;\nexport const $isParentElementRTL = mod.$isParentElementRTL;\nexport const $isParentRTL = mod.$isParentRTL;\nexport const $moveCaretSelection = mod.$moveCaretSelection;\nexport const $moveCharacter = mod.$moveCharacter;\nexport const $patchStyleText = mod.$patchStyleText;\nexport const $selectAll = mod.$selectAll;\nexport const $setBlocksType = mod.$setBlocksType;\nexport const $shouldOverrideDefaultCharacterSelection = mod.$shouldOverrideDefaultCharacterSelection;\nexport const $sliceSelectedTextNodeContent = mod.$sliceSelectedTextNodeContent;\nexport const $trimTextContentFromAnchor = mod.$trimTextContentFromAnchor;\nexport const $wrapNodes = mod.$wrapNodes;\nexport const createDOMRange = mod.createDOMRange;\nexport const createRectsFromDOMRange = mod.createRectsFromDOMRange;\nexport const getCSSFromStyleObject = mod.getCSSFromStyleObject;\nexport const getStyleObjectFromCSS = mod.getStyleObjectFromCSS;\nexport const trimTextContentFromAnchor = mod.trimTextContentFromAnchor;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { effect, namedSignals } from '@lexical/extension';\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement, mergeRegister, $findMatchingParent, calculateZoomLevel } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $createParagraphNode, $isElementNode, $isLeafNode, $setPointFromCaret, $normalizeCaret, $getChildCaret, ElementNode, buildImportMap, $isParagraphNode, $applyNodeReplacement, $createTextNode, createCommand, COMMAND_PRIORITY_LOW, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ESCAPE_COMMAND, KEY_SPACE_COMMAND, $getNearestNodeFromDOMNode, KEY_ARROW_LEFT_COMMAND, getNearestEditorFromDOMNode, defineExtension, safeCast, $getNodeByKey, INSERT_PARAGRAPH_COMMAND, $isTextNode, TextNode } from 'lexical';\nimport { getStyleObjectFromCSS } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = $getSelection();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ($isRangeSelection(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isRootOrShadowRoot(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = $createParagraphNode();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ($isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ($isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = $isLeafNode(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = $getSelection();\n  if ($isRangeSelection(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isLeafNode(node)) {\n          const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = $createParagraphNode().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          $setPointFromCaret(selection.anchor, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          $setPointFromCaret(selection.focus, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = getStyleObjectFromCSS(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in getStyleObjectFromCSS(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n  __value;\n  /** @internal */\n  __checked;\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    updateListItemChecked(dom, this, prevNode);\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || $isParagraphNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode) {\n  const parent = listItemNode.getParent();\n  const isCheckbox = $isListNode(parent) && parent.getListType() === 'check' &&\n  // Only add attributes for leaf list items\n  !$isListNode(listItemNode.getFirstChild());\n  if (!isCheckbox) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const isJoplinCheckList = domNode.classList.contains('joplin-checkbox');\n  if (isJoplinCheckList) {\n    for (const child of domNode.children) {\n      if (child.classList.contains('checkbox-wrapper') && child.children.length > 0 && child.children[0].tagName === 'INPUT') {\n        return $convertCheckboxInput(child.children[0]);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n  __tag;\n  /** @internal */\n  __start;\n  /** @internal */\n  __listType;\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag || prevNode.__listType !== this.__listType) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if (isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append($isElementNode(node) && !($isListNode(node) || node.isInline()) ? $createTextNode(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list') ||\n  // is joplin checklist\n  domNode.getAttribute('data-is-checklist') === '1') {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return mergeRegister(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = $getNearestNodeFromDOMNode(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = $findMatchingParent(anchorNode, node => $isElementNode(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!isHTMLElement(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if (isHTMLElement(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = calculateZoomLevel(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if (isHTMLElement(event.target)) {\n      const domNode = event.target;\n      const editor = getNearestEditorFromDOMNode(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = $getNearestNodeFromDOMNode(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return isHTMLElement(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = $getNearestNodeFromDOMNode(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = createCommand('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = $getNodeByKey(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ($isTextNode(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = $findMatchingParent(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\n/**\n * Configures {@link ListNode}, {@link ListItemNode} and registers\n * the strict indent transform if `hasStrictIndent` is true (default false).\n */\nconst ListExtension = defineExtension({\n  build(editor, config, state) {\n    return namedSignals(config);\n  },\n  config: safeCast({\n    hasStrictIndent: false\n  }),\n  name: '@lexical/list/List',\n  nodes: [ListNode, ListItemNode],\n  register(editor, config, state) {\n    const stores = state.getOutput();\n    return mergeRegister(registerList(editor), effect(() => stores.hasStrictIndent.value ? registerListStrictIndentTransform(editor) : undefined));\n  }\n});\n\n/**\n * Registers checklist functionality for {@link ListNode} and\n * {@link ListItemNode} with a\n * {@link INSERT_CHECK_LIST_COMMAND} listener and\n * the expected keyboard and mouse interactions for\n * checkboxes.\n */\nconst CheckListExtension = defineExtension({\n  dependencies: [ListExtension],\n  name: '@lexical/list/CheckList',\n  register: registerCheckList\n});\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $insertList, $isListItemNode, $isListNode, $removeList, CheckListExtension, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListExtension, ListItemNode, ListNode, REMOVE_LIST_COMMAND, UPDATE_LIST_START_COMMAND, insertList, registerCheckList, registerList, registerListStrictIndentTransform, removeList };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { defineExtension, safeCast, CLEAR_EDITOR_COMMAND, COMMAND_PRIORITY_EDITOR, $getRoot, $getSelection, $createParagraphNode, $isRangeSelection, shallowMergeConfig, RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, $isEditorState, HISTORY_MERGE_TAG, createEditor, $getNodeByKey, createCommand, $create, CLICK_COMMAND, isDOMNode, $getNodeFromDOMNode, COMMAND_PRIORITY_LOW, DecoratorNode, $isNodeSelection, $createNodeSelection, $setSelection, KEY_TAB_COMMAND, OUTDENT_CONTENT_COMMAND, INDENT_CONTENT_COMMAND, INSERT_TAB_COMMAND, COMMAND_PRIORITY_CRITICAL, $isBlockElementNode, $createRangeSelection, $normalizeSelection__EXPERIMENTAL } from 'lexical';\nexport { configExtension, declarePeerDependency, defineExtension, safeCast, shallowMergeConfig } from 'lexical';\nimport { mergeRegister, addClassNamesToElement, removeClassNamesFromElement, $getNearestBlockElementAncestorOrThrow, $filter } from '@lexical/utils';\n\nconst i=Symbol.for(\"preact-signals\");function t(){if(r>1){r--;return}let i,t=false;while(void 0!==s){let o=s;s=void 0;f++;while(void 0!==o){const n=o.o;o.o=void 0;o.f&=-3;if(!(8&o.f)&&v(o))try{o.c();}catch(o){if(!t){i=o;t=true;}}o=n;}}f=0;r--;if(t)throw i}function o(i){if(r>0)return i();r++;try{return i()}finally{t();}}let n,s;function h(i){const t=n;n=void 0;try{return i()}finally{n=t;}}let r=0,f=0,e=0;function u(i){if(void 0===n)return;let t=i.n;if(void 0===t||t.t!==n){t={i:0,S:i,p:n.s,n:void 0,t:n,e:void 0,x:void 0,r:t};if(void 0!==n.s)n.s.n=t;n.s=t;i.n=t;if(32&n.f)i.S(t);return t}else if(-1===t.i){t.i=0;if(void 0!==t.n){t.n.p=t.p;if(void 0!==t.p)t.p.n=t.n;t.p=n.s;t.n=void 0;n.s.n=t;n.s=t;}return t}}function c(i,t){this.v=i;this.i=0;this.n=void 0;this.t=void 0;this.W=null==t?void 0:t.watched;this.Z=null==t?void 0:t.unwatched;this.name=null==t?void 0:t.name;}c.prototype.brand=i;c.prototype.h=function(){return  true};c.prototype.S=function(i){const t=this.t;if(t!==i&&void 0===i.e){i.x=t;this.t=i;if(void 0!==t)t.e=i;else h(()=>{var i;null==(i=this.W)||i.call(this);});}};c.prototype.U=function(i){if(void 0!==this.t){const t=i.e,o=i.x;if(void 0!==t){t.x=o;i.e=void 0;}if(void 0!==o){o.e=t;i.x=void 0;}if(i===this.t){this.t=o;if(void 0===o)h(()=>{var i;null==(i=this.Z)||i.call(this);});}}};c.prototype.subscribe=function(i){return E(()=>{const t=this.value,o=n;n=void 0;try{i(t);}finally{n=o;}},{name:\"sub\"})};c.prototype.valueOf=function(){return this.value};c.prototype.toString=function(){return this.value+\"\"};c.prototype.toJSON=function(){return this.value};c.prototype.peek=function(){const i=n;n=void 0;try{return this.value}finally{n=i;}};Object.defineProperty(c.prototype,\"value\",{get(){const i=u(this);if(void 0!==i)i.i=this.i;return this.v},set(i){if(i!==this.v){if(f>100)throw new Error(\"Cycle detected\");this.v=i;this.i++;e++;r++;try{for(let i=this.t;void 0!==i;i=i.x)i.t.N();}finally{t();}}}});function d(i,t){return new c(i,t)}function v(i){for(let t=i.s;void 0!==t;t=t.n)if(t.S.i!==t.i||!t.S.h()||t.S.i!==t.i)return  true;return  false}function l(i){for(let t=i.s;void 0!==t;t=t.n){const o=t.S.n;if(void 0!==o)t.r=o;t.S.n=t;t.i=-1;if(void 0===t.n){i.s=t;break}}}function y(i){let t,o=i.s;while(void 0!==o){const i=o.p;if(-1===o.i){o.S.U(o);if(void 0!==i)i.n=o.n;if(void 0!==o.n)o.n.p=i;}else t=o;o.S.n=o.r;if(void 0!==o.r)o.r=void 0;o=i;}i.s=t;}function a(i,t){c.call(this,void 0);this.x=i;this.s=void 0;this.g=e-1;this.f=4;this.W=null==t?void 0:t.watched;this.Z=null==t?void 0:t.unwatched;this.name=null==t?void 0:t.name;}a.prototype=new c;a.prototype.h=function(){this.f&=-3;if(1&this.f)return  false;if(32==(36&this.f))return  true;this.f&=-5;if(this.g===e)return  true;this.g=e;this.f|=1;if(this.i>0&&!v(this)){this.f&=-2;return  true}const i=n;try{l(this);n=this;const i=this.x();if(16&this.f||this.v!==i||0===this.i){this.v=i;this.f&=-17;this.i++;}}catch(i){this.v=i;this.f|=16;this.i++;}n=i;y(this);this.f&=-2;return  true};a.prototype.S=function(i){if(void 0===this.t){this.f|=36;for(let i=this.s;void 0!==i;i=i.n)i.S.S(i);}c.prototype.S.call(this,i);};a.prototype.U=function(i){if(void 0!==this.t){c.prototype.U.call(this,i);if(void 0===this.t){this.f&=-33;for(let i=this.s;void 0!==i;i=i.n)i.S.U(i);}}};a.prototype.N=function(){if(!(2&this.f)){this.f|=6;for(let i=this.t;void 0!==i;i=i.x)i.t.N();}};Object.defineProperty(a.prototype,\"value\",{get(){if(1&this.f)throw new Error(\"Cycle detected\");const i=u(this);this.h();if(void 0!==i)i.i=this.i;if(16&this.f)throw this.v;return this.v}});function w(i,t){return new a(i,t)}function _(i){const o=i.u;i.u=void 0;if(\"function\"==typeof o){r++;const s=n;n=void 0;try{o();}catch(t){i.f&=-2;i.f|=8;b(i);throw t}finally{n=s;t();}}}function b(i){for(let t=i.s;void 0!==t;t=t.n)t.S.U(t);i.x=void 0;i.s=void 0;_(i);}function g(i){if(n!==this)throw new Error(\"Out-of-order effect\");y(this);n=i;this.f&=-2;if(8&this.f)b(this);t();}function p(i,t){this.x=i;this.u=void 0;this.s=void 0;this.o=void 0;this.f=32;this.name=null==t?void 0:t.name;}p.prototype.c=function(){const i=this.S();try{if(8&this.f)return;if(void 0===this.x)return;const t=this.x();if(\"function\"==typeof t)this.u=t;}finally{i();}};p.prototype.S=function(){if(1&this.f)throw new Error(\"Cycle detected\");this.f|=1;this.f&=-9;_(this);l(this);r++;const i=n;n=this;return g.bind(this,i)};p.prototype.N=function(){if(!(2&this.f)){this.f|=2;this.o=s;s=this;}};p.prototype.d=function(){this.f|=8;if(!(1&this.f))b(this);};p.prototype.dispose=function(){this.d();};function E(i,t){const o=new p(i,t);try{o.c();}catch(i){o.d();throw i}const n=o.d.bind(o);n[Symbol.dispose]=n;return n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * @experimental\n * Return an object with the same shape as `defaults` with a {@link Signal}\n * for each value. If specified, the second `opts` argument is a partial\n * of overrides to the defaults and will be used as the initial value.\n *\n * Typically used to make a reactive version of some subset of the\n * configuration of an extension, so it can be reconfigured at runtime.\n *\n * @param defaults The object with default values\n * @param opts Overrides to those default values\n * @returns An object with signals initialized with the default values\n */\nfunction namedSignals(defaults, opts = {}) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const initial = {};\n  for (const k in defaults) {\n    const v = opts[k];\n    const store = d(v === undefined ? defaults[k] : v);\n    initial[k] = store;\n  }\n  return initial;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * An Extension to focus the LexicalEditor when the root element is set\n * (typically only when the editor is first created).\n */\nconst AutoFocusExtension = defineExtension({\n  build: (editor, config, state) => {\n    return namedSignals(config);\n  },\n  config: safeCast({\n    defaultSelection: 'rootEnd',\n    disabled: false\n  }),\n  name: '@lexical/extension/AutoFocus',\n  register(editor, config, state) {\n    const stores = state.getOutput();\n    return E(() => stores.disabled.value ? undefined : editor.registerRootListener(rootElement => {\n      editor.focus(() => {\n        // If we try and move selection to the same point with setBaseAndExtent, it won't\n        // trigger a re-focus on the element. So in the case this occurs, we'll need to correct it.\n        // Normally this is fine, Selection API !== Focus API, but fore the intents of the naming\n        // of this plugin, which should preserve focus too.\n        const activeElement = document.activeElement;\n        if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {\n          // Note: preventScroll won't work in Webkit.\n          rootElement.focus({\n            preventScroll: true\n          });\n        }\n      }, {\n        defaultSelection: stores.defaultSelection.peek()\n      });\n    }));\n  }\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $defaultOnClear() {\n  const root = $getRoot();\n  const selection = $getSelection();\n  const paragraph = $createParagraphNode();\n  root.clear();\n  root.append(paragraph);\n  if (selection !== null) {\n    paragraph.select();\n  }\n  if ($isRangeSelection(selection)) {\n    selection.format = 0;\n  }\n}\nfunction registerClearEditor(editor, $onClear = $defaultOnClear) {\n  return editor.registerCommand(CLEAR_EDITOR_COMMAND, payload => {\n    editor.update($onClear);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR);\n}\n\n/**\n * An extension to provide an implementation of {@link CLEAR_EDITOR_COMMAND}\n */\nconst ClearEditorExtension = defineExtension({\n  build(editor, config, state) {\n    return namedSignals(config);\n  },\n  config: safeCast({\n    $onClear: $defaultOnClear\n  }),\n  name: '@lexical/extension/ClearEditor',\n  register(editor, config, state) {\n    const {\n      $onClear\n    } = state.getOutput();\n    return E(() => registerClearEditor(editor, $onClear.value));\n  }\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * @experimental\n * Get the sets of nodes and types registered in the\n * {@link InitialEditorConfig}. This is to be used when an extension\n * needs to register optional behavior if some node or type is present.\n *\n * @param config The InitialEditorConfig (accessible from an extension's init)\n * @returns The known types and nodes as Sets\n */\nfunction getKnownTypesAndNodes(config) {\n  const types = new Set();\n  const nodes = new Set();\n  for (const klassOrReplacement of getNodeConfig(config)) {\n    const klass = typeof klassOrReplacement === 'function' ? klassOrReplacement : klassOrReplacement.replace;\n    types.add(klass.getType());\n    nodes.add(klass);\n  }\n  return {\n    nodes,\n    types\n  };\n}\nfunction getNodeConfig(config) {\n  return (typeof config.nodes === 'function' ? config.nodes() : config.nodes) || [];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * @experimental\n * Create a Signal that will subscribe to a value from an external store when watched, similar to\n * React's [useSyncExternalStore](https://react.dev/reference/react/useSyncExternalStore).\n *\n * @param getSnapshot Used to get the initial value of the signal when created and when first watched.\n * @param register A callback that will subscribe to some external store and update the signal, must return a dispose function.\n * @returns The signal\n */\nfunction watchedSignal(getSnapshot, register) {\n  let dispose;\n  return d(getSnapshot(), {\n    unwatched() {\n      if (dispose) {\n        dispose();\n        dispose = undefined;\n      }\n    },\n    watched() {\n      this.value = getSnapshot();\n      dispose = register(this);\n    }\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * An extension to provide the current EditorState as a signal\n */\nconst EditorStateExtension = defineExtension({\n  build(editor) {\n    return watchedSignal(() => editor.getEditorState(), editorStateSignal => editor.registerUpdateListener(payload => {\n      editorStateSignal.value = payload.editorState;\n    }));\n  },\n  name: '@lexical/extension/EditorState'\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Recursively merge the given theme configuration in-place.\n *\n * @returns If `a` and `b` are both objects (and `b` is not an Array) then\n * all keys in `b` are merged into `a` then `a` is returned.\n * Otherwise `b` is returned.\n *\n * @example\n * ```ts\n * const a = { a: \"a\", nested: { a: 1 } };\n * const b = { b: \"b\", nested: { b: 2 } };\n * const rval = deepThemeMergeInPlace(a, b);\n * expect(a).toBe(rval);\n * expect(a).toEqual({ a: \"a\", b: \"b\", nested: { a: 1, b: 2 } });\n * ```\n */\nfunction deepThemeMergeInPlace(a, b) {\n  if (a && b && !Array.isArray(b) && typeof a === 'object' && typeof b === 'object') {\n    const aObj = a;\n    const bObj = b;\n    for (const k in bObj) {\n      aObj[k] = deepThemeMergeInPlace(aObj[k], bObj[k]);\n    }\n    return a;\n  }\n  return b;\n}\n\nconst ExtensionRepStateIds = {\n  /* eslint-disable sort-keys-fix/sort-keys-fix */\n  unmarked: 0,\n  temporary: 1,\n  permanent: 2,\n  configured: 3,\n  initialized: 4,\n  built: 5,\n  registered: 6,\n  afterRegistration: 7\n  /* eslint-enable sort-keys-fix/sort-keys-fix */\n};\nfunction isExactlyUnmarkedExtensionRepState(state) {\n  return state.id === ExtensionRepStateIds.unmarked;\n}\nfunction isExactlyTemporaryExtensionRepState(state) {\n  return state.id === ExtensionRepStateIds.temporary;\n}\nfunction isExactlyPermanentExtensionRepState(state) {\n  return state.id === ExtensionRepStateIds.permanent;\n}\nfunction isConfiguredExtensionRepState(state) {\n  return state.id >= ExtensionRepStateIds.configured;\n}\nfunction isInitializedExtensionRepState(state) {\n  return state.id >= ExtensionRepStateIds.initialized;\n}\nfunction isBuiltExtensionRepState(state) {\n  return state.id >= ExtensionRepStateIds.built;\n}\nfunction isAfterRegistrationState(state) {\n  return state.id >= ExtensionRepStateIds.afterRegistration;\n}\nfunction applyTemporaryMark(state) {\n  if (!isExactlyUnmarkedExtensionRepState(state)) {\n    formatDevErrorMessage(`LexicalBuilder: Can not apply a temporary mark from state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.unmarked)} unmarked)`);\n  }\n  return Object.assign(state, {\n    id: ExtensionRepStateIds.temporary\n  });\n}\nfunction applyPermanentMark(state) {\n  if (!isExactlyTemporaryExtensionRepState(state)) {\n    formatDevErrorMessage(`LexicalBuilder: Can not apply a permanent mark from state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.temporary)} temporary)`);\n  }\n  return Object.assign(state, {\n    id: ExtensionRepStateIds.permanent\n  });\n}\nfunction applyConfiguredState(state, config, registerState) {\n  return Object.assign(state, {\n    config,\n    id: ExtensionRepStateIds.configured,\n    registerState\n  });\n}\nfunction applyInitializedState(state, initResult, registerState) {\n  return Object.assign(state, {\n    id: ExtensionRepStateIds.initialized,\n    initResult,\n    registerState\n  });\n}\nfunction applyBuiltState(state, output, registerState) {\n  return Object.assign(state, {\n    id: ExtensionRepStateIds.built,\n    output,\n    registerState\n  });\n}\nfunction applyRegisteredState(state) {\n  return Object.assign(state, {\n    id: ExtensionRepStateIds.registered\n  });\n}\nfunction applyAfterRegistrationState(state) {\n  return Object.assign(state, {\n    id: ExtensionRepStateIds.afterRegistration\n  });\n}\nfunction rollbackToBuiltState(state) {\n  return Object.assign(state, {\n    id: ExtensionRepStateIds.built\n  });\n}\nconst emptySet = new Set();\n\n/**\n * @internal\n */\nclass ExtensionRep {\n  builder;\n  configs;\n  _dependency;\n  _peerNameSet;\n  extension;\n  state;\n  _signal;\n  constructor(builder, extension) {\n    this.builder = builder;\n    this.extension = extension;\n    this.configs = new Set();\n    this.state = {\n      id: ExtensionRepStateIds.unmarked\n    };\n  }\n  mergeConfigs() {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- LexicalExtensionConfig<Extension> is any\n    let config = this.extension.config || {};\n    const mergeConfig = this.extension.mergeConfig ? this.extension.mergeConfig.bind(this.extension) : shallowMergeConfig;\n    for (const cfg of this.configs) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- LexicalExtensionConfig<Extension> is any\n      config = mergeConfig(config, cfg);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return -- any\n    return config;\n  }\n  init(editorConfig) {\n    const initialState = this.state;\n    if (!isExactlyPermanentExtensionRepState(initialState)) {\n      formatDevErrorMessage(`ExtensionRep: Can not configure from state id ${String(initialState.id)}`);\n    }\n    const initState = {\n      getDependency: this.getInitDependency.bind(this),\n      getDirectDependentNames: this.getDirectDependentNames.bind(this),\n      getPeer: this.getInitPeer.bind(this),\n      getPeerNameSet: this.getPeerNameSet.bind(this)\n    };\n    const buildState = {\n      ...initState,\n      getDependency: this.getDependency.bind(this),\n      getInitResult: this.getInitResult.bind(this),\n      getPeer: this.getPeer.bind(this)\n    };\n    const state = applyConfiguredState(initialState, this.mergeConfigs(), initState);\n    this.state = state;\n    let initResult;\n    if (this.extension.init) {\n      initResult = this.extension.init(editorConfig, state.config, initState);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion -- false positive\n    this.state = applyInitializedState(state, initResult, buildState);\n  }\n  build(editor) {\n    const state = this.state;\n    if (!(state.id === ExtensionRepStateIds.initialized)) {\n      formatDevErrorMessage(`ExtensionRep: register called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.built)} initialized)`);\n    }\n    let output;\n    if (this.extension.build) {\n      output = this.extension.build(editor, state.config, state.registerState);\n    }\n    const registerState = {\n      ...state.registerState,\n      getOutput: () => output,\n      getSignal: this.getSignal.bind(this)\n    };\n    this.state = applyBuiltState(state, output, registerState);\n  }\n  register(editor, signal) {\n    this._signal = signal;\n    const state = this.state;\n    if (!(state.id === ExtensionRepStateIds.built)) {\n      formatDevErrorMessage(`ExtensionRep: register called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.built)} built)`);\n    }\n    const cleanup = this.extension.register && this.extension.register(editor, state.config, state.registerState);\n    this.state = applyRegisteredState(state);\n    return () => {\n      const afterRegistrationState = this.state;\n      if (!(afterRegistrationState.id === ExtensionRepStateIds.afterRegistration)) {\n        formatDevErrorMessage(`ExtensionRep: rollbackToBuiltState called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.afterRegistration)} afterRegistration)`);\n      }\n      this.state = rollbackToBuiltState(afterRegistrationState);\n      if (cleanup) {\n        cleanup();\n      }\n    };\n  }\n  afterRegistration(editor) {\n    const state = this.state;\n    if (!(state.id === ExtensionRepStateIds.registered)) {\n      formatDevErrorMessage(`ExtensionRep: afterRegistration called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.registered)} registered)`);\n    }\n    let rval;\n    if (this.extension.afterRegistration) {\n      rval = this.extension.afterRegistration(editor, state.config, state.registerState);\n    }\n    this.state = applyAfterRegistrationState(state);\n    return rval;\n  }\n  getSignal() {\n    if (!(this._signal !== undefined)) {\n      formatDevErrorMessage(`ExtensionRep.getSignal() called before register`);\n    }\n    return this._signal;\n  }\n  getInitResult() {\n    if (!(this.extension.init !== undefined)) {\n      formatDevErrorMessage(`ExtensionRep: getInitResult() called for Extension ${this.extension.name} that does not define init`);\n    }\n    const state = this.state;\n    if (!isInitializedExtensionRepState(state)) {\n      formatDevErrorMessage(`ExtensionRep: getInitResult() called for ExtensionRep in state id ${String(state.id)} < ${String(ExtensionRepStateIds.initialized)} (initialized)`);\n    } // eslint-disable-next-line @typescript-eslint/no-unsafe-return -- any\n    return state.initResult;\n  }\n  getInitPeer(name) {\n    const rep = this.builder.extensionNameMap.get(name);\n    return rep ? rep.getExtensionInitDependency() : undefined;\n  }\n  getExtensionInitDependency() {\n    const state = this.state;\n    if (!isConfiguredExtensionRepState(state)) {\n      formatDevErrorMessage(`ExtensionRep: getExtensionInitDependency called in state id ${String(state.id)} (expected >= ${String(ExtensionRepStateIds.configured)} configured)`);\n    }\n    return {\n      config: state.config\n    };\n  }\n  getPeer(name) {\n    const rep = this.builder.extensionNameMap.get(name);\n    return rep ? rep.getExtensionDependency() : undefined;\n  }\n  getInitDependency(dep) {\n    const rep = this.builder.getExtensionRep(dep);\n    if (!(rep !== undefined)) {\n      formatDevErrorMessage(`LexicalExtensionBuilder: Extension ${this.extension.name} missing dependency extension ${dep.name} to be in registry`);\n    }\n    return rep.getExtensionInitDependency();\n  }\n  getDependency(dep) {\n    const rep = this.builder.getExtensionRep(dep);\n    if (!(rep !== undefined)) {\n      formatDevErrorMessage(`LexicalExtensionBuilder: Extension ${this.extension.name} missing dependency extension ${dep.name} to be in registry`);\n    }\n    return rep.getExtensionDependency();\n  }\n  getState() {\n    const state = this.state;\n    if (!isAfterRegistrationState(state)) {\n      formatDevErrorMessage(`ExtensionRep getState called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.afterRegistration)} afterRegistration)`);\n    }\n    return state;\n  }\n  getDirectDependentNames() {\n    return this.builder.incomingEdges.get(this.extension.name) || emptySet;\n  }\n  getPeerNameSet() {\n    let s = this._peerNameSet;\n    if (!s) {\n      s = new Set((this.extension.peerDependencies || []).map(([name]) => name));\n      this._peerNameSet = s;\n    }\n    return s;\n  }\n  getExtensionDependency() {\n    if (!this._dependency) {\n      const state = this.state;\n      if (!isBuiltExtensionRepState(state)) {\n        formatDevErrorMessage(`Extension ${this.extension.name} used as a dependency before build`);\n      }\n      this._dependency = {\n        config: state.config,\n        init: state.initResult,\n        output: state.output\n      };\n    }\n    return this._dependency;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: HISTORY_MERGE_TAG\n};\nfunction $defaultInitializer() {\n  const root = $getRoot();\n  if (root.isEmpty()) {\n    root.append($createParagraphNode());\n  }\n}\n/**\n * An extension to set the initial state of the editor from\n * a function or serialized JSON EditorState. This is\n * implicitly included with all editors built with\n * Lexical Extension. This happens in the `afterRegistration`\n * phase so your initial state may depend on registered commands,\n * but you should not call `editor.setRootElement` earlier than\n * this phase to avoid rendering an empty editor first.\n */\nconst InitialStateExtension = defineExtension({\n  config: safeCast({\n    setOptions: HISTORY_MERGE_OPTIONS,\n    updateOptions: HISTORY_MERGE_OPTIONS\n  }),\n  init({\n    $initialEditorState = $defaultInitializer\n  }) {\n    return {\n      $initialEditorState,\n      initialized: false\n    };\n  },\n  // eslint-disable-next-line sort-keys-fix/sort-keys-fix -- typescript inference is order dependent here for some reason\n  afterRegistration(editor, {\n    updateOptions,\n    setOptions\n  }, state) {\n    const initResult = state.getInitResult();\n    if (!initResult.initialized) {\n      initResult.initialized = true;\n      const {\n        $initialEditorState\n      } = initResult;\n      if ($isEditorState($initialEditorState)) {\n        editor.setEditorState($initialEditorState, setOptions);\n      } else if (typeof $initialEditorState === 'function') {\n        editor.update(() => {\n          $initialEditorState(editor);\n        }, updateOptions);\n      } else if ($initialEditorState && (typeof $initialEditorState === 'string' || typeof $initialEditorState === 'object')) {\n        const parsedEditorState = editor.parseEditorState($initialEditorState);\n        editor.setEditorState(parsedEditorState, setOptions);\n      }\n    }\n    return () => {};\n  },\n  name: '@lexical/extension/InitialState',\n  // These are automatically added by createEditor, we add them here so they are\n  // visible during extensionRep.init so extensions can see all known types before the\n  // editor is created.\n  // (excluding ArtificialNode__DO_NOT_USE because it isn't really public API\n  // and shouldn't change anything)\n  nodes: [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode]\n});\n\n/** @internal Use a well-known symbol for dev tools purposes */\nconst builderSymbol = Symbol.for('@lexical/extension/LexicalBuilder');\n/**\n * Build a LexicalEditor by combining together one or more extensions, optionally\n * overriding some of their configuration.\n *\n * @param extensions - Extension arguments (extensions or extensions with config overrides)\n * @returns An editor handle\n *\n * @example\n * A single root extension with multiple dependencies\n *\n * ```ts\n * const editor = buildEditorFromExtensions(\n *   defineExtension({\n *     name: \"[root]\",\n *     dependencies: [\n *       RichTextExtension,\n *       configExtension(EmojiExtension, { emojiBaseUrl: \"/assets/emoji\" }),\n *     ],\n *     register: (editor: LexicalEditor) => {\n *       console.log(\"Editor Created\");\n *       return () => console.log(\"Editor Disposed\");\n *     },\n *   }),\n * );\n * ```\n *\n * @example\n * A very similar minimal configuration without the register hook\n *\n * ```ts\n * const editor = buildEditorFromExtensions(\n *   RichTextExtension,\n *   configExtension(EmojiExtension, { emojiBaseUrl: \"/assets/emoji\" }),\n * );\n * ```\n */\nfunction buildEditorFromExtensions(...extensions) {\n  return LexicalBuilder.fromExtensions(extensions).buildEditor();\n}\n\n/** @internal */\nfunction noop() {\n  /*empty*/\n}\n\n/** Throw the given Error */\nfunction defaultOnError(err) {\n  throw err;\n}\n/** @internal */\nfunction maybeWithBuilder(editor) {\n  return editor;\n}\nfunction normalizeExtensionArgument(arg) {\n  return Array.isArray(arg) ? arg : [arg];\n}\nconst PACKAGE_VERSION = \"0.38.2+dev.esm\";\n\n/** @internal */\nclass LexicalBuilder {\n  roots;\n  extensionNameMap;\n  outgoingConfigEdges;\n  incomingEdges;\n  conflicts;\n  _sortedExtensionReps;\n  PACKAGE_VERSION;\n  constructor(roots) {\n    this.outgoingConfigEdges = new Map();\n    this.incomingEdges = new Map();\n    this.extensionNameMap = new Map();\n    this.conflicts = new Map();\n    this.PACKAGE_VERSION = PACKAGE_VERSION;\n    this.roots = roots;\n    for (const extension of roots) {\n      this.addExtension(extension);\n    }\n  }\n  static fromExtensions(extensions) {\n    const roots = [normalizeExtensionArgument(InitialStateExtension)];\n    for (const extension of extensions) {\n      roots.push(normalizeExtensionArgument(extension));\n    }\n    return new LexicalBuilder(roots);\n  }\n  static maybeFromEditor(editor) {\n    const builder = maybeWithBuilder(editor)[builderSymbol];\n    if (builder) {\n      // The dev tools variant of this will relax some of these invariants\n      if (!(builder.PACKAGE_VERSION === PACKAGE_VERSION)) {\n        formatDevErrorMessage(`LexicalBuilder.fromEditor: The given editor was created with LexicalBuilder ${builder.PACKAGE_VERSION} but this version is ${PACKAGE_VERSION}. A project should have exactly one copy of LexicalBuilder`);\n      }\n      if (!(builder instanceof LexicalBuilder)) {\n        formatDevErrorMessage(`LexicalBuilder.fromEditor: There are multiple copies of the same version of LexicalBuilder in your project, and this editor was created with another one. Your project, or one of its dependencies, has its package.json and/or bundler configured incorrectly.`);\n      }\n    }\n    return builder;\n  }\n\n  /** Look up the editor that was created by this LexicalBuilder or throw */\n  static fromEditor(editor) {\n    const builder = LexicalBuilder.maybeFromEditor(editor);\n    if (!(builder !== undefined)) {\n      formatDevErrorMessage(`LexicalBuilder.fromEditor: The given editor was not created with LexicalBuilder`);\n    }\n    return builder;\n  }\n  constructEditor() {\n    const {\n      $initialEditorState: _$initialEditorState,\n      onError,\n      ...editorConfig\n    } = this.buildCreateEditorArgs();\n    const editor = Object.assign(createEditor({\n      ...editorConfig,\n      ...(onError ? {\n        onError: err => {\n          onError(err, editor);\n        }\n      } : {})\n    }), {\n      [builderSymbol]: this\n    });\n    for (const extensionRep of this.sortedExtensionReps()) {\n      extensionRep.build(editor);\n    }\n    return editor;\n  }\n  buildEditor() {\n    let disposeOnce = noop;\n    function dispose() {\n      try {\n        disposeOnce();\n      } finally {\n        disposeOnce = noop;\n      }\n    }\n    const editor = Object.assign(this.constructEditor(), {\n      dispose,\n      [Symbol.dispose]: dispose\n    });\n    disposeOnce = mergeRegister(this.registerEditor(editor), () => editor.setRootElement(null));\n    return editor;\n  }\n  hasExtensionByName(name) {\n    return this.extensionNameMap.has(name);\n  }\n  getExtensionRep(extension) {\n    const rep = this.extensionNameMap.get(extension.name);\n    if (rep) {\n      if (!(rep.extension === extension)) {\n        formatDevErrorMessage(`LexicalBuilder: A registered extension with name ${extension.name} exists but does not match the given extension`);\n      }\n      return rep;\n    }\n  }\n  addEdge(fromExtensionName, toExtensionName, configs) {\n    const outgoing = this.outgoingConfigEdges.get(fromExtensionName);\n    if (outgoing) {\n      outgoing.set(toExtensionName, configs);\n    } else {\n      this.outgoingConfigEdges.set(fromExtensionName, new Map([[toExtensionName, configs]]));\n    }\n    const incoming = this.incomingEdges.get(toExtensionName);\n    if (incoming) {\n      incoming.add(fromExtensionName);\n    } else {\n      this.incomingEdges.set(toExtensionName, new Set([fromExtensionName]));\n    }\n  }\n  addExtension(arg) {\n    if (!(this._sortedExtensionReps === undefined)) {\n      formatDevErrorMessage(`LexicalBuilder: addExtension called after finalization`);\n    }\n    const normalized = normalizeExtensionArgument(arg);\n    const [extension] = normalized;\n    if (!(typeof extension.name === 'string')) {\n      formatDevErrorMessage(`LexicalBuilder: extension name must be string, not ${typeof extension.name}`);\n    }\n    let extensionRep = this.extensionNameMap.get(extension.name);\n    if (!(extensionRep === undefined || extensionRep.extension === extension)) {\n      formatDevErrorMessage(`LexicalBuilder: Multiple extensions registered with name ${extension.name}, names must be unique`);\n    }\n    if (!extensionRep) {\n      extensionRep = new ExtensionRep(this, extension);\n      this.extensionNameMap.set(extension.name, extensionRep);\n      const hasConflict = this.conflicts.get(extension.name);\n      if (typeof hasConflict === 'string') {\n        {\n          formatDevErrorMessage(`LexicalBuilder: extension ${extension.name} conflicts with ${hasConflict}`);\n        }\n      }\n      for (const name of extension.conflictsWith || []) {\n        if (!!this.extensionNameMap.has(name)) {\n          formatDevErrorMessage(`LexicalBuilder: extension ${extension.name} conflicts with ${name}`);\n        }\n        this.conflicts.set(name, extension.name);\n      }\n      for (const dep of extension.dependencies || []) {\n        const normDep = normalizeExtensionArgument(dep);\n        this.addEdge(extension.name, normDep[0].name, normDep.slice(1));\n        this.addExtension(normDep);\n      }\n      for (const [depName, config] of extension.peerDependencies || []) {\n        this.addEdge(extension.name, depName, config ? [config] : []);\n      }\n    }\n  }\n  sortedExtensionReps() {\n    if (this._sortedExtensionReps) {\n      return this._sortedExtensionReps;\n    }\n    // depth-first search based topological DAG sort\n    // https://en.wikipedia.org/wiki/Topological_sorting\n    const sortedExtensionReps = [];\n    const visit = (rep, fromExtensionName) => {\n      let mark = rep.state;\n      if (isExactlyPermanentExtensionRepState(mark)) {\n        return;\n      }\n      const extensionName = rep.extension.name;\n      if (!isExactlyUnmarkedExtensionRepState(mark)) {\n        formatDevErrorMessage(`LexicalBuilder: Circular dependency detected for Extension ${extensionName} from ${fromExtensionName || '[unknown]'}`);\n      }\n      mark = applyTemporaryMark(mark);\n      rep.state = mark;\n      const outgoingConfigEdges = this.outgoingConfigEdges.get(extensionName);\n      if (outgoingConfigEdges) {\n        for (const toExtensionName of outgoingConfigEdges.keys()) {\n          const toRep = this.extensionNameMap.get(toExtensionName);\n          // may be undefined for an optional peer dependency\n          if (toRep) {\n            visit(toRep, extensionName);\n          }\n        }\n      }\n      mark = applyPermanentMark(mark);\n      rep.state = mark;\n      sortedExtensionReps.push(rep);\n    };\n    for (const rep of this.extensionNameMap.values()) {\n      if (isExactlyUnmarkedExtensionRepState(rep.state)) {\n        visit(rep);\n      }\n    }\n    for (const rep of sortedExtensionReps) {\n      for (const [toExtensionName, configs] of this.outgoingConfigEdges.get(rep.extension.name) || []) {\n        if (configs.length > 0) {\n          const toRep = this.extensionNameMap.get(toExtensionName);\n          if (toRep) {\n            for (const config of configs) {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- any\n              toRep.configs.add(config);\n            }\n          }\n        }\n      }\n    }\n    for (const [extension, ...configs] of this.roots) {\n      if (configs.length > 0) {\n        const toRep = this.extensionNameMap.get(extension.name);\n        if (!(toRep !== undefined)) {\n          formatDevErrorMessage(`LexicalBuilder: Expecting existing ExtensionRep for ${extension.name}`);\n        }\n        for (const config of configs) {\n          toRep.configs.add(config);\n        }\n      }\n    }\n    this._sortedExtensionReps = sortedExtensionReps;\n    return this._sortedExtensionReps;\n  }\n  registerEditor(editor) {\n    const extensionReps = this.sortedExtensionReps();\n    const controller = new AbortController();\n    const cleanups = [() => controller.abort()];\n    const signal = controller.signal;\n    for (const extensionRep of extensionReps) {\n      const cleanup = extensionRep.register(editor, signal);\n      if (cleanup) {\n        cleanups.push(cleanup);\n      }\n    }\n    for (const extensionRep of extensionReps) {\n      const cleanup = extensionRep.afterRegistration(editor);\n      if (cleanup) {\n        cleanups.push(cleanup);\n      }\n    }\n    return mergeRegister(...cleanups);\n  }\n  buildCreateEditorArgs() {\n    const config = {};\n    const nodes = new Set();\n    const replacedNodes = new Map();\n    const htmlExport = new Map();\n    const htmlImport = {};\n    const theme = {};\n    const extensionReps = this.sortedExtensionReps();\n    for (const extensionRep of extensionReps) {\n      const {\n        extension\n      } = extensionRep;\n      if (extension.onError !== undefined) {\n        config.onError = extension.onError;\n      }\n      if (extension.disableEvents !== undefined) {\n        config.disableEvents = extension.disableEvents;\n      }\n      if (extension.parentEditor !== undefined) {\n        config.parentEditor = extension.parentEditor;\n      }\n      if (extension.editable !== undefined) {\n        config.editable = extension.editable;\n      }\n      if (extension.namespace !== undefined) {\n        config.namespace = extension.namespace;\n      }\n      if (extension.$initialEditorState !== undefined) {\n        config.$initialEditorState = extension.$initialEditorState;\n      }\n      if (extension.nodes) {\n        for (const node of getNodeConfig(extension)) {\n          if (typeof node !== 'function') {\n            const conflictExtension = replacedNodes.get(node.replace);\n            if (conflictExtension) {\n              {\n                formatDevErrorMessage(`LexicalBuilder: Extension ${extension.name} can not register replacement for node ${node.replace.name} because ${conflictExtension.extension.name} already did`);\n              }\n            }\n            replacedNodes.set(node.replace, extensionRep);\n          }\n          nodes.add(node);\n        }\n      }\n      if (extension.html) {\n        if (extension.html.export) {\n          for (const [k, v] of extension.html.export.entries()) {\n            htmlExport.set(k, v);\n          }\n        }\n        if (extension.html.import) {\n          Object.assign(htmlImport, extension.html.import);\n        }\n      }\n      if (extension.theme) {\n        deepThemeMergeInPlace(theme, extension.theme);\n      }\n    }\n    if (Object.keys(theme).length > 0) {\n      config.theme = theme;\n    }\n    if (nodes.size) {\n      config.nodes = [...nodes];\n    }\n    const hasImport = Object.keys(htmlImport).length > 0;\n    const hasExport = htmlExport.size > 0;\n    if (hasImport || hasExport) {\n      config.html = {};\n      if (hasImport) {\n        config.html.import = htmlImport;\n      }\n      if (hasExport) {\n        config.html.export = htmlExport;\n      }\n    }\n    for (const extensionRep of extensionReps) {\n      extensionRep.init(config);\n    }\n    if (!config.onError) {\n      config.onError = defaultOnError;\n    }\n    return config;\n  }\n}\n\n/**\n * @experimental\n * Get the finalized config and output of an Extension that was used to build the editor.\n *\n * This is useful in the implementation of a LexicalNode or in other\n * situations where you have an editor reference but it's not easy to\n * pass the config or {@link ExtensionRegisterState} around.\n *\n * It will throw if the Editor was not built using this Extension.\n *\n * @param editor - The editor that was built using extension\n * @param extension - The concrete reference to an Extension used to build this editor\n * @returns The config and output for that Extension\n */\nfunction getExtensionDependencyFromEditor(editor, extension) {\n  const builder = LexicalBuilder.fromEditor(editor);\n  const rep = builder.getExtensionRep(extension);\n  if (!(rep !== undefined)) {\n    formatDevErrorMessage(`getExtensionDependencyFromEditor: Extension ${extension.name} was not built when creating this editor`);\n  }\n  return rep.getExtensionDependency();\n}\n\n/**\n * @experimental\n * Get the finalized config and output of an Extension that was used to build the\n * editor by name.\n *\n * This can be used from the implementation of a LexicalNode or in other\n * situation where you have an editor reference but it's not easy to pass the\n * config around. Use this version if you do not have a concrete reference to\n * the Extension for some reason (e.g. it is an optional peer dependency, or you\n * are avoiding a circular import).\n *\n * Both the explicit Extension type and the name are required.\n *\n *  @example\n * ```tsx\n * import type { HistoryExtension } from \"@lexical/history\";\n * getPeerDependencyFromEditor<typeof HistoryExtension>(editor, \"@lexical/history/History\");\n * ```\n\n * @param editor - The editor that may have been built using extension\n * @param extensionName - The name of the Extension\n * @returns The config and output of the Extension or undefined\n */\nfunction getPeerDependencyFromEditor(editor, extensionName) {\n  const builder = LexicalBuilder.fromEditor(editor);\n  const peer = builder.extensionNameMap.get(extensionName);\n  return peer ? peer.getExtensionDependency() : undefined;\n}\n\n/**\n * Get the finalized config and output of an Extension that was used to build the\n * editor by name.\n *\n * This can be used from the implementation of a LexicalNode or in other\n * situation where you have an editor reference but it's not easy to pass the\n * config around. Use this version if you do not have a concrete reference to\n * the Extension for some reason (e.g. it is an optional peer dependency, or you\n * are avoiding a circular import).\n *\n * Both the explicit Extension type and the name are required.\n *\n *  @example\n * ```tsx\n * import type { EmojiExtension } from \"./EmojiExtension\";\n * export class EmojiNode extends TextNode {\n *   // other implementation details not included\n *   createDOM(\n *     config: EditorConfig,\n *     editor?: LexicalEditor | undefined\n *   ): HTMLElement {\n *     const dom = super.createDOM(config, editor);\n *     addClassNamesToElement(\n *       dom,\n *       getPeerDependencyFromEditorOrThrow<typeof EmojiExtension>(\n *         editor || $getEditor(),\n *         \"@lexical/playground/emoji\",\n *       ).config.emojiClass,\n *     );\n *     return dom;\n *   }\n * }\n * ```\n\n * @param editor - The editor that may have been built using extension\n * @param extensionName - The name of the Extension\n * @returns The config and output of the Extension\n */\nfunction getPeerDependencyFromEditorOrThrow(editor, extensionName) {\n  const dep = getPeerDependencyFromEditor(editor, extensionName);\n  if (!(dep !== undefined)) {\n    formatDevErrorMessage(`getPeerDependencyFromEditorOrThrow: Editor was not built with Extension ${extensionName}`);\n  }\n  return dep;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst EMPTY_SET = new Set();\n\n/**\n * An extension that provides a `watchNodeKey` output that\n * returns a signal for the selection state of a node.\n *\n * Typically used for tracking whether a DecoratorNode is\n * currently selected or not. A framework independent\n * alternative to {@link useLexicalNodeSelection}.\n */\nconst NodeSelectionExtension = defineExtension({\n  build(editor, config, state) {\n    const editorStateStore = state.getDependency(EditorStateExtension).output;\n    const watchedNodeStore = d({\n      watchedNodeKeys: new Map()\n    });\n    const selectedNodeKeys = watchedSignal(() => undefined, () => E(() => {\n      const prevSelectedNodeKeys = selectedNodeKeys.peek();\n      const {\n        watchedNodeKeys\n      } = watchedNodeStore.value;\n      let nextSelectedNodeKeys;\n      let didChange = false;\n      editorStateStore.value.read(() => {\n        const selection = $getSelection();\n        if (selection) {\n          for (const [key, listeners] of watchedNodeKeys.entries()) {\n            if (listeners.size === 0) {\n              // We intentionally mutate this without firing a signal, to\n              // avoid re-triggering this effect. There are no subscribers\n              // so nothing can observe whether key was in the set or not\n              watchedNodeKeys.delete(key);\n              continue;\n            }\n            const node = $getNodeByKey(key);\n            const isSelected = node && node.isSelected() || false;\n            didChange = didChange || isSelected !== (prevSelectedNodeKeys ? prevSelectedNodeKeys.has(key) : false);\n            if (isSelected) {\n              nextSelectedNodeKeys = nextSelectedNodeKeys || new Set();\n              nextSelectedNodeKeys.add(key);\n            }\n          }\n        }\n      });\n      if (!(!didChange && nextSelectedNodeKeys && prevSelectedNodeKeys && nextSelectedNodeKeys.size === prevSelectedNodeKeys.size)) {\n        selectedNodeKeys.value = nextSelectedNodeKeys;\n      }\n    }));\n    function watchNodeKey(key) {\n      const watcher = w(() => (selectedNodeKeys.value || EMPTY_SET).has(key));\n      const {\n        watchedNodeKeys\n      } = watchedNodeStore.peek();\n      let listeners = watchedNodeKeys.get(key);\n      const hadListener = listeners !== undefined;\n      listeners = listeners || new Set();\n      listeners.add(watcher);\n      if (!hadListener) {\n        watchedNodeKeys.set(key, listeners);\n        watchedNodeStore.value = {\n          watchedNodeKeys\n        };\n      }\n      return watcher;\n    }\n    return {\n      watchNodeKey\n    };\n  },\n  dependencies: [EditorStateExtension],\n  name: '@lexical/extension/NodeSelection'\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_HORIZONTAL_RULE_COMMAND = createCommand('INSERT_HORIZONTAL_RULE_COMMAND');\nclass HorizontalRuleNode extends DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode().updateFromJSON(serializedNode);\n  }\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('hr');\n    addClassNamesToElement(element, config.theme.hr);\n    return element;\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  isInline() {\n    return false;\n  }\n  updateDOM() {\n    return false;\n  }\n}\nfunction $convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\nfunction $createHorizontalRuleNode() {\n  return $create(HorizontalRuleNode);\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\nfunction $toggleNodeSelection(node, shiftKey = false) {\n  const selection = $getSelection();\n  const wasSelected = node.isSelected();\n  const key = node.getKey();\n  let nodeSelection;\n  if (shiftKey && $isNodeSelection(selection)) {\n    nodeSelection = selection;\n  } else {\n    nodeSelection = $createNodeSelection();\n    $setSelection(nodeSelection);\n  }\n  if (wasSelected) {\n    nodeSelection.delete(key);\n  } else {\n    nodeSelection.add(key);\n  }\n}\n\n/**\n * An extension for HorizontalRuleNode that provides an implementation that\n * works without any React dependency.\n */\nconst HorizontalRuleExtension = defineExtension({\n  dependencies: [EditorStateExtension, NodeSelectionExtension],\n  name: '@lexical/extension/HorizontalRule',\n  nodes: [HorizontalRuleNode],\n  register(editor, config, state) {\n    const {\n      watchNodeKey\n    } = state.getDependency(NodeSelectionExtension).output;\n    const nodeSelectionStore = d({\n      nodeSelections: new Map()\n    });\n    const isSelectedClassName = editor._config.theme.hrSelected ?? 'selected';\n    return mergeRegister(editor.registerCommand(CLICK_COMMAND, event => {\n      if (isDOMNode(event.target)) {\n        const node = $getNodeFromDOMNode(event.target);\n        if ($isHorizontalRuleNode(node)) {\n          $toggleNodeSelection(node, event.shiftKey);\n          return true;\n        }\n      }\n      return false;\n    }, COMMAND_PRIORITY_LOW), editor.registerMutationListener(HorizontalRuleNode, (nodes, payload) => {\n      o(() => {\n        let didChange = false;\n        const {\n          nodeSelections\n        } = nodeSelectionStore.peek();\n        for (const [k, v] of nodes.entries()) {\n          if (v === 'destroyed') {\n            nodeSelections.delete(k);\n            didChange = true;\n          } else {\n            const prev = nodeSelections.get(k);\n            const dom = editor.getElementByKey(k);\n            if (prev) {\n              prev.domNode.value = dom;\n            } else {\n              didChange = true;\n              nodeSelections.set(k, {\n                domNode: d(dom),\n                selectedSignal: watchNodeKey(k)\n              });\n            }\n          }\n        }\n        if (didChange) {\n          nodeSelectionStore.value = {\n            nodeSelections\n          };\n        }\n      });\n    }), E(() => {\n      const effects = [];\n      for (const {\n        domNode,\n        selectedSignal\n      } of nodeSelectionStore.value.nodeSelections.values()) {\n        effects.push(E(() => {\n          const dom = domNode.value;\n          if (dom) {\n            const isSelected = selectedSignal.value;\n            if (isSelected) {\n              addClassNamesToElement(dom, isSelectedClassName);\n            } else {\n              removeClassNamesFromElement(dom, isSelectedClassName);\n            }\n          }\n        }));\n      }\n      return mergeRegister(...effects);\n    }));\n  }\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $indentOverTab(selection) {\n  // const handled = new Set();\n  const nodes = selection.getNodes();\n  const canIndentBlockNodes = $filter(nodes, node => {\n    if ($isBlockElementNode(node) && node.canIndent()) {\n      return node;\n    }\n    return null;\n  });\n  // 1. If selection spans across canIndent block nodes: indent\n  if (canIndentBlockNodes.length > 0) {\n    return true;\n  }\n  // 2. If first (anchor/focus) is at block start: indent\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const first = focus.isBefore(anchor) ? focus : anchor;\n  const firstNode = first.getNode();\n  const firstBlock = $getNearestBlockElementAncestorOrThrow(firstNode);\n  if (firstBlock.canIndent()) {\n    const firstBlockKey = firstBlock.getKey();\n    let selectionAtStart = $createRangeSelection();\n    selectionAtStart.anchor.set(firstBlockKey, 0, 'element');\n    selectionAtStart.focus.set(firstBlockKey, 0, 'element');\n    selectionAtStart = $normalizeSelection__EXPERIMENTAL(selectionAtStart);\n    if (selectionAtStart.anchor.is(first)) {\n      return true;\n    }\n  }\n  // 3. Else: tab\n  return false;\n}\nfunction registerTabIndentation(editor, maxIndent) {\n  return mergeRegister(editor.registerCommand(KEY_TAB_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const command = $indentOverTab(selection) ? event.shiftKey ? OUTDENT_CONTENT_COMMAND : INDENT_CONTENT_COMMAND : INSERT_TAB_COMMAND;\n    return editor.dispatchCommand(command, undefined);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {\n    const currentMaxIndent = typeof maxIndent === 'number' ? maxIndent : maxIndent ? maxIndent.peek() : null;\n    if (currentMaxIndent == null) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const indents = selection.getNodes().map(node => $getNearestBlockElementAncestorOrThrow(node).getIndent());\n    return Math.max(...indents) + 1 >= currentMaxIndent;\n  }, COMMAND_PRIORITY_CRITICAL));\n}\n/**\n * This extension adds the ability to indent content using the tab key. Generally, we don't\n * recommend using this plugin as it could negatively affect accessibility for keyboard\n * users, causing focus to become trapped within the editor.\n */\nconst TabIndentationExtension = defineExtension({\n  build(editor, config, state) {\n    return namedSignals(config);\n  },\n  config: safeCast({\n    disabled: false,\n    maxIndent: null\n  }),\n  name: '@lexical/extension/TabIndentation',\n  register(editor, config, state) {\n    const {\n      disabled,\n      maxIndent\n    } = state.getOutput();\n    return E(() => {\n      if (!disabled.value) {\n        return registerTabIndentation(editor, maxIndent);\n      }\n    });\n  }\n});\n\nexport { $createHorizontalRuleNode, $isHorizontalRuleNode, AutoFocusExtension, ClearEditorExtension, EditorStateExtension, HorizontalRuleExtension, HorizontalRuleNode, INSERT_HORIZONTAL_RULE_COMMAND, InitialStateExtension, LexicalBuilder, NodeSelectionExtension, TabIndentationExtension, o as batch, buildEditorFromExtensions, w as computed, E as effect, getExtensionDependencyFromEditor, getKnownTypesAndNodes, getPeerDependencyFromEditor, getPeerDependencyFromEditorOrThrow, namedSignals, registerClearEditor, registerTabIndentation, d as signal, h as untracked, watchedSignal };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, $getSelection, $isRangeSelection, $isElementNode, getDOMTextNode, $getAdjacentSiblingOrParentSiblingCaret, $getSiblingCaret, $getChildCaretOrSelf, $findMatchingParent, $cloneWithProperties, $setSelection, $getPreviousSelection, $caretFromPoint, $getChildCaret, $getRoot, $createParagraphNode, $getAdjacentChildCaret, $isChildCaret, $normalizeCaret, $setSelectionFromCaretRange, $getCollapsedCaretRange, $getCaretInDirection, $splitAtPointCaretNext, $isTextPointCaret, $rewindSiblingCaret, $getState, $setState, makeStepwiseIterator, $isSiblingCaret } from 'lexical';\nexport { $findMatchingParent, $getAdjacentSiblingOrParentSiblingCaret, $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\nimport { createRectsFromDOMRange } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && IS_APPLE$1 && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't necessarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!isHTMLElement(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $getOrderedSelectionPoints(selection) {\n  const points = selection.getStartEndPoints();\n  return selection.isBackward() ? [points[1], points[0]] : points;\n}\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !$isElementNode(node)) {\n    const textDOM = getDOMTextNode(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, start, startNode, startDOM, end, endNode, endDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  range.setStart(...rangeTargetFromPoint(start, startNode, startDOM));\n  range.setEnd(...rangeTargetFromPoint(end, endNode, endDOM));\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const [start, end] = $getOrderedSelectionPoints(selection);\n      const currentStartNode = start.getNode();\n      const currentStartNodeKey = currentStartNode.getKey();\n      const currentStartOffset = start.offset;\n      const currentEndNode = end.getNode();\n      const currentEndNodeKey = currentEndNode.getKey();\n      const currentEndOffset = end.offset;\n      const currentStartNodeDOM = editor.getElementByKey(currentStartNodeKey);\n      const currentEndNodeDOM = editor.getElementByKey(currentEndNodeKey);\n      const differentStartDOM = previousAnchorNode === null || currentStartNodeDOM !== previousAnchorNodeDOM || currentStartOffset !== previousAnchorOffset || currentStartNodeKey !== previousAnchorNode.getKey();\n      const differentEndDOM = previousFocusNode === null || currentEndNodeDOM !== previousFocusNodeDOM || currentEndOffset !== previousFocusOffset || currentEndNodeKey !== previousFocusNode.getKey();\n      if ((differentStartDOM || differentEndDOM) && currentStartNodeDOM !== null && currentEndNodeDOM !== null) {\n        const range = rangeFromPoints(editor, start, currentStartNode, currentStartNodeDOM, end, currentEndNode, currentEndNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentStartNode;\n      previousAnchorNodeDOM = currentStartNodeDOM;\n      previousAnchorOffset = currentStartOffset;\n      previousFocusNode = currentEndNode;\n      previousFocusNodeDOM = currentEndNodeDOM;\n      previousFocusOffset = currentEndOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\n\n/**\n * Get the adjacent caret in the same direction\n *\n * @param caret A caret or null\n * @returns `caret.getAdjacentCaret()` or `null`\n */\nfunction $getAdjacentCaret(caret) {\n  return caret ? caret.getAdjacentCaret() : null;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfs(startNode, endNode) {\n  return Array.from($reverseDfsIterator(startNode, endNode));\n}\n\n/**\n * $dfs iterator (left to right). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('next', startNode, endNode);\n}\nfunction $getEndCaret(startNode, direction) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret($getSiblingCaret(startNode, direction));\n  return rval && rval[0];\n}\nfunction $dfsCaretIterator(direction, startNode, endNode) {\n  const root = $getRoot();\n  const start = startNode || root;\n  const startCaret = $isElementNode(start) ? $getChildCaret(start, direction) : $getSiblingCaret(start, direction);\n  const startDepth = $getDepth(start);\n  const endCaret = endNode ? $getAdjacentChildCaret($getChildCaretOrSelf($getSiblingCaret(endNode, direction))) : $getEndCaret(start, direction);\n  let depth = startDepth;\n  return makeStepwiseIterator({\n    hasNext: state => state !== null,\n    initial: startCaret,\n    map: state => ({\n      depth,\n      node: state.origin\n    }),\n    step: state => {\n      if (state.isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      if ($isChildCaret(state)) {\n        depth++;\n      }\n      const rval = $getAdjacentSiblingOrParentSiblingCaret(state);\n      if (!rval || rval[0].isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      depth += rval[1];\n      return rval[0];\n    }\n  });\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret($getSiblingCaret(node, 'next'));\n  return rval && [rval[0].origin, rval[1]];\n}\nfunction $getDepth(node) {\n  let depth = -1;\n  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to parent and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  const startCaret = $getChildCaretOrSelf($getSiblingCaret(startingNode, 'previous'));\n  const next = $getAdjacentSiblingOrParentSiblingCaret(startCaret, 'root');\n  return next && next[0].origin;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('previous', startNode, endNode);\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, $cloneWithProperties(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  let initialCaret;\n  if ($isRangeSelection(selection)) {\n    initialCaret = $caretFromPoint(selection.focus, 'next');\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      const lastNode = nodes[nodes.length - 1];\n      if (lastNode) {\n        initialCaret = $getSiblingCaret(lastNode, 'next');\n      }\n    }\n    initialCaret = initialCaret || $getChildCaret($getRoot(), 'previous').getFlipped().insert($createParagraphNode());\n  }\n  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);\n  const adjacent = $getAdjacentChildCaret(insertCaret);\n  const selectionCaret = $isChildCaret(adjacent) ? $normalizeCaret(adjacent) : insertCaret;\n  $setSelectionFromCaretRange($getCollapsedCaretRange(selectionCaret));\n  return node.getLatest();\n}\n\n/**\n * If the insertion caret is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be inserted there, otherwise the parent nodes will be split according to the\n * given options.\n * @param node - The node to be inserted\n * @param caret - The location to insert or split from\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRootAtCaret(node, caret, options) {\n  let insertCaret = $getCaretInDirection(caret, 'next');\n  for (let nextCaret = insertCaret; nextCaret; nextCaret = $splitAtPointCaretNext(nextCaret, options)) {\n    insertCaret = nextCaret;\n  }\n  if (!!$isTextPointCaret(insertCaret)) {\n    formatDevErrorMessage(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);\n  }\n  insertCaret.insert(node.isInline() ? $createParagraphNode().append(node) : node);\n  return $getCaretInDirection($getSiblingCaret(node.getLatest(), 'next'), caret.direction);\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframes)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  $getChildCaret(parent, 'next').insert(node);\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ($isElementNode(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || (child => node.insertAfter(child)));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = Array.from(children).reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ($isElementNode(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return $childIterator($getChildCaret(node, 'next'));\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return $childIterator($getChildCaret(node, 'previous'));\n}\nfunction $childIterator(startCaret) {\n  const seen = new Set() ;\n  return makeStepwiseIterator({\n    hasNext: $isSiblingCaret,\n    initial: startCaret.getAdjacentCaret(),\n    map: caret => {\n      const origin = caret.origin.getLatest();\n      if (seen !== null) {\n        const key = origin.getKey();\n        if (!!seen.has(key)) {\n          formatDevErrorMessage(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      return origin;\n    },\n    step: caret => caret.getAdjacentCaret()\n  });\n}\n\n/**\n * Replace this node with its children\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  $rewindSiblingCaret($getSiblingCaret(node, 'next')).splice(1, node.getChildren());\n}\n\n/**\n * A wrapper that creates bound functions and methods for the\n * StateConfig to save some boilerplate when defining methods\n * or exporting only the accessors from your modules rather\n * than exposing the StateConfig directly.\n */\n\n/**\n * EXPERIMENTAL\n *\n * A convenience interface for working with {@link $getState} and\n * {@link $setState}.\n *\n * @param stateConfig The stateConfig to wrap with convenience functionality\n * @returns a StateWrapper\n */\nfunction makeStateWrapper(stateConfig) {\n  const $get = node => $getState(node, stateConfig);\n  const $set = (node, valueOrUpdater) => $setState(node, stateConfig, valueOrUpdater);\n  return {\n    $get,\n    $set,\n    accessors: [$get, $set],\n    makeGetterMethod: () => function $getter() {\n      return $get(this);\n    },\n    makeSetterMethod: () => function $setter(valueOrUpdater) {\n      return $set(this, valueOrUpdater);\n    },\n    stateConfig\n  };\n}\n\nexport { $descendantsMatching, $dfs, $dfsIterator, $filter, $firstToLastIterator, $getAdjacentCaret, $getDepth, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $getNextSiblingOrParentSibling, $insertFirst, $insertNodeToNearestRoot, $insertNodeToNearestRootAtCaret, $isEditorIsNestedEditor, $lastToFirstIterator, $restoreEditorState, $reverseDfs, $reverseDfsIterator, $unwrapAndFilterDescendants, $unwrapNode, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, makeStateWrapper, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, mlcPositionNodeOnRange as positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement, selectionAlwaysOnDisplay };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalUtils.dev.mjs';\nimport * as modProd from './LexicalUtils.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $descendantsMatching = mod.$descendantsMatching;\nexport const $dfs = mod.$dfs;\nexport const $dfsIterator = mod.$dfsIterator;\nexport const $filter = mod.$filter;\nexport const $findMatchingParent = mod.$findMatchingParent;\nexport const $firstToLastIterator = mod.$firstToLastIterator;\nexport const $getAdjacentCaret = mod.$getAdjacentCaret;\nexport const $getAdjacentSiblingOrParentSiblingCaret = mod.$getAdjacentSiblingOrParentSiblingCaret;\nexport const $getDepth = mod.$getDepth;\nexport const $getNearestBlockElementAncestorOrThrow = mod.$getNearestBlockElementAncestorOrThrow;\nexport const $getNearestNodeOfType = mod.$getNearestNodeOfType;\nexport const $getNextRightPreorderNode = mod.$getNextRightPreorderNode;\nexport const $getNextSiblingOrParentSibling = mod.$getNextSiblingOrParentSibling;\nexport const $insertFirst = mod.$insertFirst;\nexport const $insertNodeToNearestRoot = mod.$insertNodeToNearestRoot;\nexport const $insertNodeToNearestRootAtCaret = mod.$insertNodeToNearestRootAtCaret;\nexport const $isEditorIsNestedEditor = mod.$isEditorIsNestedEditor;\nexport const $lastToFirstIterator = mod.$lastToFirstIterator;\nexport const $restoreEditorState = mod.$restoreEditorState;\nexport const $reverseDfs = mod.$reverseDfs;\nexport const $reverseDfsIterator = mod.$reverseDfsIterator;\nexport const $splitNode = mod.$splitNode;\nexport const $unwrapAndFilterDescendants = mod.$unwrapAndFilterDescendants;\nexport const $unwrapNode = mod.$unwrapNode;\nexport const $wrapNodeInElement = mod.$wrapNodeInElement;\nexport const CAN_USE_BEFORE_INPUT = mod.CAN_USE_BEFORE_INPUT;\nexport const CAN_USE_DOM = mod.CAN_USE_DOM;\nexport const IS_ANDROID = mod.IS_ANDROID;\nexport const IS_ANDROID_CHROME = mod.IS_ANDROID_CHROME;\nexport const IS_APPLE = mod.IS_APPLE;\nexport const IS_APPLE_WEBKIT = mod.IS_APPLE_WEBKIT;\nexport const IS_CHROME = mod.IS_CHROME;\nexport const IS_FIREFOX = mod.IS_FIREFOX;\nexport const IS_IOS = mod.IS_IOS;\nexport const IS_SAFARI = mod.IS_SAFARI;\nexport const addClassNamesToElement = mod.addClassNamesToElement;\nexport const calculateZoomLevel = mod.calculateZoomLevel;\nexport const isBlockDomNode = mod.isBlockDomNode;\nexport const isHTMLAnchorElement = mod.isHTMLAnchorElement;\nexport const isHTMLElement = mod.isHTMLElement;\nexport const isInlineDomNode = mod.isInlineDomNode;\nexport const isMimeType = mod.isMimeType;\nexport const makeStateWrapper = mod.makeStateWrapper;\nexport const markSelection = mod.markSelection;\nexport const mediaFileReader = mod.mediaFileReader;\nexport const mergeRegister = mod.mergeRegister;\nexport const objectKlassEquals = mod.objectKlassEquals;\nexport const positionNodeOnRange = mod.positionNodeOnRange;\nexport const registerNestedElementResolver = mod.registerNestedElementResolver;\nexport const removeClassNamesFromElement = mod.removeClassNamesFromElement;\nexport const selectionAlwaysOnDisplay = mod.selectionAlwaysOnDisplay;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalExtension.dev.mjs';\nimport * as modProd from './LexicalExtension.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $createHorizontalRuleNode = mod.$createHorizontalRuleNode;\nexport const $isHorizontalRuleNode = mod.$isHorizontalRuleNode;\nexport const AutoFocusExtension = mod.AutoFocusExtension;\nexport const ClearEditorExtension = mod.ClearEditorExtension;\nexport const EditorStateExtension = mod.EditorStateExtension;\nexport const HorizontalRuleExtension = mod.HorizontalRuleExtension;\nexport const HorizontalRuleNode = mod.HorizontalRuleNode;\nexport const INSERT_HORIZONTAL_RULE_COMMAND = mod.INSERT_HORIZONTAL_RULE_COMMAND;\nexport const InitialStateExtension = mod.InitialStateExtension;\nexport const LexicalBuilder = mod.LexicalBuilder;\nexport const NodeSelectionExtension = mod.NodeSelectionExtension;\nexport const TabIndentationExtension = mod.TabIndentationExtension;\nexport const batch = mod.batch;\nexport const buildEditorFromExtensions = mod.buildEditorFromExtensions;\nexport const computed = mod.computed;\nexport const configExtension = mod.configExtension;\nexport const declarePeerDependency = mod.declarePeerDependency;\nexport const defineExtension = mod.defineExtension;\nexport const effect = mod.effect;\nexport const getExtensionDependencyFromEditor = mod.getExtensionDependencyFromEditor;\nexport const getKnownTypesAndNodes = mod.getKnownTypesAndNodes;\nexport const getPeerDependencyFromEditor = mod.getPeerDependencyFromEditor;\nexport const getPeerDependencyFromEditorOrThrow = mod.getPeerDependencyFromEditorOrThrow;\nexport const namedSignals = mod.namedSignals;\nexport const registerClearEditor = mod.registerClearEditor;\nexport const registerTabIndentation = mod.registerTabIndentation;\nexport const safeCast = mod.safeCast;\nexport const shallowMergeConfig = mod.shallowMergeConfig;\nexport const signal = mod.signal;\nexport const untracked = mod.untracked;\nexport const watchedSignal = mod.watchedSignal;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalList.dev.mjs';\nimport * as modProd from './LexicalList.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $createListItemNode = mod.$createListItemNode;\nexport const $createListNode = mod.$createListNode;\nexport const $getListDepth = mod.$getListDepth;\nexport const $handleListInsertParagraph = mod.$handleListInsertParagraph;\nexport const $insertList = mod.$insertList;\nexport const $isListItemNode = mod.$isListItemNode;\nexport const $isListNode = mod.$isListNode;\nexport const $removeList = mod.$removeList;\nexport const CheckListExtension = mod.CheckListExtension;\nexport const INSERT_CHECK_LIST_COMMAND = mod.INSERT_CHECK_LIST_COMMAND;\nexport const INSERT_ORDERED_LIST_COMMAND = mod.INSERT_ORDERED_LIST_COMMAND;\nexport const INSERT_UNORDERED_LIST_COMMAND = mod.INSERT_UNORDERED_LIST_COMMAND;\nexport const ListExtension = mod.ListExtension;\nexport const ListItemNode = mod.ListItemNode;\nexport const ListNode = mod.ListNode;\nexport const REMOVE_LIST_COMMAND = mod.REMOVE_LIST_COMMAND;\nexport const UPDATE_LIST_START_COMMAND = mod.UPDATE_LIST_START_COMMAND;\nexport const insertList = mod.insertList;\nexport const registerCheckList = mod.registerCheckList;\nexport const registerList = mod.registerList;\nexport const registerListStrictIndentTransform = mod.registerListStrictIndentTransform;\nexport const removeList = mod.removeList;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $insertDataTransferForRichText, copyToClipboard } from '@lexical/clipboard';\nimport { DragonExtension } from '@lexical/dragon';\nimport { $isParentRTL, $shouldOverrideDefaultCharacterSelection, $moveCharacter } from '@lexical/selection';\nimport { mergeRegister, $findMatchingParent, objectKlassEquals, addClassNamesToElement, isHTMLElement, $getNearestBlockElementAncestorOrThrow } from '@lexical/utils';\nimport { createCommand, defineExtension, CLICK_COMMAND, $getSelection, $isNodeSelection, COMMAND_PRIORITY_EDITOR, DELETE_CHARACTER_COMMAND, $isRangeSelection, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, REMOVE_TEXT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, $isElementNode, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, $insertNodes, $createTabNode, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, KEY_ARROW_UP_COMMAND, $getAdjacentNode, $isDecoratorNode, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, DROP_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $isTextNode, $normalizeSelection__EXPERIMENTAL, $setSelection, DRAGSTART_COMMAND, DRAGOVER_COMMAND, SELECT_ALL_COMMAND, $selectAll, COPY_COMMAND, CUT_COMMAND, PASTE_COMMAND, isDOMNode, isSelectionCapturedInDecoratorInput, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, ElementNode, $createParagraphNode, $getRoot, $isRootNode, PASTE_TAG, setNodeIndentFromDOM, $applyNodeReplacement } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && IS_APPLE && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = createCommand('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createQuoteNode().updateFromJSON(serializedNode);\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = $createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return $applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends ElementNode {\n  /** @internal */\n  __tag;\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setTag(tag) {\n    const self = this.getWritable();\n    this.__tag = tag;\n    return self;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    return prevNode.__tag !== this.__tag;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const lastDesc = this.getLastDescendant();\n    const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();\n    const newElement = isAtEnd || !selection ? $createParagraphNode() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = $createParagraphNode();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      setNodeIndentFromDOM(element, node);\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag = 'h1') {\n  return $applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = $getSelection();\n    const clipboardData = objectKlassEquals(event, InputEvent) || objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      $insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: PASTE_TAG\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    } else if ($isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if (objectKlassEquals(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if (objectKlassEquals(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = $getNearestNodeFromDOMNode(target);\n  return $isDecoratorNode(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === $getRoot().getChildrenSize();\n}\nfunction $isSelectionCollapsedAtFrontOfIndentedBlock(selection) {\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const {\n    anchor\n  } = selection;\n  if (anchor.offset !== 0) {\n    return false;\n  }\n  const anchorNode = anchor.getNode();\n  if ($isRootNode(anchorNode)) {\n    return false;\n  }\n  const element = $getNearestBlockElementAncestorOrThrow(anchorNode);\n  return element.getIndent() > 0 && (element.is(anchorNode) || anchorNode.is(element.getFirstDescendant()));\n}\n\n/**\n * Resets the capitalization of the selection to default.\n * Called when the user presses space, tab, or enter key.\n * @param selection The selection to reset the capitalization of.\n */\nfunction $resetCapitalization(selection) {\n  for (const format of ['lowercase', 'uppercase', 'capitalize']) {\n    if (selection.hasFormat(format)) {\n      selection.toggleFormat(format);\n    }\n  }\n}\nfunction registerRichText(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(CLICK_COMMAND, payload => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.deleteCharacter(isBackward);\n      return true;\n    } else if ($isNodeSelection(selection)) {\n      selection.deleteNodes();\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = $getSelection();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        $insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if ($isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_TEXT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_ELEMENT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(Math.max(0, indent - 1));\n      }\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      const possibleNode = $getAdjacentNode(selection.focus, true);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = $getAdjacentNode(selection.focus, false);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        if ($isParentRTL(nodes[0])) {\n          nodes[0].selectNext(0, 0);\n        } else {\n          nodes[0].selectPrevious();\n        }\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        if ($isParentRTL(nodes[0])) {\n          nodes[0].selectPrevious();\n        } else {\n          nodes[0].selectNext(0, 0);\n        }\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      if ($isSelectionCollapsedAtFrontOfIndentedBlock(selection)) {\n        event.preventDefault();\n        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined);\n      }\n      // Exception handling for iOS native behavior instead of Lexical's behavior when using Korean on iOS devices.\n      // more details - https://github.com/facebook/lexical/issues/5841\n      if (IS_IOS && navigator.language === 'ko-KR') {\n        return false;\n      }\n    } else if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!($isRangeSelection(selection) || $isNodeSelection(selection))) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    $resetCapitalization(selection);\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = $getNearestNodeFromDOMNode(domNode);\n        if (node !== null) {\n          const selection = $createRangeSelection();\n          if ($isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection);\n          $setSelection(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = $getNearestNodeFromDOMNode(eventRange.node);\n      if ($isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {\n    $selectAll();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, event => {\n    copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if (isDOMNode(event.target) && isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_SPACE_COMMAND, _ => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_TAB_COMMAND, _ => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\n/**\n * An extension to register \\@lexical/rich-text behavior and nodes\n * ({@link HeadingNode}, {@link QuoteNode})\n */\nconst RichTextExtension = defineExtension({\n  conflictsWith: ['@lexical/plain-text'],\n  dependencies: [DragonExtension],\n  name: '@lexical/rich-text',\n  nodes: [HeadingNode, QuoteNode],\n  register: registerRichText\n});\n\nexport { $createHeadingNode, $createQuoteNode, $isHeadingNode, $isQuoteNode, DRAG_DROP_PASTE, HeadingNode, QuoteNode, RichTextExtension, eventFiles, registerRichText };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $caretFromPoint, $isTextPointCaret, $getCaretRange, $getChildCaret, $getRoot, $isTextNode, $isElementNode, $parseSerializedNode, getDOMSelection, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  const plainString = dataTransfer.getData('text/plain');\n\n  // Skip HTML handling if it matches the plain text representation.\n  // This avoids unnecessary processing for plain text strings created by\n  // iOS Safari autocorrect, which incorrectly includes a `text/html` type.\n  if (htmlString && plainString !== htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = plainString || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n    $updateSelectionOnInsert(selection);\n  }\n  return;\n}\nfunction $updateSelectionOnInsert(selection) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const anchor = selection.anchor;\n    let nodeToInspect = null;\n    const anchorCaret = $caretFromPoint(anchor, 'previous');\n    if (anchorCaret) {\n      if ($isTextPointCaret(anchorCaret)) {\n        nodeToInspect = anchorCaret.origin;\n      } else {\n        const range = $getCaretRange(anchorCaret, $getChildCaret($getRoot(), 'next').getFlipped());\n        for (const caret of range) {\n          if ($isTextNode(caret.origin)) {\n            nodeToInspect = caret.origin;\n            break;\n          } else if ($isElementNode(caret.origin) && !caret.origin.isInline()) {\n            break;\n          }\n        }\n      }\n    }\n    if (nodeToInspect && $isTextNode(nodeToInspect)) {\n      const newFormat = nodeToInspect.getFormat();\n      const newStyle = nodeToInspect.getStyle();\n      if (selection.format !== newFormat || selection.style !== newStyle) {\n        selection.format = newFormat;\n        selection.style = newStyle;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null && $isTextNode(target)) {\n    target = $sliceSelectedTextNodeContent(selection, target, 'clone');\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n  if ($isTextNode(target) && target.getTextContentSize() === 0) {\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    shouldInclude = false;\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSerializedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const editorWindow = editor._window || window;\n  const windowDocument = editorWindow.document;\n  const domSelection = getDOMSelection(editorWindow);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          editorWindow.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = editorWindow.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    const selection = $getSelection();\n    if (!selection || selection.isCollapsed()) {\n      return false;\n    }\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const [k] of clipboardDataFunctions) {\n    if (data[k] === undefined) {\n      clipboardData.setData(k, '');\n    }\n  }\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { isDOMDocumentNode, $getRoot, $isElementNode, $isTextNode, getRegisteredNode, isDocumentFragment, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = isDOMDocumentNode(dom) ? dom.body.childNodes : dom.childNodes;\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (const element of elements) {\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificialNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null && $isTextNode(currentNode)) {\n    target = $sliceSelectedTextNodeContent(selection, currentNode, 'clone');\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = getRegisteredNode(editor, target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element) || isDocumentFragment(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if (isDocumentFragment(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificialNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalHtml.dev.mjs';\nimport * as modProd from './LexicalHtml.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $generateHtmlFromNodes = mod.$generateHtmlFromNodes;\nexport const $generateNodesFromDOM = mod.$generateNodesFromDOM;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalClipboard.dev.mjs';\nimport * as modProd from './LexicalClipboard.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $generateJSONFromSelectedNodes = mod.$generateJSONFromSelectedNodes;\nexport const $generateNodesFromSerializedNodes = mod.$generateNodesFromSerializedNodes;\nexport const $getClipboardDataFromSelection = mod.$getClipboardDataFromSelection;\nexport const $getHtmlContent = mod.$getHtmlContent;\nexport const $getLexicalContent = mod.$getLexicalContent;\nexport const $insertDataTransferForPlainText = mod.$insertDataTransferForPlainText;\nexport const $insertDataTransferForRichText = mod.$insertDataTransferForRichText;\nexport const $insertGeneratedNodes = mod.$insertGeneratedNodes;\nexport const copyToClipboard = mod.copyToClipboard;\nexport const setLexicalClipboardDataTransfer = mod.setLexicalClipboardDataTransfer;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { effect, namedSignals } from '@lexical/extension';\nimport { defineExtension, safeCast, $getSelection, $isRangeSelection, $isTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (_e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength] = args;\n            // TODO: we should probably handle formatCommand somehow?\n            // formatCommand;\n            editor.update(() => {\n              const selection = $getSelection();\n              if ($isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ($isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ($isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n/**\n * Add Dragon speech to text input support to the editor, via the\n * \\@lexical/dragon module.\n */\nconst DragonExtension = defineExtension({\n  build: (editor, config, state) => namedSignals(config),\n  config: safeCast({\n    disabled: typeof window === 'undefined'\n  }),\n  name: '@lexical/dragon',\n  register: (editor, config, state) => effect(() => state.getOutput().disabled.value ? undefined : registerDragonSupport(editor))\n});\n\nexport { DragonExtension, registerDragonSupport };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalDragon.dev.mjs';\nimport * as modProd from './LexicalDragon.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const DragonExtension = mod.DragonExtension;\nexport const registerDragonSupport = mod.registerDragonSupport;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalRichText.dev.mjs';\nimport * as modProd from './LexicalRichText.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $createHeadingNode = mod.$createHeadingNode;\nexport const $createQuoteNode = mod.$createQuoteNode;\nexport const $isHeadingNode = mod.$isHeadingNode;\nexport const $isQuoteNode = mod.$isQuoteNode;\nexport const DRAG_DROP_PASTE = mod.DRAG_DROP_PASTE;\nexport const HeadingNode = mod.HeadingNode;\nexport const QuoteNode = mod.QuoteNode;\nexport const RichTextExtension = mod.RichTextExtension;\nexport const eventFiles = mod.eventFiles;\nexport const registerRichText = mod.registerRichText;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, addClassNamesToElement, removeClassNamesFromElement, $getAdjacentCaret, mergeRegister } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isTextNode, $isTabNode, $createTabNode, $createLineBreakNode, $create, TextNode, $applyNodeReplacement, $getSiblingCaret, getTextDirection, $isElementNode, $isLineBreakNode, defineExtension, $createTextNode, $getNodeByKey, $getSelection, $isRangeSelection, $createPoint, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, INSERT_TAB_COMMAND, $setSelectionFromCaretRange, $getCaretRangeInDirection, $getCaretRange, $getTextPointCaret, $normalizeCaret, KEY_ARROW_UP_COMMAND, MOVE_TO_START, KEY_TAB_COMMAND, COMMAND_PRIORITY_LOW, $insertNodes, KEY_ARROW_DOWN_COMMAND, MOVE_TO_END } from 'lexical';\nimport 'prismjs';\nimport 'prismjs/components/prism-clike.js';\nimport 'prismjs/components/prism-javascript.js';\nimport 'prismjs/components/prism-markup.js';\nimport 'prismjs/components/prism-markdown.js';\nimport 'prismjs/components/prism-c.js';\nimport 'prismjs/components/prism-css.js';\nimport 'prismjs/components/prism-objectivec.js';\nimport 'prismjs/components/prism-sql.js';\nimport 'prismjs/components/prism-powershell.js';\nimport 'prismjs/components/prism-python.js';\nimport 'prismjs/components/prism-rust.js';\nimport 'prismjs/components/prism-swift.js';\nimport 'prismjs/components/prism-typescript.js';\nimport 'prismjs/components/prism-java.js';\nimport 'prismjs/components/prism-cpp.js';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nfunction invariant(cond, message, ...args) {\n  if (cond) {\n    return;\n  }\n  throw new Error('Internal Lexical error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version. Error: ' + message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-language';\nconst HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\nconst THEME_DATA_ATTRIBUTE = 'data-theme';\n\n/** @noInheritDoc */\nclass CodeNode extends ElementNode {\n  /** @internal */\n  __language;\n  /** @internal */\n  __theme;\n  /** @internal */\n  __isSyntaxHighlightSupported;\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = language || undefined;\n    this.__isSyntaxHighlightSupported = false;\n    this.__theme = undefined;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__language = prevNode.__language;\n    this.__theme = prevNode.__theme;\n    this.__isSyntaxHighlightSupported = prevNode.__isSyntaxHighlightSupported;\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    const theme = this.getTheme();\n    if (theme) {\n      element.setAttribute(THEME_DATA_ATTRIBUTE, theme);\n    }\n    const style = this.getStyle();\n    if (style) {\n      element.setAttribute('style', style);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n    const isSyntaxHighlightSupported = this.__isSyntaxHighlightSupported;\n    const prevIsSyntaxHighlightSupported = prevNode.__isSyntaxHighlightSupported;\n    if (prevIsSyntaxHighlightSupported && prevLanguage) {\n      if (isSyntaxHighlightSupported && language) {\n        if (language !== prevLanguage) {\n          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n        }\n      } else {\n        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);\n      }\n    } else if (isSyntaxHighlightSupported && language) {\n      dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n    const theme = this.__theme;\n    const prevTheme = prevNode.__theme;\n    if (theme) {\n      if (theme !== prevTheme) {\n        dom.setAttribute(THEME_DATA_ATTRIBUTE, theme);\n      }\n    } else if (prevTheme) {\n      dom.removeAttribute(THEME_DATA_ATTRIBUTE);\n    }\n    const style = this.__style;\n    const prevStyle = prevNode.__style;\n    if (style) {\n      if (style !== prevStyle) {\n        dom.setAttribute('style', style);\n      }\n    } else if (prevStyle) {\n      dom.removeAttribute('style');\n    }\n    return false;\n  }\n  exportDOM(editor) {\n    const element = document.createElement('pre');\n    addClassNamesToElement(element, editor._config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    const theme = this.getTheme();\n    if (theme) {\n      element.setAttribute(THEME_DATA_ATTRIBUTE, theme);\n    }\n    const style = this.getStyle();\n    if (style) {\n      element.setAttribute('style', style);\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: $convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: () => ({\n        conversion: $convertDivElement,\n        priority: 1\n      }),\n      pre: () => ({\n        conversion: $convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: $convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createCodeNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setLanguage(serializedNode.language).setTheme(serializedNode.theme);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage(),\n      theme: this.getTheme()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = $createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const {\n      anchor,\n      focus\n    } = selection;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ($isTextNode(firstSelectionNode)) {\n      let node = $getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = [];\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if ($isTabNode(node)) {\n          insertNodes.push($createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          while (spaces < textSize && text[spaces] === ' ') {\n            spaces++;\n          }\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      const split = firstSelectionNode.splitText(anchor.offset)[0];\n      const x = anchor.offset === 0 ? 0 : 1;\n      const index = split.getIndexWithinParent() + x;\n      const codeNode = firstSelectionNode.getParentOrThrow();\n      const nodesToInsert = [$createLineBreakNode(), ...insertNodes];\n      codeNode.splice(index, 0, nodesToInsert);\n      const last = insertNodes[insertNodes.length - 1];\n      if (last) {\n        last.select();\n      } else if (anchor.offset === 0) {\n        split.selectPrevious();\n      } else {\n        split.getNextSibling().selectNext(0, 0);\n      }\n    }\n    if ($isCodeNode(firstSelectionNode)) {\n      const {\n        offset\n      } = selection.anchor;\n      firstSelectionNode.splice(offset, 0, [$createLineBreakNode()]);\n      firstSelectionNode.select(offset + 1, offset + 1);\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = language || undefined;\n    return writable;\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n  setIsSyntaxHighlightSupported(isSupported) {\n    const writable = this.getWritable();\n    writable.__isSyntaxHighlightSupported = isSupported;\n    return writable;\n  }\n  getIsSyntaxHighlightSupported() {\n    return this.getLatest().__isSyntaxHighlightSupported;\n  }\n  setTheme(theme) {\n    const writable = this.getWritable();\n    writable.__theme = theme || undefined;\n    return writable;\n  }\n  getTheme() {\n    return this.getLatest().__theme;\n  }\n}\nfunction $createCodeNode(language, theme) {\n  return $create(CodeNode).setLanguage(language).setTheme(theme);\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction $convertPreElement(domNode) {\n  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction $convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction $convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends TextNode {\n  /** @internal */\n  __highlightType;\n  constructor(text = '', highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  setHighlightType(highlightType) {\n    const self = this.getWritable();\n    self.__highlightType = highlightType || undefined;\n    return self;\n  }\n  canHaveFormat() {\n    return false;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    addClassNamesToElement(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        removeClassNamesFromElement(dom, prevClassName);\n      }\n      if (nextClassName) {\n        addClassNamesToElement(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    return $createCodeHighlightNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHighlightType(serializedNode.highlightType);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType()\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text = '', highlightType) {\n  return $applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\n\nfunction $getLastMatchingCodeNode(anchor, direction) {\n  let matchingNode = anchor;\n  for (let caret = $getSiblingCaret(anchor, direction); caret && ($isCodeHighlightNode(caret.origin) || $isTabNode(caret.origin)); caret = $getAdjacentCaret(caret)) {\n    matchingNode = caret.origin;\n  }\n  return matchingNode;\n}\nfunction $getFirstCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'previous');\n}\nfunction $getLastCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'next');\n}\n\n/**\n * Determines the visual writing direction of a code line.\n *\n * Scans the line segments (CodeHighlightNode/TabNode) from start to end\n * and returns the first strong direction found (\"ltr\" or \"rtl\").\n * If no strong character is found, falls back to the parent element's\n * direction. Returns null if indeterminate.\n */\nfunction $getCodeLineDirection(anchor) {\n  const start = $getFirstCodeNodeOfLine(anchor);\n  const end = $getLastCodeNodeOfLine(anchor);\n  let node = start;\n  while (node !== null) {\n    if ($isCodeHighlightNode(node)) {\n      const direction = getTextDirection(node.getTextContent());\n      if (direction !== null) {\n        return direction;\n      }\n    }\n    if (node === end) {\n      break;\n    }\n    node = node.getNextSibling();\n  }\n  const parent = start.getParent();\n  if ($isElementNode(parent)) {\n    const parentDirection = parent.getDirection();\n    if (parentDirection === 'ltr' || parentDirection === 'rtl') {\n      return parentDirection;\n    }\n  }\n  return null;\n}\nfunction $getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n        formatDevErrorMessage(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if ($isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  }\n  // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  }\n  // Spaces, tabs or nothing ahead of anchor\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || $isLineBreakNode(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction $getEndOfCodeInLine(anchor) {\n  const lastNode = $getLastCodeNodeOfLine(anchor);\n  if (!!$isLineBreakNode(lastNode)) {\n    formatDevErrorMessage(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Add code blocks to the editor (syntax highlighting provided separately)\n */\nconst CodeExtension = defineExtension({\n  name: '@lexical/code',\n  nodes: [CodeNode, CodeHighlightNode]\n});\n\n(function (Prism) {\n\n\tPrism.languages.diff = {\n\t\t'coord': [\n\t\t\t// Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n\t\t\t/^(?:\\*{3}|-{3}|\\+{3}).*$/m,\n\t\t\t// Match \"@@ ... @@\" coord lines in unified diff.\n\t\t\t/^@@.*@@$/m,\n\t\t\t// Match coord lines in normal diff (starts with a number).\n\t\t\t/^\\d.*$/m\n\t\t]\n\n\t\t// deleted, inserted, unchanged, diff\n\t};\n\n\t/**\n\t * A map from the name of a block to its line prefix.\n\t *\n\t * @type {Object<string, string>}\n\t */\n\tvar PREFIXES = {\n\t\t'deleted-sign': '-',\n\t\t'deleted-arrow': '<',\n\t\t'inserted-sign': '+',\n\t\t'inserted-arrow': '>',\n\t\t'unchanged': ' ',\n\t\t'diff': '!',\n\t};\n\n\t// add a token for each prefix\n\tObject.keys(PREFIXES).forEach(function (name) {\n\t\tvar prefix = PREFIXES[name];\n\n\t\tvar alias = [];\n\t\tif (!/^\\w+$/.test(name)) { // \"deleted-sign\" -> \"deleted\"\n\t\t\talias.push(/\\w+/.exec(name)[0]);\n\t\t}\n\t\tif (name === 'diff') {\n\t\t\talias.push('bold');\n\t\t}\n\n\t\tPrism.languages.diff[name] = {\n\t\t\tpattern: RegExp('^(?:[' + prefix + '].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+', 'm'),\n\t\t\talias: alias,\n\t\t\tinside: {\n\t\t\t\t'line': {\n\t\t\t\t\tpattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'prefix': {\n\t\t\t\t\tpattern: /[\\s\\S]/,\n\t\t\t\t\talias: /\\w+/.exec(name)[0]\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t});\n\n\t// make prefixes available to Diff plugin\n\tObject.defineProperty(Prism.languages.diff, 'PREFIXES', {\n\t\tvalue: PREFIXES\n\t});\n\n}(Prism));\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst Prism$1 = globalThis.Prism || window.Prism;\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  powershell: 'PowerShell',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getCodeLanguages = () => Object.keys(Prism$1.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism$1.languages[language] !== 'function').sort();\nfunction getCodeLanguageOptions() {\n  const options = [];\n  for (const [lang, friendlyName] of Object.entries(CODE_LANGUAGE_FRIENDLY_NAME_MAP)) {\n    options.push([lang, friendlyName]);\n  }\n  return options;\n}\n\n// Prism has no theme support\nfunction getCodeThemeOptions() {\n  const options = [];\n  return options;\n}\nfunction getDiffedLanguage(language) {\n  const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n  const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(language);\n  return diffLanguageMatch ? diffLanguageMatch[1] : null;\n}\nfunction isCodeLanguageLoaded(language) {\n  const diffedLanguage = getDiffedLanguage(language);\n  const langId = diffedLanguage ? diffedLanguage : language;\n  try {\n    // eslint-disable-next-line no-prototype-builtins\n    return langId ? Prism$1.languages.hasOwnProperty(langId) : false;\n  } catch (_unused) {\n    return false;\n  }\n}\nasync function loadCodeLanguage(language, editor, codeNodeKey) {\n  // NOT IMPLEMENTED\n}\nfunction getTextContent(token) {\n  if (typeof token === 'string') {\n    return token;\n  } else if (Array.isArray(token)) {\n    return token.map(getTextContent).join('');\n  } else {\n    return getTextContent(token.content);\n  }\n}\n\n// The following code is extracted/adapted from prismjs v2\n// It will probably be possible to use it directly from prism v2\n// in the future when prismjs v2 is published and Lexical upgrades\n// the prismsjs dependency\nfunction tokenizeDiffHighlight(tokens, language) {\n  const diffLanguage = language;\n  const diffGrammar = Prism$1.languages[diffLanguage];\n  const env = {\n    tokens\n  };\n  const PREFIXES = Prism$1.languages.diff.PREFIXES;\n  for (const token of env.tokens) {\n    if (typeof token === 'string' || !(token.type in PREFIXES) || !Array.isArray(token.content)) {\n      continue;\n    }\n    const type = token.type;\n    let insertedPrefixes = 0;\n    const getPrefixToken = () => {\n      insertedPrefixes++;\n      return new Prism$1.Token('prefix', PREFIXES[type], type.replace(/^(\\w+).*/, '$1'));\n    };\n    const withoutPrefixes = token.content.filter(t => typeof t === 'string' || t.type !== 'prefix');\n    const prefixCount = token.content.length - withoutPrefixes.length;\n    const diffTokens = Prism$1.tokenize(getTextContent(withoutPrefixes), diffGrammar);\n\n    // re-insert prefixes\n    // always add a prefix at the start\n    diffTokens.unshift(getPrefixToken());\n    const LINE_BREAK = /\\r\\n|\\n/g;\n    const insertAfterLineBreakString = text => {\n      const result = [];\n      LINE_BREAK.lastIndex = 0;\n      let last = 0;\n      let m;\n      while (insertedPrefixes < prefixCount && (m = LINE_BREAK.exec(text))) {\n        const end = m.index + m[0].length;\n        result.push(text.slice(last, end));\n        last = end;\n        result.push(getPrefixToken());\n      }\n      if (result.length === 0) {\n        return undefined;\n      }\n      if (last < text.length) {\n        result.push(text.slice(last));\n      }\n      return result;\n    };\n    const insertAfterLineBreak = toks => {\n      for (let i = 0; i < toks.length && insertedPrefixes < prefixCount; i++) {\n        const tok = toks[i];\n        if (typeof tok === 'string') {\n          const inserted = insertAfterLineBreakString(tok);\n          if (inserted) {\n            toks.splice(i, 1, ...inserted);\n            i += inserted.length - 1;\n          }\n        } else if (typeof tok.content === 'string') {\n          const inserted = insertAfterLineBreakString(tok.content);\n          if (inserted) {\n            tok.content = inserted;\n          }\n        } else if (Array.isArray(tok.content)) {\n          insertAfterLineBreak(tok.content);\n        } else {\n          insertAfterLineBreak([tok.content]);\n        }\n      }\n    };\n    insertAfterLineBreak(diffTokens);\n    if (insertedPrefixes < prefixCount) {\n      // we are missing the last prefix\n      diffTokens.push(getPrefixToken());\n    }\n    token.content = diffTokens;\n  }\n  return env.tokens;\n}\nfunction $getHighlightNodes(codeNode, language) {\n  const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n  const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(language);\n  const code = codeNode.getTextContent();\n  let tokens = Prism$1.tokenize(code, Prism$1.languages[diffLanguageMatch ? 'diff' : language]);\n  if (diffLanguageMatch) {\n    tokens = tokenizeDiffHighlight(tokens, diffLanguageMatch[1]);\n  }\n  return $mapTokensToLexicalStructure(tokens);\n}\nfunction $mapTokensToLexicalStructure(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push($createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push($createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content,\n        alias\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...$mapTokensToLexicalStructure([content], token.type === 'prefix' && typeof alias === 'string' ? alias : token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...$mapTokensToLexicalStructure(content, token.type === 'unchanged' ? undefined : token.type));\n      }\n    }\n  }\n  return nodes;\n}\n\nconst PrismTokenizer = {\n  $tokenize(codeNode, language) {\n    return $getHighlightNodes(codeNode, language || this.defaultLanguage);\n  },\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return Prism$1.tokenize(code, Prism$1.languages[language || ''] || Prism$1.languages[this.defaultLanguage]);\n  }\n};\nfunction $textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace($createTextNode(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if ($isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n  const language = node.getLanguage() || tokenizer.defaultLanguage;\n  if (isCodeLanguageLoaded(language)) {\n    if (!node.getIsSyntaxHighlightSupported()) {\n      node.setIsSyntaxHighlightSupported(true);\n    }\n  } else {\n    if (node.getIsSyntaxHighlightSupported()) {\n      node.setIsSyntaxHighlightSupported(false);\n    }\n    loadCodeLanguage(language, editor, nodeKey);\n    return;\n  }\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey);\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual CodeHighlightNode to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    $updateAndRetainSelection(nodeKey, () => {\n      const currentNode = $getNodeByKey(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      //const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n      const currentLanguage = currentNode.getLanguage() || tokenizer.defaultLanguage;\n      //const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(currentLanguage);\n\n      const highlightNodes = tokenizer.$tokenize(currentNode, currentLanguage);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction $updateAndRetainSelection(nodeKey, updateFn) {\n  const node = $getNodeByKey(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = $getSelection();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && $isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = $isTextNode(_node);\n    if (isText || $isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code highlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || $isTabNode(nodeA) && $isTabNode(nodeB) || $isLineBreakNode(nodeA) && $isLineBreakNode(nodeB);\n}\n\n/**\n * Returns a boolean.\n * Check that the selection span is within a single CodeNode.\n * This is used to guard against executing handlers that can only be\n * applied in a single CodeNode context\n */\nfunction $isSelectionInCode(selection) {\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const maybeAnchorCodeNode = $isCodeNode(anchorNode) ? anchorNode : anchorNode.getParent();\n  const focusNode = selection.focus.getNode();\n  const maybeFocusCodeNode = $isCodeNode(focusNode) ? focusNode : focusNode.getParent();\n  return $isCodeNode(maybeAnchorCodeNode) && maybeAnchorCodeNode.is(maybeFocusCodeNode);\n}\n\n/**\n * Returns an Array of code lines\n * Take the sequence of LineBreakNode | TabNode | CodeHighlightNode forming\n * the selection and split it by LineBreakNode.\n * If the selection ends at the start of the last line, it is considered empty.\n * Empty lines are discarded.\n */\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n      formatDevErrorMessage(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if ($isLineBreakNode(node)) {\n      if (lastLine.length > 0) {\n        lines.push(lastLine);\n        lastLine = [];\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  if (lastLine.length > 0) {\n    const selectionEnd = selection.isBackward() ? selection.anchor : selection.focus;\n\n    // Discard the last line if the selection ends exactly at the\n    // start of the line (no real selection)\n    const lastPoint = $createPoint(lastLine[0].getKey(), 0, 'text');\n    if (!selectionEnd.is(lastPoint)) {\n      lines.push(lastLine);\n    }\n  }\n  return lines;\n}\nfunction $handleTab(shiftKey) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? INDENT_CONTENT_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? INSERT_TAB_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  // 1. early decision when there is no real selection\n  if (anchor.is(focus)) {\n    return tabOrOutdent;\n  }\n\n  // 2. If only empty lines or multiple non-empty lines are selected: indent/outdent\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length !== 1) {\n    return indentOrOutdent;\n  }\n  const codeLine = codeLines[0];\n  const codeLineLength = codeLine.length;\n  if (!(codeLineLength !== 0)) {\n    formatDevErrorMessage(`$getCodeLines only extracts non-empty lines`);\n  } // Take into account the direction of the selection\n  let selectionFirst;\n  let selectionLast;\n  if (selection.isBackward()) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n\n  // find boundary elements of the line\n  // since codeLine only contains TabNode | CodeHighlightNode\n  // the result of these functions should is of Type TabNode | CodeHighlightNode\n  const firstOfLine = $getFirstCodeNodeOfLine(codeLine[0]);\n  const lastOfLine = $getLastCodeNodeOfLine(codeLine[0]);\n  const anchorOfLine = $createPoint(firstOfLine.getKey(), 0, 'text');\n  const focusOfLine = $createPoint(lastOfLine.getKey(), lastOfLine.getTextContentSize(), 'text');\n\n  // 3. multiline because selection started strictly before the line\n  if (selectionFirst.isBefore(anchorOfLine)) {\n    return indentOrOutdent;\n  }\n\n  // 4. multiline because the selection stops strictly after the line\n  if (focusOfLine.isBefore(selectionLast)) {\n    return indentOrOutdent;\n  }\n\n  // The selection if within the line.\n  // 4. If it does not touch both borders, it needs a tab\n  if (anchorOfLine.isBefore(selectionFirst) || selectionLast.isBefore(focusOfLine)) {\n    return tabOrOutdent;\n  }\n\n  // 5. Selection is matching a full line on non-empty code\n  return indentOrOutdent;\n}\nfunction $handleMultilineIndent(type) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length;\n\n  // Special Indent case\n  // Selection is collapsed at the beginning of a line\n  if (codeLinesLength === 0 && selection.isCollapsed()) {\n    if (type === INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([$createTabNode()]);\n    }\n    return true;\n  }\n\n  // Special Indent case\n  // Selection is matching only one LineBreak\n  if (codeLinesLength === 0 && type === INDENT_CONTENT_COMMAND && selection.getTextContent() === '\\n') {\n    const tabNode = $createTabNode();\n    const lineBreakNode = $createLineBreakNode();\n    const direction = selection.isBackward() ? 'previous' : 'next';\n    selection.insertNodes([tabNode, lineBreakNode]);\n    $setSelectionFromCaretRange($getCaretRangeInDirection($getCaretRange($getTextPointCaret(tabNode, 'next', 0), $normalizeCaret($getSiblingCaret(lineBreakNode, 'next'))), direction));\n    return true;\n  }\n\n  // Indent Non Empty Lines\n  for (let i = 0; i < codeLinesLength; i++) {\n    const line = codeLines[i];\n    // a line here is never empty\n    if (line.length > 0) {\n      let firstOfLine = line[0];\n\n      // make sure to consider the first node on the first line\n      // because the line might not be fully selected\n      if (i === 0) {\n        firstOfLine = $getFirstCodeNodeOfLine(firstOfLine);\n      }\n      if (type === INDENT_CONTENT_COMMAND) {\n        const tabNode = $createTabNode();\n        firstOfLine.insertBefore(tabNode);\n        // First real code line may need selection adjustment\n        // when firstOfLine is at the selection boundary\n        if (i === 0) {\n          const anchorKey = selection.isBackward() ? 'focus' : 'anchor';\n          const anchorLine = $createPoint(firstOfLine.getKey(), 0, 'text');\n          if (selection[anchorKey].is(anchorLine)) {\n            selection[anchorKey].set(tabNode.getKey(), 0, 'text');\n          }\n        }\n      } else if ($isTabNode(firstOfLine)) {\n        firstOfLine.remove();\n      }\n    }\n  }\n  return true;\n}\nfunction $handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // siblings that can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = $getFirstCodeNodeOfLine(anchorNode);\n    end = $getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = $getFirstCodeNodeOfLine(focusNode);\n    end = $getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !$isTabNode(node) && !$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!$isLineBreakNode(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || $isTabNode(sibling) || $isLineBreakNode(sibling) ? arrowIsUp ? $getFirstCodeNodeOfLine(sibling) : $getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction $handleMoveTo(type, event) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === MOVE_TO_START;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  const focusLineNode = focusNode;\n  const direction = $getCodeLineDirection(focusLineNode);\n  const moveToStart = direction === 'rtl' ? !isMoveToStart : isMoveToStart;\n  if (moveToStart) {\n    const start = $getStartOfCodeInLine(focusLineNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if ($isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusLineNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = $getEndOfCodeInLine(focusLineNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  const registrations = [];\n\n  // Only register the mutation listener if not in headless mode\n  if (editor._headless !== true) {\n    registrations.push(editor.registerMutationListener(CodeNode, mutations => {\n      editor.getEditorState().read(() => {\n        for (const [key, type] of mutations) {\n          if (type !== 'destroyed') {\n            const node = $getNodeByKey(key);\n            if (node !== null) {\n              updateCodeGutter(node, editor);\n            }\n          }\n        }\n      });\n    }, {\n      skipInitialization: false\n    }));\n  }\n\n  // Add the rest of the registrations\n  registrations.push(editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(TextNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(KEY_TAB_COMMAND, event => {\n    const command = $handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(INDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(OUTDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(OUTDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the start of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === 0 && anchorNode.getPreviousSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(KEY_ARROW_UP_COMMAND, event);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the end of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(KEY_ARROW_DOWN_COMMAND, event);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_START, event => $handleMoveTo(MOVE_TO_START, event), COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_END, event => $handleMoveTo(MOVE_TO_END, event), COMMAND_PRIORITY_LOW));\n  return mergeRegister(...registrations);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/** @deprecated renamed to {@link $getFirstCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getFirstCodeNodeOfLine = $getFirstCodeNodeOfLine;\n/** @deprecated renamed to {@link $getLastCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getLastCodeNodeOfLine = $getLastCodeNodeOfLine;\n/** @deprecated renamed to {@link $getEndOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getEndOfCodeInLine = $getEndOfCodeInLine;\n/** @deprecated renamed to {@link $getStartOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getStartOfCodeInLine = $getStartOfCodeInLine;\n\nexport { $createCodeHighlightNode, $createCodeNode, $getCodeLineDirection, $getEndOfCodeInLine, $getFirstCodeNodeOfLine, $getLastCodeNodeOfLine, $getStartOfCodeInLine, $isCodeHighlightNode, $isCodeNode, CODE_LANGUAGE_FRIENDLY_NAME_MAP, CODE_LANGUAGE_MAP, CodeExtension, CodeHighlightNode, CodeNode, DEFAULT_CODE_LANGUAGE, PrismTokenizer, getCodeLanguageOptions, getCodeLanguages, getCodeThemeOptions, getDefaultCodeLanguage, getEndOfCodeInLine, getFirstCodeNodeOfLine, getLanguageFriendlyName, getLastCodeNodeOfLine, getStartOfCodeInLine, normalizeCodeLang, normalizeCodeLang as normalizeCodeLanguage, registerCodeHighlighting };\n", "Prism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n", "(function (Prism) {\n\n\t// Allow only one line break\n\tvar inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n\n\t/**\n\t * This function is intended for the creation of the bold or italic pattern.\n\t *\n\t * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n\t *\n\t * _Note:_ Keep in mind that this adds a capturing group.\n\t *\n\t * @param {string} pattern\n\t * @returns {RegExp}\n\t */\n\tfunction createInline(pattern) {\n\t\tpattern = pattern.replace(/<inner>/g, function () { return inner; });\n\t\treturn RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + '(?:' + pattern + ')');\n\t}\n\n\n\tvar tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n\tvar tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function () { return tableCell; });\n\tvar tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n\n\n\tPrism.languages.markdown = Prism.languages.extend('markup', {});\n\tPrism.languages.insertBefore('markdown', 'prolog', {\n\t\t'front-matter-block': {\n\t\t\tpattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^---|---$/,\n\t\t\t\t'front-matter': {\n\t\t\t\t\tpattern: /\\S+(?:\\s+\\S+)*/,\n\t\t\t\t\talias: ['yaml', 'language-yaml'],\n\t\t\t\t\tinside: Prism.languages.yaml\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'blockquote': {\n\t\t\t// > ...\n\t\t\tpattern: /^>(?:[\\t ]*>)*/m,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'table': {\n\t\t\tpattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),\n\t\t\tinside: {\n\t\t\t\t'table-data-rows': {\n\t\t\t\t\tpattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'table-data': {\n\t\t\t\t\t\t\tpattern: RegExp(tableCell),\n\t\t\t\t\t\t\tinside: Prism.languages.markdown\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': /\\|/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'table-line': {\n\t\t\t\t\tpattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /\\||:?-{3,}:?/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'table-header-row': {\n\t\t\t\t\tpattern: RegExp('^' + tableRow + '$'),\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'table-header': {\n\t\t\t\t\t\t\tpattern: RegExp(tableCell),\n\t\t\t\t\t\t\talias: 'important',\n\t\t\t\t\t\t\tinside: Prism.languages.markdown\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': /\\|/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'code': [\n\t\t\t{\n\t\t\t\t// Prefixed by 4 spaces or 1 tab and preceded by an empty line\n\t\t\t\tpattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t{\n\t\t\t\t// ```optional language\n\t\t\t\t// code block\n\t\t\t\t// ```\n\t\t\t\tpattern: /^```[\\s\\S]*?^```$/m,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'code-block': {\n\t\t\t\t\t\tpattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'code-language': {\n\t\t\t\t\t\tpattern: /^(```).+/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'punctuation': /```/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'title': [\n\t\t\t{\n\t\t\t\t// title 1\n\t\t\t\t// =======\n\n\t\t\t\t// title 2\n\t\t\t\t// -------\n\t\t\t\tpattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /==+$|--+$/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t// # title 1\n\t\t\t\t// ###### title 6\n\t\t\t\tpattern: /(^\\s*)#.+/m,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /^#+|#+$/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'hr': {\n\t\t\t// ***\n\t\t\t// ---\n\t\t\t// * * *\n\t\t\t// -----------\n\t\t\tpattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'list': {\n\t\t\t// * item\n\t\t\t// + item\n\t\t\t// - item\n\t\t\t// 1. item\n\t\t\tpattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'url-reference': {\n\t\t\t// [id]: http://example.com \"Optional title\"\n\t\t\t// [id]: http://example.com 'Optional title'\n\t\t\t// [id]: http://example.com (Optional title)\n\t\t\t// [id]: <http://example.com> \"Optional title\"\n\t\t\tpattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n\t\t\tinside: {\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /^(!?\\[)[^\\]]+/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n\t\t\t\t'punctuation': /^[\\[\\]!:]|[<>]/\n\t\t\t},\n\t\t\talias: 'url'\n\t\t},\n\t\t'bold': {\n\t\t\t// **strong**\n\t\t\t// __strong__\n\n\t\t\t// allow one nested instance of italic text using the same delimiter\n\t\t\tpattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^..)[\\s\\S]+(?=..$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\*\\*|__/\n\t\t\t}\n\t\t},\n\t\t'italic': {\n\t\t\t// *em*\n\t\t\t// _em_\n\n\t\t\t// allow one nested instance of bold text using the same delimiter\n\t\t\tpattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^.)[\\s\\S]+(?=.$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /[*_]/\n\t\t\t}\n\t\t},\n\t\t'strike': {\n\t\t\t// ~~strike through~~\n\t\t\t// ~strike~\n\t\t\t// eslint-disable-next-line regexp/strict\n\t\t\tpattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /~~?/\n\t\t\t}\n\t\t},\n\t\t'code-snippet': {\n\t\t\t// `code`\n\t\t\t// ``code``\n\t\t\tpattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\talias: ['code', 'keyword']\n\t\t},\n\t\t'url': {\n\t\t\t// [example](http://example.com \"Optional title\")\n\t\t\t// [example][id]\n\t\t\t// [example] [id]\n\t\t\tpattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'operator': /^!/,\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^\\[)[^\\]]+(?=\\])/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\tpattern: /(^\\]\\()[^\\s)]+/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t['url', 'bold', 'italic', 'strike'].forEach(function (token) {\n\t\t['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {\n\t\t\tif (token !== inside) {\n\t\t\t\tPrism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n\t\t\t}\n\t\t});\n\t});\n\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (env.language !== 'markdown' && env.language !== 'md') {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction walkTokens(tokens) {\n\t\t\tif (!tokens || typeof tokens === 'string') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (token.type !== 'code') {\n\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n\t\t\t\t * is optional. But the grammar is defined so that there is only one case we have to handle:\n\t\t\t\t *\n\t\t\t\t * token.content = [\n\t\t\t\t *     <span class=\"punctuation\">```</span>,\n\t\t\t\t *     <span class=\"code-language\">xxxx</span>,\n\t\t\t\t *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n\t\t\t\t *     <span class=\"code-block\">...</span>,\n\t\t\t\t *     '\\n', // exactly one new lines again\n\t\t\t\t *     <span class=\"punctuation\">```</span>\n\t\t\t\t * ];\n\t\t\t\t */\n\n\t\t\t\tvar codeLang = token.content[1];\n\t\t\t\tvar codeBlock = token.content[3];\n\n\t\t\t\tif (codeLang && codeBlock &&\n\t\t\t\t\tcodeLang.type === 'code-language' && codeBlock.type === 'code-block' &&\n\t\t\t\t\ttypeof codeLang.content === 'string') {\n\n\t\t\t\t\t// this might be a language that Prism does not support\n\n\t\t\t\t\t// do some replacements to support C++, C#, and F#\n\t\t\t\t\tvar lang = codeLang.content.replace(/\\b#/g, 'sharp').replace(/\\b\\+\\+/g, 'pp');\n\t\t\t\t\t// only use the first word\n\t\t\t\t\tlang = (/[a-z][\\w-]*/i.exec(lang) || [''])[0].toLowerCase();\n\t\t\t\t\tvar alias = 'language-' + lang;\n\n\t\t\t\t\t// add alias\n\t\t\t\t\tif (!codeBlock.alias) {\n\t\t\t\t\t\tcodeBlock.alias = [alias];\n\t\t\t\t\t} else if (typeof codeBlock.alias === 'string') {\n\t\t\t\t\t\tcodeBlock.alias = [codeBlock.alias, alias];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcodeBlock.alias.push(alias);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twalkTokens(env.tokens);\n\t});\n\n\tPrism.hooks.add('wrap', function (env) {\n\t\tif (env.type !== 'code-block') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar codeLang = '';\n\t\tfor (var i = 0, l = env.classes.length; i < l; i++) {\n\t\t\tvar cls = env.classes[i];\n\t\t\tvar match = /language-(.+)/.exec(cls);\n\t\t\tif (match) {\n\t\t\t\tcodeLang = match[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar grammar = Prism.languages[codeLang];\n\n\t\tif (!grammar) {\n\t\t\tif (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {\n\t\t\t\tvar id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);\n\t\t\t\tenv.attributes['id'] = id;\n\n\t\t\t\tPrism.plugins.autoloader.loadLanguages(codeLang, function () {\n\t\t\t\t\tvar ele = document.getElementById(id);\n\t\t\t\t\tif (ele) {\n\t\t\t\t\t\tele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tenv.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n\t\t}\n\t});\n\n\tvar tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');\n\n\t/**\n\t * A list of known entity names.\n\t *\n\t * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n\t *\n\t * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n\t */\n\tvar KNOWN_ENTITY_NAMES = {\n\t\t'amp': '&',\n\t\t'lt': '<',\n\t\t'gt': '>',\n\t\t'quot': '\"',\n\t};\n\n\t// IE 11 doesn't support `String.fromCodePoint`\n\tvar fromCodePoint = String.fromCodePoint || String.fromCharCode;\n\n\t/**\n\t * Returns the text content of a given HTML source code string.\n\t *\n\t * @param {string} html\n\t * @returns {string}\n\t */\n\tfunction textContent(html) {\n\t\t// remove all tags\n\t\tvar text = html.replace(tagPattern, '');\n\n\t\t// decode known entities\n\t\ttext = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (m, code) {\n\t\t\tcode = code.toLowerCase();\n\n\t\t\tif (code[0] === '#') {\n\t\t\t\tvar value;\n\t\t\t\tif (code[1] === 'x') {\n\t\t\t\t\tvalue = parseInt(code.slice(2), 16);\n\t\t\t\t} else {\n\t\t\t\t\tvalue = Number(code.slice(1));\n\t\t\t\t}\n\n\t\t\t\treturn fromCodePoint(value);\n\t\t\t} else {\n\t\t\t\tvar known = KNOWN_ENTITY_NAMES[code];\n\t\t\t\tif (known) {\n\t\t\t\t\treturn known;\n\t\t\t\t}\n\n\t\t\t\t// unable to decode\n\t\t\t\treturn m;\n\t\t\t}\n\t\t});\n\n\t\treturn text;\n\t}\n\n\tPrism.languages.md = Prism.languages.markdown;\n\n}(Prism));\n", "Prism.languages.c = Prism.languages.extend('clike', {\n\t'comment': {\n\t\tpattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\tgreedy: true\n\t},\n\t'string': {\n\t\t// https://en.cppreference.com/w/c/language/string_literal\n\t\tpattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n\t\tlookbehind: true\n\t},\n\t'keyword': /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n\t'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n\t'number': /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n\t'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\n\nPrism.languages.insertBefore('c', 'string', {\n\t'char': {\n\t\t// https://en.cppreference.com/w/c/language/character_constant\n\t\tpattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n\t\tgreedy: true\n\t}\n});\n\nPrism.languages.insertBefore('c', 'string', {\n\t'macro': {\n\t\t// allow for multiline macro definitions\n\t\t// spaces after the # character compile fine with gcc\n\t\tpattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property',\n\t\tinside: {\n\t\t\t'string': [\n\t\t\t\t{\n\t\t\t\t\t// highlight the path of the include statement as a string\n\t\t\t\t\tpattern: /^(#\\s*include\\s*)<[^>]+>/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\tPrism.languages.c['string']\n\t\t\t],\n\t\t\t'char': Prism.languages.c['char'],\n\t\t\t'comment': Prism.languages.c['comment'],\n\t\t\t'macro-name': [\n\t\t\t\t{\n\t\t\t\t\tpattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'function'\n\t\t\t\t}\n\t\t\t],\n\t\t\t// highlight macro directives as keywords\n\t\t\t'directive': {\n\t\t\t\tpattern: /^(#\\s*)[a-z]+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t'directive-hash': /^#/,\n\t\t\t'punctuation': /##|\\\\(?=[\\r\\n])/,\n\t\t\t'expression': {\n\t\t\t\tpattern: /\\S[\\s\\S]*/,\n\t\t\t\tinside: Prism.languages.c\n\t\t\t}\n\t\t}\n\t}\n});\n\nPrism.languages.insertBefore('c', 'function', {\n\t// highlight predefined macros as constants\n\t'constant': /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\n\ndelete Prism.languages.c['boolean'];\n", "(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: RegExp('@[\\\\w-](?:' + /[^;{\\s\"']|\\s+(?!\\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\\s*\\{))/.source),\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n", "Prism.languages.objectivec = Prism.languages.extend('c', {\n\t'string': {\n\t\tpattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'keyword': /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n\t'operator': /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\n\ndelete Prism.languages.objectivec['class-name'];\n\nPrism.languages.objc = Prism.languages.objectivec;\n", "Prism.languages.sql = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n\t\tlookbehind: true\n\t},\n\t'variable': [\n\t\t{\n\t\t\tpattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t/@[\\w.$]+/\n\t],\n\t'string': {\n\t\tpattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n\t\tgreedy: true,\n\t\tlookbehind: true\n\t},\n\t'identifier': {\n\t\tpattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n\t\tgreedy: true,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /^`|`$/\n\t\t}\n\t},\n\t'function': /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i, // Should we highlight user defined functions too?\n\t'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n\t'boolean': /\\b(?:FALSE|NULL|TRUE)\\b/i,\n\t'number': /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n\t'operator': /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n\t'punctuation': /[;[\\]()`,.]/\n};\n", "(function (Prism) {\n\n\tvar powershell = Prism.languages.powershell = {\n\t\t'comment': [\n\t\t\t{\n\t\t\t\tpattern: /(^|[^`])<#[\\s\\S]*?#>/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(^|[^`])#.*/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'string': [\n\t\t\t{\n\t\t\t\tpattern: /\"(?:`[\\s\\S]|[^`\"])*\"/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /'(?:[^']|'')*'/,\n\t\t\t\tgreedy: true\n\t\t\t}\n\t\t],\n\t\t// Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices\n\t\t// Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)\n\t\t'namespace': /\\[[a-z](?:\\[(?:\\[[^\\]]*\\]|[^\\[\\]])*\\]|[^\\[\\]])*\\]/i,\n\t\t'boolean': /\\$(?:false|true)\\b/i,\n\t\t'variable': /\\$\\w+\\b/,\n\t\t// Cmdlets and aliases. Aliases should come last, otherwise \"write\" gets preferred over \"write-host\" for example\n\t\t// Get-Command | ?{ $_.ModuleName -match \"Microsoft.PowerShell.(Util|Core|Management)\" }\n\t\t// Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match \"Microsoft.PowerShell.(Util|Core|Management)\" }\n\t\t'function': [\n\t\t\t/\\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\\b/i,\n\t\t\t/\\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\\b/i\n\t\t],\n\t\t// per http://technet.microsoft.com/en-us/library/hh847744.aspx\n\t\t'keyword': /\\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\\b/i,\n\t\t'operator': {\n\t\t\tpattern: /(^|\\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\\b|-[-=]?|\\+[+=]?|[*\\/%]=?)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[|{}[\\];(),.]/\n\t};\n\n\t// Variable interpolation inside strings, and nested expressions\n\tpowershell.string[0].inside = {\n\t\t'function': {\n\t\t\t// Allow for one level of nesting\n\t\t\tpattern: /(^|[^`])\\$\\((?:\\$\\([^\\r\\n()]*\\)|(?!\\$\\()[^\\r\\n)])*\\)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: powershell\n\t\t},\n\t\t'boolean': powershell.boolean,\n\t\t'variable': powershell.variable,\n\t};\n\n}(Prism));\n", "Prism.languages.python = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])#.*/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'string-interpolation': {\n\t\tpattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'interpolation': {\n\t\t\t\t// \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n\t\t\t\tpattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'format-spec': {\n\t\t\t\t\t\tpattern: /(:)[^:(){}]+(?=\\}$)/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'conversion-option': {\n\t\t\t\t\t\tpattern: /![sra](?=[:}]$)/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: null\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'triple-quoted-string': {\n\t\tpattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n\t\tgreedy: true,\n\t\talias: 'string'\n\t},\n\t'string': {\n\t\tpattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n\t\tgreedy: true\n\t},\n\t'function': {\n\t\tpattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n\t\tlookbehind: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\bclass\\s+)\\w+/i,\n\t\tlookbehind: true\n\t},\n\t'decorator': {\n\t\tpattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n\t\tlookbehind: true,\n\t\talias: ['annotation', 'punctuation'],\n\t\tinside: {\n\t\t\t'punctuation': /\\./\n\t\t}\n\t},\n\t'keyword': /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n\t'builtin': /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n\t'boolean': /\\b(?:False|None|True)\\b/,\n\t'number': /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n\t'operator': /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\nPrism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;\n\nPrism.languages.py = Prism.languages.python;\n", "(function (Prism) {\n\n\tvar multilineComment = /\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\//.source;\n\tfor (var i = 0; i < 2; i++) {\n\t\t// support 4 levels of nested comments\n\t\tmultilineComment = multilineComment.replace(/<self>/g, function () { return multilineComment; });\n\t}\n\tmultilineComment = multilineComment.replace(/<self>/g, function () { return /[^\\s\\S]/.source; });\n\n\n\tPrism.languages.rust = {\n\t\t'comment': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(^|[^\\\\])/.source + multilineComment),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t}\n\t\t],\n\t\t'string': {\n\t\t\tpattern: /b?\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|b?r(#*)\"(?:[^\"]|\"(?!\\1))*\"\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'char': {\n\t\t\tpattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'attribute': {\n\t\t\tpattern: /#!?\\[(?:[^\\[\\]\"]|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\")*\\]/,\n\t\t\tgreedy: true,\n\t\t\talias: 'attr-name',\n\t\t\tinside: {\n\t\t\t\t'string': null // see below\n\t\t\t}\n\t\t},\n\n\t\t// Closure params should not be confused with bitwise OR |\n\t\t'closure-params': {\n\t\t\tpattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'closure-punctuation': {\n\t\t\t\t\tpattern: /^\\||\\|$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: null // see below\n\t\t\t}\n\t\t},\n\n\t\t'lifetime-annotation': {\n\t\t\tpattern: /'\\w+/,\n\t\t\talias: 'symbol'\n\t\t},\n\n\t\t'fragment-specifier': {\n\t\t\tpattern: /(\\$\\w+:)[a-z]+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'variable': /\\$\\w+/,\n\n\t\t'function-definition': {\n\t\t\tpattern: /(\\bfn\\s+)\\w+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function'\n\t\t},\n\t\t'type-definition': {\n\t\t\tpattern: /(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'class-name'\n\t\t},\n\t\t'module-declaration': [\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'namespace'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'namespace',\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /::/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'keyword': [\n\t\t\t// https://github.com/rust-lang/reference/blob/master/src/keywords.md\n\t\t\t/\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,\n\t\t\t// primitives and str\n\t\t\t// https://doc.rust-lang.org/stable/rust-by-example/primitives.html\n\t\t\t/\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/\n\t\t],\n\n\t\t// functions can technically start with an upper-case letter, but this will introduce a lot of false positives\n\t\t// and Rust's naming conventions recommend snake_case anyway.\n\t\t// https://doc.rust-lang.org/1.0.0/style/style/naming/README.html\n\t\t'function': /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,\n\t\t'macro': {\n\t\t\tpattern: /\\b\\w+!/,\n\t\t\talias: 'property'\n\t\t},\n\t\t'constant': /\\b[A-Z_][A-Z_\\d]+\\b/,\n\t\t'class-name': /\\b[A-Z]\\w*\\b/,\n\n\t\t'namespace': {\n\t\t\tpattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /::/\n\t\t\t}\n\t\t},\n\n\t\t// Hex, oct, bin, dec numbers with visual separators and type suffix\n\t\t'number': /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t'punctuation': /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n\t\t'operator': /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n\t};\n\n\tPrism.languages.rust['closure-params'].inside.rest = Prism.languages.rust;\n\tPrism.languages.rust['attribute'].inside['string'] = Prism.languages.rust['string'];\n\n}(Prism));\n", "Prism.languages.swift = {\n\t'comment': {\n\t\t// Nested comments are supported up to 2 levels\n\t\tpattern: /(^|[^\\\\:])(?:\\/\\/.*|\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*\\*\\/)/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'string-literal': [\n\t\t// https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[^\"#])/.source\n\t\t\t\t+ '(?:'\n\t\t\t\t// single-line string\n\t\t\t\t+ /\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^(])|[^\\\\\\r\\n\"])*\"/.source\n\t\t\t\t+ '|'\n\t\t\t\t// multi-line string\n\t\t\t\t+ /\"\"\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|[^(])|[^\\\\\"]|\"(?!\"\"))*\"\"\"/.source\n\t\t\t\t+ ')'\n\t\t\t\t+ /(?![\"#])/.source\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /(\\\\\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: null // see below\n\t\t\t\t},\n\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\tpattern: /^\\)|\\\\\\($/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\\\(?=[\\r\\n])/,\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[^\"#])(#+)/.source\n\t\t\t\t+ '(?:'\n\t\t\t\t// single-line string\n\t\t\t\t+ /\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^#])|[^\\\\\\r\\n])*?\"/.source\n\t\t\t\t+ '|'\n\t\t\t\t// multi-line string\n\t\t\t\t+ /\"\"\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|[^#])|[^\\\\])*?\"\"\"/.source\n\t\t\t\t+ ')'\n\t\t\t\t+ '\\\\2'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /(\\\\#+\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: null // see below\n\t\t\t\t},\n\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\tpattern: /^\\)|\\\\#+\\($/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t],\n\n\t'directive': {\n\t\t// directives with conditions\n\t\tpattern: RegExp(\n\t\t\t/#/.source\n\t\t\t+ '(?:'\n\t\t\t+ (\n\t\t\t\t/(?:elseif|if)\\b/.source\n\t\t\t\t+ '(?:[ \\t]*'\n\t\t\t\t// This regex is a little complex. It's equivalent to this:\n\t\t\t\t//   (?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*<round>)?|<round>)(?:[ \\t]*(?:&&|\\|\\|))?\n\t\t\t\t// where <round> is a general parentheses expression.\n\t\t\t\t+ /(?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*\\((?:[^()]|\\([^()]*\\))*\\))?|\\((?:[^()]|\\([^()]*\\))*\\))(?:[ \\t]*(?:&&|\\|\\|))?/.source\n\t\t\t\t+ ')+'\n\t\t\t)\n\t\t\t+ '|'\n\t\t\t+ /(?:else|endif)\\b/.source\n\t\t\t+ ')'\n\t\t),\n\t\talias: 'property',\n\t\tinside: {\n\t\t\t'directive-name': /^#\\w+/,\n\t\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t\t'number': /\\b\\d+(?:\\.\\d+)*\\b/,\n\t\t\t'operator': /!|&&|\\|\\||[<>]=?/,\n\t\t\t'punctuation': /[(),]/\n\t\t}\n\t},\n\t'literal': {\n\t\tpattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\\b/,\n\t\talias: 'constant'\n\t},\n\t'other-directive': {\n\t\tpattern: /#\\w+\\b/,\n\t\talias: 'property'\n\t},\n\n\t'attribute': {\n\t\tpattern: /@\\w+/,\n\t\talias: 'atrule'\n\t},\n\n\t'function-definition': {\n\t\tpattern: /(\\bfunc\\s+)\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'label': {\n\t\t// https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141\n\t\tpattern: /\\b(break|continue)\\s+\\w+|\\b[a-zA-Z_]\\w*(?=\\s*:\\s*(?:for|repeat|while)\\b)/,\n\t\tlookbehind: true,\n\t\talias: 'important'\n\t},\n\n\t'keyword': /\\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'nil': {\n\t\tpattern: /\\bnil\\b/,\n\t\talias: 'constant'\n\t},\n\n\t'short-argument': /\\$\\d+\\b/,\n\t'omit': {\n\t\tpattern: /\\b_\\b/,\n\t\talias: 'keyword'\n\t},\n\t'number': /\\b(?:[\\d_]+(?:\\.[\\de_]+)?|0x[a-f0-9_]+(?:\\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b/i,\n\n\t// A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.\n\t'class-name': /\\b[A-Z](?:[A-Z_\\d]*[a-z]\\w*)?\\b/,\n\t'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n\t'constant': /\\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\\b/,\n\n\t// Operators are generic in Swift. Developers can even create new operators (e.g. +++).\n\t// https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481\n\t// This regex only supports ASCII operators.\n\t'operator': /[-+*/%=!<>&|^~?]+|\\.[.\\-+*/%=!<>&|^~?]+/,\n\t'punctuation': /[{}[\\]();,.:\\\\]/\n};\n\nPrism.languages.swift['string-literal'].forEach(function (rule) {\n\trule.inside['interpolation'].inside = Prism.languages.swift;\n});\n", "(function (Prism) {\n\n\tPrism.languages.typescript = Prism.languages.extend('javascript', {\n\t\t'class-name': {\n\t\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: null // see below\n\t\t},\n\t\t'builtin': /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/,\n\t});\n\n\t// The keywords TypeScript adds to JavaScript\n\tPrism.languages.typescript.keyword.push(\n\t\t/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/,\n\t\t// keywords that have to be followed by an identifier\n\t\t/\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/,\n\t\t// This is for `import type *, {}`\n\t\t/\\btype\\b(?=\\s*(?:[\\{*]|$))/\n\t);\n\n\t// doesn't work with TS because TS is too complex\n\tdelete Prism.languages.typescript['parameter'];\n\tdelete Prism.languages.typescript['literal-property'];\n\n\t// a version of typescript specifically for highlighting types\n\tvar typeInside = Prism.languages.extend('typescript', {});\n\tdelete typeInside['class-name'];\n\n\tPrism.languages.typescript['class-name'].inside = typeInside;\n\n\tPrism.languages.insertBefore('typescript', 'function', {\n\t\t'decorator': {\n\t\t\tpattern: /@[$\\w\\xA0-\\uFFFF]+/,\n\t\t\tinside: {\n\t\t\t\t'at': {\n\t\t\t\t\tpattern: /^@/,\n\t\t\t\t\talias: 'operator'\n\t\t\t\t},\n\t\t\t\t'function': /^[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t\t'generic-function': {\n\t\t\t// e.g. foo<T extends \"bar\" | \"baz\">( ...\n\t\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/, // everything after the first <\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: typeInside\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.ts = Prism.languages.typescript;\n\n}(Prism));\n", "(function (Prism) {\n\n\tvar keywords = /\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\\s*[(){}[\\]<>=%~.:,;?+\\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\\b/;\n\n\t// full package (optional) + parent classes (optional)\n\tvar classNamePrefix = /(?:[a-z]\\w*\\s*\\.\\s*)*(?:[A-Z]\\w*\\s*\\.\\s*)*/.source;\n\n\t// based on the java naming conventions\n\tvar className = {\n\t\tpattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z](?:[\\d_A-Z]*[a-z]\\w*)?\\b/.source),\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'namespace': {\n\t\t\t\tpattern: /^[a-z]\\w*(?:\\s*\\.\\s*[a-z]\\w*)*(?:\\s*\\.)?/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\./\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\./\n\t\t}\n\t};\n\n\tPrism.languages.java = Prism.languages.extend('clike', {\n\t\t'string': {\n\t\t\tpattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t'class-name': [\n\t\t\tclassName,\n\t\t\t{\n\t\t\t\t// variables, parameters, and constructor references\n\t\t\t\t// this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n\t\t\t\tpattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z]\\w*(?=\\s+\\w+\\s*[;,=()]|\\s*(?:\\[[\\s,]*\\]\\s*)?::\\s*new\\b)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: className.inside\n\t\t\t},\n\t\t\t{\n\t\t\t\t// class names based on keyword\n\t\t\t\t// this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n\t\t\t\tpattern: RegExp(/(\\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\\s+)/.source + classNamePrefix + /[A-Z]\\w*\\b/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: className.inside\n\t\t\t}\n\t\t],\n\t\t'keyword': keywords,\n\t\t'function': [\n\t\t\tPrism.languages.clike.function,\n\t\t\t{\n\t\t\t\tpattern: /(::\\s*)[a-z_]\\w*/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'number': /\\b0b[01][01_]*L?\\b|\\b0x(?:\\.[\\da-f_p+-]+|[\\da-f_]+(?:\\.[\\da-f_p+-]+)?)\\b|(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[dfl]?/i,\n\t\t'operator': {\n\t\t\tpattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\\+\\+|&&|\\|\\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'constant': /\\b[A-Z][A-Z_\\d]+\\b/\n\t});\n\n\tPrism.languages.insertBefore('java', 'string', {\n\t\t'triple-quoted-string': {\n\t\t\t// http://openjdk.java.net/jeps/355#Description\n\t\t\tpattern: /\"\"\"[ \\t]*[\\r\\n](?:(?:\"|\"\")?(?:\\\\.|[^\"\\\\]))*\"\"\"/,\n\t\t\tgreedy: true,\n\t\t\talias: 'string'\n\t\t},\n\t\t'char': {\n\t\t\tpattern: /'(?:\\\\.|[^'\\\\\\r\\n]){1,6}'/,\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('java', 'class-name', {\n\t\t'annotation': {\n\t\t\tpattern: /(^|[^.])@\\w+(?:\\s*\\.\\s*\\w+)*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'generics': {\n\t\t\tpattern: /<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&))*>)*>)*>)*>/,\n\t\t\tinside: {\n\t\t\t\t'class-name': className,\n\t\t\t\t'keyword': keywords,\n\t\t\t\t'punctuation': /[<>(),.:]/,\n\t\t\t\t'operator': /[?&|]/\n\t\t\t}\n\t\t},\n\t\t'import': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\bimport\\s+)/.source + classNamePrefix + /(?:[A-Z]\\w*|\\*)(?=\\s*;)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': className.inside.namespace,\n\t\t\t\t\t'punctuation': /\\./,\n\t\t\t\t\t'operator': /\\*/,\n\t\t\t\t\t'class-name': /\\w+/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\bimport\\s+static\\s+)/.source + classNamePrefix + /(?:\\w+|\\*)(?=\\s*;)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'static',\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': className.inside.namespace,\n\t\t\t\t\t'static': /\\b\\w+$/,\n\t\t\t\t\t'punctuation': /\\./,\n\t\t\t\t\t'operator': /\\*/,\n\t\t\t\t\t'class-name': /\\w+/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'namespace': {\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:exports|import(?:\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\s+)(?!<keyword>)[a-z]\\w*(?:\\.[a-z]\\w*)*\\.?/\n\t\t\t\t\t.source.replace(/<keyword>/g, function () { return keywords.source; })),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /\\./,\n\t\t\t}\n\t\t}\n\t});\n}(Prism));\n", "(function (Prism) {\n\n\tvar keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n\tvar modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () { return keyword.source; });\n\n\tPrism.languages.cpp = Prism.languages.extend('c', {\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source\n\t\t\t\t\t.replace(/<keyword>/g, function () { return keyword.source; })),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t// This is intended to capture the class name of method implementations like:\n\t\t\t//   void foo::bar() const {}\n\t\t\t// However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n\t\t\t// it starts with an uppercase letter. This approximation should give decent results.\n\t\t\t/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n\t\t\t// This will capture the class name before destructors like:\n\t\t\t//   Foo::~Foo() {}\n\t\t\t/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n\t\t\t// This also intends to capture the class name of method implementations but here the class has template\n\t\t\t// parameters, so it can't be a namespace (until C++ adds generic namespaces).\n\t\t\t/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n\t\t],\n\t\t'keyword': keyword,\n\t\t'number': {\n\t\t\tpattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n\t\t\tgreedy: true\n\t\t},\n\t\t'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'string', {\n\t\t'module': {\n\t\t\t// https://en.cppreference.com/w/cpp/language/modules\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:import|module)\\s+)/.source +\n\t\t\t\t'(?:' +\n\t\t\t\t// header-name\n\t\t\t\t/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source +\n\t\t\t\t'|' +\n\t\t\t\t// module name or partition or both\n\t\t\t\t/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +\n\t\t\t\t')'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'string': /^[<\"][\\s\\S]+/,\n\t\t\t\t'operator': /:/,\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t},\n\t\t'raw-string': {\n\t\t\tpattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n\t\t\talias: 'string',\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'keyword', {\n\t\t'generic-function': {\n\t\t\tpattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n\t\t\tinside: {\n\t\t\t\t'function': /^\\w+/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/,\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: Prism.languages.cpp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'operator', {\n\t\t'double-colon': {\n\t\t\tpattern: /::/,\n\t\t\talias: 'punctuation'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'class-name', {\n\t\t// the base clause is an optional list of parent classes\n\t\t// https://en.cppreference.com/w/cpp/language/class\n\t\t'base-clause': {\n\t\t\tpattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: Prism.languages.extend('cpp', {})\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('inside', 'double-colon', {\n\t\t// All untokenized words that are not namespaces should be class names\n\t\t'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n\t}, Prism.languages.cpp['base-clause']);\n\n}(Prism));\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{isHTMLElement as t,addClassNamesToElement as e,removeClassNamesFromElement as n,$getAdjacentCaret as r,mergeRegister as i}from\"@lexical/utils\";import{ElementNode as o,$createParagraphNode as s,$isTextNode as l,$isTabNode as u,$createTabNode as c,$createLineBreakNode as g,$create as a,TextNode as f,$applyNodeReplacement as p,$getSiblingCaret as h,getTextDirection as d,$isElementNode as m,$isLineBreakNode as y,defineExtension as x,$createTextNode as _,$getNodeByKey as S,$getSelection as v,$isRangeSelection as T,$createPoint as b,INDENT_CONTENT_COMMAND as C,OUTDENT_CONTENT_COMMAND as N,INSERT_TAB_COMMAND as j,$setSelectionFromCaretRange as w,$getCaretRangeInDirection as k,$getCaretRange as A,$getTextPointCaret as P,$normalizeCaret as L,KEY_ARROW_UP_COMMAND as O,MOVE_TO_START as H,KEY_TAB_COMMAND as E,COMMAND_PRIORITY_LOW as z,$insertNodes as B,KEY_ARROW_DOWN_COMMAND as D,MOVE_TO_END as F}from\"lexical\";import\"prismjs\";import\"prismjs/components/prism-clike.js\";import\"prismjs/components/prism-javascript.js\";import\"prismjs/components/prism-markup.js\";import\"prismjs/components/prism-markdown.js\";import\"prismjs/components/prism-c.js\";import\"prismjs/components/prism-css.js\";import\"prismjs/components/prism-objectivec.js\";import\"prismjs/components/prism-sql.js\";import\"prismjs/components/prism-powershell.js\";import\"prismjs/components/prism-python.js\";import\"prismjs/components/prism-rust.js\";import\"prismjs/components/prism-swift.js\";import\"prismjs/components/prism-typescript.js\";import\"prismjs/components/prism-java.js\";import\"prismjs/components/prism-cpp.js\";function I(t,...e){const n=new URL(\"https://lexical.dev/docs/error\"),r=new URLSearchParams;r.append(\"code\",t);for(const t of e)r.append(\"v\",t);throw n.search=r.toString(),Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}const M=\"javascript\",J=()=>M;function R(e,n){for(const r of e.childNodes){if(t(r)&&r.tagName===n)return!0;R(r,n)}return!1}const K=\"data-language\",$=\"data-highlight-language\",W=\"data-theme\";class q extends o{__language;__theme;__isSyntaxHighlightSupported;static getType(){return\"code\"}static clone(t){return new q(t.__language,t.__key)}constructor(t,e){super(e),this.__language=t||void 0,this.__isSyntaxHighlightSupported=!1,this.__theme=void 0}afterCloneFrom(t){super.afterCloneFrom(t),this.__language=t.__language,this.__theme=t.__theme,this.__isSyntaxHighlightSupported=t.__isSyntaxHighlightSupported}createDOM(t){const n=document.createElement(\"code\");e(n,t.theme.code),n.setAttribute(\"spellcheck\",\"false\");const r=this.getLanguage();r&&(n.setAttribute(K,r),this.getIsSyntaxHighlightSupported()&&n.setAttribute($,r));const i=this.getTheme();i&&n.setAttribute(W,i);const o=this.getStyle();return o&&n.setAttribute(\"style\",o),n}updateDOM(t,e,n){const r=this.__language,i=t.__language;r?r!==i&&e.setAttribute(K,r):i&&e.removeAttribute(K);const o=this.__isSyntaxHighlightSupported;t.__isSyntaxHighlightSupported&&i?o&&r?r!==i&&e.setAttribute($,r):e.removeAttribute($):o&&r&&e.setAttribute($,r);const s=this.__theme,l=t.__theme;s?s!==l&&e.setAttribute(W,s):l&&e.removeAttribute(W);const u=this.__style,c=t.__style;return u?u!==c&&e.setAttribute(\"style\",u):c&&e.removeAttribute(\"style\"),!1}exportDOM(t){const n=document.createElement(\"pre\");e(n,t._config.theme.code),n.setAttribute(\"spellcheck\",\"false\");const r=this.getLanguage();r&&(n.setAttribute(K,r),this.getIsSyntaxHighlightSupported()&&n.setAttribute($,r));const i=this.getTheme();i&&n.setAttribute(W,i);const o=this.getStyle();return o&&n.setAttribute(\"style\",o),{element:n}}static importDOM(){return{code:t=>null!=t.textContent&&(/\\r?\\n/.test(t.textContent)||R(t,\"BR\"))?{conversion:Q,priority:1}:null,div:()=>({conversion:G,priority:1}),pre:()=>({conversion:Q,priority:0}),table:t=>tt(t)?{conversion:V,priority:3}:null,td:t=>{const e=t,n=e.closest(\"table\");return e.classList.contains(\"js-file-line\")||n&&tt(n)?{conversion:Y,priority:3}:null},tr:t=>{const e=t.closest(\"table\");return e&&tt(e)?{conversion:Y,priority:3}:null}}}static importJSON(t){return U().updateFromJSON(t)}updateFromJSON(t){return super.updateFromJSON(t).setLanguage(t.language).setTheme(t.theme)}exportJSON(){return{...super.exportJSON(),language:this.getLanguage(),theme:this.getTheme()}}insertNewAfter(t,e=!0){const n=this.getChildren(),r=n.length;if(r>=2&&\"\\n\"===n[r-1].getTextContent()&&\"\\n\"===n[r-2].getTextContent()&&t.isCollapsed()&&t.anchor.key===this.__key&&t.anchor.offset===r){n[r-1].remove(),n[r-2].remove();const t=s();return this.insertAfter(t,e),t}const{anchor:i,focus:o}=t,a=(i.isBefore(o)?i:o).getNode();if(l(a)){let t=st(a);const e=[];for(;;)if(u(t))e.push(c()),t=t.getNextSibling();else{if(!it(t))break;{let n=0;const r=t.getTextContent(),i=t.getTextContentSize();for(;n<i&&\" \"===r[n];)n++;if(0!==n&&e.push(rt(\" \".repeat(n))),n!==i)break;t=t.getNextSibling()}}const n=a.splitText(i.offset)[0],r=0===i.offset?0:1,o=n.getIndexWithinParent()+r,s=a.getParentOrThrow(),l=[g(),...e];s.splice(o,0,l);const f=e[e.length-1];f?f.select():0===i.offset?n.selectPrevious():n.getNextSibling().selectNext(0,0)}if(X(a)){const{offset:e}=t.anchor;a.splice(e,0,[g()]),a.select(e+1,e+1)}return null}canIndent(){return!1}collapseAtStart(){const t=s();return this.getChildren().forEach(e=>t.append(e)),this.replace(t),!0}setLanguage(t){const e=this.getWritable();return e.__language=t||void 0,e}getLanguage(){return this.getLatest().__language}setIsSyntaxHighlightSupported(t){const e=this.getWritable();return e.__isSyntaxHighlightSupported=t,e}getIsSyntaxHighlightSupported(){return this.getLatest().__isSyntaxHighlightSupported}setTheme(t){const e=this.getWritable();return e.__theme=t||void 0,e}getTheme(){return this.getLatest().__theme}}function U(t,e){return a(q).setLanguage(t).setTheme(e)}function X(t){return t instanceof q}function Q(t){return{node:U(t.getAttribute(K))}}function G(t){const e=t,n=Z(e);return n||function(t){let e=t.parentElement;for(;null!==e;){if(Z(e))return!0;e=e.parentElement}return!1}(e)?{node:n?U():null}:{node:null}}function V(){return{node:U()}}function Y(){return{node:null}}function Z(t){return null!==t.style.fontFamily.match(\"monospace\")}function tt(t){return t.classList.contains(\"js-file-line-container\")}class et extends f{__highlightType;constructor(t=\"\",e,n){super(t,n),this.__highlightType=e}static getType(){return\"code-highlight\"}static clone(t){return new et(t.__text,t.__highlightType||void 0,t.__key)}getHighlightType(){return this.getLatest().__highlightType}setHighlightType(t){const e=this.getWritable();return e.__highlightType=t||void 0,e}canHaveFormat(){return!1}createDOM(t){const n=super.createDOM(t),r=nt(t.theme,this.__highlightType);return e(n,r),n}updateDOM(t,r,i){const o=super.updateDOM(t,r,i),s=nt(i.theme,t.__highlightType),l=nt(i.theme,this.__highlightType);return s!==l&&(s&&n(r,s),l&&e(r,l)),o}static importJSON(t){return rt().updateFromJSON(t)}updateFromJSON(t){return super.updateFromJSON(t).setHighlightType(t.highlightType)}exportJSON(){return{...super.exportJSON(),highlightType:this.getHighlightType()}}setFormat(t){return this}isParentRequired(){return!0}createParentElementNode(){return U()}}function nt(t,e){return e&&t&&t.codeHighlight&&t.codeHighlight[e]}function rt(t=\"\",e){return p(new et(t,e))}function it(t){return t instanceof et}function ot(t,e){let n=t;for(let i=h(t,e);i&&(it(i.origin)||u(i.origin));i=r(i))n=i.origin;return n}function st(t){return ot(t,\"previous\")}function lt(t){return ot(t,\"next\")}function ut(t){const e=st(t),n=lt(t);let r=e;for(;null!==r;){if(it(r)){const t=d(r.getTextContent());if(null!==t)return t}if(r===n)break;r=r.getNextSibling()}const i=e.getParent();if(m(i)){const t=i.getDirection();if(\"ltr\"===t||\"rtl\"===t)return t}return null}function ct(t,e){let n=null,r=null,i=t,o=e,s=t.getTextContent();for(;;){if(0===o){if(i=i.getPreviousSibling(),null===i)break;if(it(i)||u(i)||y(i)||I(167),y(i)){n={node:i,offset:1};break}o=Math.max(0,i.getTextContentSize()-1),s=i.getTextContent()}else o--;const t=s[o];it(i)&&\" \"!==t&&(r={node:i,offset:o})}if(null!==r)return r;let l=null;if(e<t.getTextContentSize())it(t)&&(l=t.getTextContent()[e]);else{const e=t.getNextSibling();it(e)&&(l=e.getTextContent()[0])}if(null!==l&&\" \"!==l)return n;{const r=function(t,e){let n=t,r=e,i=t.getTextContent(),o=t.getTextContentSize();for(;;){if(!it(n)||r===o){if(n=n.getNextSibling(),null===n||y(n))return null;it(n)&&(r=0,i=n.getTextContent(),o=n.getTextContentSize())}if(it(n)){if(\" \"!==i[r])return{node:n,offset:r};r++}}}(t,e);return null!==r?r:n}}function gt(t){const e=lt(t);return y(e)&&I(168),e}const at=x({name:\"@lexical/code\",nodes:[q,et]});!function(t){t.languages.diff={coord:[/^(?:\\*{3}|-{3}|\\+{3}).*$/m,/^@@.*@@$/m,/^\\d.*$/m]};var e={\"deleted-sign\":\"-\",\"deleted-arrow\":\"<\",\"inserted-sign\":\"+\",\"inserted-arrow\":\">\",unchanged:\" \",diff:\"!\"};Object.keys(e).forEach(function(n){var r=e[n],i=[];/^\\w+$/.test(n)||i.push(/\\w+/.exec(n)[0]),\"diff\"===n&&i.push(\"bold\"),t.languages.diff[n]={pattern:RegExp(\"^(?:[\"+r+\"].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+\",\"m\"),alias:i,inside:{line:{pattern:/(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,lookbehind:!0},prefix:{pattern:/[\\s\\S]/,alias:/\\w+/.exec(n)[0]}}}}),Object.defineProperty(t.languages.diff,\"PREFIXES\",{value:e})}(Prism);const ft=globalThis.Prism||window.Prism,pt={c:\"C\",clike:\"C-like\",cpp:\"C++\",css:\"CSS\",html:\"HTML\",java:\"Java\",js:\"JavaScript\",markdown:\"Markdown\",objc:\"Objective-C\",plain:\"Plain Text\",powershell:\"PowerShell\",py:\"Python\",rust:\"Rust\",sql:\"SQL\",swift:\"Swift\",typescript:\"TypeScript\",xml:\"XML\"},ht={cpp:\"cpp\",java:\"java\",javascript:\"js\",md:\"markdown\",plaintext:\"plain\",python:\"py\",text:\"plain\",ts:\"typescript\"};function dt(t){return ht[t]||t}function mt(t){const e=dt(t);return pt[e]||e}const yt=()=>Object.keys(ft.languages).filter(t=>\"function\"!=typeof ft.languages[t]).sort();function xt(){const t=[];for(const[e,n]of Object.entries(pt))t.push([e,n]);return t}function _t(){return[]}function St(t){return\"string\"==typeof t?t:Array.isArray(t)?t.map(St).join(\"\"):St(t.content)}function vt(t,e){const n=/^diff-([\\w-]+)/i.exec(e),r=t.getTextContent();let i=ft.tokenize(r,ft.languages[n?\"diff\":e]);return n&&(i=function(t,e){const n=e,r=ft.languages[n],i={tokens:t},o=ft.languages.diff.PREFIXES;for(const t of i.tokens){if(\"string\"==typeof t||!(t.type in o)||!Array.isArray(t.content))continue;const e=t.type;let n=0;const i=()=>(n++,new ft.Token(\"prefix\",o[e],e.replace(/^(\\w+).*/,\"$1\"))),s=t.content.filter(t=>\"string\"==typeof t||\"prefix\"!==t.type),l=t.content.length-s.length,u=ft.tokenize(St(s),r);u.unshift(i());const c=/\\r\\n|\\n/g,g=t=>{const e=[];c.lastIndex=0;let r,o=0;for(;n<l&&(r=c.exec(t));){const n=r.index+r[0].length;e.push(t.slice(o,n)),o=n,e.push(i())}if(0!==e.length)return o<t.length&&e.push(t.slice(o)),e},a=t=>{for(let e=0;e<t.length&&n<l;e++){const n=t[e];if(\"string\"==typeof n){const r=g(n);r&&(t.splice(e,1,...r),e+=r.length-1)}else if(\"string\"==typeof n.content){const t=g(n.content);t&&(n.content=t)}else Array.isArray(n.content)?a(n.content):a([n.content])}};a(u),n<l&&u.push(i()),t.content=u}return i.tokens}(i,n[1])),Tt(i)}function Tt(t,e){const n=[];for(const r of t)if(\"string\"==typeof r){const t=r.split(/(\\n|\\t)/),i=t.length;for(let r=0;r<i;r++){const i=t[r];\"\\n\"===i||\"\\r\\n\"===i?n.push(g()):\"\\t\"===i?n.push(c()):i.length>0&&n.push(rt(i,e))}}else{const{content:t,alias:e}=r;\"string\"==typeof t?n.push(...Tt([t],\"prefix\"===r.type&&\"string\"==typeof e?e:r.type)):Array.isArray(t)&&n.push(...Tt(t,\"unchanged\"===r.type?void 0:r.type))}return n}const bt={$tokenize(t,e){return vt(t,e||this.defaultLanguage)},defaultLanguage:M,tokenize(t,e){return ft.tokenize(t,ft.languages[e||\"\"]||ft.languages[this.defaultLanguage])}};function Ct(t,e,n){const r=t.getParent();X(r)?wt(r,e,n):it(t)&&t.replace(_(t.__text))}function Nt(t,e){const n=e.getElementByKey(t.getKey());if(null===n)return;const r=t.getChildren(),i=r.length;if(i===n.__cachedChildrenLength)return;n.__cachedChildrenLength=i;let o=\"1\",s=1;for(let t=0;t<i;t++)y(r[t])&&(o+=\"\\n\"+ ++s);n.setAttribute(\"data-gutter\",o)}const jt=new Set;function wt(t,e,n){const r=t.getKey();void 0===t.getLanguage()&&t.setLanguage(n.defaultLanguage);const i=t.getLanguage()||n.defaultLanguage;if(!function(t){const e=function(t){const e=/^diff-([\\w-]+)/i.exec(t);return e?e[1]:null}(t),n=e||t;try{return!!n&&ft.languages.hasOwnProperty(n)}catch(t){return!1}}(i))return t.getIsSyntaxHighlightSupported()&&t.setIsSyntaxHighlightSupported(!1),void async function(){}();t.getIsSyntaxHighlightSupported()||t.setIsSyntaxHighlightSupported(!0),jt.has(r)||(jt.add(r),e.update(()=>{!function(t,e){const n=S(t);if(!X(n)||!n.isAttached())return;const r=v();if(!T(r))return void e();const i=r.anchor,o=i.offset,s=\"element\"===i.type&&y(n.getChildAtIndex(i.offset-1));let u=0;if(!s){const t=i.getNode();u=o+t.getPreviousSiblings().reduce((t,e)=>t+e.getTextContentSize(),0)}if(!e())return;if(s)return void i.getNode().select(o,o);n.getChildren().some(t=>{const e=l(t);if(e||y(t)){const n=t.getTextContentSize();if(e&&n>=u)return t.select(u,u),!0;u-=n}return!1})}(r,()=>{const e=S(r);if(!X(e)||!e.isAttached())return!1;const i=e.getLanguage()||n.defaultLanguage,o=n.$tokenize(e,i),s=function(t,e){let n=0;for(;n<t.length&&kt(t[n],e[n]);)n++;const r=t.length,i=e.length,o=Math.min(r,i)-n;let s=0;for(;s<o;)if(s++,!kt(t[r-s],e[i-s])){s--;break}const l=n,u=r-s,c=e.slice(n,i-s);return{from:l,nodesForReplacement:c,to:u}}(e.getChildren(),o),{from:l,to:u,nodesForReplacement:c}=s;return!(l===u&&!c.length)&&(t.splice(l,u-l,c),!0)})},{onUpdate:()=>{jt.delete(r)},skipTransforms:!0}))}function kt(t,e){return it(t)&&it(e)&&t.__text===e.__text&&t.__highlightType===e.__highlightType||u(t)&&u(e)||y(t)&&y(e)}function At(t){if(!T(t))return!1;const e=t.anchor.getNode(),n=X(e)?e:e.getParent(),r=t.focus.getNode(),i=X(r)?r:r.getParent();return X(n)&&n.is(i)}function Pt(t){const e=t.getNodes(),n=[];if(1===e.length&&X(e[0]))return n;let r=[];for(let t=0;t<e.length;t++){const i=e[t];it(i)||u(i)||y(i)||I(169),y(i)?r.length>0&&(n.push(r),r=[]):r.push(i)}if(r.length>0){const e=t.isBackward()?t.anchor:t.focus,i=b(r[0].getKey(),0,\"text\");e.is(i)||n.push(r)}return n}function Lt(t){const e=v();if(!T(e)||!At(e))return!1;const n=Pt(e),r=n.length;if(0===r&&e.isCollapsed())return t===C&&e.insertNodes([c()]),!0;if(0===r&&t===C&&\"\\n\"===e.getTextContent()){const t=c(),n=g(),r=e.isBackward()?\"previous\":\"next\";return e.insertNodes([t,n]),w(k(A(P(t,\"next\",0),L(h(n,\"next\"))),r)),!0}for(let i=0;i<r;i++){const r=n[i];if(r.length>0){let n=r[0];if(0===i&&(n=st(n)),t===C){const t=c();if(n.insertBefore(t),0===i){const r=e.isBackward()?\"focus\":\"anchor\",i=b(n.getKey(),0,\"text\");e[r].is(i)&&e[r].set(t.getKey(),0,\"text\")}}else u(n)&&n.remove()}}return!0}function Ot(t,e){const n=v();if(!T(n))return!1;const{anchor:r,focus:i}=n,o=r.offset,s=i.offset,l=r.getNode(),c=i.getNode(),g=t===O;if(!At(n)||!it(l)&&!u(l)||!it(c)&&!u(c))return!1;if(!e.altKey){if(n.isCollapsed()){const t=l.getParentOrThrow();if(g&&0===o&&null===l.getPreviousSibling()){if(null===t.getPreviousSibling())return t.selectPrevious(),e.preventDefault(),!0}else if(!g&&o===l.getTextContentSize()&&null===l.getNextSibling()){if(null===t.getNextSibling())return t.selectNext(),e.preventDefault(),!0}}return!1}let a,f;if(l.isBefore(c)?(a=st(l),f=lt(c)):(a=st(c),f=lt(l)),null==a||null==f)return!1;const p=a.getNodesBetween(f);for(let t=0;t<p.length;t++){const e=p[t];if(!it(e)&&!u(e)&&!y(e))return!1}e.preventDefault(),e.stopPropagation();const h=g?a.getPreviousSibling():f.getNextSibling();if(!y(h))return!0;const d=g?h.getPreviousSibling():h.getNextSibling();if(null==d)return!0;const m=it(d)||u(d)||y(d)?g?st(d):lt(d):null;let x=null!=m?m:d;return h.remove(),p.forEach(t=>t.remove()),t===O?(p.forEach(t=>x.insertBefore(t)),x.insertBefore(h)):(x.insertAfter(h),x=h,p.forEach(t=>{x.insertAfter(t),x=t})),n.setTextNodeRange(l,o,c,s),!0}function Ht(t,e){const n=v();if(!T(n))return!1;const{anchor:r,focus:i}=n,o=r.getNode(),s=i.getNode(),l=t===H;if(!At(n)||!it(o)&&!u(o)||!it(s)&&!u(s))return!1;const c=s;if(\"rtl\"===ut(c)?!l:l){const t=ct(c,i.offset);if(null!==t){const{node:e,offset:r}=t;y(e)?e.selectNext(0,0):n.setTextNodeRange(e,r,e,r)}else c.getParentOrThrow().selectStart()}else{gt(c).select()}return e.preventDefault(),e.stopPropagation(),!0}function Et(t,e){if(!t.hasNodes([q,et]))throw new Error(\"CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor\");null==e&&(e=bt);const n=[];return!0!==t._headless&&n.push(t.registerMutationListener(q,e=>{t.getEditorState().read(()=>{for(const[n,r]of e)if(\"destroyed\"!==r){const e=S(n);null!==e&&Nt(e,t)}})},{skipInitialization:!1})),n.push(t.registerNodeTransform(q,n=>wt(n,t,e)),t.registerNodeTransform(f,n=>Ct(n,t,e)),t.registerNodeTransform(et,n=>Ct(n,t,e)),t.registerCommand(E,e=>{const n=function(t){const e=v();if(!T(e)||!At(e))return null;const n=t?N:C,r=t?N:j,i=e.anchor,o=e.focus;if(i.is(o))return r;const s=Pt(e);if(1!==s.length)return n;const l=s[0];let u,c;0===l.length&&I(285),e.isBackward()?(u=o,c=i):(u=i,c=o);const g=st(l[0]),a=lt(l[0]),f=b(g.getKey(),0,\"text\"),p=b(a.getKey(),a.getTextContentSize(),\"text\");return u.isBefore(f)||p.isBefore(c)?n:f.isBefore(u)||c.isBefore(p)?r:n}(e.shiftKey);return null!==n&&(e.preventDefault(),t.dispatchCommand(n,void 0),!0)},z),t.registerCommand(j,()=>!!At(v())&&(B([c()]),!0),z),t.registerCommand(C,t=>Lt(C),z),t.registerCommand(N,t=>Lt(N),z),t.registerCommand(O,t=>{const e=v();if(!T(e))return!1;const{anchor:n}=e,r=n.getNode();return!!At(e)&&(e.isCollapsed()&&0===n.offset&&null===r.getPreviousSibling()&&X(r.getParentOrThrow())?(t.preventDefault(),!0):Ot(O,t))},z),t.registerCommand(D,t=>{const e=v();if(!T(e))return!1;const{anchor:n}=e,r=n.getNode();return!!At(e)&&(e.isCollapsed()&&n.offset===r.getTextContentSize()&&null===r.getNextSibling()&&X(r.getParentOrThrow())?(t.preventDefault(),!0):Ot(D,t))},z),t.registerCommand(H,t=>Ht(H,t),z),t.registerCommand(F,t=>Ht(F,t),z)),i(...n)}const zt=st,Bt=lt,Dt=gt,Ft=ct;export{rt as $createCodeHighlightNode,U as $createCodeNode,ut as $getCodeLineDirection,gt as $getEndOfCodeInLine,st as $getFirstCodeNodeOfLine,lt as $getLastCodeNodeOfLine,ct as $getStartOfCodeInLine,it as $isCodeHighlightNode,X as $isCodeNode,pt as CODE_LANGUAGE_FRIENDLY_NAME_MAP,ht as CODE_LANGUAGE_MAP,at as CodeExtension,et as CodeHighlightNode,q as CodeNode,M as DEFAULT_CODE_LANGUAGE,bt as PrismTokenizer,xt as getCodeLanguageOptions,yt as getCodeLanguages,_t as getCodeThemeOptions,J as getDefaultCodeLanguage,Dt as getEndOfCodeInLine,zt as getFirstCodeNodeOfLine,mt as getLanguageFriendlyName,Bt as getLastCodeNodeOfLine,Ft as getStartOfCodeInLine,dt as normalizeCodeLang,dt as normalizeCodeLanguage,Et as registerCodeHighlighting};\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalCode.dev.mjs';\nimport * as modProd from './LexicalCode.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $createCodeHighlightNode = mod.$createCodeHighlightNode;\nexport const $createCodeNode = mod.$createCodeNode;\nexport const $getCodeLineDirection = mod.$getCodeLineDirection;\nexport const $getEndOfCodeInLine = mod.$getEndOfCodeInLine;\nexport const $getFirstCodeNodeOfLine = mod.$getFirstCodeNodeOfLine;\nexport const $getLastCodeNodeOfLine = mod.$getLastCodeNodeOfLine;\nexport const $getStartOfCodeInLine = mod.$getStartOfCodeInLine;\nexport const $isCodeHighlightNode = mod.$isCodeHighlightNode;\nexport const $isCodeNode = mod.$isCodeNode;\nexport const CODE_LANGUAGE_FRIENDLY_NAME_MAP = mod.CODE_LANGUAGE_FRIENDLY_NAME_MAP;\nexport const CODE_LANGUAGE_MAP = mod.CODE_LANGUAGE_MAP;\nexport const CodeExtension = mod.CodeExtension;\nexport const CodeHighlightNode = mod.CodeHighlightNode;\nexport const CodeNode = mod.CodeNode;\nexport const DEFAULT_CODE_LANGUAGE = mod.DEFAULT_CODE_LANGUAGE;\nexport const PrismTokenizer = mod.PrismTokenizer;\nexport const getCodeLanguageOptions = mod.getCodeLanguageOptions;\nexport const getCodeLanguages = mod.getCodeLanguages;\nexport const getCodeThemeOptions = mod.getCodeThemeOptions;\nexport const getDefaultCodeLanguage = mod.getDefaultCodeLanguage;\nexport const getEndOfCodeInLine = mod.getEndOfCodeInLine;\nexport const getFirstCodeNodeOfLine = mod.getFirstCodeNodeOfLine;\nexport const getLanguageFriendlyName = mod.getLanguageFriendlyName;\nexport const getLastCodeNodeOfLine = mod.getLastCodeNodeOfLine;\nexport const getStartOfCodeInLine = mod.getStartOfCodeInLine;\nexport const normalizeCodeLang = mod.normalizeCodeLang;\nexport const normalizeCodeLanguage = mod.normalizeCodeLanguage;\nexport const registerCodeHighlighting = mod.registerCodeHighlighting;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement, $findMatchingParent, mergeRegister, objectKlassEquals } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection, $isNodeSelection, $normalizeSelection__EXPERIMENTAL, $setSelection, defineExtension, shallowMergeConfig, COMMAND_PRIORITY_LOW, PASTE_COMMAND, safeCast, isDOMNode, getNearestEditorFromDOMNode, $getNearestNodeFromDOMNode, TextNode, $isTextNode, $isLineBreakNode, $createTextNode } from 'lexical';\nimport { namedSignals, effect } from '@lexical/extension';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n  __url;\n  /** @internal */\n  __target;\n  /** @internal */\n  __rel;\n  /** @internal */\n  __title;\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    this.updateLinkDOM(null, element, config);\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateLinkDOM(prevNode, anchor, config) {\n    if (isHTMLAnchorElement(anchor)) {\n      if (!prevNode || prevNode.__url !== this.__url) {\n        anchor.href = this.sanitizeUrl(this.__url);\n      }\n      for (const attr of ['target', 'rel', 'title']) {\n        const key = `__${attr}`;\n        const value = this[key];\n        if (!prevNode || prevNode[key] !== value) {\n          if (value) {\n            anchor[attr] = value;\n          } else {\n            anchor.removeAttribute(attr);\n          }\n        }\n      }\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    this.updateLinkDOM(prevNode, anchor, config);\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    url = formatUrl(url);\n    try {\n      const parsedUrl = new URL(formatUrl(url));\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n  __isUnlinked;\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!$isElementNode(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = $getSelection();\n  if (!$isRangeSelection(initialSelection)) {\n    return $fn();\n  }\n  const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = $getSelection();\n    if ($isRangeSelection(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      $setSelection($normalizeSelection__EXPERIMENTAL(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Splits a LinkNode by removing selected children from it.\n * Handles three cases: selection at start, end, or middle of the link.\n * @param parentLink - The LinkNode to split\n * @param extractedNodes - The nodes that were extracted from the selection\n */\nfunction $splitLinkAtSelection(parentLink, extractedNodes) {\n  const extractedKeys = new Set(extractedNodes.filter(n => parentLink.isParentOf(n)).map(n => n.getKey()));\n  const allChildren = parentLink.getChildren();\n  const extractedChildren = allChildren.filter(child => extractedKeys.has(child.getKey()));\n  if (extractedChildren.length === allChildren.length) {\n    allChildren.forEach(child => parentLink.insertBefore(child));\n    parentLink.remove();\n    return;\n  }\n  const firstExtractedIndex = allChildren.findIndex(child => extractedKeys.has(child.getKey()));\n  const lastExtractedIndex = allChildren.findLastIndex(child => extractedKeys.has(child.getKey()));\n  const isAtStart = firstExtractedIndex === 0;\n  const isAtEnd = lastExtractedIndex === allChildren.length - 1;\n  if (isAtStart) {\n    extractedChildren.forEach(child => parentLink.insertBefore(child));\n  } else if (isAtEnd) {\n    for (let i = extractedChildren.length - 1; i >= 0; i--) {\n      parentLink.insertAfter(extractedChildren[i]);\n    }\n  } else {\n    for (let i = extractedChildren.length - 1; i >= 0; i--) {\n      parentLink.insertAfter(extractedChildren[i]);\n    }\n    const trailingChildren = allChildren.slice(lastExtractedIndex + 1);\n    if (trailingChildren.length > 0) {\n      const newLink = $createLinkNode(parentLink.getURL(), {\n        rel: parentLink.getRel(),\n        target: parentLink.getTarget(),\n        title: parentLink.getTitle()\n      });\n      extractedChildren[extractedChildren.length - 1].insertAfter(newLink);\n      trailingChildren.forEach(child => newLink.append(child));\n    }\n  }\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param urlOrAttributes - The URL the link directs to, or an attributes object with an url property\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(urlOrAttributes, attributes = {}) {\n  let url;\n  if (urlOrAttributes && typeof urlOrAttributes === 'object') {\n    const {\n      url: urlProp,\n      ...rest\n    } = urlOrAttributes;\n    url = urlProp;\n    attributes = {\n      ...rest,\n      ...attributes\n    };\n  } else {\n    url = urlOrAttributes;\n  }\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (selection === null || !$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n    return;\n  }\n  if ($isNodeSelection(selection)) {\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return;\n    }\n\n    // Handle all selected nodes\n    nodes.forEach(node => {\n      if (url === null) {\n        // Remove link\n        const linkParent = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (linkParent) {\n          linkParent.insertBefore(node);\n          if (linkParent.getChildren().length === 0) {\n            linkParent.remove();\n          }\n        }\n      } else {\n        // Add/Update link\n        const existingLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (existingLink) {\n          existingLink.setURL(url);\n          if (target !== undefined) {\n            existingLink.setTarget(target);\n          }\n          if (rel !== undefined) {\n            existingLink.setRel(rel);\n          }\n        } else {\n          const linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          node.insertBefore(linkNode);\n          linkNode.append(node);\n        }\n      }\n    });\n    return;\n  }\n\n  // Handle RangeSelection\n  const nodes = selection.extract();\n  if (url === null) {\n    const processedLinks = new Set();\n    nodes.forEach(node => {\n      const parentLink = node.getParent();\n      if ($isLinkNode(parentLink) && !$isAutoLinkNode(parentLink)) {\n        const linkKey = parentLink.getKey();\n        if (processedLinks.has(linkKey)) {\n          return;\n        }\n        $splitLinkAtSelection(parentLink, nodes);\n        processedLinks.add(linkKey);\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $findMatchingParent(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $findMatchingParent(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ($isElementNode(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\nconst PHONE_NUMBER_REGEX = /^\\+?[0-9\\s()-]{5,}$/;\n\n/**\n * Formats a URL string by adding appropriate protocol if missing\n *\n * @param url - URL to format\n * @returns Formatted URL with appropriate protocol\n */\nfunction formatUrl(url) {\n  // Check if URL already has a protocol\n  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {\n    // URL already has a protocol, leave it as is\n    return url;\n  }\n  // Check if it's a relative path (starting with '/', '.', or '#')\n  else if (url.match(/^[/#.]/)) {\n    // Relative path, leave it as is\n    return url;\n  }\n\n  // Check for email address\n  else if (url.includes('@')) {\n    return `mailto:${url}`;\n  }\n\n  // Check for phone number\n  else if (PHONE_NUMBER_REGEX.test(url)) {\n    return `tel:${url}`;\n  }\n\n  // For everything else, return with https:// prefix\n  return `https://${url}`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst defaultProps = {\n  attributes: undefined,\n  validateUrl: undefined\n};\n\n/** @internal */\nfunction registerLink(editor, stores) {\n  return mergeRegister(effect(() => editor.registerCommand(TOGGLE_LINK_COMMAND, payload => {\n    const validateUrl = stores.validateUrl.peek();\n    const attributes = stores.attributes.peek();\n    if (payload === null) {\n      $toggleLink(null);\n      return true;\n    } else if (typeof payload === 'string') {\n      if (validateUrl === undefined || validateUrl(payload)) {\n        $toggleLink(payload, attributes);\n        return true;\n      }\n      return false;\n    } else {\n      const {\n        url,\n        target,\n        rel,\n        title\n      } = payload;\n      $toggleLink(url, {\n        ...attributes,\n        rel,\n        target,\n        title\n      });\n      return true;\n    }\n  }, COMMAND_PRIORITY_LOW)), effect(() => {\n    const validateUrl = stores.validateUrl.value;\n    if (!validateUrl) {\n      return;\n    }\n    const attributes = stores.attributes.value;\n    return editor.registerCommand(PASTE_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || selection.isCollapsed() || !objectKlassEquals(event, ClipboardEvent)) {\n        return false;\n      }\n      if (event.clipboardData === null) {\n        return false;\n      }\n      const clipboardText = event.clipboardData.getData('text');\n      if (!validateUrl(clipboardText)) {\n        return false;\n      }\n      // If we select nodes that are elements then avoid applying the link.\n      if (!selection.getNodes().some(node => $isElementNode(node))) {\n        editor.dispatchCommand(TOGGLE_LINK_COMMAND, {\n          ...attributes,\n          url: clipboardText\n        });\n        event.preventDefault();\n        return true;\n      }\n      return false;\n    }, COMMAND_PRIORITY_LOW);\n  }));\n}\n\n/**\n * Provides {@link LinkNode}, an implementation of\n * {@link TOGGLE_LINK_COMMAND}, and a {@link PASTE_COMMAND}\n * listener to wrap selected nodes in a link when a\n * URL is pasted and `validateUrl` is defined.\n */\nconst LinkExtension = defineExtension({\n  build(editor, config, state) {\n    return namedSignals(config);\n  },\n  config: defaultProps,\n  mergeConfig(config, overrides) {\n    const merged = shallowMergeConfig(config, overrides);\n    if (config.attributes) {\n      merged.attributes = shallowMergeConfig(config.attributes, merged.attributes);\n    }\n    return merged;\n  },\n  name: '@lexical/link/Link',\n  nodes: [LinkNode],\n  register(editor, config, state) {\n    return registerLink(editor, state.getOutput());\n  }\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findMatchingDOM(startNode, predicate) {\n  let node = startNode;\n  while (node != null) {\n    if (predicate(node)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\nfunction registerClickableLink(editor, stores, eventOptions = {}) {\n  const onClick = event => {\n    const target = event.target;\n    if (!isDOMNode(target)) {\n      return;\n    }\n    const nearestEditor = getNearestEditorFromDOMNode(target);\n    if (nearestEditor === null) {\n      return;\n    }\n    let url = null;\n    let urlTarget = null;\n    nearestEditor.update(() => {\n      const clickedNode = $getNearestNodeFromDOMNode(target);\n      if (clickedNode !== null) {\n        const maybeLinkNode = $findMatchingParent(clickedNode, $isElementNode);\n        if (!stores.disabled.peek()) {\n          if ($isLinkNode(maybeLinkNode)) {\n            url = maybeLinkNode.sanitizeUrl(maybeLinkNode.getURL());\n            urlTarget = maybeLinkNode.getTarget();\n          } else {\n            const a = findMatchingDOM(target, isHTMLAnchorElement);\n            if (a !== null) {\n              url = a.href;\n              urlTarget = a.target;\n            }\n          }\n        }\n      }\n    });\n    if (url === null || url === '') {\n      return;\n    }\n\n    // Allow user to select link text without following url\n    const selection = editor.getEditorState().read($getSelection);\n    if ($isRangeSelection(selection) && !selection.isCollapsed()) {\n      event.preventDefault();\n      return;\n    }\n    const isMiddle = event.type === 'auxclick' && event.button === 1;\n    window.open(url, stores.newTab.peek() || isMiddle || event.metaKey || event.ctrlKey || urlTarget === '_blank' ? '_blank' : '_self');\n    event.preventDefault();\n  };\n  const onMouseUp = event => {\n    if (event.button === 1) {\n      onClick(event);\n    }\n  };\n  return editor.registerRootListener((rootElement, prevRootElement) => {\n    if (prevRootElement !== null) {\n      prevRootElement.removeEventListener('click', onClick);\n      prevRootElement.removeEventListener('mouseup', onMouseUp);\n    }\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', onClick, eventOptions);\n      rootElement.addEventListener('mouseup', onMouseUp, eventOptions);\n    }\n  });\n}\n\n/**\n * Normally in a Lexical editor the `CLICK_COMMAND` on a LinkNode will cause the\n * selection to change instead of opening a link. This extension can be used to\n * restore the default behavior, e.g. when the editor is not editable.\n */\nconst ClickableLinkExtension = defineExtension({\n  build(editor, config, state) {\n    return namedSignals(config);\n  },\n  config: safeCast({\n    disabled: false,\n    newTab: false\n  }),\n  dependencies: [LinkExtension],\n  name: '@lexical/link/ClickableLink',\n  register(editor, config, state) {\n    return registerClickableLink(editor, state.getOutput());\n  }\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createLinkMatcherWithRegExp(regExp, urlTransformer = text => text) {\n  return text => {\n    const match = regExp.exec(text);\n    if (match === null) {\n      return null;\n    }\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0])\n    };\n  };\n}\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n    if (match) {\n      return match;\n    }\n  }\n  return null;\n}\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/;\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\n\n/**\n * Check if the text content starts with a fullstop followed by a top-level domain.\n * Meaning if the text content can be a beginning of a top level domain.\n * @param textContent\n * @param isEmail\n * @returns boolean\n */\nfunction startsWithTLD(textContent, isEmail) {\n  if (isEmail) {\n    return /^\\.[a-zA-Z]{2,}/.test(textContent);\n  } else {\n    return /^\\.[a-zA-Z0-9]{1,}/.test(textContent);\n  }\n}\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n  if ($isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n  return previousNode === null || $isLineBreakNode(previousNode) || $isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());\n}\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n  if ($isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n  return nextNode === null || $isLineBreakNode(nextNode) || $isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());\n}\nfunction isContentAroundIsValid(matchStart, matchEnd, text, nodes) {\n  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]);\n  if (!contentBeforeIsValid) {\n    return false;\n  }\n  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);\n  return contentAfterIsValid;\n}\nfunction extractMatchingNodes(nodes, startIndex, endIndex) {\n  const unmodifiedBeforeNodes = [];\n  const matchingNodes = [];\n  const unmodifiedAfterNodes = [];\n  let matchingOffset = 0;\n  let currentOffset = 0;\n  const currentNodes = [...nodes];\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0];\n    const currentNodeText = currentNode.getTextContent();\n    const currentNodeLength = currentNodeText.length;\n    const currentNodeStart = currentOffset;\n    const currentNodeEnd = currentOffset + currentNodeLength;\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode);\n      matchingOffset += currentNodeLength;\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode);\n    } else {\n      matchingNodes.push(currentNode);\n    }\n    currentOffset += currentNodeLength;\n    currentNodes.shift();\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];\n}\nfunction $createAutoLinkNode_(nodes, startIndex, endIndex, match) {\n  const linkNode = $createAutoLinkNode(match.url, match.attributes);\n  if (nodes.length === 1) {\n    let remainingTextNode = nodes[0];\n    let linkTextNode;\n    if (startIndex === 0) {\n      [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);\n    } else {\n      [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);\n    }\n    const textNode = $createTextNode(match.text);\n    textNode.setFormat(linkTextNode.getFormat());\n    textNode.setDetail(linkTextNode.getDetail());\n    textNode.setStyle(linkTextNode.getStyle());\n    linkNode.append(textNode);\n    linkTextNode.replace(linkNode);\n    return remainingTextNode;\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0];\n    let offset = firstTextNode.getTextContent().length;\n    let firstLinkTextNode;\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode;\n    } else {\n      [, firstLinkTextNode] = firstTextNode.splitText(startIndex);\n    }\n    const linkNodes = [];\n    let remainingTextNode;\n    for (let i = 1; i < nodes.length; i++) {\n      const currentNode = nodes[i];\n      const currentNodeText = currentNode.getTextContent();\n      const currentNodeLength = currentNodeText.length;\n      const currentNodeStart = offset;\n      const currentNodeEnd = offset + currentNodeLength;\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode);\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);\n          linkNodes.push(linkTextNode);\n          remainingTextNode = endNode;\n        }\n      }\n      offset += currentNodeLength;\n    }\n    const selection = $getSelection();\n    const selectedTextNode = selection ? selection.getNodes().find($isTextNode) : undefined;\n    const textNode = $createTextNode(firstLinkTextNode.getTextContent());\n    textNode.setFormat(firstLinkTextNode.getFormat());\n    textNode.setDetail(firstLinkTextNode.getDetail());\n    textNode.setStyle(firstLinkTextNode.getStyle());\n    linkNode.append(textNode, ...linkNodes);\n    // it does not preserve caret position if caret was at the first text node\n    // so we need to restore caret position\n    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n      if ($isRangeSelection(selection)) {\n        textNode.select(selection.anchor.offset, selection.focus.offset);\n      } else if ($isNodeSelection(selection)) {\n        textNode.select(0, textNode.getTextContent().length);\n      }\n    }\n    firstLinkTextNode.replace(linkNode);\n    return remainingTextNode;\n  }\n  return undefined;\n}\nfunction $handleLinkCreation(nodes, matchers, onChange) {\n  let currentNodes = [...nodes];\n  const initialText = currentNodes.map(node => node.getTextContent()).join('');\n  let text = initialText;\n  let match;\n  let invalidMatchEnd = 0;\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index;\n    const matchLength = match.length;\n    const matchEnd = matchStart + matchLength;\n    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, initialText, currentNodes);\n    if (isValid) {\n      const [matchingOffset,, matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;\n      const remainingTextNode = $createAutoLinkNode_(matchingNodes, actualMatchStart, actualMatchEnd, match);\n      currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;\n      onChange(match.url, null);\n      invalidMatchEnd = 0;\n    } else {\n      invalidMatchEnd += matchEnd;\n    }\n    text = text.substring(matchEnd);\n  }\n}\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n  const url = linkNode.getURL();\n  if (url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n  if (match.attributes) {\n    const rel = linkNode.getRel();\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null);\n      onChange(match.attributes.rel || null, rel);\n    }\n    const target = linkNode.getTarget();\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null);\n      onChange(match.attributes.target || null, target);\n    }\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(textNode, matchers, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n  if ($isAutoLinkNode(previousSibling) && !previousSibling.getIsUnlinked() && (!startsWithSeparator(text) || startsWithTLD(text, previousSibling.isEmailURI()))) {\n    previousSibling.append(textNode);\n    handleLinkEdit(previousSibling, matchers, onChange);\n    onChange(null, previousSibling.getURL());\n  }\n  if ($isAutoLinkNode(nextSibling) && !nextSibling.getIsUnlinked() && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling);\n    handleLinkEdit(nextSibling, matchers, onChange);\n    onChange(null, nextSibling.getURL());\n  }\n}\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n  node.remove();\n  return children.map(child => child.getLatest());\n}\nfunction getTextNodesToMatch(textNode) {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode];\n  let nextSibling = textNode.getNextSibling();\n  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling);\n    if (/[\\s]/.test(nextSibling.getTextContent())) {\n      break;\n    }\n    nextSibling = nextSibling.getNextSibling();\n  }\n  return textNodesToMatch;\n}\nconst defaultConfig = {\n  changeHandlers: [],\n  matchers: []\n};\nfunction registerAutoLink(editor, config = defaultConfig) {\n  const {\n    matchers,\n    changeHandlers\n  } = config;\n  const onChange = (url, prevUrl) => {\n    for (const handler of changeHandlers) {\n      handler(url, prevUrl);\n    }\n  };\n  return mergeRegister(editor.registerNodeTransform(TextNode, textNode => {\n    const parent = textNode.getParentOrThrow();\n    const previous = textNode.getPreviousSibling();\n    if ($isAutoLinkNode(parent) && !parent.getIsUnlinked()) {\n      handleLinkEdit(parent, matchers, onChange);\n    } else if (!$isLinkNode(parent)) {\n      if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))) {\n        const textNodesToMatch = getTextNodesToMatch(textNode);\n        $handleLinkCreation(textNodesToMatch, matchers, onChange);\n      }\n      handleBadNeighbors(textNode, matchers, onChange);\n    }\n  }), editor.registerCommand(TOGGLE_LINK_COMMAND, payload => {\n    const selection = $getSelection();\n    if (payload !== null || !$isRangeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.extract();\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if ($isAutoLinkNode(parent)) {\n        // invert the value\n        parent.setIsUnlinked(!parent.getIsUnlinked());\n        parent.markDirty();\n      }\n    });\n    return false;\n  }, COMMAND_PRIORITY_LOW));\n}\n\n/**\n * An extension to automatically create AutoLinkNode from text\n * that matches the configured matchers. No default implementation\n * is provided for any matcher, see {@link createLinkMatcherWithRegExp}\n * for a helper function to create a matcher from a RegExp, and the\n * Playground's [AutoLinkPlugin](https://github.com/facebook/lexical/blob/main/packages/lexical-playground/src/plugins/AutoLinkPlugin/index.tsx)\n * for some example RegExps that could be used.\n *\n * The given `matchers` and `changeHandlers` will be merged by\n * concatenating the configured arrays.\n */\nconst AutoLinkExtension = defineExtension({\n  config: defaultConfig,\n  dependencies: [LinkExtension],\n  mergeConfig(config, overrides) {\n    const merged = shallowMergeConfig(config, overrides);\n    for (const k of ['matchers', 'changeHandlers']) {\n      const v = overrides[k];\n      if (Array.isArray(v)) {\n        merged[k] = [...config[k], ...v];\n      }\n    }\n    return merged;\n  },\n  name: '@lexical/link/AutoLink',\n  register: registerAutoLink\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\n\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkExtension, AutoLinkNode, ClickableLinkExtension, LinkExtension, LinkNode, TOGGLE_LINK_COMMAND, createLinkMatcherWithRegExp, formatUrl, registerAutoLink, registerClickableLink, registerLink, toggleLink };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalLink.dev.mjs';\nimport * as modProd from './LexicalLink.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $createAutoLinkNode = mod.$createAutoLinkNode;\nexport const $createLinkNode = mod.$createLinkNode;\nexport const $isAutoLinkNode = mod.$isAutoLinkNode;\nexport const $isLinkNode = mod.$isLinkNode;\nexport const $toggleLink = mod.$toggleLink;\nexport const AutoLinkExtension = mod.AutoLinkExtension;\nexport const AutoLinkNode = mod.AutoLinkNode;\nexport const ClickableLinkExtension = mod.ClickableLinkExtension;\nexport const LinkExtension = mod.LinkExtension;\nexport const LinkNode = mod.LinkNode;\nexport const TOGGLE_LINK_COMMAND = mod.TOGGLE_LINK_COMMAND;\nexport const createLinkMatcherWithRegExp = mod.createLinkMatcherWithRegExp;\nexport const formatUrl = mod.formatUrl;\nexport const registerAutoLink = mod.registerAutoLink;\nexport const registerClickableLink = mod.registerClickableLink;\nexport const registerLink = mod.registerLink;\nexport const toggleLink = mod.toggleLink;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, $descendantsMatching, $findMatchingParent, removeClassNamesFromElement, objectKlassEquals, isHTMLElement as isHTMLElement$1, $insertFirst as $insertFirst$1, mergeRegister, $insertNodeToNearestRoot, $unwrapAndFilterDescendants } from '@lexical/utils';\nimport { ElementNode, isHTMLElement, $isInlineElementOrDecoratorNode, $isTextNode, $isLineBreakNode, $createParagraphNode, $applyNodeReplacement, createCommand, $createTextNode, $getSelection, $isRangeSelection, $isParagraphNode, $createPoint, $getNodeByKey, $isElementNode, $normalizeSelection__EXPERIMENTAL, isCurrentlyReadOnlyMode, TEXT_TYPE_TO_FORMAT, $getEditor, $setSelection, SELECTION_CHANGE_COMMAND, getDOMSelection, $createRangeSelection, $isRootNode, INSERT_PARAGRAPH_COMMAND, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, COMMAND_PRIORITY_HIGH, KEY_ESCAPE_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, CUT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $getNearestNodeFromDOMNode, $createRangeSelectionFromDom, isDOMNode, $isRootOrShadowRoot, $caretFromPoint, $isExtendableTextPointCaret, $extendCaretToRange, $isSiblingCaret, $getSiblingCaret, $setPointFromCaret, $normalizeCaret, $isChildCaret, $getChildCaret, $getAdjacentChildCaret, setDOMUnmanaged, COMMAND_PRIORITY_EDITOR, CLICK_COMMAND, defineExtension, safeCast } from 'lexical';\nimport { effect, namedSignals } from '@lexical/extension';\nimport { copyToClipboard, $getClipboardDataFromSelection } from '@lexical/clipboard';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n  __colSpan;\n  /** @internal */\n  __rowSpan;\n  /** @internal */\n  __headerState;\n  /** @internal */\n  __width;\n  /** @internal */\n  __backgroundColor;\n  /** @internal */\n  __verticalAlign;\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n    this.__verticalAlign = node.__verticalAlign;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableCellNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || undefined).setBackgroundColor(serializedNode.backgroundColor || null).setVerticalAlign(serializedNode.verticalAlign || undefined);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n    this.__verticalAlign = undefined;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    if (isValidVerticalAlign(this.__verticalAlign)) {\n      element.style.verticalAlign = this.__verticalAlign;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const output = super.exportDOM(editor);\n    if (isHTMLElement(output.element)) {\n      const element = output.element;\n      element.setAttribute('data-temporary-table-cell-lexical-key', this.getKey());\n      element.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element.rowSpan = this.__rowSpan;\n      }\n      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element.style.verticalAlign = this.getVerticalAlign() || 'top';\n      element.style.textAlign = 'start';\n      if (this.__backgroundColor === null && this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return output;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(isValidVerticalAlign(this.__verticalAlign) && {\n        verticalAlign: this.__verticalAlign\n      }),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  getVerticalAlign() {\n    return this.getLatest().__verticalAlign;\n  }\n  setVerticalAlign(newVerticalAlign) {\n    const self = this.getWritable();\n    self.__verticalAlign = newVerticalAlign || undefined;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor || prevNode.__verticalAlign !== this.__verticalAlign;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction isValidVerticalAlign(verticalAlign) {\n  return verticalAlign === 'middle' || verticalAlign === 'bottom';\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const verticalAlign = domNode_.style.verticalAlign;\n  if (isValidVerticalAlign(verticalAlign)) {\n    tableCellNode.__verticalAlign = verticalAlign;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      const result = [];\n      let paragraphNode = null;\n      const removeSingleLineBreakNode = () => {\n        if (paragraphNode) {\n          const firstChild = paragraphNode.getFirstChild();\n          if ($isLineBreakNode(firstChild) && paragraphNode.getChildrenSize() === 1) {\n            firstChild.remove();\n          }\n        }\n      };\n      for (const child of childLexicalNodes) {\n        if ($isInlineElementOrDecoratorNode(child) || $isTextNode(child) || $isLineBreakNode(child)) {\n          if ($isTextNode(child)) {\n            if (hasBoldFontWeight) {\n              child.toggleFormat('bold');\n            }\n            if (hasLinethroughTextDecoration) {\n              child.toggleFormat('strikethrough');\n            }\n            if (hasItalicFontStyle) {\n              child.toggleFormat('italic');\n            }\n            if (hasUnderlineTextDecoration) {\n              child.toggleFormat('underline');\n            }\n          }\n          if (paragraphNode) {\n            paragraphNode.append(child);\n          } else {\n            paragraphNode = $createParagraphNode().append(child);\n            result.push(paragraphNode);\n          }\n        } else {\n          result.push(child);\n          removeSingleLineBreakNode();\n          paragraphNode = null;\n        }\n      }\n      removeSingleLineBreakNode();\n      if (result.length === 0) {\n        result.push($createParagraphNode());\n      }\n      return result;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n  __height;\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    const height = this.getHeight();\n    return {\n      ...super.exportJSON(),\n      ...(height === undefined ? undefined : {\n        height\n      })\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return self;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableCellNode),\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableRowAtSelection} or {@link $insertTableRowAtNode} instead.\n */\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtSelection(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableRowAtNode(anchorStartRow + anchorCell.__rowSpan > focusStartRow + focusCell.__rowSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableRowAtNode(focusStartRow < anchorStartRow ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableRowAtSelection}\n */\nconst $insertTableRow__EXPERIMENTAL = $insertTableRowAtSelection;\n\n/**\n * Inserts a table row before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtNode(cellNode, insertAfter = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: cellStartRow\n  } = cellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const insertAfterEndRow = cellStartRow + cellNode.__rowSpan - 1;\n    const insertAfterEndRowMap = gridMap[insertAfterEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertAfterEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {\n        const currentCell = insertAfterEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);\n    if (!$isTableRowNode(insertAfterEndRowNode)) {\n      formatDevErrorMessage(`insertAfterEndRow is not a TableRowNode`);\n    }\n    insertAfterEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const insertBeforeStartRow = cellStartRow;\n    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertBeforeStartRowMap[i];\n      if (startRow === insertBeforeStartRow) {\n        const currentCell = insertBeforeStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);\n    if (!$isTableRowNode(insertBeforeStartRowNode)) {\n      formatDevErrorMessage(`insertBeforeStartRow is not a TableRowNode`);\n    }\n    insertBeforeStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableColumnAtSelection} or {@link $insertTableColumnAtNode} instead.\n */\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtSelection(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableColumnAtNode(anchorStartColumn + anchorCell.__colSpan > focusStartColumn + focusCell.__colSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableColumnAtNode(focusStartColumn < anchorStartColumn ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableColumnAtSelection}\n */\nconst $insertTableColumn__EXPERIMENTAL = $insertTableColumnAtSelection;\n\n/**\n * Inserts a column before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtNode(cellNode, insertAfter = true, shouldSetSelection = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const rowCount = gridMap.length;\n  const {\n    startColumn\n  } = cellMap;\n  const insertAfterColumn = insertAfter ? startColumn + cellNode.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    formatDevErrorMessage(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        formatDevErrorMessage(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null && shouldSetSelection) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $deleteTableColumnAtSelection} instead.\n */\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRowAtSelection() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top or bottom have to be trimmed\n      if (cellStartRow < anchorStartRow || cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        const intersectionStart = Math.max(cellStartRow, anchorStartRow);\n        const intersectionEnd = Math.min(cell.__rowSpan + cellStartRow - 1, focusEndRow);\n        const overflowRowsCount = intersectionStart <= intersectionEnd ? intersectionEnd - intersectionStart + 1 : 0;\n        cell.setRowSpan(cell.__rowSpan - overflowRowsCount);\n      }\n      // Rows overflowing bottom have to be moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow &&\n      // Handle overflow only once\n      row === focusEndRow) {\n        if (!(nextRowNode !== null)) {\n          formatDevErrorMessage(`Expected nextRowNode not to be null`);\n        }\n        let insertAfterCell = null;\n        for (let columnIndex = 0; columnIndex < column; columnIndex++) {\n          const currentCellMap = nextRow[columnIndex];\n          const currentCell = currentCellMap.cell;\n          // Checking the cell having startRow as same as nextRow\n          if (currentCellMap.startRow === row + 1) {\n            insertAfterCell = currentCell;\n          }\n          if (currentCell.__colSpan > 1) {\n            columnIndex += currentCell.__colSpan - 1;\n          }\n        }\n        if (insertAfterCell === null) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          insertAfterCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableRowAtSelection}\n */\nconst $deleteTableRow__EXPERIMENTAL = $deleteTableRowAtSelection;\nfunction $deleteTableColumnAtSelection() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableColumnAtSelection}\n */\nconst $deleteTableColumn__EXPERIMENTAL = $deleteTableColumnAtSelection;\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $mergeCells(cellNodes) {\n  if (cellNodes.length === 0) {\n    return null;\n  }\n\n  // Find the table node\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(cellNodes[0]);\n  const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null);\n\n  // Find the boundaries of the selection including merged cells\n  let minRow = Infinity;\n  let maxRow = -Infinity;\n  let minCol = Infinity;\n  let maxCol = -Infinity;\n\n  // First pass: find the actual boundaries considering merged cells\n  const processedCells = new Set();\n  for (const row of gridMap) {\n    for (const mapCell of row) {\n      if (!mapCell || !mapCell.cell) {\n        continue;\n      }\n      const cellKey = mapCell.cell.getKey();\n      if (processedCells.has(cellKey)) {\n        continue;\n      }\n      if (cellNodes.some(cell => cell.is(mapCell.cell))) {\n        processedCells.add(cellKey);\n        // Get the actual position of this cell in the grid\n        const cellStartRow = mapCell.startRow;\n        const cellStartCol = mapCell.startColumn;\n        const cellRowSpan = mapCell.cell.__rowSpan || 1;\n        const cellColSpan = mapCell.cell.__colSpan || 1;\n\n        // Update boundaries considering the cell's actual position and span\n        minRow = Math.min(minRow, cellStartRow);\n        maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1);\n        minCol = Math.min(minCol, cellStartCol);\n        maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1);\n      }\n    }\n  }\n\n  // Validate boundaries\n  if (minRow === Infinity || minCol === Infinity) {\n    return null;\n  }\n\n  // The total span of the merged cell\n  const totalRowSpan = maxRow - minRow + 1;\n  const totalColSpan = maxCol - minCol + 1;\n\n  // Use the top-left cell as the target cell\n  const targetCellMap = gridMap[minRow][minCol];\n  if (!targetCellMap.cell) {\n    return null;\n  }\n  const targetCell = targetCellMap.cell;\n\n  // Set the spans for the target cell\n  targetCell.setColSpan(totalColSpan);\n  targetCell.setRowSpan(totalRowSpan);\n\n  // Move content from other cells to the target cell\n  const seenCells = new Set([targetCell.getKey()]);\n\n  // Second pass: merge content and remove other cells\n  for (let row = minRow; row <= maxRow; row++) {\n    for (let col = minCol; col <= maxCol; col++) {\n      const mapCell = gridMap[row][col];\n      if (!mapCell.cell) {\n        continue;\n      }\n      const currentCell = mapCell.cell;\n      const key = currentCell.getKey();\n      if (!seenCells.has(key)) {\n        seenCells.add(key);\n        const isEmpty = $cellContainsEmptyParagraph(currentCell);\n        if (!isEmpty) {\n          targetCell.append(...currentCell.getChildren());\n        }\n        currentCell.remove();\n      }\n    }\n  }\n\n  // Ensure target cell has content\n  if (targetCell.getChildrenSize() === 0) {\n    targetCell.append($createParagraphNode());\n  }\n  return targetCell;\n}\nfunction $cellContainsEmptyParagraph(cell) {\n  if (cell.getChildrenSize() !== 1) {\n    return false;\n  }\n  const firstChild = cell.getFirstChildOrThrow();\n  if (!$isParagraphNode(firstChild) || !firstChild.isEmpty()) {\n    return false;\n  }\n  return true;\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const cellNode = $findMatchingParent(anchor, $isTableCellNode);\n  if (!$isTableCellNode(cellNode)) {\n    formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n  }\n  return $unmergeCellNode(cellNode);\n}\nfunction $unmergeCellNode(cellNode) {\n  const [cell, row, grid] = $getNodeTriplet(cellNode);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append($createParagraphNode()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        formatDevErrorMessage(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(tableNode, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    formatDevErrorMessage(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    formatDevErrorMessage(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = tableNode.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      formatDevErrorMessage(`Expected TableNode children to be TableRowNode`);\n    }\n    const startMapRow = getMapRow(rowIdx);\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        formatDevErrorMessage(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    formatDevErrorMessage(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    formatDevErrorMessage(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $computeTableCellRectSpans(map, boundary) {\n  const {\n    minColumn,\n    maxColumn,\n    minRow,\n    maxRow\n  } = boundary;\n  let topSpan = 1;\n  let leftSpan = 1;\n  let rightSpan = 1;\n  let bottomSpan = 1;\n  const topRow = map[minRow];\n  const bottomRow = map[maxRow];\n  for (let col = minColumn; col <= maxColumn; col++) {\n    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);\n    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);\n  }\n  for (let row = minRow; row <= maxRow; row++) {\n    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);\n    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);\n  }\n  return {\n    bottomSpan,\n    leftSpan,\n    rightSpan,\n    topSpan\n  };\n}\nfunction $computeTableCellRectBoundary(map, cellAMap, cellBMap) {\n  // Initial boundaries based on the anchor and focus cells\n  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n\n  // Keep expanding until we have a complete rectangle\n  let hasChanges;\n  do {\n    hasChanges = false;\n\n    // Check all cells in the table\n    for (let row = 0; row < map.length; row++) {\n      for (let col = 0; col < map[0].length; col++) {\n        const cell = map[row][col];\n        if (!cell) {\n          continue;\n        }\n        const cellEndCol = cell.startColumn + cell.cell.__colSpan - 1;\n        const cellEndRow = cell.startRow + cell.cell.__rowSpan - 1;\n\n        // Check if this cell intersects with our current selection rectangle\n        const intersectsHorizontally = cell.startColumn <= maxColumn && cellEndCol >= minColumn;\n        const intersectsVertically = cell.startRow <= maxRow && cellEndRow >= minRow;\n\n        // If the cell intersects either horizontally or vertically\n        if (intersectsHorizontally && intersectsVertically) {\n          // Expand boundaries to include this cell completely\n          const newMinColumn = Math.min(minColumn, cell.startColumn);\n          const newMaxColumn = Math.max(maxColumn, cellEndCol);\n          const newMinRow = Math.min(minRow, cell.startRow);\n          const newMaxRow = Math.max(maxRow, cellEndRow);\n\n          // Check if boundaries changed\n          if (newMinColumn !== minColumn || newMaxColumn !== maxColumn || newMinRow !== minRow || newMaxRow !== maxRow) {\n            minColumn = newMinColumn;\n            maxColumn = newMaxColumn;\n            minRow = newMinRow;\n            maxRow = newMaxRow;\n            hasChanges = true;\n          }\n        }\n      }\n    }\n  } while (hasChanges);\n  return {\n    maxColumn,\n    maxRow,\n    minColumn,\n    minRow\n  };\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\nfunction $getCellNodes(tableSelection) {\n  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ['anchor', 'focus'].map(k => {\n    const node = tableSelection[k].getNode();\n    const cellNode = $findMatchingParent(node, $isTableCellNode);\n    if (!$isTableCellNode(cellNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);\n    }\n    const rowNode = cellNode.getParent();\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} cell parent to be a TableRowNode`);\n    }\n    const tableNode = rowNode.getParent();\n    if (!$isTableNode(tableNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} row parent to be a TableNode`);\n    }\n    return [node, cellNode, rowNode, tableNode];\n  });\n  // TODO: nested tables may violate this\n  if (!anchorTable.is(focusTable)) {\n    formatDevErrorMessage(`Expected TableSelection anchor and focus to be in the same table`);\n  }\n  return {\n    anchorCell,\n    anchorNode,\n    anchorRow,\n    anchorTable,\n    focusCell,\n    focusNode,\n    focusRow,\n    focusTable\n  };\n}\nclass TableSelection {\n  tableKey;\n  anchor;\n  focus;\n  _cachedNodes;\n  dirty;\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * {@link $createTableSelection} unfortunately makes it very easy to create\n   * nonsense selections, so we have a method to see if the selection probably\n   * makes sense.\n   *\n   * @returns true if the TableSelection is (probably) valid\n   */\n  isValid() {\n    if (this.tableKey === 'root' || this.anchor.key === 'root' || this.anchor.type !== 'element' || this.focus.key === 'root' || this.focus.type !== 'element') {\n      return false;\n    }\n\n    // Check if the referenced nodes still exist in the editor\n    const tableNode = $getNodeByKey(this.tableKey);\n    const anchorNode = $getNodeByKey(this.anchor.key);\n    const focusNode = $getNodeByKey(this.focus.key);\n    return tableNode !== null && anchorNode !== null && focusNode !== null;\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    // note: closure compiler's acorn does not support ||=\n    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, $createPoint(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint(this.focus.key, this.focus.offset, this.focus.type));\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ($isParagraphNode(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      formatDevErrorMessage(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const {\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);\n    if (!(anchorCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCell);\n    if (!(focusCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    if (!this.isValid()) {\n      return [];\n    }\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const {\n      anchorTable: tableNode,\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          formatDevErrorMessage(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          formatDevErrorMessage(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    const {\n      minColumn,\n      maxColumn,\n      minRow,\n      maxRow\n    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          formatDevErrorMessage(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n          lastRow = currentRow;\n        }\n        if (!nodeMap.has(cell.getKey())) {\n          $visitRecursively(cell, childNode => {\n            nodeMap.set(childNode.getKey(), childNode);\n          });\n        }\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  // TODO this is a suboptimal design, it doesn't make sense to have\n  // a table selection that isn't associated with a table. This\n  // constructor should have required arguments and in true we\n  // should check that they point to a table and are element points to\n  // cell nodes of that table.\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $createTableSelectionFrom(tableNode, anchorCell, focusCell) {\n  const tableNodeKey = tableNode.getKey();\n  const anchorCellKey = anchorCell.getKey();\n  const focusCellKey = focusCell.getKey();\n  {\n    if (!tableNode.isAttached()) {\n      formatDevErrorMessage(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);\n    }\n    if (!tableNode.is($findTableNode(anchorCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);\n    }\n    if (!tableNode.is($findTableNode(focusCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);\n    } // TODO: Check for rectangular grid\n  }\n  const prevSelection = $getSelection();\n  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();\n  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());\n  return nextSelection;\n}\n\n/**\n * Depth first visitor\n * @param node The starting node\n * @param $visit The function to call for each node. If the function returns false, then children of this node will not be explored\n */\nfunction $visitRecursively(node, $visit) {\n  const stack = [[node]];\n  for (let currentArray = stack.at(-1); currentArray !== undefined && stack.length > 0; currentArray = stack.at(-1)) {\n    const currentNode = currentArray.pop();\n    if (currentNode === undefined) {\n      stack.pop();\n    } else if ($visit(currentNode) !== false && $isElementNode(currentNode)) {\n      stack.push(currentNode.getChildren());\n    }\n  }\n}\n\nfunction $getTableAndElementByKey(tableNodeKey, editor = $getEditor()) {\n  const tableNode = $getNodeByKey(tableNodeKey);\n  if (!$isTableNode(tableNode)) {\n    formatDevErrorMessage(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);\n  }\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);\n  }\n  return {\n    tableElement,\n    tableNode\n  };\n}\nclass TableObserver {\n  focusX;\n  focusY;\n  listenersToRemove;\n  table;\n  isHighlightingCells;\n  anchorX;\n  anchorY;\n  tableNodeKey;\n  anchorCell;\n  focusCell;\n  anchorCellNodeKey;\n  focusCellNodeKey;\n  editor;\n  tableSelection;\n  hasHijackedSelectionStyles;\n  isSelecting;\n  pointerType;\n  shouldCheckSelection;\n  abortController;\n  listenerOptions;\n  nextFocus;\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.isSelecting = false;\n    this.pointerType = null;\n    this.shouldCheckSelection = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n    this.nextFocus = null;\n    this.trackTable();\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  $lookup() {\n    return $getTableAndElementByKey(this.tableNodeKey, this.editor);\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.getEditorState().read(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const {\n          tableNode,\n          tableElement\n        } = this.$lookup();\n        this.table = getTable(tableNode, tableElement);\n      }, {\n        editor: this.editor\n      });\n    });\n    this.editor.getEditorState().read(() => {\n      const {\n        tableNode,\n        tableElement\n      } = this.$lookup();\n      this.table = getTable(tableNode, tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }, {\n      editor: this.editor\n    });\n  }\n  $clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.$enableHighlightStyle();\n    const {\n      tableNode,\n      tableElement\n    } = this.$lookup();\n    const grid = getTable(tableNode, tableElement);\n    $updateDOMForSelection(editor, grid, null);\n    if ($getSelection() !== null) {\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    }\n  }\n  $enableHighlightStyle() {\n    const editor = this.editor;\n    const {\n      tableElement\n    } = this.$lookup();\n    removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n    tableElement.classList.remove('disable-selection');\n    this.hasHijackedSelectionStyles = false;\n  }\n  $disableHighlightStyle() {\n    const {\n      tableElement\n    } = this.$lookup();\n    addClassNamesToElement(tableElement, this.editor._config.theme.tableSelection);\n    this.hasHijackedSelectionStyles = true;\n  }\n  $updateTableTableSelection(selection) {\n    if (selection !== null) {\n      if (!(selection.tableKey === this.tableNodeKey)) {\n        formatDevErrorMessage(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);\n      }\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n      this.updateDOMSelection();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else {\n      this.$clearHighlight();\n    }\n  }\n\n  /**\n   * @internal\n   * Firefox has a strange behavior where pressing the down arrow key from\n   * above the table will move the caret after the table and then lexical\n   * will select the last cell instead of the first.\n   * We do still want to let the browser handle caret movement but we will\n   * use this property to \"tag\" the update so that we can recheck the\n   * selection after the event is processed.\n   */\n  setShouldCheckSelection() {\n    this.shouldCheckSelection = true;\n  }\n  /**\n   * @internal\n   */\n  getAndClearShouldCheckSelection() {\n    if (this.shouldCheckSelection) {\n      this.shouldCheckSelection = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   * When handling mousemove events we track what the focus cell should be, but\n   * the DOM selection may end up somewhere else entirely. We don't have an elegant\n   * way to handle this after the DOM selection has been resolved in a\n   * SELECTION_CHANGE_COMMAND callback.\n   */\n  setNextFocus(nextFocus) {\n    this.nextFocus = nextFocus;\n  }\n\n  /** @internal */\n  getAndClearNextFocus() {\n    const {\n      nextFocus\n    } = this;\n    if (nextFocus !== null) {\n      this.nextFocus = null;\n    }\n    return nextFocus;\n  }\n\n  /** @internal */\n  updateDOMSelection() {\n    if (this.anchorCell !== null && this.focusCell !== null) {\n      const domSelection = getDOMSelection(this.editor._window);\n      // We are not using a native selection for tables, and if we\n      // set one then the reconciler will undo it.\n      // TODO - it would make sense to have one so that native\n      //        copy/paste worked. Right now we have to emulate with\n      //        keyboard events but it won't fire if triggered from the menu\n      if (domSelection && domSelection.rangeCount > 0) {\n        domSelection.removeAllRanges();\n      }\n    }\n  }\n  $setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    const {\n      tableNode\n    } = this.$lookup();\n    const cellX = cell.x;\n    const cellY = cell.y;\n    this.focusCell = cell;\n    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n    } else if (cellX === this.focusX && cellY === this.focusY) {\n      return false;\n    }\n    this.focusX = cellX;\n    this.focusY = cellY;\n    if (this.isHighlightingCells) {\n      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {\n        this.focusCellNodeKey = focusTableCellNode.getKey();\n        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);\n        $setSelection(this.tableSelection);\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        $updateDOMForSelection(editor, this.table, this.tableSelection);\n        return true;\n      }\n    }\n    return false;\n  }\n  $getAnchorTableCell() {\n    return this.anchorCellNodeKey ? $getNodeByKey(this.anchorCellNodeKey) : null;\n  }\n  $getAnchorTableCellOrThrow() {\n    const anchorTableCell = this.$getAnchorTableCell();\n    if (!(anchorTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver anchorTableCell is null`);\n    }\n    return anchorTableCell;\n  }\n  $getFocusTableCell() {\n    return this.focusCellNodeKey ? $getNodeByKey(this.focusCellNodeKey) : null;\n  }\n  $getFocusTableCellOrThrow() {\n    const focusTableCell = this.$getFocusTableCell();\n    if (!(focusTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver focusTableCell is null`);\n    }\n    return focusTableCell;\n  }\n  $setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    const {\n      tableNode\n    } = this.$lookup();\n    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n    if (anchorTableCellNode !== null) {\n      const anchorNodeKey = anchorTableCellNode.getKey();\n      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n      this.anchorCellNodeKey = anchorNodeKey;\n    }\n  }\n  $formatCells(type) {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected Table selection`);\n    }\n    const formatSelection = $createRangeSelection();\n    const anchor = formatSelection.anchor;\n    const focus = formatSelection.focus;\n    const cellNodes = selection.getNodes().filter($isTableCellNode);\n    if (!(cellNodes.length > 0)) {\n      formatDevErrorMessage(`No table cells present`);\n    }\n    const paragraph = cellNodes[0].getFirstChild();\n    const alignFormatWith = $isParagraphNode(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n    cellNodes.forEach(cellNode => {\n      anchor.set(cellNode.getKey(), 0, 'element');\n      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n      formatSelection.formatText(type, alignFormatWith);\n    });\n    $setSelection(selection);\n    this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  $clearText() {\n    const {\n      editor\n    } = this;\n    const tableNode = $getNodeByKey(this.tableNodeKey);\n    if (!$isTableNode(tableNode)) {\n      throw new Error('Expected TableNode.');\n    }\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected TableSelection`);\n    }\n    const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n    // Check if the entire table is selected by verifying first and last cells\n    const firstRow = tableNode.getFirstChild();\n    const lastRow = tableNode.getLastChild();\n    const isEntireTableSelected = selectedNodes.length > 0 && firstRow !== null && lastRow !== null && $isTableRowNode(firstRow) && $isTableRowNode(lastRow) && selectedNodes[0] === firstRow.getFirstChild() && selectedNodes[selectedNodes.length - 1] === lastRow.getLastChild();\n    if (isEntireTableSelected) {\n      tableNode.selectPrevious();\n      const parent = tableNode.getParent();\n      // Delete entire table\n      tableNode.remove();\n      // Handle case when table was the only node\n      if ($isRootNode(parent) && parent.isEmpty()) {\n        editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n      }\n      return;\n    }\n    selectedNodes.forEach(cellNode => {\n      if ($isElementNode(cellNode)) {\n        const paragraphNode = $createParagraphNode();\n        const textNode = $createTextNode();\n        paragraphNode.append(textNode);\n        cellNode.append(paragraphNode);\n        cellNode.getChildren().forEach(child => {\n          if (child !== paragraphNode) {\n            child.remove();\n          }\n        });\n      }\n    });\n    $updateDOMForSelection(editor, this.table, null);\n    $setSelection(null);\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst isPointerDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction isHTMLTableElement(el) {\n  return isHTMLElement(el) && el.nodeName === 'TABLE';\n}\nfunction getTableElement(tableNode, dom) {\n  if (!dom) {\n    return dom;\n  }\n  const element = isHTMLTableElement(dom) ? dom : tableNode.getDOMSlot(dom).element;\n  if (!(element.nodeName === 'TABLE')) {\n    formatDevErrorMessage(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);\n  }\n  return element;\n}\nfunction getEditorWindow(editor) {\n  return editor._window;\n}\nfunction $findParentTableCellNodeInTable(tableNode, node) {\n  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {\n    if (tableNode.is(currentNode)) {\n      return lastTableCellNode;\n    } else if ($isTableCellNode(currentNode)) {\n      lastTableCellNode = currentNode;\n    }\n  }\n  return null;\n}\nconst ARROW_KEY_COMMANDS_WITH_DIRECTION = [[KEY_ARROW_DOWN_COMMAND, 'down'], [KEY_ARROW_UP_COMMAND, 'up'], [KEY_ARROW_LEFT_COMMAND, 'backward'], [KEY_ARROW_RIGHT_COMMAND, 'forward']];\nconst DELETE_TEXT_COMMANDS = [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND];\nconst DELETE_KEY_COMMANDS = [KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND];\nfunction applyTableHandlers(tableNode, element, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  const editorWindow = getEditorWindow(editor);\n  if (!(rootElement !== null && editorWindow !== null)) {\n    formatDevErrorMessage(`applyTableHandlers: editor has no root element set`);\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const tableElement = getTableElement(tableNode, element);\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => detachTableObserverFromTableElement(tableElement, tableObserver));\n  const createPointerHandlers = () => {\n    if (tableObserver.isSelecting) {\n      return;\n    }\n    const onPointerUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('pointerup', onPointerUp);\n      editorWindow.removeEventListener('pointermove', onPointerMove);\n    };\n    const onPointerMove = moveEvent => {\n      if (!isPointerDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n        tableObserver.isSelecting = false;\n        editorWindow.removeEventListener('pointerup', onPointerUp);\n        editorWindow.removeEventListener('pointermove', onPointerMove);\n        return;\n      }\n      if (!isDOMNode(moveEvent.target)) {\n        return;\n      }\n      let focusCell = null;\n      // In firefox the moveEvent.target may be captured so we must always\n      // consult the coordinates #7245\n      const override = !(IS_FIREFOX || tableElement.contains(moveEvent.target));\n      if (override) {\n        focusCell = getDOMCellInTableFromTarget(tableElement, moveEvent.target);\n      } else {\n        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {\n          focusCell = getDOMCellInTableFromTarget(tableElement, el);\n          if (focusCell) {\n            break;\n          }\n        }\n      }\n      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {\n        tableObserver.setNextFocus({\n          focusCell,\n          override\n        });\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n      }\n    };\n    tableObserver.isSelecting = true;\n    editorWindow.addEventListener('pointerup', onPointerUp, tableObserver.listenerOptions);\n    editorWindow.addEventListener('pointermove', onPointerMove, tableObserver.listenerOptions);\n  };\n  const onPointerDown = event => {\n    tableObserver.pointerType = event.pointerType;\n    if (event.button !== 0 || !isDOMNode(event.target) || !editorWindow) {\n      return;\n    }\n    const targetCell = getDOMCellFromTarget(event.target);\n    if (targetCell !== null) {\n      editor.update(() => {\n        const prevSelection = $getPreviousSelection();\n        // We can't trust Firefox to do the right thing with the selection and\n        // we don't have a proper state machine to do this \"correctly\" but\n        // if we go ahead and make the table selection now it will work\n        if (IS_FIREFOX && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ($isRangeSelection(prevSelection) || $isTableSelection(prevSelection))) {\n          const prevAnchorNode = prevSelection.anchor.getNode();\n          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());\n          if (prevAnchorCell) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));\n            tableObserver.$setFocusCellForSelection(targetCell);\n            stopEvent(event);\n          } else {\n            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();\n            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);\n          }\n        } else {\n          // Only set anchor cell for selection if this is not a simple touch tap\n          // Touch taps should not initiate table selection mode\n          if (event.pointerType !== 'touch') {\n            tableObserver.$setAnchorCellForSelection(targetCell);\n          }\n        }\n      });\n    }\n    createPointerHandlers();\n  };\n  tableElement.addEventListener('pointerdown', onPointerDown, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('pointerdown', onPointerDown);\n  });\n  const onTripleClick = event => {\n    if (event.detail >= 3 && isDOMNode(event.target)) {\n      const targetCell = getDOMCellFromTarget(event.target);\n      if (targetCell !== null) {\n        event.preventDefault();\n      }\n    }\n  };\n  tableElement.addEventListener('mousedown', onTripleClick, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('mousedown', onTripleClick);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const pointerDownCallback = event => {\n    const target = event.target;\n    if (event.button !== 0 || !isDOMNode(target)) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.$clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('pointerdown', pointerDownCallback, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    editorWindow.removeEventListener('pointerdown', pointerDownCallback);\n  });\n  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, event => $handleArrowKey(editor, event, direction, tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());\n      if (focusCellNode !== null) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.$clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const command of DELETE_TEXT_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_HIGH));\n  }\n  const $deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.$clearText();\n      return true;\n    }\n    return false;\n  };\n  for (const command of DELETE_KEY_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (selection) {\n      if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ($isRangeSelection(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n\n    // Align the table if the entire table is selected\n    if ($isFullTableSelection(selection, tableNode)) {\n      tableNode.setFormat(formatType);\n      return true;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);\n    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    const visited = new Set();\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        if (visited.has(cell)) {\n          continue;\n        }\n        visited.add(cell);\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {\n        return false;\n      }\n      stopEvent(event);\n      $selectAdjacentCell(tableCellNode, event.shiftKey ? 'previous' : 'next');\n      return true;\n    }, COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (selectionPayload, dispatchEditor) => {\n    if (editor !== dispatchEditor) {\n      return false;\n    }\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor, focus] = anchorAndFocus;\n    const [anchorCellNode, anchorRowNode, gridNode] = $getNodeTriplet(anchor);\n    const focusCellNode = $findMatchingParent(focus.getNode(), n => $isTableCellNode(n));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableRowNode(anchorRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const templateGrid = nodes[0];\n    const [initialGridMap, anchorCellMap, focusCellMap] = $computeTableMap(gridNode, anchorCellNode, focusCellNode);\n    const [templateGridMap] = $computeTableMapSkipCellCheck(templateGrid, null, null);\n    const initialRowCount = initialGridMap.length;\n    const initialColCount = initialRowCount > 0 ? initialGridMap[0].length : 0;\n\n    // If we have a range selection, we'll fit the template grid into the\n    // table, growing the table if necessary.\n    let startRow = anchorCellMap.startRow;\n    let startCol = anchorCellMap.startColumn;\n    let affectedRowCount = templateGridMap.length;\n    let affectedColCount = affectedRowCount > 0 ? templateGridMap[0].length : 0;\n    if (isTableSelection) {\n      // If we have a table selection, we'll only modify the cells within\n      // the selection boundary.\n      const selectionBoundary = $computeTableCellRectBoundary(initialGridMap, anchorCellMap, focusCellMap);\n      const selectionRowCount = selectionBoundary.maxRow - selectionBoundary.minRow + 1;\n      const selectionColCount = selectionBoundary.maxColumn - selectionBoundary.minColumn + 1;\n      startRow = selectionBoundary.minRow;\n      startCol = selectionBoundary.minColumn;\n      affectedRowCount = Math.min(affectedRowCount, selectionRowCount);\n      affectedColCount = Math.min(affectedColCount, selectionColCount);\n    }\n\n    // Step 1: Unmerge all merged cells within the affected area\n    let didPerformMergeOperations = false;\n    const lastRowForUnmerge = Math.min(initialRowCount, startRow + affectedRowCount) - 1;\n    const lastColForUnmerge = Math.min(initialColCount, startCol + affectedColCount) - 1;\n    const unmergedKeys = new Set();\n    for (let row = startRow; row <= lastRowForUnmerge; row++) {\n      for (let col = startCol; col <= lastColForUnmerge; col++) {\n        const cellMap = initialGridMap[row][col];\n        if (unmergedKeys.has(cellMap.cell.getKey())) {\n          continue; // cell was a merged cell that was already handled\n        }\n        if (cellMap.cell.__rowSpan === 1 && cellMap.cell.__colSpan === 1) {\n          continue; // cell is not a merged cell\n        }\n        $unmergeCellNode(cellMap.cell);\n        unmergedKeys.add(cellMap.cell.getKey());\n        didPerformMergeOperations = true;\n      }\n    }\n    let [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 2: Expand current table (if needed)\n    const rowsToInsert = affectedRowCount - initialRowCount + startRow;\n    for (let i = 0; i < rowsToInsert; i++) {\n      const cellMap = interimGridMap[initialRowCount - 1][0];\n      $insertTableRowAtNode(cellMap.cell);\n    }\n    const colsToInsert = affectedColCount - initialColCount + startCol;\n    for (let i = 0; i < colsToInsert; i++) {\n      const cellMap = interimGridMap[0][initialColCount - 1];\n      $insertTableColumnAtNode(cellMap.cell, true, false);\n    }\n    [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 3: Merge cells and set cell content, to match template grid\n    for (let row = startRow; row < startRow + affectedRowCount; row++) {\n      for (let col = startCol; col < startCol + affectedColCount; col++) {\n        const templateRow = row - startRow;\n        const templateCol = col - startCol;\n        const templateCellMap = templateGridMap[templateRow][templateCol];\n        if (templateCellMap.startRow !== templateRow || templateCellMap.startColumn !== templateCol) {\n          continue; // cell is a merged cell that was already handled\n        }\n        const templateCell = templateCellMap.cell;\n        if (templateCell.__rowSpan !== 1 || templateCell.__colSpan !== 1) {\n          const cellsToMerge = [];\n          const lastRowForMerge = Math.min(row + templateCell.__rowSpan, startRow + affectedRowCount) - 1;\n          const lastColForMerge = Math.min(col + templateCell.__colSpan, startCol + affectedColCount) - 1;\n          for (let r = row; r <= lastRowForMerge; r++) {\n            for (let c = col; c <= lastColForMerge; c++) {\n              const cellMap = interimGridMap[r][c];\n              cellsToMerge.push(cellMap.cell);\n            }\n          }\n          $mergeCells(cellsToMerge);\n          didPerformMergeOperations = true;\n        }\n        const {\n          cell\n        } = interimGridMap[row][col];\n        const originalChildren = cell.getChildren();\n        templateCell.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            cell.append(child);\n          } else {\n            cell.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n      }\n    }\n    if (isTableSelection && didPerformMergeOperations) {\n      // reset the table selection in case the anchor or focus cell was\n      // removed via merge operations\n      const [finalGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n      const newAnchorCellMap = finalGridMap[anchorCellMap.startRow][anchorCellMap.startColumn];\n      newAnchorCellMap.cell.selectEnd();\n    }\n    return true;\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    const nextFocus = tableObserver.getAndClearNextFocus();\n    if (nextFocus !== null) {\n      const {\n        focusCell\n      } = nextFocus;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {\n          // The selection is already the correct table selection\n          return false;\n        } else {\n          tableObserver.$setFocusCellForSelection(focusCell);\n          return true;\n        }\n      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {\n        // The selection has crossed cells\n        tableObserver.$setFocusCellForSelection(focusCell);\n        return true;\n      }\n    }\n    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();\n    // If they pressed the down arrow with the selection outside of the\n    // table, and then the selection ends up in the table but not in the\n    // first cell, then move the selection to the first cell.\n    if (shouldCheckSelection && $isRangeSelection(prevSelection) && $isRangeSelection(selection) && selection.isCollapsed()) {\n      const anchor = selection.anchor.getNode();\n      const firstRow = tableNode.getFirstChild();\n      const anchorCell = $findCellNode(anchor);\n      if (anchorCell !== null && $isTableRowNode(firstRow)) {\n        const firstCell = firstRow.getFirstChild();\n        if ($isTableCellNode(firstCell) && tableNode.is($findMatchingParent(anchorCell, node => node.is(tableNode) || node.is(firstCell)))) {\n          // The selection moved to the table, but not in the first cell\n          firstCell.selectStart();\n          return true;\n        }\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartiallyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into table selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));\n          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n        }\n\n        // Handle case when the pointer type is touch and the current and\n        // previous selection are collapsed, and the previous anchor and current\n        // focus cell nodes are different, then we convert it into table selection\n        // However, only do this if the table observer is actively selecting (user dragging)\n        // to prevent unwanted selections when simply tapping between cells on mobile\n        if (tableObserver.pointerType === 'touch' && tableObserver.isSelecting && selection.isCollapsed() && $isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevAnchorCellNode = $findCellNode(prevSelection.anchor.getNode());\n          if (prevAnchorCellNode && !prevAnchorCellNode.is(focusCellNode)) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCellNode));\n            tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n            tableObserver.pointerType = null;\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editorWindow);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  return tableObserver;\n}\nfunction detachTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    formatDevErrorMessage(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getDOMCellInTableFromTarget(table, node) {\n  if (!table.contains(node)) {\n    return null;\n  }\n  let cell = null;\n  for (let currentNode = node; currentNode != null; currentNode = currentNode.parentNode) {\n    if (currentNode === table) {\n      return cell;\n    }\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      cell = currentNode._cell || null;\n    }\n  }\n  return null;\n}\nfunction getTable(tableNode, dom) {\n  const tableElement = getTableElement(tableNode, dom);\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.$disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.$enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nfunction $selectAdjacentCell(tableCellNode, direction) {\n  const siblingMethod = direction === 'next' ? 'getNextSibling' : 'getPreviousSibling';\n  const childMethod = direction === 'next' ? 'getFirstChild' : 'getLastChild';\n  const sibling = tableCellNode[siblingMethod]();\n  if ($isElementNode(sibling)) {\n    return sibling.selectEnd();\n  }\n  const parentRow = $findMatchingParent(tableCellNode, $isTableRowNode);\n  if (!(parentRow !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Cell not in table row`);\n  }\n  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {\n    const child = nextRow[childMethod]();\n    if ($isElementNode(child)) {\n      return child.selectEnd();\n    }\n  }\n  const parentTable = $findMatchingParent(parentRow, $isTableNode);\n  if (!(parentTable !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Row not in table`);\n  }\n  return direction === 'next' ? parentTable.selectNext() : parentTable.selectPrevious();\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nfunction getCorner(rect, cellValue) {\n  let colName;\n  let rowName;\n  if (cellValue.startColumn === rect.minColumn) {\n    colName = 'minColumn';\n  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {\n    colName = 'maxColumn';\n  } else {\n    return null;\n  }\n  if (cellValue.startRow === rect.minRow) {\n    rowName = 'minRow';\n  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {\n    rowName = 'maxRow';\n  } else {\n    return null;\n  }\n  return [colName, rowName];\n}\nfunction getCornerOrThrow(rect, cellValue) {\n  const corner = getCorner(rect, cellValue);\n  if (!(corner !== null)) {\n    formatDevErrorMessage(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);\n  }\n  return corner;\n}\nfunction oppositeCorner([colName, rowName]) {\n  return [colName === 'minColumn' ? 'maxColumn' : 'minColumn', rowName === 'minRow' ? 'maxRow' : 'minRow'];\n}\nfunction cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {\n  const rowNum = rect[rowName];\n  const rowMap = tableMap[rowNum];\n  if (!(rowMap !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);\n  }\n  const colNum = rect[colName];\n  const cell = rowMap[colNum];\n  if (!(cell !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);\n  }\n  return cell;\n}\nfunction $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {\n  // We are sure that the focus now either contracts or expands the rect\n  // but both the anchor and focus might be moved to ensure a rectangle\n  // given a potentially ragged merge shape\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorCorner = getCorner(rect, anchorCellValue);\n  if (anchorCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];\n  }\n  const newFocusCorner = getCorner(rect, newFocusCellValue);\n  if (newFocusCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];\n  }\n  // TODO this doesn't have to be arbitrary, use the closest corner instead\n  const newAnchorCorner = ['minColumn', 'minRow'];\n  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];\n}\nfunction $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);\n  const spans = $computeTableCellRectSpans(tableMap, rect);\n  const {\n    topSpan,\n    leftSpan,\n    bottomSpan,\n    rightSpan\n  } = spans;\n  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);\n  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);\n  let fCol = rect[focusColumn];\n  let fRow = rect[focusRow];\n  if (direction === 'forward') {\n    fCol += focusColumn === 'maxColumn' ? 1 : leftSpan;\n  } else if (direction === 'backward') {\n    fCol -= focusColumn === 'minColumn' ? 1 : rightSpan;\n  } else if (direction === 'down') {\n    fRow += focusRow === 'maxRow' ? 1 : topSpan;\n  } else if (direction === 'up') {\n    fRow -= focusRow === 'minRow' ? 1 : bottomSpan;\n  }\n  const targetRowMap = tableMap[fRow];\n  if (targetRowMap === undefined) {\n    return false;\n  }\n  const newFocusCellValue = targetRowMap[fCol];\n  if (newFocusCellValue === undefined) {\n    return false;\n  }\n  // We can be certain that anchorCellValue and newFocusCellValue are\n  // contained within the desired selection, but we are not certain if\n  // they need to be expanded or not to maintain a rectangular shape\n  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);\n  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);\n  tableObserver.$setAnchorCellForSelection(anchorDOM);\n  tableObserver.$setFocusCellForSelection(focusDOM, true);\n  return true;\n}\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    // TODO this should probably return false if there's an unrelated\n    //      shadow root between the node and the table (e.g. another table,\n    //      collapsible, etc.)\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction $isFullTableSelection(selection, tableNode) {\n  if ($isTableSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (tableNode && anchorNode && focusNode) {\n      const [map] = $computeTableMap(tableNode, anchorNode, focusNode);\n      return anchorNode.getKey() === map[0][0].cell.getKey() && focusNode.getKey() === map[map.length - 1].at(-1).cell.getKey();\n    }\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const editorThemeClasses = editor._config.theme;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  addClassNamesToElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const editorThemeClasses = editor._config.theme;\n  removeClassNamesFromElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $getBlockParentIfFirstNode(node) {\n  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {\n    if ($isElementNode(currentNode)) {\n      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {\n        // Not the first child or the initial node\n        return null;\n      } else if (!currentNode.isInline()) {\n        return currentNode;\n      }\n    }\n  }\n  return null;\n}\nfunction $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, isBackward, tableNode, tableObserver) {\n  const initialFocus = $caretFromPoint(selection.focus, isBackward ? 'previous' : 'next');\n  if ($isExtendableTextPointCaret(initialFocus)) {\n    return false;\n  }\n  let lastCaret = initialFocus;\n  // TableCellNode is the only shadow root we are interested in piercing so\n  // we find the last internal caret and then check its parent\n  for (const nextCaret of $extendCaretToRange(initialFocus).iterNodeCarets('shadowRoot')) {\n    if (!($isSiblingCaret(nextCaret) && $isElementNode(nextCaret.origin))) {\n      return false;\n    }\n    lastCaret = nextCaret;\n  }\n  const lastCaretParent = lastCaret.getParentAtCaret();\n  if (!$isTableCellNode(lastCaretParent)) {\n    return false;\n  }\n  const anchorCell = lastCaretParent;\n  const focusCaret = $findNextTableCell($getSiblingCaret(anchorCell, lastCaret.direction));\n  const anchorCellTable = $findMatchingParent(anchorCell, $isTableNode);\n  if (!(anchorCellTable && anchorCellTable.is(tableNode))) {\n    return false;\n  }\n  const anchorCellDOM = editor.getElementByKey(anchorCell.getKey());\n  const anchorDOMCell = getDOMCellFromTarget(anchorCellDOM);\n  if (!anchorCellDOM || !anchorDOMCell) {\n    return false;\n  }\n  const anchorCellTableElement = $getElementForTableNode(editor, anchorCellTable);\n  tableObserver.table = anchorCellTableElement;\n  if (!focusCaret) {\n    if (alter === 'extend') {\n      // extend the selection from a range inside the cell to a table selection of the cell\n      tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n      tableObserver.$setFocusCellForSelection(anchorDOMCell, true);\n    } else {\n      // exit the table\n      const outerFocusCaret = $getTableExitCaret($getSiblingCaret(anchorCellTable, initialFocus.direction));\n      $setPointFromCaret(selection.anchor, outerFocusCaret);\n      $setPointFromCaret(selection.focus, outerFocusCaret);\n    }\n  } else if (alter === 'extend') {\n    const focusDOMCell = getDOMCellFromTarget(editor.getElementByKey(focusCaret.origin.getKey()));\n    if (!focusDOMCell) {\n      return false;\n    }\n    tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n    tableObserver.$setFocusCellForSelection(focusDOMCell, true);\n  } else {\n    // alter === 'move'\n    const innerFocusCaret = $normalizeCaret(focusCaret);\n    $setPointFromCaret(selection.anchor, innerFocusCaret);\n    $setPointFromCaret(selection.focus, innerFocusCaret);\n  }\n  stopEvent(event);\n  return true;\n}\nfunction $getTableExitCaret(initialCaret) {\n  const adjacent = $getAdjacentChildCaret(initialCaret);\n  return $isChildCaret(adjacent) ? $normalizeCaret(adjacent) : initialCaret;\n}\nfunction $findNextTableCell(initialCaret) {\n  for (const nextCaret of $extendCaretToRange(initialCaret).iterNodeCarets('root')) {\n    const {\n      origin\n    } = nextCaret;\n    if ($isTableCellNode(origin)) {\n      // not sure why ts isn't narrowing here (even if the guard is on nextCaret.origin)\n      // but returning a new caret is fine\n      if ($isChildCaret(nextCaret)) {\n        return $getChildCaret(origin, initialCaret.direction);\n      }\n    } else if (!$isTableRowNode(origin)) {\n      break;\n    }\n  }\n  return null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (direction === 'backward') {\n        if (selection.focus.offset > 0) {\n          return false;\n        }\n        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        if (event.shiftKey) {\n          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), 'element');\n        } else {\n          siblingNode.selectEnd();\n        }\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = $isTextNode(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, $isTextNode(newFocusNode) ? 'text' : 'element');\n          $setSelection(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);\n            if (tableCellNode !== null) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.$setAnchorCellForSelection(firstCellDOM);\n              tableObserver.$setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isElementNode(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    if (direction === 'down' && $isScrollableTablesActive(editor)) {\n      // Enable Firefox workaround\n      tableObserver.setShouldCheckSelection();\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection)) {\n    if (direction === 'backward' || direction === 'forward') {\n      const alter = event.shiftKey ? 'extend' : 'move';\n      return $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, direction === 'backward', tableNode, tableObserver);\n    }\n    if (selection.isCollapsed()) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n      const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n      if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n        return false;\n      }\n      const anchorCellTable = $findTableNode(anchorCellNode);\n      if (anchorCellTable !== tableNode && anchorCellTable != null) {\n        const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));\n        if (anchorCellTableElement != null) {\n          tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);\n          return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n        }\n      }\n      const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n      const anchorDOM = editor.getElementByKey(anchor.key);\n      if (anchorDOM == null || anchorCellDom == null) {\n        return false;\n      }\n      let edgeSelectionRect;\n      if (anchor.type === 'element') {\n        edgeSelectionRect = anchorDOM.getBoundingClientRect();\n      } else {\n        const domSelection = getDOMSelection(getEditorWindow(editor));\n        if (domSelection === null || domSelection.rangeCount === 0) {\n          return false;\n        }\n        const range = domSelection.getRangeAt(0);\n        edgeSelectionRect = range.getBoundingClientRect();\n      }\n      const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n      if (edgeChild == null) {\n        return false;\n      }\n      const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n      if (edgeChildDOM == null) {\n        return false;\n      }\n      const edgeRect = edgeChildDOM.getBoundingClientRect();\n      const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n      if (isExiting) {\n        stopEvent(event);\n        const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n        if (event.shiftKey) {\n          const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n          tableObserver.$setAnchorCellForSelection(cell);\n          tableObserver.$setFocusCellForSelection(cell, true);\n        } else {\n          return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n        }\n        return true;\n      }\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    if (!$isTableNode(tableNodeFromSelection)) {\n      formatDevErrorMessage(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);\n    }\n    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.$updateTableTableSelection(selection);\n    const grid = getTable(tableNodeFromSelection, tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.$setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);\n      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = getDOMSelection(getEditorWindow(editor));\n  if (!domSelection) {\n    return undefined;\n  }\n  const domAnchorNode = domSelection.anchorNode;\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));\n  // We are only interested in the scenario where the\n  // native selection anchor is:\n  // - at or inside the table's parent DOM\n  // - and NOT at or inside the table DOM\n  // It may be adjacent to the table DOM (e.g. in a wrapper)\n  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\nfunction $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {\n  const {\n    tableNode\n  } = tableObserver.$lookup();\n  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n}\nfunction $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {\n  return $findParentTableCellNodeInTable(tableNode, $getNearestNodeFromDOMNode(startingDOM, editorState));\n}\n\nfunction isHTMLDivElement(element) {\n  return isHTMLElement$1(element) && element.nodeName === 'DIV';\n}\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    addClassNamesToElement(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\nfunction setFrozenColumns(dom, tableElement, config, frozenColumnCount) {\n  if (frozenColumnCount > 0) {\n    addClassNamesToElement(dom, config.theme.tableFrozenColumn);\n    tableElement.setAttribute('data-lexical-frozen-column', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableFrozenColumn);\n    tableElement.removeAttribute('data-lexical-frozen-column');\n  }\n}\nfunction setFrozenRows(dom, tableElement, config, frozenRowCount) {\n  if (frozenRowCount > 0) {\n    addClassNamesToElement(dom, config.theme.tableFrozenRow);\n    tableElement.setAttribute('data-lexical-frozen-row', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableFrozenRow);\n    tableElement.removeAttribute('data-lexical-frozen-row');\n  }\n}\nfunction alignTableElement(dom, config, formatType) {\n  if (!config.theme.tableAlignment) {\n    return;\n  }\n  const removeClasses = [];\n  const addClasses = [];\n  for (const format of ['center', 'right']) {\n    const classes = config.theme.tableAlignment[format];\n    if (!classes) {\n      continue;\n    }\n    (format === formatType ? addClasses : removeClasses).push(classes);\n  }\n  removeClassNamesFromElement(dom, ...removeClasses);\n  addClassNamesToElement(dom, ...addClasses);\n}\nconst scrollableEditors = new WeakSet();\nfunction $isScrollableTablesActive(editor = $getEditor()) {\n  return scrollableEditors.has(editor);\n}\nfunction setScrollableTablesActive(editor, active) {\n  if (active) {\n    if (!editor._config.theme.tableScrollableWrapper) {\n      console.warn('TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.');\n    }\n    scrollableEditors.add(editor);\n  } else {\n    scrollableEditors.delete(editor);\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  /** @internal */\n  __rowStriping;\n  __frozenColumnCount;\n  __frozenRowCount;\n  __colWidths;\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = colWidths !== undefined && true ? Object.freeze(colWidths) : colWidths;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n    this.__frozenColumnCount = prevNode.__frozenColumnCount;\n    this.__frozenRowCount = prevNode.__frozenRowCount;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setFrozenColumns(serializedNode.frozenColumnCount || 0).setFrozenRows(serializedNode.frozenRowCount || 0).setColWidths(serializedNode.colWidths);\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n    this.__frozenColumnCount = 0;\n    this.__frozenRowCount = 0;\n    this.__colWidths = undefined;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : undefined,\n      frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : undefined,\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined\n    };\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  getDOMSlot(element) {\n    const tableElement = !isHTMLTableElement(element) ? element.querySelector('table') : element;\n    if (!isHTMLTableElement(tableElement)) {\n      formatDevErrorMessage(`TableNode.getDOMSlot: createDOM() did not return a table`);\n    }\n    return super.getDOMSlot(element).withElement(tableElement).withAfter(tableElement.querySelector('colgroup'));\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    if (this.__style) {\n      tableElement.style.cssText = this.__style;\n    }\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    setDOMUnmanaged(colGroup);\n    addClassNamesToElement(tableElement, config.theme.table);\n    this.updateTableElement(null, tableElement, config);\n    if ($isScrollableTablesActive(editor)) {\n      const wrapperElement = document.createElement('div');\n      const classes = config.theme.tableScrollableWrapper;\n      if (classes) {\n        addClassNamesToElement(wrapperElement, classes);\n      } else {\n        wrapperElement.style.cssText = 'overflow-x: auto;';\n      }\n      wrapperElement.appendChild(tableElement);\n      this.updateTableWrapper(null, wrapperElement, tableElement, config);\n      return wrapperElement;\n    }\n    return tableElement;\n  }\n  updateTableWrapper(prevNode, tableWrapper, tableElement, config) {\n    if (this.__frozenColumnCount !== (prevNode ? prevNode.__frozenColumnCount : 0)) {\n      setFrozenColumns(tableWrapper, tableElement, config, this.__frozenColumnCount);\n    }\n    if (this.__frozenRowCount !== (prevNode ? prevNode.__frozenRowCount : 0)) {\n      setFrozenRows(tableWrapper, tableElement, config, this.__frozenRowCount);\n    }\n  }\n  updateTableElement(prevNode, tableElement, config) {\n    if (this.__style !== (prevNode ? prevNode.__style : '')) {\n      tableElement.style.cssText = this.__style;\n    }\n    if (this.__rowStriping !== (prevNode ? prevNode.__rowStriping : false)) {\n      setRowStriping(tableElement, config, this.__rowStriping);\n    }\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    alignTableElement(tableElement, config, this.getFormatType());\n  }\n  updateDOM(prevNode, dom, config) {\n    const slot = this.getDOMSlot(dom);\n    const tableElement = slot.element;\n    if (dom === tableElement === $isScrollableTablesActive()) {\n      return true;\n    }\n    if (isHTMLDivElement(dom)) {\n      this.updateTableWrapper(prevNode, dom, tableElement, config);\n    }\n    this.updateTableElement(prevNode, tableElement, config);\n    return false;\n  }\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n    const {\n      element\n    } = superExport;\n    return {\n      after: tableElement => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n        }\n        if (!isHTMLTableElement(tableElement) && isHTMLElement$1(tableElement)) {\n          tableElement = tableElement.querySelector('table');\n        }\n        if (!isHTMLTableElement(tableElement)) {\n          return null;\n        }\n        alignTableElement(tableElement, editor._config, this.getFormatType());\n\n        // Scan the table map to build a map of table cell key to the columns it needs\n        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);\n        const cellValues = new Map();\n        for (const mapRow of tableMap) {\n          for (const mapValue of mapRow) {\n            const key = mapValue.cell.getKey();\n            if (!cellValues.has(key)) {\n              cellValues.set(key, {\n                colSpan: mapValue.cell.getColSpan(),\n                startColumn: mapValue.startColumn\n              });\n            }\n          }\n        }\n\n        // scan the DOM to find the table cell keys that were used and mark those columns\n        const knownColumns = new Set();\n        for (const cellDOM of tableElement.querySelectorAll(':scope > tr > [data-temporary-table-cell-lexical-key]')) {\n          const key = cellDOM.getAttribute('data-temporary-table-cell-lexical-key');\n          if (key) {\n            const cellSpan = cellValues.get(key);\n            cellDOM.removeAttribute('data-temporary-table-cell-lexical-key');\n            if (cellSpan) {\n              cellValues.delete(key);\n              for (let i = 0; i < cellSpan.colSpan; i++) {\n                knownColumns.add(i + cellSpan.startColumn);\n              }\n            }\n          }\n        }\n\n        // Compute the colgroup and columns in the export\n        const colGroup = tableElement.querySelector(':scope > colgroup');\n        if (colGroup) {\n          // Only include the <col /> for rows that are in the output\n          const cols = Array.from(tableElement.querySelectorAll(':scope > colgroup > col')).filter((dom, i) => knownColumns.has(i));\n          colGroup.replaceChildren(...cols);\n        }\n\n        // Wrap direct descendant rows in a tbody for export\n        const rows = tableElement.querySelectorAll(':scope > tr');\n        if (rows.length > 0) {\n          const tBody = document.createElement('tbody');\n          for (const row of rows) {\n            tBody.appendChild(row);\n          }\n          tableElement.append(tBody);\n        }\n        return tableElement;\n      },\n      element: !isHTMLTableElement(element) && isHTMLElement$1(element) ? element.querySelector('table') : element\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      for (let x = 0; x < row.length; x++) {\n        const cell = row[x];\n        if (cell == null) {\n          continue;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);\n        if (cellNode !== null && tableCellNode.is(cellNode)) {\n          return {\n            x,\n            y\n          };\n        }\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    const self = this.getWritable();\n    self.__rowStriping = newRowStriping;\n    return self;\n  }\n  setFrozenColumns(columnCount) {\n    const self = this.getWritable();\n    self.__frozenColumnCount = columnCount;\n    return self;\n  }\n  getFrozenColumns() {\n    return this.getLatest().__frozenColumnCount;\n  }\n  setFrozenRows(rowCount) {\n    const self = this.getWritable();\n    self.__frozenRowCount = rowCount;\n    return self;\n  }\n  getFrozenRows() {\n    return this.getLatest().__frozenRowCount;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`$getElementForTableNode: Table Element Not Found`);\n  }\n  return getTable(tableNode, tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-column')) {\n    tableNode.setFrozenColumns(1);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-row')) {\n    tableNode.setFrozenRows(1);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      let width = col.style.width || '';\n      if (!PIXEL_VALUE_REG_EXP.test(width)) {\n        // Also support deprecated width attribute for google docs\n        width = col.getAttribute('width') || '';\n        if (!/^\\d+$/.test(width)) {\n          columns = undefined;\n          break;\n        }\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableRowNode),\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nfunction $insertTableCommandListener({\n  rows,\n  columns,\n  includeHeaders\n}) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if (!selection || !$isRangeSelection(selection)) {\n    return false;\n  }\n\n  // Prevent nested tables by checking if we're already inside a table\n  if ($findTableNode(selection.anchor.getNode())) {\n    return false;\n  }\n  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n  $insertNodeToNearestRoot(tableNode);\n  const firstDescendant = tableNode.getFirstDescendant();\n  if ($isTextNode(firstDescendant)) {\n    firstDescendant.select();\n  }\n  return true;\n}\nfunction $tableCellTransform(node) {\n  if (!$isTableRowNode(node.getParent())) {\n    // TableCellNode must be a child of TableRowNode.\n    node.remove();\n  } else if (node.isEmpty()) {\n    // TableCellNode should never be empty\n    node.append($createParagraphNode());\n  }\n}\nfunction $tableRowTransform(node) {\n  if (!$isTableNode(node.getParent())) {\n    // TableRowNode must be a child of TableNode.\n    // TODO: Future support of tbody/thead/tfoot may change this\n    node.remove();\n  } else {\n    $unwrapAndFilterDescendants(node, $isTableCellNode);\n  }\n}\nfunction $tableTransform(node) {\n  // TableRowNode is the only valid child for TableNode\n  // TODO: Future support of tbody/thead/tfoot/caption may change this\n  $unwrapAndFilterDescendants(node, $isTableRowNode);\n  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n  const maxRowLength = gridMap.reduce((curLength, row) => {\n    return Math.max(curLength, row.length);\n  }, 0);\n  const rowNodes = node.getChildren();\n  for (let i = 0; i < gridMap.length; ++i) {\n    const rowNode = rowNodes[i];\n    if (!rowNode) {\n      continue;\n    }\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);\n    }\n    const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n    if (rowLength === maxRowLength) {\n      continue;\n    }\n    for (let j = rowLength; j < maxRowLength; ++j) {\n      // TODO: inherit header state from another header or body\n      const newCell = $createTableCellNode();\n      newCell.append($createParagraphNode());\n      rowNode.append(newCell);\n    }\n  }\n}\nfunction $tableClickCommand(event) {\n  if (event.detail < 3 || !isDOMNode(event.target)) {\n    return false;\n  }\n  const startNode = $getNearestNodeFromDOMNode(event.target);\n  if (startNode === null) {\n    return false;\n  }\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (blockNode === null) {\n    return false;\n  }\n  const rootNode = blockNode.getParent();\n  if (!$isTableCellNode(rootNode)) {\n    return false;\n  }\n  blockNode.select(0);\n  return true;\n}\n\n/**\n * Register a transform to ensure that all TableCellNode have a colSpan and rowSpan of 1.\n * This should only be registered when you do not want to support merged cells.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTableCellUnmergeTransform(editor) {\n  return editor.registerNodeTransform(TableCellNode, node => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [,, gridNode] = $getNodeTriplet(node);\n      const [gridMap] = $computeTableMap(gridNode, node, node);\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length;\n      const columnsCount = gridMap[0].length;\n      let row = gridNode.getFirstChild();\n      if (!$isTableRowNode(row)) {\n        formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n      }\n      const unmerged = [];\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling();\n          if (!$isTableRowNode(row)) {\n            formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n          }\n        }\n        let lastRowCell = null;\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j];\n          const cell = cellMap.cell;\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell;\n            unmerged.push(cell);\n          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            if (!$isTableCellNode(cell)) {\n              formatDevErrorMessage(`Expected TableNode cell to be a TableCellNode`);\n            }\n            const newCell = $createTableCellNode(cell.__headerState);\n            if (lastRowCell !== null) {\n              lastRowCell.insertAfter(newCell);\n            } else {\n              $insertFirst$1(row, newCell);\n            }\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1);\n        cell.setRowSpan(1);\n      }\n    }\n  });\n}\nfunction registerTableSelectionObserver(editor, hasTabHandler = true) {\n  const tableSelections = new Map();\n  const initializeTableNode = (tableNode, nodeKey, dom) => {\n    const tableElement = getTableElement(tableNode, dom);\n    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n    tableSelections.set(nodeKey, [tableSelection, tableElement]);\n  };\n  const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n    editor.getEditorState().read(() => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        const tableSelection = tableSelections.get(nodeKey);\n        if (mutation === 'created' || mutation === 'updated') {\n          const {\n            tableNode,\n            tableElement\n          } = $getTableAndElementByKey(nodeKey);\n          if (tableSelection === undefined) {\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          } else if (tableElement !== tableSelection[1]) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          }\n        } else if (mutation === 'destroyed') {\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      editor\n    });\n  }, {\n    skipInitialization: false\n  });\n  return () => {\n    unregisterMutationListener();\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, [tableSelection]] of tableSelections) {\n      tableSelection.removeListeners();\n    }\n  };\n}\n\n/**\n * Register the INSERT_TABLE_COMMAND listener and the table integrity transforms. The\n * table selection observer should be registered separately after this with\n * {@link registerTableSelectionObserver}.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTablePlugin(editor) {\n  if (!editor.hasNodes([TableNode])) {\n    {\n      formatDevErrorMessage(`TablePlugin: TableNode is not registered on editor`);\n    }\n  }\n  return mergeRegister(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, ({\n    nodes,\n    selection\n  }, dispatchEditor) => {\n    if (editor !== dispatchEditor || !$isRangeSelection(selection)) {\n      return false;\n    }\n    const isInsideTableCell = $findTableNode(selection.anchor.getNode()) !== null;\n    return isInsideTableCell && nodes.some($isTableNode);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLICK_COMMAND, $tableClickCommand, COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Configures {@link TableNode}, {@link TableRowNode}, {@link TableCellNode} and\n * registers table behaviors (see {@link TableConfig})\n */\nconst TableExtension = defineExtension({\n  build(editor, config, state) {\n    return namedSignals(config);\n  },\n  config: safeCast({\n    hasCellBackgroundColor: true,\n    hasCellMerge: true,\n    hasHorizontalScroll: true,\n    hasTabHandler: true\n  }),\n  name: '@lexical/table/Table',\n  nodes: [TableNode, TableRowNode, TableCellNode],\n  register(editor, config, state) {\n    const stores = state.getOutput();\n    return mergeRegister(effect(() => {\n      const hasHorizontalScroll = stores.hasHorizontalScroll.value;\n      const hadHorizontalScroll = $isScrollableTablesActive(editor);\n      if (hadHorizontalScroll !== hasHorizontalScroll) {\n        setScrollableTablesActive(editor, hasHorizontalScroll);\n        // Registering the transform has the side-effect of marking all existing\n        // TableNodes as dirty. The handler is immediately unregistered.\n        editor.registerNodeTransform(TableNode, () => {})();\n      }\n    }), registerTablePlugin(editor), effect(() => registerTableSelectionObserver(editor, stores.hasTabHandler.value)), effect(() => stores.hasCellMerge.value ? undefined : registerTableCellUnmergeTransform(editor)), effect(() => stores.hasCellBackgroundColor.value ? undefined : editor.registerNodeTransform(TableCellNode, node => {\n      if (node.getBackgroundColor() !== null) {\n        node.setBackgroundColor(null);\n      }\n    })));\n  }\n});\n\nexport { $computeTableMap, $computeTableMapSkipCellCheck, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $createTableSelectionFrom, $deleteTableColumn, $deleteTableColumnAtSelection, $deleteTableColumn__EXPERIMENTAL, $deleteTableRowAtSelection, $deleteTableRow__EXPERIMENTAL, $findCellNode, $findTableNode, $getElementForTableNode, $getNodeTriplet, $getTableAndElementByKey, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumnAtSelection, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRowAtSelection, $insertTableRow__EXPERIMENTAL, $isScrollableTablesActive, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $mergeCells, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableExtension, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableElement, getTableObserverFromTableElement, registerTableCellUnmergeTransform, registerTablePlugin, registerTableSelectionObserver, setScrollableTablesActive };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalTable.dev.mjs';\nimport * as modProd from './LexicalTable.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $computeTableMap = mod.$computeTableMap;\nexport const $computeTableMapSkipCellCheck = mod.$computeTableMapSkipCellCheck;\nexport const $createTableCellNode = mod.$createTableCellNode;\nexport const $createTableNode = mod.$createTableNode;\nexport const $createTableNodeWithDimensions = mod.$createTableNodeWithDimensions;\nexport const $createTableRowNode = mod.$createTableRowNode;\nexport const $createTableSelection = mod.$createTableSelection;\nexport const $createTableSelectionFrom = mod.$createTableSelectionFrom;\nexport const $deleteTableColumn = mod.$deleteTableColumn;\nexport const $deleteTableColumnAtSelection = mod.$deleteTableColumnAtSelection;\nexport const $deleteTableColumn__EXPERIMENTAL = mod.$deleteTableColumn__EXPERIMENTAL;\nexport const $deleteTableRowAtSelection = mod.$deleteTableRowAtSelection;\nexport const $deleteTableRow__EXPERIMENTAL = mod.$deleteTableRow__EXPERIMENTAL;\nexport const $findCellNode = mod.$findCellNode;\nexport const $findTableNode = mod.$findTableNode;\nexport const $getElementForTableNode = mod.$getElementForTableNode;\nexport const $getNodeTriplet = mod.$getNodeTriplet;\nexport const $getTableAndElementByKey = mod.$getTableAndElementByKey;\nexport const $getTableCellNodeFromLexicalNode = mod.$getTableCellNodeFromLexicalNode;\nexport const $getTableCellNodeRect = mod.$getTableCellNodeRect;\nexport const $getTableColumnIndexFromTableCellNode = mod.$getTableColumnIndexFromTableCellNode;\nexport const $getTableNodeFromLexicalNodeOrThrow = mod.$getTableNodeFromLexicalNodeOrThrow;\nexport const $getTableRowIndexFromTableCellNode = mod.$getTableRowIndexFromTableCellNode;\nexport const $getTableRowNodeFromTableCellNodeOrThrow = mod.$getTableRowNodeFromTableCellNodeOrThrow;\nexport const $insertTableColumn = mod.$insertTableColumn;\nexport const $insertTableColumnAtSelection = mod.$insertTableColumnAtSelection;\nexport const $insertTableColumn__EXPERIMENTAL = mod.$insertTableColumn__EXPERIMENTAL;\nexport const $insertTableRow = mod.$insertTableRow;\nexport const $insertTableRowAtSelection = mod.$insertTableRowAtSelection;\nexport const $insertTableRow__EXPERIMENTAL = mod.$insertTableRow__EXPERIMENTAL;\nexport const $isScrollableTablesActive = mod.$isScrollableTablesActive;\nexport const $isTableCellNode = mod.$isTableCellNode;\nexport const $isTableNode = mod.$isTableNode;\nexport const $isTableRowNode = mod.$isTableRowNode;\nexport const $isTableSelection = mod.$isTableSelection;\nexport const $mergeCells = mod.$mergeCells;\nexport const $removeTableRowAtIndex = mod.$removeTableRowAtIndex;\nexport const $unmergeCell = mod.$unmergeCell;\nexport const INSERT_TABLE_COMMAND = mod.INSERT_TABLE_COMMAND;\nexport const TableCellHeaderStates = mod.TableCellHeaderStates;\nexport const TableCellNode = mod.TableCellNode;\nexport const TableExtension = mod.TableExtension;\nexport const TableNode = mod.TableNode;\nexport const TableObserver = mod.TableObserver;\nexport const TableRowNode = mod.TableRowNode;\nexport const applyTableHandlers = mod.applyTableHandlers;\nexport const getDOMCellFromTarget = mod.getDOMCellFromTarget;\nexport const getTableElement = mod.getTableElement;\nexport const getTableObserverFromTableElement = mod.getTableObserverFromTableElement;\nexport const registerTableCellUnmergeTransform = mod.registerTableCellUnmergeTransform;\nexport const registerTablePlugin = mod.registerTablePlugin;\nexport const registerTableSelectionObserver = mod.registerTableSelectionObserver;\nexport const setScrollableTablesActive = mod.setScrollableTablesActive;", "import Prism from 'prismjs';\n\nfunction createElement(name, properties, content = \"\") {\n  const element = document.createElement(name);\n  for (const [ key, value ] of Object.entries(properties || {})) {\n    if (key in element) {\n      element[key] = value;\n    } else if (value !== null && value !== undefined) {\n      element.setAttribute(key, value);\n    }\n  }\n  if (content) {\n    element.innerHTML = content;\n  }\n  return element\n}\n\nfunction parseHtml(html) {\n  const parser = new DOMParser();\n  return parser.parseFromString(html, \"text/html\")\n}\n\nfunction createAttachmentFigure(contentType, isPreviewable, fileName) {\n  const extension = fileName ? fileName.split(\".\").pop().toLowerCase() : \"unknown\";\n  return createElement(\"figure\", {\n    className: `attachment attachment--${isPreviewable ? \"preview\" : \"file\"} attachment--${extension}`,\n    \"data-content-type\": contentType\n  })\n}\n\nfunction isPreviewableImage(contentType) {\n  return contentType.startsWith(\"image/\") && !contentType.includes(\"svg\")\n}\n\nfunction dispatchCustomEvent(element, name, detail) {\n  const event = new CustomEvent(name, {\n    detail: detail,\n    bubbles: true,\n  });\n  element.dispatchEvent(event);\n}\n\nfunction dispatch(element, eventName, detail = null, cancelable = false) {\n  return element.dispatchEvent(new CustomEvent(eventName, { bubbles: true, detail, cancelable }))\n}\n\nfunction generateDomId(prefix) {\n  const randomPart = Math.random().toString(36).slice(2, 10);\n  return `${prefix}-${randomPart}`\n}\n\nfunction highlightCode() {\n  const elements = document.querySelectorAll(\"pre[data-language]\");\n\n  elements.forEach(preElement => {\n    highlightElement(preElement);\n  });\n}\n\nfunction highlightElement(preElement) {\n  const language = preElement.getAttribute(\"data-language\");\n  let code = preElement.innerHTML.replace(/<br\\s*\\/?>/gi, \"\\n\");\n\n  const grammar = Prism.languages?.[language];\n  if (!grammar) return\n\n  // unescape HTML entities in the code block\n  code = new DOMParser().parseFromString(code, \"text/html\").body.textContent || \"\";\n\n  const highlightedHtml = Prism.highlight(code, grammar, language);\n  const codeElement = createElement(\"code\", { \"data-language\": language, innerHTML: highlightedHtml });\n  preElement.replaceWith(codeElement);\n}\n\nexport { createAttachmentFigure, createElement, dispatch, dispatchCustomEvent, generateDomId, highlightCode, isPreviewableImage, parseHtml };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $insertDataTransferForPlainText, $getHtmlContent } from '@lexical/clipboard';\nimport { DragonExtension } from '@lexical/dragon';\nimport { $shouldOverrideDefaultCharacterSelection, $moveCharacter } from '@lexical/selection';\nimport { mergeRegister, objectKlassEquals } from '@lexical/utils';\nimport { defineExtension, DELETE_CHARACTER_COMMAND, $getSelection, $isRangeSelection, COMMAND_PRIORITY_EDITOR, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, REMOVE_TEXT_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_ENTER_COMMAND, SELECT_ALL_COMMAND, $selectAll, COPY_COMMAND, CUT_COMMAND, PASTE_COMMAND, DROP_COMMAND, DRAGSTART_COMMAND, PASTE_TAG } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && IS_APPLE && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction onCopyForPlainText(event, editor) {\n  editor.update(() => {\n    if (event !== null) {\n      const clipboardData = objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;\n      const selection = $getSelection();\n      if (selection !== null && !selection.isCollapsed() && clipboardData != null) {\n        event.preventDefault();\n        const htmlString = $getHtmlContent(editor);\n        if (htmlString !== null) {\n          clipboardData.setData('text/html', htmlString);\n        }\n        clipboardData.setData('text/plain', selection.getTextContent());\n      }\n    }\n  });\n}\nfunction onPasteForPlainText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = $getSelection();\n    const clipboardData = objectKlassEquals(event, ClipboardEvent) ? event.clipboardData : null;\n    if (clipboardData != null && $isRangeSelection(selection)) {\n      $insertDataTransferForPlainText(clipboardData, selection);\n    }\n  }, {\n    tag: PASTE_TAG\n  });\n}\nfunction onCutForPlainText(event, editor) {\n  onCopyForPlainText(event, editor);\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    }\n  });\n}\nfunction registerPlainText(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if (typeof eventOrText === 'string') {\n      selection.insertText(eventOrText);\n    } else {\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        $insertDataTransferForPlainText(dataTransfer, selection);\n      } else {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    // Exception handling for iOS native behavior instead of Lexical's behavior when using Korean on iOS devices.\n    // more details - https://github.com/facebook/lexical/issues/5841\n    if (IS_IOS && navigator.language === 'ko-KR') {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n    }\n    return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {\n    $selectAll();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    onCopyForPlainText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    onCutForPlainText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    onPasteForPlainText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    // TODO: Make drag and drop work at some point.\n    event.preventDefault();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    // TODO: Make drag and drop work at some point.\n    event.preventDefault();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\n/**\n * An extension to register \\@lexical/plain-text behavior\n */\nconst PlainTextExtension = defineExtension({\n  conflictsWith: ['@lexical/rich-text'],\n  dependencies: [DragonExtension],\n  name: '@lexical/plain-text',\n  register: registerPlainText\n});\n\nexport { PlainTextExtension, registerPlainText };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalPlainText.dev.mjs';\nimport * as modProd from './LexicalPlainText.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const PlainTextExtension = mod.PlainTextExtension;\nexport const registerPlainText = mod.registerPlainText;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isParagraphNode, $isTextNode, $getRoot, $isElementNode, $isDecoratorNode, $isLineBreakNode, $getSelection, $createTextNode, $createParagraphNode, $createLineBreakNode, createState, $setState, $getState, COLLABORATION_TAG, HISTORIC_TAG, $isRangeSelection, $isRootOrShadowRoot, $createRangeSelection, $setSelection } from 'lexical';\nimport { $isListNode, $isListItemNode, ListNode, ListItemNode, $createListItemNode, $createListNode } from '@lexical/list';\nimport { $isQuoteNode, HeadingNode, QuoteNode, $createHeadingNode, $isHeadingNode, $createQuoteNode } from '@lexical/rich-text';\nimport { $findMatchingParent } from '@lexical/utils';\nimport { CodeNode, $createCodeNode, $isCodeNode } from '@lexical/code';\nimport { LinkNode, $createLinkNode, $isLinkNode, $isAutoLinkNode } from '@lexical/link';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (!key) {\n      continue;\n    }\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    multilineElement: byType['multiline-element'] || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nfunction isEmptyParagraph(node) {\n  if (!$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && $isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction createMarkdownExport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const elementTransformers = [...byType.multilineElement, ...byType.element];\n  const isNewlineDelimited = !shouldPreserveNewLines;\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1)\n  // Make sure all text transformers that contain 'code' in their format are at the end of the array. Otherwise, formatted code like\n  // <strong><code>code</code></strong> will be exported as `**Bold Code**`, as the code format will be applied first, and the bold format\n  // will be applied second and thus skipped entirely, as the code format will prevent any further formatting.\n  .sort((a, b) => {\n    return Number(a.format.includes('code')) - Number(b.format.includes('code'));\n  });\n  return node => {\n    const output = [];\n    const children = (node || $getRoot()).getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const result = exportTopLevelElements(child, elementTransformers, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(\n        // separate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n        isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? '\\n'.concat(result) : result);\n      }\n    }\n    // Ensure consecutive groups of texts are at least \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    if (!transformer.export) {\n      continue;\n    }\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if ($isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if ($isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags) {\n  const output = [];\n  const children = node.getChildren();\n  // keep track of unclosed tags from the very beginning\n  if (!unclosedTags) {\n    unclosedTags = [];\n  }\n  if (!unclosableTags) {\n    unclosableTags = [];\n  }\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      if (!transformer.export) {\n        continue;\n      }\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers, unclosedTags,\n      // Add current unclosed tags to the list of unclosable tags - we don't want nested tags from\n      // textmatch transformers to close the outer ones, as that may result in invalid markdown.\n      // E.g. **text [text**](https://lexical.io)\n      // is invalid markdown, as the closing ** is inside the link.\n      //\n      [...unclosableTags, ...unclosedTags]), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex, unclosedTags, unclosableTags));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if ($isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if ($isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex, unclosedTags, unclosableTags));\n    } else if ($isElementNode(child)) {\n      // empty paragraph returns \"\"\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags));\n    } else if ($isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers,\n// unclosed tags include the markdown tags that haven't been closed yet, and their associated formats\nunclosedTags, unclosableTags) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // If the node has no format, we use the original text.\n  // Otherwise, we escape leading and trailing whitespaces to their corresponding code points,\n  // ensuring the returned string maintains its original formatting, e.g., \"**&#32;&#32;&#32;foo&#32;&#32;&#32;**\".\n  let output = node.getFormat() === 0 ? textContent : escapeLeadingAndTrailingWhitespaces(textContent);\n  if (!node.hasFormat('code')) {\n    // Escape any markdown characters in the text content\n    output = output.replace(/([*_`~\\\\])/g, '\\\\$1');\n  }\n\n  // the opening tags to be added to the result\n  let openingTags = '';\n  // the closing tags to be added to the result\n  let closingTagsBefore = '';\n  let closingTagsAfter = '';\n  const prevNode = getTextSibling(node, true);\n  const nextNode = getTextSibling(node, false);\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    // dedup applied formats\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n\n      // append the tag to openingTags, if it's not applied to the previous nodes,\n      // or the nodes before that (which would result in an unclosed tag)\n      if (!hasFormat(prevNode, format) || !unclosedTags.find(element => element.tag === tag)) {\n        unclosedTags.push({\n          format,\n          tag\n        });\n        openingTags += tag;\n      }\n    }\n  }\n\n  // close any tags in the same order they were applied, if necessary\n  for (let i = 0; i < unclosedTags.length; i++) {\n    const nodeHasFormat = hasFormat(node, unclosedTags[i].format);\n    const nextNodeHasFormat = hasFormat(nextNode, unclosedTags[i].format);\n\n    // prevent adding closing tag if next sibling will do it\n    if (nodeHasFormat && nextNodeHasFormat) {\n      continue;\n    }\n    const unhandledUnclosedTags = [...unclosedTags]; // Shallow copy to avoid modifying the original array\n\n    while (unhandledUnclosedTags.length > i) {\n      const unclosedTag = unhandledUnclosedTags.pop();\n\n      // If tag is unclosable, don't close it and leave it in the original array,\n      // So that it can be closed when it's no longer unclosable\n      if (unclosableTags && unclosedTag && unclosableTags.find(element => element.tag === unclosedTag.tag)) {\n        continue;\n      }\n      if (unclosedTag && typeof unclosedTag.tag === 'string') {\n        if (!nodeHasFormat) {\n          // Handles cases where the tag has not been closed before, e.g. if the previous node\n          // was a text match transformer that did not account for closing tags of the next node (e.g. a link)\n          closingTagsBefore += unclosedTag.tag;\n        } else if (!nextNodeHasFormat) {\n          closingTagsAfter += unclosedTag.tag;\n        }\n      }\n      // Mutate the original array to remove the closed tag\n      unclosedTags.pop();\n    }\n    break;\n  }\n  output = openingTags + output + closingTagsAfter;\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return closingTagsBefore + output;\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if ($isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if ($isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if ($isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return $isTextNode(node) && node.hasFormat(format);\n}\nfunction escapeLeadingAndTrailingWhitespaces(textContent) {\n  return textContent.replace(/^\\s+|\\s+$/g, match => {\n    return [...match].map(char => '&#' + char.codePointAt(0) + ';').join('');\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    return null;\n  }\n  const textFormatMatchStart = match.index || 0;\n  const textFormatMatchEnd = textFormatMatchStart + match[0].length;\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  return {\n    endIndex: textFormatMatchEnd,\n    match,\n    startIndex: textFormatMatchStart,\n    transformer\n  };\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction importTextFormatTransformer(textNode, startIndex, endIndex, transformer, match) {\n  const textContent = textNode.getTextContent();\n\n  // No text matches - we can safely process the text format match\n  let transformedNode, nodeAfter, nodeBefore;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    transformedNode = textNode;\n  } else {\n    if (startIndex === 0) {\n      [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n    } else {\n      [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  transformedNode.setTextContent(match[2]);\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!transformedNode.hasFormat(format)) {\n        transformedNode.toggleFormat(format);\n      }\n    }\n  }\n  return {\n    nodeAfter: nodeAfter,\n    nodeBefore: nodeBefore,\n    transformedNode: transformedNode\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextMatchTransformer(textNode_, textMatchTransformers) {\n  const textNode = textNode_;\n  let foundMatchStartIndex = undefined;\n  let foundMatchEndIndex = undefined;\n  let foundMatchTransformer = undefined;\n  let foundMatch = undefined;\n  for (const transformer of textMatchTransformers) {\n    if (!transformer.replace || !transformer.importRegExp) {\n      continue;\n    }\n    const match = textNode.getTextContent().match(transformer.importRegExp);\n    if (!match) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = transformer.getEndIndex ? transformer.getEndIndex(textNode, match) : startIndex + match[0].length;\n    if (endIndex === false) {\n      continue;\n    }\n    if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined ||\n    // Wraps previous match or is strictly before it.\n    startIndex < foundMatchStartIndex && (endIndex > foundMatchEndIndex || endIndex <= foundMatchStartIndex)) {\n      foundMatchStartIndex = startIndex;\n      foundMatchEndIndex = endIndex;\n      foundMatchTransformer = transformer;\n      foundMatch = match;\n    }\n  }\n  if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined || foundMatchTransformer === undefined || foundMatch === undefined) {\n    return null;\n  }\n  return {\n    endIndex: foundMatchEndIndex,\n    match: foundMatch,\n    startIndex: foundMatchStartIndex,\n    transformer: foundMatchTransformer\n  };\n}\nfunction importFoundTextMatchTransformer(textNode, startIndex, endIndex, transformer, match) {\n  let transformedNode, nodeAfter, nodeBefore;\n  if (startIndex === 0) {\n    [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n  } else {\n    [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n  }\n  if (!transformer.replace) {\n    return null;\n  }\n  const potentialTransformedNode = transformer.replace(transformedNode, match);\n  return {\n    nodeAfter,\n    nodeBefore,\n    transformedNode: potentialTransformedNode || undefined\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Returns true if the node can contain transformable markdown.\n * Code nodes cannot contain transformable markdown.\n * For example, `code **bold**` should not be transformed to\n * <code>code <strong>bold</strong></code>.\n */\nfunction canContainTransformableMarkdown(node) {\n  return $isTextNode(node) && !node.hasFormat('code');\n}\n\n/**\n * Handles applying both text format and text match transformers.\n * It finds the outermost text format or text match and applies it,\n * then recursively calls itself to apply the next outermost transformer,\n * until there are no more transformers to apply.\n */\nfunction importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  let foundTextFormat = findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex);\n  let foundTextMatch = findOutermostTextMatchTransformer(textNode, textMatchTransformers);\n  if (foundTextFormat && foundTextMatch) {\n    // Find the outermost transformer\n    if (foundTextFormat.startIndex <= foundTextMatch.startIndex && foundTextFormat.endIndex >= foundTextMatch.endIndex ||\n    // foundTextMatch is not contained within foundTextFormat\n    foundTextMatch.startIndex > foundTextFormat.endIndex) {\n      // foundTextFormat wraps foundTextMatch - apply foundTextFormat by setting foundTextMatch to null\n      foundTextMatch = null;\n    } else {\n      // foundTextMatch wraps foundTextFormat - apply foundTextMatch by setting foundTextFormat to null\n      foundTextFormat = null;\n    }\n  }\n  if (foundTextFormat) {\n    const result = importTextFormatTransformer(textNode, foundTextFormat.startIndex, foundTextFormat.endIndex, foundTextFormat.transformer, foundTextFormat.match);\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  } else if (foundTextMatch) {\n    const result = importFoundTextMatchTransformer(textNode, foundTextMatch.startIndex, foundTextMatch.endIndex, foundTextMatch.transformer, foundTextMatch.match);\n    if (!result) {\n      return;\n    }\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  }\n\n  // Handle escape characters\n  const textContent = textNode.getTextContent();\n  const escapedText = textContent.replace(/\\\\([*_`~\\\\])/g, '$1').replace(/&#(\\d+);/g, (_, codePoint) => {\n    return String.fromCodePoint(codePoint);\n  });\n  textNode.setTextContent(escapedText);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction createMarkdownImport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || $getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      const [imported, shiftedIndex] = $importMultiline(lines, i, byType.multilineElement, root);\n      if (imported) {\n        // If a multiline markdown element was imported, we don't want to process the lines that were part of it anymore.\n        // There could be other sub-markdown elements (both multiline and normal ones) matching within this matched multiline element's children.\n        // However, it would be the responsibility of the matched multiline transformer to decide how it wants to handle them.\n        // We cannot handle those, as there is no way for us to know how to maintain the correct order of generated lexical nodes for possible children.\n        i = shiftedIndex; // Next loop will start from the line after the last line of the multiline element\n        continue;\n      }\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch, shouldPreserveNewLines);\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren();\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove();\n      }\n    }\n    if ($getSelection() !== null) {\n      root.selectStart();\n    }\n  };\n}\n\n/**\n *\n * @returns first element of the returned tuple is a boolean indicating if a multiline element was imported. The second element is the index of the last line that was processed.\n */\nfunction $importMultiline(lines, startLineIndex, multilineElementTransformers, rootNode) {\n  for (const transformer of multilineElementTransformers) {\n    const {\n      handleImportAfterStartMatch,\n      regExpEnd,\n      regExpStart,\n      replace\n    } = transformer;\n    const startMatch = lines[startLineIndex].match(regExpStart);\n    if (!startMatch) {\n      continue; // Try next transformer\n    }\n    if (handleImportAfterStartMatch) {\n      const result = handleImportAfterStartMatch({\n        lines,\n        rootNode,\n        startLineIndex,\n        startMatch,\n        transformer\n      });\n      if (result === null) {\n        continue;\n      } else if (result) {\n        return result;\n      }\n    }\n    const regexpEndRegex = typeof regExpEnd === 'object' && 'regExp' in regExpEnd ? regExpEnd.regExp : regExpEnd;\n    const isEndOptional = regExpEnd && typeof regExpEnd === 'object' && 'optional' in regExpEnd ? regExpEnd.optional : !regExpEnd;\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    // check every single line for the closing match. It could also be on the same line as the opening match.\n    while (endLineIndex < linesLength) {\n      const endMatch = regexpEndRegex ? lines[endLineIndex].match(regexpEndRegex) : null;\n      if (!endMatch) {\n        if (!isEndOptional || isEndOptional && endLineIndex < linesLength - 1 // Optional end, but didn't reach the end of the document yet => continue searching for potential closing match\n        ) {\n          endLineIndex++;\n          continue; // Search next line for closing match\n        }\n      }\n\n      // Now, check if the closing match matched is the same as the opening match.\n      // If it is, we need to continue searching for the actual closing match.\n      if (endMatch && startLineIndex === endLineIndex && endMatch.index === startMatch.index) {\n        endLineIndex++;\n        continue; // Search next line for closing match\n      }\n\n      // At this point, we have found the closing match. Next: calculate the lines in between open and closing match\n      // This should not include the matches themselves, and be split up by lines\n      const linesInBetween = [];\n      if (endMatch && startLineIndex === endLineIndex) {\n        linesInBetween.push(lines[startLineIndex].slice(startMatch[0].length, -endMatch[0].length));\n      } else {\n        for (let i = startLineIndex; i <= endLineIndex; i++) {\n          if (i === startLineIndex) {\n            const text = lines[i].slice(startMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else if (i === endLineIndex && endMatch) {\n            const text = lines[i].slice(0, -endMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else {\n            linesInBetween.push(lines[i]);\n          }\n        }\n      }\n      if (replace(rootNode, null, startMatch, endMatch, linesInBetween, true) !== false) {\n        // Return here. This $importMultiline function is run line by line and should only process a single multiline element at a time.\n        return [true, endLineIndex];\n      }\n\n      // The replace function returned false, despite finding the matching open and close tags => this transformer does not want to handle it.\n      // Thus, we continue letting the remaining transformers handle the passed lines of text from the beginning\n      break;\n    }\n  }\n\n  // No multiline transformer handled this line successfully\n  return [false, startLineIndex];\n}\nfunction $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers, shouldPreserveNewLines) {\n  const textNode = $createTextNode(lineText);\n  const elementNode = $createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      if (replace(elementNode, [textNode], match, true) !== false) {\n        break;\n      }\n    }\n  }\n  importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineText.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if (!shouldPreserveNewLines && (\n    // Only append if we're not preserving newlines\n    $isParagraphNode(previousNode) || $isQuoteNode(previousNode) || $isListNode(previousNode))) {\n      let targetNode = previousNode;\n      if ($isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = $findMatchingParent(lastDescendant, $isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    // Single-char tag (e.g. \"*\"),\n    if (tag.length === 1) {\n      if (tag === '`') {\n        // Special handling for backticks - match content with escaped backticks\n        fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\\\`])(\\`)((?:\\\\\\\\\\`|[^\\`])+?)(\\`)(?!\\`)`);\n      } else {\n        fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n      }\n    } else {\n      // Multi\u2010char tags (e.g. \"**\")\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<!\\\\\\\\)(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?!\\\\\\\\)`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Regexp to locate *any* potential opening tag (longest first).\n    openTagsRegExp: new RegExp(`${escapeRegExp}(${openTagsRegExp.join('|')})`, 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ORDERED_LIST_REGEX = /^(\\s*)(\\d{1,})\\.\\s/;\nconst UNORDERED_LIST_REGEX = /^(\\s*)[-*+]\\s/;\nconst CHECK_LIST_REGEX = /^(\\s*)(?:[-*+]\\s)?\\s?(\\[(\\s|x)?\\])\\s/i;\nconst HEADING_REGEX = /^(#{1,6})\\s/;\nconst QUOTE_REGEX = /^>\\s/;\nconst CODE_START_REGEX = /^[ \\t]*```([\\w-]+)?/;\nconst CODE_END_REGEX = /[ \\t]*```$/;\nconst CODE_SINGLE_LINE_REGEX = /^[ \\t]*```[^`]+(?:(?:`{1,2}|`{4,})[^`]+)*```(?:[^`]|$)/;\nconst TABLE_ROW_REG_EXP = /^(?:\\|)(.+)(?:\\|)\\s?$/;\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/;\nconst TAG_START_REGEX = /^<[a-z_][\\w-]*(?:\\s[^<>]*)?\\/?>/i;\nconst TAG_END_REGEX = /^<\\/[a-z_][\\w-]*\\s*>/i;\nconst ENDS_WITH = regex => new RegExp(`(?:${regex.source})$`, regex.flags);\nconst listMarkerState = createState('mdListMarker', {\n  parse: v => typeof v === 'string' && /^[-*+]$/.test(v) ? v : '-'\n});\nconst createBlockNode = createNode => {\n  return (parentNode, children, match, isImport) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nfunction getIndent(whitespaces) {\n  const tabs = whitespaces.match(/\\t/g);\n  const spaces = whitespaces.match(/ /g);\n  let indent = 0;\n  if (tabs) {\n    indent += tabs.length;\n  }\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);\n  }\n  return indent;\n}\nconst listReplace = listType => {\n  return (parentNode, children, match, isImport) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    const firstMatchChar = match[0].trim()[0];\n    const listMarker = (listType === 'bullet' || listType === 'check') && firstMatchChar === listMarkerState.parse(firstMatchChar) ? firstMatchChar : undefined;\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      if (listMarker) {\n        $setState(nextNode, listMarkerState, listMarker);\n      }\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      if (listMarker) {\n        $setState(previousNode, listMarkerState, listMarker);\n      }\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      if (listMarker) {\n        $setState(list, listMarkerState, listMarker);\n      }\n      list.append(listItem);\n      parentNode.replace(list);\n    }\n    listItem.append(...children);\n    if (!isImport) {\n      listItem.select(0, 0);\n    }\n    const indent = getIndent(match[1]);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst $listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if ($isListNode(firstChild)) {\n          output.push($listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const listMarker = $getState(listNode, listMarkerState);\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `${listMarker} [${listItemNode.getChecked() ? 'x' : ' '}] ` : listMarker + ' ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [HeadingNode],\n  export: (node, exportChildren) => {\n    if (!$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: HEADING_REGEX,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return $createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: QUOTE_REGEX,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [$createLineBreakNode(), ...children]);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = $createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [CodeNode],\n  export: node => {\n    if (!$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExpEnd: {\n    optional: true,\n    regExp: CODE_END_REGEX\n  },\n  regExpStart: CODE_START_REGEX,\n  replace: (rootNode, children, startMatch, endMatch, linesInBetween, isImport) => {\n    let codeBlockNode;\n    let code;\n    if (!children && linesInBetween) {\n      if (linesInBetween.length === 1) {\n        // Single-line code blocks\n        if (endMatch) {\n          // End match on same line. Example: ```markdown hello```. markdown should not be considered the language here.\n          codeBlockNode = $createCodeNode();\n          code = startMatch[1] + linesInBetween[0];\n        } else {\n          // No end match. We should assume the language is next to the backticks and that code will be typed on the next line in the future\n          codeBlockNode = $createCodeNode(startMatch[1]);\n          code = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n      } else {\n        // Treat multi-line code blocks as if they always have an end match\n        codeBlockNode = $createCodeNode(startMatch[1]);\n        if (linesInBetween[0].trim().length === 0) {\n          // Filter out all start and end lines that are length 0 until we find the first line with content\n          while (linesInBetween.length > 0 && !linesInBetween[0].length) {\n            linesInBetween.shift();\n          }\n        } else {\n          // The first line already has content => Remove the first space of the line if it exists\n          linesInBetween[0] = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n\n        // Filter out all end lines that are length 0 until we find the last line with content\n        while (linesInBetween.length > 0 && !linesInBetween[linesInBetween.length - 1].length) {\n          linesInBetween.pop();\n        }\n        code = linesInBetween.join('\\n');\n      }\n      const textNode = $createTextNode(code);\n      codeBlockNode.append(textNode);\n      rootNode.append(codeBlockNode);\n    } else if (children) {\n      createBlockNode(match => {\n        return $createCodeNode(match ? match[1] : undefined);\n      })(rootNode, children, startMatch, isImport);\n    }\n  },\n  type: 'multiline-element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? $listExport(node, exportChildren, 0) : null;\n  },\n  regExp: UNORDERED_LIST_REGEX,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? $listExport(node, exportChildren, 0) : null;\n  },\n  regExp: CHECK_LIST_REGEX,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? $listExport(node, exportChildren, 0) : null;\n  },\n  regExp: ORDERED_LIST_REGEX,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!$isLinkNode(node) || $isAutoLinkNode(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const textContent = exportChildren(node);\n    const linkContent = title ? `[${textContent}](${node.getURL()} \"${title}\")` : `[${textContent}](${node.getURL()})`;\n    return linkContent;\n  },\n  importRegExp: /(?:\\[(.+?)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[(.+?)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = $createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const openBracketAmount = linkText.split('[').length - 1;\n    const closeBracketAmount = linkText.split(']').length - 1;\n    let parsedLinkText = linkText;\n    let outsideLinkText = '';\n    if (openBracketAmount < closeBracketAmount) {\n      return;\n    } else if (openBracketAmount > closeBracketAmount) {\n      const linkTextParts = linkText.split('[');\n      outsideLinkText = '[' + linkTextParts[0];\n      parsedLinkText = linkTextParts.slice(1).join('[');\n    }\n    const linkTextNode = $createTextNode(parsedLinkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n    if (outsideLinkText) {\n      linkNode.insertBefore($createTextNode(outsideLinkText));\n    }\n    return linkTextNode;\n  },\n  trigger: ')',\n  type: 'text-match'\n};\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, UNORDERED_LIST, ORDERED_LIST];\nconst MULTILINE_ELEMENT_TRANSFORMERS = [CODE];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...MULTILINE_ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\nfunction normalizeMarkdown(input, shouldMergeAdjacentLines = false) {\n  const lines = input.split('\\n');\n  let inCodeBlock = false;\n  const sanitizedLines = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trimEnd();\n    const lastLine = sanitizedLines[sanitizedLines.length - 1];\n\n    // Code blocks of ```single line``` don't toggle the inCodeBlock flag\n    if (CODE_SINGLE_LINE_REGEX.test(line)) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // Detect the start or end of a code block\n    if (CODE_START_REGEX.test(line) || CODE_END_REGEX.test(line)) {\n      inCodeBlock = !inCodeBlock;\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // If we are inside a code block, keep the line unchanged\n    if (inCodeBlock) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // In markdown the concept of \"empty paragraphs\" does not exist.\n    // Blocks must be separated by an empty line. Non-empty adjacent lines must be merged.\n    if (line === '' || lastLine === '' || !lastLine || HEADING_REGEX.test(lastLine) || HEADING_REGEX.test(line) || QUOTE_REGEX.test(line) || ORDERED_LIST_REGEX.test(line) || UNORDERED_LIST_REGEX.test(line) || CHECK_LIST_REGEX.test(line) || TABLE_ROW_REG_EXP.test(line) || TABLE_ROW_DIVIDER_REG_EXP.test(line) || !shouldMergeAdjacentLines || TAG_START_REGEX.test(line) || TAG_END_REGEX.test(line) || ENDS_WITH(TAG_END_REGEX).test(lastLine) || ENDS_WITH(TAG_START_REGEX).test(lastLine) || CODE_END_REGEX.test(lastLine)) {\n      sanitizedLines.push(line);\n    } else {\n      sanitizedLines[sanitizedLines.length - 1] = lastLine + ' ' + line.trimStart();\n    }\n  }\n  return sanitizedLines.join('\\n');\n}\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExpStart,\n    replace,\n    regExpEnd\n  } of elementTransformers) {\n    if (regExpEnd && !('optional' in regExpEnd) || regExpEnd && 'optional' in regExpEnd && !regExpEnd.optional) {\n      continue;\n    }\n    const match = textContent.match(regExpStart);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, null, null, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    if (!transformer.replace || !transformer.regExp) {\n      continue;\n    }\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if ($isLineBreakNode(sibling)) {\n        break;\n      }\n      if ($isTextNode(sibling)) {\n        if (sibling.hasFormat('code')) {\n          continue;\n        }\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = $getSelection();\n    const nextSelection = $createRangeSelection();\n    $setSelection(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersByTrigger = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match' || type === 'multiline-element') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            formatDevErrorMessage(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const $transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {\n      return;\n    }\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has(COLLABORATION_TAG) || tags.has(HISTORIC_TAG)) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read($getSelection);\n    const prevSelection = prevEditorState.read($getSelection);\n\n    // We expect selection to be a collapsed range and not match previous one (as we want\n    // to trigger transforms only as user types)\n    if (!$isRangeSelection(prevSelection) || !$isRangeSelection(selection) || !selection.isCollapsed() || selection.is(prevSelection)) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      if (!canContainTransformableMarkdown(anchorNode)) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || $isCodeNode(parentNode)) {\n        return;\n      }\n      $transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n *\n *  @param {boolean} [shouldPreserveNewLines] By setting this to true, new lines will be preserved between conversions\n *  @param {boolean} [shouldMergeAdjacentLines] By setting this to true, adjacent non empty lines will be merged according to commonmark spec: https://spec.commonmark.org/0.24/#example-177. Not applicable if shouldPreserveNewLines = true.\n */\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false, shouldMergeAdjacentLines = false) {\n  const sanitizedMarkdown = shouldPreserveNewLines ? markdown : normalizeMarkdown(markdown, shouldMergeAdjacentLines);\n  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);\n  return importMarkdown(sanitizedMarkdown, node);\n}\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);\n  return exportMarkdown(node);\n}\n\nexport { $convertFromMarkdownString, $convertToMarkdownString, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, CHECK_LIST, CODE, ELEMENT_TRANSFORMERS, HEADING, HIGHLIGHT, INLINE_CODE, ITALIC_STAR, ITALIC_UNDERSCORE, LINK, MULTILINE_ELEMENT_TRANSFORMERS, ORDERED_LIST, QUOTE, STRIKETHROUGH, TEXT_FORMAT_TRANSFORMERS, TEXT_MATCH_TRANSFORMERS, TRANSFORMERS, UNORDERED_LIST, registerMarkdownShortcuts };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalMarkdown.dev.mjs';\nimport * as modProd from './LexicalMarkdown.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const $convertFromMarkdownString = mod.$convertFromMarkdownString;\nexport const $convertToMarkdownString = mod.$convertToMarkdownString;\nexport const BOLD_ITALIC_STAR = mod.BOLD_ITALIC_STAR;\nexport const BOLD_ITALIC_UNDERSCORE = mod.BOLD_ITALIC_UNDERSCORE;\nexport const BOLD_STAR = mod.BOLD_STAR;\nexport const BOLD_UNDERSCORE = mod.BOLD_UNDERSCORE;\nexport const CHECK_LIST = mod.CHECK_LIST;\nexport const CODE = mod.CODE;\nexport const ELEMENT_TRANSFORMERS = mod.ELEMENT_TRANSFORMERS;\nexport const HEADING = mod.HEADING;\nexport const HIGHLIGHT = mod.HIGHLIGHT;\nexport const INLINE_CODE = mod.INLINE_CODE;\nexport const ITALIC_STAR = mod.ITALIC_STAR;\nexport const ITALIC_UNDERSCORE = mod.ITALIC_UNDERSCORE;\nexport const LINK = mod.LINK;\nexport const MULTILINE_ELEMENT_TRANSFORMERS = mod.MULTILINE_ELEMENT_TRANSFORMERS;\nexport const ORDERED_LIST = mod.ORDERED_LIST;\nexport const QUOTE = mod.QUOTE;\nexport const STRIKETHROUGH = mod.STRIKETHROUGH;\nexport const TEXT_FORMAT_TRANSFORMERS = mod.TEXT_FORMAT_TRANSFORMERS;\nexport const TEXT_MATCH_TRANSFORMERS = mod.TEXT_MATCH_TRANSFORMERS;\nexport const TRANSFORMERS = mod.TRANSFORMERS;\nexport const UNORDERED_LIST = mod.UNORDERED_LIST;\nexport const registerMarkdownShortcuts = mod.registerMarkdownShortcuts;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { namedSignals, effect, batch, getPeerDependencyFromEditor } from '@lexical/extension';\nimport { mergeRegister } from '@lexical/utils';\nimport { defineExtension, safeCast, configExtension, UNDO_COMMAND, COMMAND_PRIORITY_EDITOR, REDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, HISTORIC_TAG, HISTORY_PUSH_TAG, HISTORY_MERGE_TAG, $isRangeSelection, $isTextNode, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!$isRangeSelection(nextSelection) || !$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!$isTextNode(prevDirtyNode) || !$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = $isRangeSelection(prevSelection) && $isRangeSelection(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && $isTextNode(prevNode) && $isTextNode(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delayOrStore) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has(HISTORIC_TAG)) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has(HISTORY_PUSH_TAG);\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has(HISTORY_MERGE_TAG);\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      const delay = typeof delayOrStore === 'number' ? delayOrStore : delayOrStore.peek();\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = mergeRegister(editor.registerCommand(UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n/**\n * Registers necessary listeners to manage undo/redo history stack and related\n * editor commands, via the \\@lexical/history module.\n */\n\nconst HistoryExtension = defineExtension({\n  build: (editor, {\n    delay,\n    createInitialHistoryState,\n    disabled\n  }) => namedSignals({\n    delay,\n    disabled,\n    historyState: createInitialHistoryState(editor)\n  }),\n  config: safeCast({\n    createInitialHistoryState: createEmptyHistoryState,\n    delay: 300,\n    disabled: typeof window === 'undefined'\n  }),\n  name: '@lexical/history/History',\n  register: (editor, config, state) => {\n    const stores = state.getOutput();\n    return effect(() => stores.disabled.value ? undefined : registerHistory(editor, stores.historyState.value, stores.delay));\n  }\n});\nfunction getHistoryPeer(editor) {\n  return editor ? getPeerDependencyFromEditor(editor, HistoryExtension.name) : null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related\n * editor commands, via the \\@lexical/history module, only if the parent editor\n * has a history plugin implementation.\n */\nconst SharedHistoryExtension = defineExtension({\n  dependencies: [configExtension(HistoryExtension, {\n    createInitialHistoryState: () => {\n      throw new Error('SharedHistory did not inherit parent history');\n    },\n    disabled: true\n  })],\n  name: '@lexical/history/SharedHistory',\n  register(editor, _config, state) {\n    const {\n      output\n    } = state.getDependency(HistoryExtension);\n    const parentPeer = getHistoryPeer(editor._parentEditor);\n    if (!parentPeer) {\n      return () => {};\n    }\n    const parentOutput = parentPeer.output;\n    return effect(() => batch(() => {\n      output.delay.value = parentOutput.delay.value;\n      output.historyState.value = parentOutput.historyState.value;\n      // Note that toggling the parent history will force this to be changed\n      output.disabled.value = parentOutput.disabled.value;\n    }));\n  }\n});\n\nexport { HistoryExtension, SharedHistoryExtension, createEmptyHistoryState, registerHistory };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalHistory.dev.mjs';\nimport * as modProd from './LexicalHistory.prod.mjs';\nconst mod = process.env.NODE_ENV !== 'production' ? modDev : modProd;\nexport const HistoryExtension = mod.HistoryExtension;\nexport const SharedHistoryExtension = mod.SharedHistoryExtension;\nexport const createEmptyHistoryState = mod.createEmptyHistoryState;\nexport const registerHistory = mod.registerHistory;", "import type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Gets the original marked default options.\n */\nexport function _getDefaults<ParserOutput = string, RendererOutput = string>(): MarkedOptions<ParserOutput, RendererOutput> {\n  return {\n    async: false,\n    breaks: false,\n    extensions: null,\n    gfm: true,\n    hooks: null,\n    pedantic: false,\n    renderer: null,\n    silent: false,\n    tokenizer: null,\n    walkTokens: null,\n  };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport let _defaults: MarkedOptions<any, any> = _getDefaults();\n\nexport function changeDefaults<ParserOutput = string, RendererOutput = string>(newDefaults: MarkedOptions<ParserOutput, RendererOutput>) {\n  _defaults = newDefaults;\n}\n", "const noopTest = { exec: () => null } as unknown as RegExp;\n\nfunction edit(regex: string | RegExp, opt = '') {\n  let source = typeof regex === 'string' ? regex : regex.source;\n  const obj = {\n    replace: (name: string | RegExp, val: string | RegExp) => {\n      let valSource = typeof val === 'string' ? val : val.source;\n      valSource = valSource.replace(other.caret, '$1');\n      source = source.replace(name, valSource);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(source, opt);\n    },\n  };\n  return obj;\n}\n\nconst supportsLookbehind = (() => {\ntry {\n  // eslint-disable-next-line prefer-regex-literals\n  return !!new RegExp('(?<=1)(?<!1)');\n} catch {\n  // See browser support here:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookbehind_assertion\n  return false;\n}\n})();\n\nexport const other = {\n  codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n  outputLinkReplace: /\\\\([\\[\\]])/g,\n  indentCodeCompensation: /^(\\s+)(?:```)/,\n  beginningSpace: /^\\s+/,\n  endingHash: /#$/,\n  startingSpaceChar: /^ /,\n  endingSpaceChar: / $/,\n  nonSpaceChar: /[^ ]/,\n  newLineCharGlobal: /\\n/g,\n  tabCharGlobal: /\\t/g,\n  multipleSpaceGlobal: /\\s+/g,\n  blankLine: /^[ \\t]*$/,\n  doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n  blockquoteStart: /^ {0,3}>/,\n  blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n  blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n  listReplaceTabs: /^\\t+/,\n  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n  listIsTask: /^\\[[ xX]\\] /,\n  listReplaceTask: /^\\[[ xX]\\] +/,\n  anyLine: /\\n.*\\n/,\n  hrefBrackets: /^<(.*)>$/,\n  tableDelimiter: /[:|]/,\n  tableAlignChars: /^\\||\\| *$/g,\n  tableRowBlankLine: /\\n[ \\t]*$/,\n  tableAlignRight: /^ *-+: *$/,\n  tableAlignCenter: /^ *:-+: *$/,\n  tableAlignLeft: /^ *:-+ *$/,\n  startATag: /^<a /i,\n  endATag: /^<\\/a>/i,\n  startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n  endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n  startAngleBracket: /^</,\n  endAngleBracket: />$/,\n  pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n  unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n  escapeTest: /[&<>\"']/,\n  escapeReplace: /[&<>\"']/g,\n  escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n  escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n  unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n  caret: /(^|[^\\[])\\^/g,\n  percentDecode: /%25/g,\n  findPipe: /\\|/g,\n  splitPipe: / \\|/,\n  slashPipe: /\\\\\\|/g,\n  carriageReturn: /\\r\\n|\\r/g,\n  spaceLine: /^ +$/gm,\n  notSpaceStart: /^\\S*/,\n  endingNewline: /\\n$/,\n  listItemRegex: (bull: string) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n  nextBulletRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n  hrRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n  fencesBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n  headingBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n  htmlBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n};\n\n/**\n * Block-Level Grammar\n */\n\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/\\|table/g, '') // table not in commonmark\n  .getRegex();\nconst lheadingGfm = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n  .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\[\\s\\S]|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n  .replace('label', _blockLabel)\n  .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n  .getRegex();\n\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n  .replace(/bull/g, bullet)\n  .getRegex();\n\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n  + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\n  '^ {0,3}(?:' // optional indentation\n+ '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n+ '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n+ '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n+ '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n+ '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n+ '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n+ '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n+ '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n+ ')', 'i')\n  .replace('comment', _comment)\n  .replace('tag', _tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst paragraph = edit(_paragraph)\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n  .replace('paragraph', paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nconst blockNormal = {\n  blockquote,\n  code: blockCode,\n  def,\n  fences,\n  heading,\n  hr,\n  html,\n  lheading,\n  list,\n  newline,\n  paragraph,\n  table: noopTest,\n  text: blockText,\n};\n\ntype BlockKeys = keyof typeof blockNormal;\n\n/**\n * GFM Block Grammar\n */\n\nconst gfmTable = edit(\n  '^ *([^\\\\n ].*)\\\\n' // Header\n+ ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n+ '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockGfm: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  lheading: lheadingGfm,\n  table: gfmTable,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('table', gfmTable) // interrupt paragraphs with table\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex(),\n};\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nconst blockPedantic: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', _comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', lheading)\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .replace('|tag', '')\n    .getRegex(),\n};\n\n/**\n * Inline-Level Grammar\n */\n\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n  .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = edit(/link|precode-code|html/, 'g')\n  .replace('link', /\\[(?:[^\\[\\]`]|(?<a>`+)[^`]+\\k<a>(?!`))*?\\]\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)]|\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)])*\\))*\\)/)\n  .replace('precode-', supportsLookbehind ? '(?<!`)()' : '(^^|[^`])')\n  .replace('code', /(?<b>`+)[^`]+\\k<b>(?!`)/)\n  .replace('html', /<(?! )[^<>]*?>/)\n  .getRegex();\n\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\n\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\nconst emStrongRDelimAstCore =\n  '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n+ '|[^*]+(?=[^*])' // Consume to delim\n+ '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n+ '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n+ '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n+ '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\n\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n  .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\n  '^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n+ '|[^_]+(?=[^_])' // Consume to delim\n+ '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n+ '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n+ '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n+ '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n+ '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n  .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n  .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n  .getRegex();\n\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit(\n  '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n  .replace('comment', _inlineComment)\n  .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst _inlineLabel = /(?:\\[(?:\\\\[\\s\\S]|[^\\[\\]\\\\])*\\]|\\\\[\\s\\S]|`+[^`]*?`+(?!`)|[^\\[\\]\\\\`])*?/;\n\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/)\n  .replace('label', _inlineLabel)\n  .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/)\n  .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n  .getRegex();\n\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n  .replace('label', _inlineLabel)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n  .replace('reflink', reflink)\n  .replace('nolink', nolink)\n  .getRegex();\n\nconst _caseInsensitiveProtocol = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/;\n\n/**\n * Normal Inline Grammar\n */\n\nconst inlineNormal = {\n  _backpedal: noopTest, // only used for GFM url\n  anyPunctuation,\n  autolink,\n  blockSkip,\n  br,\n  code: inlineCode,\n  del: noopTest,\n  emStrongLDelim,\n  emStrongRDelimAst,\n  emStrongRDelimUnd,\n  escape,\n  link,\n  nolink,\n  punctuation,\n  reflink,\n  reflinkSearch,\n  tag,\n  text: inlineText,\n  url: noopTest,\n};\n\ntype InlineKeys = keyof typeof inlineNormal;\n\n/**\n * Pedantic Inline Grammar\n */\n\nconst inlinePedantic: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n};\n\n/**\n * GFM Inline Grammar\n */\n\nconst inlineGfm: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  emStrongRDelimAst: emStrongRDelimAstGfm,\n  emStrongLDelim: emStrongLDelimGfm,\n  url: edit(/^((?:protocol):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/)\n    .replace('protocol', _caseInsensitiveProtocol)\n    .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n    .getRegex(),\n  _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])((?:\\\\[\\s\\S]|[^\\\\])*?(?:\\\\[\\s\\S]|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n  text: edit(/^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|protocol:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/)\n    .replace('protocol', _caseInsensitiveProtocol)\n    .getRegex(),\n};\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\nconst inlineBreaks: Record<InlineKeys, RegExp> = {\n  ...inlineGfm,\n  br: edit(br).replace('{2,}', '*').getRegex(),\n  text: edit(inlineGfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex(),\n};\n\n/**\n * exports\n */\n\nexport const block = {\n  normal: blockNormal,\n  gfm: blockGfm,\n  pedantic: blockPedantic,\n};\n\nexport const inline = {\n  normal: inlineNormal,\n  gfm: inlineGfm,\n  breaks: inlineBreaks,\n  pedantic: inlinePedantic,\n};\n\nexport interface Rules {\n  other: typeof other\n  block: Record<BlockKeys, RegExp>\n  inline: Record<InlineKeys, RegExp>\n}\n", "import { other } from './rules.ts';\n\n/**\n * Helpers\n */\nconst escapeReplacements: { [index: string]: string } = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch: string) => escapeReplacements[ch];\n\nexport function escape(html: string, encode?: boolean) {\n  if (encode) {\n    if (other.escapeTest.test(html)) {\n      return html.replace(other.escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (other.escapeTestNoEncode.test(html)) {\n      return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nexport function unescape(html: string) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(other.unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nexport function cleanUrl(href: string) {\n  try {\n    href = encodeURI(href).replace(other.percentDecode, '%');\n  } catch {\n    return null;\n  }\n  return href;\n}\n\nexport function splitCells(tableRow: string, count?: number) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n      let escaped = false;\n      let curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(other.splitPipe);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) {\n    cells.shift();\n  }\n  if (cells.length > 0 && !cells.at(-1)?.trim()) {\n    cells.pop();\n  }\n\n  if (count) {\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) cells.push('');\n    }\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str: string, c: string, invert?: boolean) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nexport function findClosingBracket(str: string, b: string) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n\n  let level = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  if (level > 0) {\n    return -2;\n  }\n\n  return -1;\n}\n", "import { _defaults } from './defaults.ts';\nimport {\n  rtrim,\n  splitCells,\n  findClosingBracket,\n} from './helpers.ts';\nimport type { Rules } from './rules.ts';\nimport type { _Lexer } from './Lexer.ts';\nimport type { Links, Tokens, Token } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\nfunction outputLink(cap: string[], link: Pick<Tokens.Link, 'href' | 'title'>, raw: string, lexer: _Lexer, rules: Rules): Tokens.Link | Tokens.Image {\n  const href = link.href;\n  const title = link.title || null;\n  const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n\n  lexer.state.inLink = true;\n  const token: Tokens.Link | Tokens.Image = {\n    type: cap[0].charAt(0) === '!' ? 'image' : 'link',\n    raw,\n    href,\n    title,\n    text,\n    tokens: lexer.inlineTokens(text),\n  };\n  lexer.state.inLink = false;\n  return token;\n}\n\nfunction indentCodeCompensation(raw: string, text: string, rules: Rules) {\n  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(rules.other.beginningSpace);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nexport class _Tokenizer<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  rules!: Rules; // set by the lexer\n  lexer!: _Lexer<ParserOutput, RendererOutput>; // set by the lexer\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  space(src: string): Tokens.Space | undefined {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0],\n      };\n    }\n  }\n\n  code(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text,\n      };\n    }\n  }\n\n  fences(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n        text,\n      };\n    }\n  }\n\n  heading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (this.rules.other.endingHash.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  hr(src: string): Tokens.Hr | undefined {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: rtrim(cap[0], '\\n'),\n      };\n    }\n  }\n\n  blockquote(src: string): Tokens.Blockquote | undefined {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      let lines = rtrim(cap[0], '\\n').split('\\n');\n      let raw = '';\n      let text = '';\n      const tokens: Token[] = [];\n\n      while (lines.length > 0) {\n        let inBlockquote = false;\n        const currentLines = [];\n\n        let i;\n        for (i = 0; i < lines.length; i++) {\n          // get lines up to a continuation\n          if (this.rules.other.blockquoteStart.test(lines[i])) {\n            currentLines.push(lines[i]);\n            inBlockquote = true;\n          } else if (!inBlockquote) {\n            currentLines.push(lines[i]);\n          } else {\n            break;\n          }\n        }\n        lines = lines.slice(i);\n\n        const currentRaw = currentLines.join('\\n');\n        const currentText = currentRaw\n          // precede setext continuation with 4 spaces so it isn't a setext\n          .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n          .replace(this.rules.other.blockquoteSetextReplace2, '');\n        raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n        text = text ? `${text}\\n${currentText}` : currentText;\n\n        // parse blockquote lines as top level tokens\n        // merge paragraphs if this is a continuation\n        const top = this.lexer.state.top;\n        this.lexer.state.top = true;\n        this.lexer.blockTokens(currentText, tokens, true);\n        this.lexer.state.top = top;\n\n        // if there is no continuation then we are done\n        if (lines.length === 0) {\n          break;\n        }\n\n        const lastToken = tokens.at(-1);\n\n        if (lastToken?.type === 'code') {\n          // blockquote continuation cannot be preceded by a code block\n          break;\n        } else if (lastToken?.type === 'blockquote') {\n          // include continuation in nested blockquote\n          const oldToken = lastToken as Tokens.Blockquote;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.blockquote(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n          break;\n        } else if (lastToken?.type === 'list') {\n          // include continuation in nested list\n          const oldToken = lastToken as Tokens.List;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.list(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n          lines = newText.substring(tokens.at(-1)!.raw.length).split('\\n');\n          continue;\n        }\n      }\n\n      return {\n        type: 'blockquote',\n        raw,\n        tokens,\n        text,\n      };\n    }\n  }\n\n  list(src: string): Tokens.List | undefined {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list: Tokens.List = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: [],\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      if (this.options.pedantic) {\n        bull = isordered ? bull : '[*+-]';\n      }\n\n      // Get next list item\n      const itemRegex = this.rules.other.listItemRegex(bull);\n      let endsWithBlankLine = false;\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        let endEarly = false;\n        let raw = '';\n        let itemContents = '';\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t: string) => ' '.repeat(3 * t.length));\n        let nextLine = src.split('\\n', 1)[0];\n        let blankLine = !line.trim();\n\n        let indent = 0;\n        if (this.options.pedantic) {\n          indent = 2;\n          itemContents = line.trimStart();\n        } else if (blankLine) {\n          indent = cap[1].length + 1;\n        } else {\n          indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n          const hrRegex = this.rules.other.hrRegex(indent);\n          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            const rawLine = src.split('\\n', 1)[0];\n            let nextLineWithoutTabs;\n            nextLine = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            if (this.options.pedantic) {\n              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n              nextLineWithoutTabs = nextLine;\n            } else {\n              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n            }\n\n            // End list item if found code fences\n            if (fencesBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new heading\n            if (headingBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of html block\n            if (htmlBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(nextLine)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(nextLine)) {\n              break;\n            }\n\n            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n              itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n            } else {\n              // not enough indentation\n              if (blankLine) {\n                break;\n              }\n\n              // paragraph continuation unless last line was a different block level element\n              if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                break;\n              }\n              if (fencesBeginRegex.test(line)) {\n                break;\n              }\n              if (headingBeginRegex.test(line)) {\n                break;\n              }\n              if (hrRegex.test(line)) {\n                break;\n              }\n\n              itemContents += '\\n' + nextLine;\n            }\n\n            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n              blankLine = true;\n            }\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n            line = nextLineWithoutTabs.slice(indent);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (this.rules.other.doubleBlankLine.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        let istask: RegExpExecArray | null = null;\n        let ischecked: boolean | undefined;\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = this.rules.other.listIsTask.exec(itemContents);\n          if (istask) {\n            ischecked = istask[0] !== '[ ] ';\n            itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!istask,\n          checked: ischecked,\n          loose: false,\n          text: itemContents,\n          tokens: [],\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      const lastItem = list.items.at(-1);\n      if (lastItem) {\n        lastItem.raw = lastItem.raw.trimEnd();\n        lastItem.text = lastItem.text.trimEnd();\n      } else {\n        // not a list since there were no items\n        return;\n      }\n      list.raw = list.raw.trimEnd();\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (let i = 0; i < list.items.length; i++) {\n        this.lexer.state.top = false;\n        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n        if (!list.loose) {\n          // Check if list should be loose\n          const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n\n          list.loose = hasMultipleLineBreaks;\n        }\n      }\n\n      // Set all items to loose if list is loose\n      if (list.loose) {\n        for (let i = 0; i < list.items.length; i++) {\n          list.items[i].loose = true;\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src: string): Tokens.HTML | undefined {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token: Tokens.HTML = {\n        type: 'html',\n        block: true,\n        raw: cap[0],\n        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n        text: cap[0],\n      };\n      return token;\n    }\n  }\n\n  def(src: string): Tokens.Def | undefined {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href,\n        title,\n      };\n    }\n  }\n\n  table(src: string): Tokens.Table | undefined {\n    const cap = this.rules.block.table.exec(src);\n    if (!cap) {\n      return;\n    }\n\n    if (!this.rules.other.tableDelimiter.test(cap[2])) {\n      // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n      return;\n    }\n\n    const headers = splitCells(cap[1]);\n    const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n    const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n\n    const item: Tokens.Table = {\n      type: 'table',\n      raw: cap[0],\n      header: [],\n      align: [],\n      rows: [],\n    };\n\n    if (headers.length !== aligns.length) {\n      // header and align columns must be equal, rows can be different.\n      return;\n    }\n\n    for (const align of aligns) {\n      if (this.rules.other.tableAlignRight.test(align)) {\n        item.align.push('right');\n      } else if (this.rules.other.tableAlignCenter.test(align)) {\n        item.align.push('center');\n      } else if (this.rules.other.tableAlignLeft.test(align)) {\n        item.align.push('left');\n      } else {\n        item.align.push(null);\n      }\n    }\n\n    for (let i = 0; i < headers.length; i++) {\n      item.header.push({\n        text: headers[i],\n        tokens: this.lexer.inline(headers[i]),\n        header: true,\n        align: item.align[i],\n      });\n    }\n\n    for (const row of rows) {\n      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n        return {\n          text: cell,\n          tokens: this.lexer.inline(cell),\n          header: false,\n          align: item.align[i],\n        };\n      }));\n    }\n\n    return item;\n  }\n\n  lheading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: this.lexer.inline(cap[1]),\n      };\n    }\n  }\n\n  paragraph(src: string): Tokens.Paragraph | undefined {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n        ? cap[1].slice(0, -1)\n        : cap[1];\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  text(src: string): Tokens.Text | undefined {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: this.lexer.inline(cap[0]),\n      };\n    }\n  }\n\n  escape(src: string): Tokens.Escape | undefined {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: cap[1],\n      };\n    }\n  }\n\n  tag(src: string): Tokens.Tag | undefined {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n        this.lexer.state.inLink = true;\n      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n        this.lexer.state.inLink = false;\n      }\n      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = true;\n      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = false;\n      }\n\n      return {\n        type: 'html',\n        raw: cap[0],\n        inLink: this.lexer.state.inLink,\n        inRawBlock: this.lexer.state.inRawBlock,\n        block: false,\n        text: cap[0],\n      };\n    }\n  }\n\n  link(src: string): Tokens.Link | Tokens.Image | undefined {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const trimmedUrl = cap[2].trim();\n      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n        // commonmark requires matching angle brackets\n        if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          return;\n        }\n\n        // ending angle bracket cannot be escaped\n        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n          return;\n        }\n      } else {\n        // find closing parenthesis\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex === -2) {\n          // more open parens than closed\n          return;\n        }\n\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        // split pedantic href and title\n        const link = this.rules.other.pedanticHrefTitle.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n\n      href = href.trim();\n      if (this.rules.other.startAngleBracket.test(href)) {\n        if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          // pedantic allows starting angle bracket without ending angle bracket\n          href = href.slice(1);\n        } else {\n          href = href.slice(1, -1);\n        }\n      }\n      return outputLink(cap, {\n        href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n        title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n      }, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  reflink(src: string, links: Links): Tokens.Link | Tokens.Image | Tokens.Text | undefined {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n      || (cap = this.rules.inline.nolink.exec(src))) {\n      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const link = links[linkString.toLowerCase()];\n      if (!link) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text,\n        };\n      }\n      return outputLink(cap, link, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  emStrong(src: string, maskedSrc: string, prevChar = ''): Tokens.Em | Tokens.Strong | undefined {\n    let match = this.rules.inline.emStrongLDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n      // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n      const lLength = [...match[0]].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = [...rDelim].length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n        // char length can be >1 for unicode characters;\n        const lastCharLength = [...match[0]][0].length;\n        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = raw.slice(1, -1);\n          return {\n            type: 'em',\n            raw,\n            text,\n            tokens: this.lexer.inlineTokens(text),\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = raw.slice(2, -2);\n        return {\n          type: 'strong',\n          raw,\n          text,\n          tokens: this.lexer.inlineTokens(text),\n        };\n      }\n    }\n  }\n\n  codespan(src: string): Tokens.Codespan | undefined {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text,\n      };\n    }\n  }\n\n  br(src: string): Tokens.Br | undefined {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0],\n      };\n    }\n  }\n\n  del(src: string): Tokens.Del | undefined {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2],\n        tokens: this.lexer.inlineTokens(cap[2]),\n      };\n    }\n  }\n\n  autolink(src: string): Tokens.Link | undefined {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[1];\n        href = 'mailto:' + text;\n      } else {\n        text = cap[1];\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  url(src: string): Tokens.Link | undefined {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[0];\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n        } while (prevCapZero !== cap[0]);\n        text = cap[0];\n        if (cap[1] === 'www.') {\n          href = 'http://' + cap[0];\n        } else {\n          href = cap[0];\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  inlineText(src: string): Tokens.Text | undefined {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      const escaped = this.lexer.state.inRawBlock;\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        escaped,\n      };\n    }\n  }\n}\n", "import { _Tokenizer } from './Tokenizer.ts';\nimport { _defaults } from './defaults.ts';\nimport { other, block, inline } from './rules.ts';\nimport type { Token, TokensList, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Block Lexer\n */\nexport class _Lexer<ParserOutput = string, RendererOutput = string> {\n  tokens: TokensList;\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  state: {\n    inLink: boolean;\n    inRawBlock: boolean;\n    top: boolean;\n  };\n\n  private tokenizer: _Tokenizer<ParserOutput, RendererOutput>;\n  private inlineQueue: { src: string, tokens: Token[] }[];\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    // TokenList cannot be created in one go\n    this.tokens = [] as unknown as TokensList;\n    this.tokens.links = Object.create(null);\n    this.options = options || _defaults;\n    this.options.tokenizer = this.options.tokenizer || new _Tokenizer<ParserOutput, RendererOutput>();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n    this.tokenizer.lexer = this;\n    this.inlineQueue = [];\n    this.state = {\n      inLink: false,\n      inRawBlock: false,\n      top: true,\n    };\n\n    const rules = {\n      other,\n      block: block.normal,\n      inline: inline.normal,\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline,\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex<ParserOutput = string, RendererOutput = string>(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const lexer = new _Lexer<ParserOutput, RendererOutput>(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline<ParserOutput = string, RendererOutput = string>(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const lexer = new _Lexer<ParserOutput, RendererOutput>(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src: string) {\n    src = src.replace(other.carriageReturn, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    for (let i = 0; i < this.inlineQueue.length; i++) {\n      const next = this.inlineQueue[i];\n      this.inlineTokens(next.src, next.tokens);\n    }\n    this.inlineQueue = [];\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src: string, tokens?: Token[], lastParagraphClipped?: boolean): Token[];\n  blockTokens(src: string, tokens?: TokensList, lastParagraphClipped?: boolean): TokensList;\n  blockTokens(src: string, tokens: Token[] = [], lastParagraphClipped = false) {\n    if (this.options.pedantic) {\n      src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n    }\n\n    while (src) {\n      let token: Tokens.Generic | undefined;\n\n      if (this.options.extensions?.block?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.raw.length === 1 && lastToken !== undefined) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unnecessary paragraph tags\n          lastToken.raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.tokenizer.def(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title,\n          };\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n        const lastToken = tokens.at(-1);\n        if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = cutSrc.length !== src.length;\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src: string, tokens: Token[] = []) {\n    this.inlineQueue.push({ src, tokens });\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src: string, tokens: Token[] = []): Token[] {\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match: RegExpExecArray | null = null;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index)\n              + '[' + 'a'.repeat(match[0].length - 2) + ']'\n              + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n\n    // Mask out escaped characters\n    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n    }\n\n    // Mask out other blocks\n    let offset;\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      offset = match[2] ? match[2].length : 0;\n      maskedSrc = maskedSrc.slice(0, match.index + offset) + '[' + 'a'.repeat(match[0].length - offset - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    // Mask out blocks from extensions\n    maskedSrc = this.options.hooks?.emStrongMask?.call({ lexer: this }, maskedSrc) ?? maskedSrc;\n\n    let keepPrevChar = false;\n    let prevChar = '';\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      let token: Tokens.Generic | undefined;\n\n      // extensions\n      if (this.options.extensions?.inline?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.type === 'text' && lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.tokenizer.inlineText(cutSrc)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n}\n", "import { _defaults } from './defaults.ts';\nimport {\n  cleanUrl,\n  escape,\n} from './helpers.ts';\nimport { other } from './rules.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Tokens } from './Tokens.ts';\nimport type { _Parser } from './Parser.ts';\n\n/**\n * Renderer\n */\nexport class _Renderer<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  parser!: _Parser<ParserOutput, RendererOutput>; // set by the parser\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  space(token: Tokens.Space): RendererOutput {\n    return '' as RendererOutput;\n  }\n\n  code({ text, lang, escaped }: Tokens.Code): RendererOutput {\n    const langString = (lang || '').match(other.notSpaceStart)?.[0];\n\n    const code = text.replace(other.endingNewline, '') + '\\n';\n\n    if (!langString) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n' as RendererOutput;\n    }\n\n    return '<pre><code class=\"language-'\n      + escape(langString)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n' as RendererOutput;\n  }\n\n  blockquote({ tokens }: Tokens.Blockquote): RendererOutput {\n    const body = this.parser.parse(tokens);\n    return `<blockquote>\\n${body}</blockquote>\\n` as RendererOutput;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  def(token: Tokens.Def): RendererOutput {\n    return '' as RendererOutput;\n  }\n\n  heading({ tokens, depth }: Tokens.Heading): RendererOutput {\n    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n` as RendererOutput;\n  }\n\n  hr(token: Tokens.Hr): RendererOutput {\n    return '<hr>\\n' as RendererOutput;\n  }\n\n  list(token: Tokens.List): RendererOutput {\n    const ordered = token.ordered;\n    const start = token.start;\n\n    let body = '';\n    for (let j = 0; j < token.items.length; j++) {\n      const item = token.items[j];\n      body += this.listitem(item);\n    }\n\n    const type = ordered ? 'ol' : 'ul';\n    const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n' as RendererOutput;\n  }\n\n  listitem(item: Tokens.ListItem): RendererOutput {\n    let itemBody = '';\n    if (item.task) {\n      const checkbox = this.checkbox({ checked: !!item.checked });\n      if (item.loose) {\n        if (item.tokens[0]?.type === 'paragraph') {\n          item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n            item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n            item.tokens[0].tokens[0].escaped = true;\n          }\n        } else {\n          item.tokens.unshift({\n            type: 'text',\n            raw: checkbox + ' ',\n            text: checkbox + ' ',\n            escaped: true,\n          });\n        }\n      } else {\n        itemBody += checkbox + ' ';\n      }\n    }\n\n    itemBody += this.parser.parse(item.tokens, !!item.loose);\n\n    return `<li>${itemBody}</li>\\n` as RendererOutput;\n  }\n\n  checkbox({ checked }: Tokens.Checkbox): RendererOutput {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\">' as RendererOutput;\n  }\n\n  paragraph({ tokens }: Tokens.Paragraph): RendererOutput {\n    return `<p>${this.parser.parseInline(tokens)}</p>\\n` as RendererOutput;\n  }\n\n  table(token: Tokens.Table): RendererOutput {\n    let header = '';\n\n    // header\n    let cell = '';\n    for (let j = 0; j < token.header.length; j++) {\n      cell += this.tablecell(token.header[j]);\n    }\n    header += this.tablerow({ text: cell as ParserOutput });\n\n    let body = '';\n    for (let j = 0; j < token.rows.length; j++) {\n      const row = token.rows[j];\n\n      cell = '';\n      for (let k = 0; k < row.length; k++) {\n        cell += this.tablecell(row[k]);\n      }\n\n      body += this.tablerow({ text: cell as ParserOutput });\n    }\n    if (body) body = `<tbody>${body}</tbody>`;\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n' as RendererOutput;\n  }\n\n  tablerow({ text }: Tokens.TableRow<ParserOutput>): RendererOutput {\n    return `<tr>\\n${text}</tr>\\n` as RendererOutput;\n  }\n\n  tablecell(token: Tokens.TableCell): RendererOutput {\n    const content = this.parser.parseInline(token.tokens);\n    const type = token.header ? 'th' : 'td';\n    const tag = token.align\n      ? `<${type} align=\"${token.align}\">`\n      : `<${type}>`;\n    return tag + content + `</${type}>\\n` as RendererOutput;\n  }\n\n  /**\n   * span level renderer\n   */\n  strong({ tokens }: Tokens.Strong): RendererOutput {\n    return `<strong>${this.parser.parseInline(tokens)}</strong>` as RendererOutput;\n  }\n\n  em({ tokens }: Tokens.Em): RendererOutput {\n    return `<em>${this.parser.parseInline(tokens)}</em>` as RendererOutput;\n  }\n\n  codespan({ text }: Tokens.Codespan): RendererOutput {\n    return `<code>${escape(text, true)}</code>` as RendererOutput;\n  }\n\n  br(token: Tokens.Br): RendererOutput {\n    return '<br>' as RendererOutput;\n  }\n\n  del({ tokens }: Tokens.Del): RendererOutput {\n    return `<del>${this.parser.parseInline(tokens)}</del>` as RendererOutput;\n  }\n\n  link({ href, title, tokens }: Tokens.Link): RendererOutput {\n    const text = this.parser.parseInline(tokens) as string;\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return text as RendererOutput;\n    }\n    href = cleanHref;\n    let out = '<a href=\"' + href + '\"';\n    if (title) {\n      out += ' title=\"' + (escape(title)) + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out as RendererOutput;\n  }\n\n  image({ href, title, text, tokens }: Tokens.Image): RendererOutput {\n    if (tokens) {\n      text = this.parser.parseInline(tokens, this.parser.textRenderer) as string;\n    }\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return escape(text) as RendererOutput;\n    }\n    href = cleanHref;\n\n    let out = `<img src=\"${href}\" alt=\"${text}\"`;\n    if (title) {\n      out += ` title=\"${escape(title)}\"`;\n    }\n    out += '>';\n    return out as RendererOutput;\n  }\n\n  text(token: Tokens.Text | Tokens.Escape): RendererOutput {\n    return 'tokens' in token && token.tokens\n      ? this.parser.parseInline(token.tokens) as unknown as RendererOutput\n      : ('escaped' in token && token.escaped ? token.text as RendererOutput : escape(token.text) as RendererOutput);\n  }\n}\n", "import type { Tokens } from './Tokens.ts';\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer<RendererOutput = string> {\n  // no need for block level renderers\n  strong({ text }: Tokens.Strong): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  em({ text }: Tokens.Em): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  codespan({ text }: Tokens.Codespan): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  del({ text }: Tokens.Del): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  text({ text }: Tokens.Text | Tokens.Escape | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  link({ text }: Tokens.Link): RendererOutput {\n    return '' + text as RendererOutput;\n  }\n\n  image({ text }: Tokens.Image): RendererOutput {\n    return '' + text as RendererOutput;\n  }\n\n  br(): RendererOutput {\n    return '' as RendererOutput;\n  }\n}\n", "import { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _defaults } from './defaults.ts';\nimport type { MarkedToken, Token, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Parsing & Compiling\n */\nexport class _Parser<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  renderer: _Renderer<ParserOutput, RendererOutput>;\n  textRenderer: _TextRenderer<RendererOutput>;\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n    this.options.renderer = this.options.renderer || new _Renderer<ParserOutput, RendererOutput>();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.renderer.parser = this;\n    this.textRenderer = new _TextRenderer<RendererOutput>();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse<ParserOutput = string, RendererOutput = string>(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const parser = new _Parser<ParserOutput, RendererOutput>(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline<ParserOutput = string, RendererOutput = string>(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const parser = new _Parser<ParserOutput, RendererOutput>(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens: Token[], top = true): ParserOutput {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const genericToken = anyToken as Tokens.Generic;\n        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'def', 'paragraph', 'text'].includes(genericToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'space': {\n          out += this.renderer.space(token);\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr(token);\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(token);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token);\n          continue;\n        }\n        case 'table': {\n          out += this.renderer.table(token);\n          continue;\n        }\n        case 'blockquote': {\n          out += this.renderer.blockquote(token);\n          continue;\n        }\n        case 'list': {\n          out += this.renderer.list(token);\n          continue;\n        }\n        case 'html': {\n          out += this.renderer.html(token);\n          continue;\n        }\n        case 'def': {\n          out += this.renderer.def(token);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(token);\n          continue;\n        }\n        case 'text': {\n          let textToken = token;\n          let body = this.renderer.text(textToken) as string;\n          while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n            textToken = tokens[++i] as Tokens.Text;\n            body += ('\\n' + this.renderer.text(textToken));\n          }\n          if (top) {\n            out += this.renderer.paragraph({\n              type: 'paragraph',\n              raw: body,\n              text: body,\n              tokens: [{ type: 'text', raw: body, text: body, escaped: true }],\n            });\n          } else {\n            out += body;\n          }\n          continue;\n        }\n\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '' as ParserOutput;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out as ParserOutput;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens: Token[], renderer: _Renderer<ParserOutput, RendererOutput> | _TextRenderer<RendererOutput> = this.renderer): ParserOutput {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token);\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(token);\n          break;\n        }\n        case 'em': {\n          out += renderer.em(token);\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token);\n          break;\n        }\n        case 'br': {\n          out += renderer.br(token);\n          break;\n        }\n        case 'del': {\n          out += renderer.del(token);\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '' as ParserOutput;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out as ParserOutput;\n  }\n}\n", "import { _defaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\n\nexport class _Hooks<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  block?: boolean;\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  static passThroughHooks = new Set([\n    'preprocess',\n    'postprocess',\n    'processAllTokens',\n    'emStrongMask',\n  ]);\n\n  static passThroughHooksRespectAsync = new Set([\n    'preprocess',\n    'postprocess',\n    'processAllTokens',\n  ]);\n\n  /**\n   * Process markdown before marked\n   */\n  preprocess(markdown: string) {\n    return markdown;\n  }\n\n  /**\n   * Process HTML after marked is finished\n   */\n  postprocess(html: ParserOutput) {\n    return html;\n  }\n\n  /**\n   * Process all tokens before walk tokens\n   */\n  processAllTokens(tokens: Token[] | TokensList) {\n    return tokens;\n  }\n\n  /**\n   * Mask contents that should not be interpreted as em/strong delimiters\n   */\n  emStrongMask(src: string) {\n    return src;\n  }\n\n  /**\n   * Provide function to tokenize markdown\n   */\n  provideLexer() {\n    return this.block ? _Lexer.lex : _Lexer.lexInline;\n  }\n\n  /**\n   * Provide function to parse tokens\n   */\n  provideParser() {\n    return this.block ? _Parser.parse<ParserOutput, RendererOutput> : _Parser.parseInline<ParserOutput, RendererOutput>;\n  }\n}\n", "import { _getDefaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { escape } from './helpers.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, Tokens, TokensList } from './Tokens.ts';\n\nexport type MaybePromise = void | Promise<void>;\n\ntype UnknownFunction = (...args: unknown[]) => unknown;\ntype GenericRendererFunction = (...args: unknown[]) => string | false;\n\nexport class Marked<ParserOutput = string, RendererOutput = string> {\n  defaults = _getDefaults<ParserOutput, RendererOutput>();\n  options = this.setOptions;\n\n  parse = this.parseMarkdown(true);\n  parseInline = this.parseMarkdown(false);\n\n  Parser = _Parser<ParserOutput, RendererOutput>;\n  Renderer = _Renderer<ParserOutput, RendererOutput>;\n  TextRenderer = _TextRenderer<RendererOutput>;\n  Lexer = _Lexer;\n  Tokenizer = _Tokenizer<ParserOutput, RendererOutput>;\n  Hooks = _Hooks<ParserOutput, RendererOutput>;\n\n  constructor(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {\n    this.use(...args);\n  }\n\n  /**\n   * Run callback for every token\n   */\n  walkTokens(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n    let values: MaybePromise[] = [];\n    for (const token of tokens) {\n      values = values.concat(callback.call(this, token));\n      switch (token.type) {\n        case 'table': {\n          const tableToken = token as Tokens.Table;\n          for (const cell of tableToken.header) {\n            values = values.concat(this.walkTokens(cell.tokens, callback));\n          }\n          for (const row of tableToken.rows) {\n            for (const cell of row) {\n              values = values.concat(this.walkTokens(cell.tokens, callback));\n            }\n          }\n          break;\n        }\n        case 'list': {\n          const listToken = token as Tokens.List;\n          values = values.concat(this.walkTokens(listToken.items, callback));\n          break;\n        }\n        default: {\n          const genericToken = token as Tokens.Generic;\n          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n              const tokens = genericToken[childTokens].flat(Infinity) as Token[] | TokensList;\n              values = values.concat(this.walkTokens(tokens, callback));\n            });\n          } else if (genericToken.tokens) {\n            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n          }\n        }\n      }\n    }\n    return values;\n  }\n\n  use(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {\n    const extensions: MarkedOptions<ParserOutput, RendererOutput>['extensions'] = this.defaults.extensions || { renderers: {}, childTokens: {} };\n\n    args.forEach((pack) => {\n      // copy options to new object\n      const opts = { ...pack } as MarkedOptions<ParserOutput, RendererOutput>;\n\n      // set async to true if it was set to true before\n      opts.async = this.defaults.async || opts.async || false;\n\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        pack.extensions.forEach((ext) => {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n          if ('renderer' in ext) { // Renderer extensions\n            const prevRenderer = extensions.renderers[ext.name];\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function(...args) {\n                let ret = ext.renderer.apply(this, args);\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n          if ('tokenizer' in ext) { // Tokenizer Extensions\n            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n            const extLevel = extensions[ext.level];\n            if (extLevel) {\n              extLevel.unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n            if (ext.start) { // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n          if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n        opts.extensions = extensions;\n      }\n\n      // ==-- Parse \"overwrite\" extensions --== //\n      if (pack.renderer) {\n        const renderer = this.defaults.renderer || new _Renderer<ParserOutput, RendererOutput>(this.defaults);\n        for (const prop in pack.renderer) {\n          if (!(prop in renderer)) {\n            throw new Error(`renderer '${prop}' does not exist`);\n          }\n          if (['options', 'parser'].includes(prop)) {\n            // ignore options property\n            continue;\n          }\n          const rendererProp = prop as Exclude<keyof _Renderer<ParserOutput, RendererOutput>, 'options' | 'parser'>;\n          const rendererFunc = pack.renderer[rendererProp] as GenericRendererFunction;\n          const prevRenderer = renderer[rendererProp] as GenericRendererFunction;\n          // Replace renderer with func to run extension, but fall back if false\n          renderer[rendererProp] = (...args: unknown[]) => {\n            let ret = rendererFunc.apply(renderer, args);\n            if (ret === false) {\n              ret = prevRenderer.apply(renderer, args);\n            }\n            return (ret || '') as RendererOutput;\n          };\n        }\n        opts.renderer = renderer;\n      }\n      if (pack.tokenizer) {\n        const tokenizer = this.defaults.tokenizer || new _Tokenizer<ParserOutput, RendererOutput>(this.defaults);\n        for (const prop in pack.tokenizer) {\n          if (!(prop in tokenizer)) {\n            throw new Error(`tokenizer '${prop}' does not exist`);\n          }\n          if (['options', 'rules', 'lexer'].includes(prop)) {\n            // ignore options, rules, and lexer properties\n            continue;\n          }\n          const tokenizerProp = prop as Exclude<keyof _Tokenizer<ParserOutput, RendererOutput>, 'options' | 'rules' | 'lexer'>;\n          const tokenizerFunc = pack.tokenizer[tokenizerProp] as UnknownFunction;\n          const prevTokenizer = tokenizer[tokenizerProp] as UnknownFunction;\n          // Replace tokenizer with func to run extension, but fall back if false\n          // @ts-expect-error cannot type tokenizer function dynamically\n          tokenizer[tokenizerProp] = (...args: unknown[]) => {\n            let ret = tokenizerFunc.apply(tokenizer, args);\n            if (ret === false) {\n              ret = prevTokenizer.apply(tokenizer, args);\n            }\n            return ret;\n          };\n        }\n        opts.tokenizer = tokenizer;\n      }\n\n      // ==-- Parse Hooks extensions --== //\n      if (pack.hooks) {\n        const hooks = this.defaults.hooks || new _Hooks<ParserOutput, RendererOutput>();\n        for (const prop in pack.hooks) {\n          if (!(prop in hooks)) {\n            throw new Error(`hook '${prop}' does not exist`);\n          }\n          if (['options', 'block'].includes(prop)) {\n            // ignore options and block properties\n            continue;\n          }\n          const hooksProp = prop as Exclude<keyof _Hooks<ParserOutput, RendererOutput>, 'options' | 'block'>;\n          const hooksFunc = pack.hooks[hooksProp] as UnknownFunction;\n          const prevHook = hooks[hooksProp] as UnknownFunction;\n          if (_Hooks.passThroughHooks.has(prop)) {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (arg: unknown) => {\n              if (this.defaults.async && _Hooks.passThroughHooksRespectAsync.has(prop)) {\n                return (async() => {\n                  const ret = await hooksFunc.call(hooks, arg);\n                  return prevHook.call(hooks, ret);\n                })();\n              }\n\n              const ret = hooksFunc.call(hooks, arg);\n              return prevHook.call(hooks, ret);\n            };\n          } else {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (...args: unknown[]) => {\n              if (this.defaults.async) {\n                return (async() => {\n                  let ret = await hooksFunc.apply(hooks, args);\n                  if (ret === false) {\n                    ret = await prevHook.apply(hooks, args);\n                  }\n                  return ret;\n                })();\n              }\n\n              let ret = hooksFunc.apply(hooks, args);\n              if (ret === false) {\n                ret = prevHook.apply(hooks, args);\n              }\n              return ret;\n            };\n          }\n        }\n        opts.hooks = hooks;\n      }\n\n      // ==-- Parse WalkTokens extensions --== //\n      if (pack.walkTokens) {\n        const walkTokens = this.defaults.walkTokens;\n        const packWalktokens = pack.walkTokens;\n        opts.walkTokens = function(token) {\n          let values: MaybePromise[] = [];\n          values.push(packWalktokens.call(this, token));\n          if (walkTokens) {\n            values = values.concat(walkTokens.call(this, token));\n          }\n          return values;\n        };\n      }\n\n      this.defaults = { ...this.defaults, ...opts };\n    });\n\n    return this;\n  }\n\n  setOptions(opt: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.defaults = { ...this.defaults, ...opt };\n    return this;\n  }\n\n  lexer(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    return _Lexer.lex(src, options ?? this.defaults);\n  }\n\n  parser(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    return _Parser.parse<ParserOutput, RendererOutput>(tokens, options ?? this.defaults);\n  }\n\n  private parseMarkdown(blockType: boolean) {\n    type overloadedParse = {\n      (src: string, options: MarkedOptions<ParserOutput, RendererOutput> & { async: true }): Promise<ParserOutput>;\n      (src: string, options: MarkedOptions<ParserOutput, RendererOutput> & { async: false }): ParserOutput;\n      (src: string, options?: MarkedOptions<ParserOutput, RendererOutput> | null): ParserOutput | Promise<ParserOutput>;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const parse: overloadedParse = (src: string, options?: MarkedOptions<ParserOutput, RendererOutput> | null): any => {\n      const origOpt = { ...options };\n      const opt = { ...this.defaults, ...origOpt };\n\n      const throwError = this.onError(!!opt.silent, !!opt.async);\n\n      // throw error if an extension set async to true but parse was called with async: false\n      if (this.defaults.async === true && origOpt.async === false) {\n        return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n      }\n\n      // throw error in case of non string input\n      if (typeof src === 'undefined' || src === null) {\n        return throwError(new Error('marked(): input parameter is undefined or null'));\n      }\n      if (typeof src !== 'string') {\n        return throwError(new Error('marked(): input parameter is of type '\n          + Object.prototype.toString.call(src) + ', string expected'));\n      }\n\n      if (opt.hooks) {\n        opt.hooks.options = opt;\n        opt.hooks.block = blockType;\n      }\n\n      if (opt.async) {\n        return (async() => {\n          const processedSrc = opt.hooks ? await opt.hooks.preprocess(src) : src;\n          const lexer = opt.hooks ? await opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n          const tokens = await lexer(processedSrc, opt);\n          const processedTokens = opt.hooks ? await opt.hooks.processAllTokens(tokens) : tokens;\n          if (opt.walkTokens) {\n            await Promise.all(this.walkTokens(processedTokens, opt.walkTokens));\n          }\n          const parser = opt.hooks ? await opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n          const html = await parser(processedTokens, opt);\n          return opt.hooks ? await opt.hooks.postprocess(html) : html;\n        })().catch(throwError);\n      }\n\n      try {\n        if (opt.hooks) {\n          src = opt.hooks.preprocess(src) as string;\n        }\n        const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n        let tokens = lexer(src, opt);\n        if (opt.hooks) {\n          tokens = opt.hooks.processAllTokens(tokens);\n        }\n        if (opt.walkTokens) {\n          this.walkTokens(tokens, opt.walkTokens);\n        }\n        const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n        let html = parser(tokens, opt);\n        if (opt.hooks) {\n          html = opt.hooks.postprocess(html);\n        }\n        return html;\n      } catch(e) {\n        return throwError(e as Error);\n      }\n    };\n\n    return parse;\n  }\n\n  private onError(silent: boolean, async: boolean) {\n    return (e: Error): string | Promise<string> => {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (silent) {\n        const msg = '<p>An error occurred:</p><pre>'\n          + escape(e.message + '', true)\n          + '</pre>';\n        if (async) {\n          return Promise.resolve(msg);\n        }\n        return msg;\n      }\n\n      if (async) {\n        return Promise.reject(e);\n      }\n      throw e;\n    };\n  }\n}\n", "import { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { Marked } from './Instance.ts';\nimport {\n  _getDefaults,\n  changeDefaults,\n  _defaults,\n} from './defaults.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\nimport type { MaybePromise } from './Instance.ts';\n\nconst markedInstance = new Marked();\n\n/**\n * Compiles markdown to HTML asynchronously.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options, having async: true\n * @return Promise of string of compiled HTML\n */\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\n\n/**\n * Compiles markdown to HTML.\n *\n * @param src String of markdown source to be compiled\n * @param options Optional hash of options\n * @return String of compiled HTML. Will be a Promise of string if async is set to true by any extensions.\n */\nexport function marked(src: string, options: MarkedOptions & { async: false }): string;\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\nexport function marked(src: string, options?: MarkedOptions | null): string | Promise<string>;\nexport function marked(src: string, opt?: MarkedOptions | null): string | Promise<string> {\n  return markedInstance.parse(src, opt);\n}\n\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\nmarked.setOptions = function(options: MarkedOptions) {\n  markedInstance.setOptions(options);\n  marked.defaults = markedInstance.defaults;\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\n\nmarked.defaults = _defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(...args: MarkedExtension[]) {\n  markedInstance.use(...args);\n  marked.defaults = markedInstance.defaults;\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n  return markedInstance.walkTokens(tokens, callback);\n};\n\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\n\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport { _defaults as defaults, _getDefaults as getDefaults } from './defaults.ts';\nexport { _Lexer as Lexer } from './Lexer.ts';\nexport { _Parser as Parser } from './Parser.ts';\nexport { _Tokenizer as Tokenizer } from './Tokenizer.ts';\nexport { _Renderer as Renderer } from './Renderer.ts';\nexport { _TextRenderer as TextRenderer } from './TextRenderer.ts';\nexport { _Hooks as Hooks } from './Hooks.ts';\nexport { Marked } from './Instance.ts';\nexport type * from './MarkedOptions.ts';\nexport type * from './Tokens.ts';\n", "/*\nLesli\n\nCopyright (c) 2025, Lesli Technologies, S. A.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program. If not, see http://www.gnu.org/licenses/.\n\nLesli \u00B7 Ruby on Rails SaaS Development Framework.\n\nMade with \u2665 by LesliTech\nBuilding a better future, one line of code at a time.\n\n@contact  hello@lesli.tech\n@website  https://www.lesli.tech\n@license  GPLv3 http://www.gnu.org/licenses/gpl-3.0.en.html\n\n// \u00B7 ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~\n// \u00B7 \n*/\n\n\n// \u00B7 Import Rails dependencies\n// \u00B7 ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~\nimport \"@hotwired/turbo\"\nimport \"@37signals/lexxy\"\n\n\n// \u00B7 Import Lesli dependencies \n// \u00B7 ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~\nimport dayjs from \"dayjs\";\nimport Alpine from \"alpinejs\";\nimport ChartJs from \"chart.js/auto\";\nimport LesliChart from \"./lesli_chart\";\nimport debug from \"lesli-js/debug/browser\";\n\n\n// \u00B7 Make libs globally available\n// \u00B7 ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~\nwindow.dayjs = dayjs\nwindow.debug = debug\nwindow.Alpine = Alpine\nwindow.ChartJs = ChartJs\nwindow.LesliChart = LesliChart\n\n\n// \u00B7 Init needed frameworks\n// \u00B7 ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~\nAlpine.start()\n\n\n// \u00B7 Print a nice message to let the people know Lesli is running\n// \u00B7 ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~     ~\u00B7~\n// console.clear()\n// debug.lesli_message_warning(\"lesli?.company?.name\") \n// debug.info(\"Lesli application\", \"lesli_application_version\") \ndebug.info(\"Ruby on Rails SaaS Development Framework\", \"Lesli\") \n", "// packages/alpinejs/src/scheduler.js\nvar flushPending = false;\nvar flushing = false;\nvar queue = [];\nvar lastFlushedIndex = -1;\nfunction scheduler(callback) {\n  queueJob(callback);\n}\nfunction queueJob(job) {\n  if (!queue.includes(job))\n    queue.push(job);\n  queueFlush();\n}\nfunction dequeueJob(job) {\n  let index = queue.indexOf(job);\n  if (index !== -1 && index > lastFlushedIndex)\n    queue.splice(index, 1);\n}\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n    queueMicrotask(flushJobs);\n  }\n}\nfunction flushJobs() {\n  flushPending = false;\n  flushing = true;\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n    lastFlushedIndex = i;\n  }\n  queue.length = 0;\n  lastFlushedIndex = -1;\n  flushing = false;\n}\n\n// packages/alpinejs/src/reactivity.js\nvar reactive;\nvar effect;\nvar release;\nvar raw;\nvar shouldSchedule = true;\nfunction disableEffectScheduling(callback) {\n  shouldSchedule = false;\n  callback();\n  shouldSchedule = true;\n}\nfunction setReactivityEngine(engine) {\n  reactive = engine.reactive;\n  release = engine.release;\n  effect = (callback) => engine.effect(callback, { scheduler: (task) => {\n    if (shouldSchedule) {\n      scheduler(task);\n    } else {\n      task();\n    }\n  } });\n  raw = engine.raw;\n}\nfunction overrideEffect(override) {\n  effect = override;\n}\nfunction elementBoundEffect(el) {\n  let cleanup2 = () => {\n  };\n  let wrappedEffect = (callback) => {\n    let effectReference = effect(callback);\n    if (!el._x_effects) {\n      el._x_effects = /* @__PURE__ */ new Set();\n      el._x_runEffects = () => {\n        el._x_effects.forEach((i) => i());\n      };\n    }\n    el._x_effects.add(effectReference);\n    cleanup2 = () => {\n      if (effectReference === void 0)\n        return;\n      el._x_effects.delete(effectReference);\n      release(effectReference);\n    };\n    return effectReference;\n  };\n  return [wrappedEffect, () => {\n    cleanup2();\n  }];\n}\nfunction watch(getter, callback) {\n  let firstTime = true;\n  let oldValue;\n  let effectReference = effect(() => {\n    let value = getter();\n    JSON.stringify(value);\n    if (!firstTime) {\n      queueMicrotask(() => {\n        callback(value, oldValue);\n        oldValue = value;\n      });\n    } else {\n      oldValue = value;\n    }\n    firstTime = false;\n  });\n  return () => release(effectReference);\n}\n\n// packages/alpinejs/src/mutation.js\nvar onAttributeAddeds = [];\nvar onElRemoveds = [];\nvar onElAddeds = [];\nfunction onElAdded(callback) {\n  onElAddeds.push(callback);\n}\nfunction onElRemoved(el, callback) {\n  if (typeof callback === \"function\") {\n    if (!el._x_cleanups)\n      el._x_cleanups = [];\n    el._x_cleanups.push(callback);\n  } else {\n    callback = el;\n    onElRemoveds.push(callback);\n  }\n}\nfunction onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\nfunction onAttributeRemoved(el, name, callback) {\n  if (!el._x_attributeCleanups)\n    el._x_attributeCleanups = {};\n  if (!el._x_attributeCleanups[name])\n    el._x_attributeCleanups[name] = [];\n  el._x_attributeCleanups[name].push(callback);\n}\nfunction cleanupAttributes(el, names) {\n  if (!el._x_attributeCleanups)\n    return;\n  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\n    if (names === void 0 || names.includes(name)) {\n      value.forEach((i) => i());\n      delete el._x_attributeCleanups[name];\n    }\n  });\n}\nfunction cleanupElement(el) {\n  el._x_effects?.forEach(dequeueJob);\n  while (el._x_cleanups?.length)\n    el._x_cleanups.pop()();\n}\nvar observer = new MutationObserver(onMutate);\nvar currentlyObserving = false;\nfunction startObservingMutations() {\n  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });\n  currentlyObserving = true;\n}\nfunction stopObservingMutations() {\n  flushObserver();\n  observer.disconnect();\n  currentlyObserving = false;\n}\nvar queuedMutations = [];\nfunction flushObserver() {\n  let records = observer.takeRecords();\n  queuedMutations.push(() => records.length > 0 && onMutate(records));\n  let queueLengthWhenTriggered = queuedMutations.length;\n  queueMicrotask(() => {\n    if (queuedMutations.length === queueLengthWhenTriggered) {\n      while (queuedMutations.length > 0)\n        queuedMutations.shift()();\n    }\n  });\n}\nfunction mutateDom(callback) {\n  if (!currentlyObserving)\n    return callback();\n  stopObservingMutations();\n  let result = callback();\n  startObservingMutations();\n  return result;\n}\nvar isCollecting = false;\nvar deferredMutations = [];\nfunction deferMutations() {\n  isCollecting = true;\n}\nfunction flushAndStopDeferringMutations() {\n  isCollecting = false;\n  onMutate(deferredMutations);\n  deferredMutations = [];\n}\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n    return;\n  }\n  let addedNodes = [];\n  let removedNodes = /* @__PURE__ */ new Set();\n  let addedAttributes = /* @__PURE__ */ new Map();\n  let removedAttributes = /* @__PURE__ */ new Map();\n  for (let i = 0; i < mutations.length; i++) {\n    if (mutations[i].target._x_ignoreMutationObserver)\n      continue;\n    if (mutations[i].type === \"childList\") {\n      mutations[i].removedNodes.forEach((node) => {\n        if (node.nodeType !== 1)\n          return;\n        if (!node._x_marker)\n          return;\n        removedNodes.add(node);\n      });\n      mutations[i].addedNodes.forEach((node) => {\n        if (node.nodeType !== 1)\n          return;\n        if (removedNodes.has(node)) {\n          removedNodes.delete(node);\n          return;\n        }\n        if (node._x_marker)\n          return;\n        addedNodes.push(node);\n      });\n    }\n    if (mutations[i].type === \"attributes\") {\n      let el = mutations[i].target;\n      let name = mutations[i].attributeName;\n      let oldValue = mutations[i].oldValue;\n      let add2 = () => {\n        if (!addedAttributes.has(el))\n          addedAttributes.set(el, []);\n        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });\n      };\n      let remove = () => {\n        if (!removedAttributes.has(el))\n          removedAttributes.set(el, []);\n        removedAttributes.get(el).push(name);\n      };\n      if (el.hasAttribute(name) && oldValue === null) {\n        add2();\n      } else if (el.hasAttribute(name)) {\n        remove();\n        add2();\n      } else {\n        remove();\n      }\n    }\n  }\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach((i) => i(el, attrs));\n  });\n  for (let node of removedNodes) {\n    if (addedNodes.some((i) => i.contains(node)))\n      continue;\n    onElRemoveds.forEach((i) => i(node));\n  }\n  for (let node of addedNodes) {\n    if (!node.isConnected)\n      continue;\n    onElAddeds.forEach((i) => i(node));\n  }\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n}\n\n// packages/alpinejs/src/scope.js\nfunction scope(node) {\n  return mergeProxies(closestDataStack(node));\n}\nfunction addScopeToNode(node, data2, referenceNode) {\n  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];\n  return () => {\n    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);\n  };\n}\nfunction closestDataStack(node) {\n  if (node._x_dataStack)\n    return node._x_dataStack;\n  if (typeof ShadowRoot === \"function\" && node instanceof ShadowRoot) {\n    return closestDataStack(node.host);\n  }\n  if (!node.parentNode) {\n    return [];\n  }\n  return closestDataStack(node.parentNode);\n}\nfunction mergeProxies(objects) {\n  return new Proxy({ objects }, mergeProxyTrap);\n}\nvar mergeProxyTrap = {\n  ownKeys({ objects }) {\n    return Array.from(\n      new Set(objects.flatMap((i) => Object.keys(i)))\n    );\n  },\n  has({ objects }, name) {\n    if (name == Symbol.unscopables)\n      return false;\n    return objects.some(\n      (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)\n    );\n  },\n  get({ objects }, name, thisProxy) {\n    if (name == \"toJSON\")\n      return collapseProxies;\n    return Reflect.get(\n      objects.find(\n        (obj) => Reflect.has(obj, name)\n      ) || {},\n      name,\n      thisProxy\n    );\n  },\n  set({ objects }, name, value, thisProxy) {\n    const target = objects.find(\n      (obj) => Object.prototype.hasOwnProperty.call(obj, name)\n    ) || objects[objects.length - 1];\n    const descriptor = Object.getOwnPropertyDescriptor(target, name);\n    if (descriptor?.set && descriptor?.get)\n      return descriptor.set.call(thisProxy, value) || true;\n    return Reflect.set(target, name, value);\n  }\n};\nfunction collapseProxies() {\n  let keys = Reflect.ownKeys(this);\n  return keys.reduce((acc, key) => {\n    acc[key] = Reflect.get(this, key);\n    return acc;\n  }, {});\n}\n\n// packages/alpinejs/src/interceptor.js\nfunction initInterceptors(data2) {\n  let isObject2 = (val) => typeof val === \"object\" && !Array.isArray(val) && val !== null;\n  let recurse = (obj, basePath = \"\") => {\n    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {\n      if (enumerable === false || value === void 0)\n        return;\n      if (typeof value === \"object\" && value !== null && value.__v_skip)\n        return;\n      let path = basePath === \"\" ? key : `${basePath}.${key}`;\n      if (typeof value === \"object\" && value !== null && value._x_interceptor) {\n        obj[key] = value.initialize(data2, path, key);\n      } else {\n        if (isObject2(value) && value !== obj && !(value instanceof Element)) {\n          recurse(value, path);\n        }\n      }\n    });\n  };\n  return recurse(data2);\n}\nfunction interceptor(callback, mutateObj = () => {\n}) {\n  let obj = {\n    initialValue: void 0,\n    _x_interceptor: true,\n    initialize(data2, path, key) {\n      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);\n    }\n  };\n  mutateObj(obj);\n  return (initialValue) => {\n    if (typeof initialValue === \"object\" && initialValue !== null && initialValue._x_interceptor) {\n      let initialize = obj.initialize.bind(obj);\n      obj.initialize = (data2, path, key) => {\n        let innerValue = initialValue.initialize(data2, path, key);\n        obj.initialValue = innerValue;\n        return initialize(data2, path, key);\n      };\n    } else {\n      obj.initialValue = initialValue;\n    }\n    return obj;\n  };\n}\nfunction get(obj, path) {\n  return path.split(\".\").reduce((carry, segment) => carry[segment], obj);\n}\nfunction set(obj, path, value) {\n  if (typeof path === \"string\")\n    path = path.split(\".\");\n  if (path.length === 1)\n    obj[path[0]] = value;\n  else if (path.length === 0)\n    throw error;\n  else {\n    if (obj[path[0]])\n      return set(obj[path[0]], path.slice(1), value);\n    else {\n      obj[path[0]] = {};\n      return set(obj[path[0]], path.slice(1), value);\n    }\n  }\n}\n\n// packages/alpinejs/src/magics.js\nvar magics = {};\nfunction magic(name, callback) {\n  magics[name] = callback;\n}\nfunction injectMagics(obj, el) {\n  let memoizedUtilities = getUtilities(el);\n  Object.entries(magics).forEach(([name, callback]) => {\n    Object.defineProperty(obj, `$${name}`, {\n      get() {\n        return callback(el, memoizedUtilities);\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\nfunction getUtilities(el) {\n  let [utilities, cleanup2] = getElementBoundUtilities(el);\n  let utils = { interceptor, ...utilities };\n  onElRemoved(el, cleanup2);\n  return utils;\n}\n\n// packages/alpinejs/src/utils/error.js\nfunction tryCatch(el, expression, callback, ...args) {\n  try {\n    return callback(...args);\n  } catch (e) {\n    handleError(e, el, expression);\n  }\n}\nfunction handleError(error2, el, expression = void 0) {\n  error2 = Object.assign(\n    error2 ?? { message: \"No error message given.\" },\n    { el, expression }\n  );\n  console.warn(`Alpine Expression Error: ${error2.message}\n\n${expression ? 'Expression: \"' + expression + '\"\\n\\n' : \"\"}`, el);\n  setTimeout(() => {\n    throw error2;\n  }, 0);\n}\n\n// packages/alpinejs/src/evaluator.js\nvar shouldAutoEvaluateFunctions = true;\nfunction dontAutoEvaluateFunctions(callback) {\n  let cache = shouldAutoEvaluateFunctions;\n  shouldAutoEvaluateFunctions = false;\n  let result = callback();\n  shouldAutoEvaluateFunctions = cache;\n  return result;\n}\nfunction evaluate(el, expression, extras = {}) {\n  let result;\n  evaluateLater(el, expression)((value) => result = value, extras);\n  return result;\n}\nfunction evaluateLater(...args) {\n  return theEvaluatorFunction(...args);\n}\nvar theEvaluatorFunction = normalEvaluator;\nfunction setEvaluator(newEvaluator) {\n  theEvaluatorFunction = newEvaluator;\n}\nfunction normalEvaluator(el, expression) {\n  let overriddenMagics = {};\n  injectMagics(overriddenMagics, el);\n  let dataStack = [overriddenMagics, ...closestDataStack(el)];\n  let evaluator = typeof expression === \"function\" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);\n  return tryCatch.bind(null, el, expression, evaluator);\n}\nfunction generateEvaluatorFromFunction(dataStack, func) {\n  return (receiver = () => {\n  }, { scope: scope2 = {}, params = [] } = {}) => {\n    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);\n    runIfTypeOfFunction(receiver, result);\n  };\n}\nvar evaluatorMemo = {};\nfunction generateFunctionFromString(expression, el) {\n  if (evaluatorMemo[expression]) {\n    return evaluatorMemo[expression];\n  }\n  let AsyncFunction = Object.getPrototypeOf(async function() {\n  }).constructor;\n  let rightSideSafeExpression = /^[\\n\\s]*if.*\\(.*\\)/.test(expression.trim()) || /^(let|const)\\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;\n  const safeAsyncFunction = () => {\n    try {\n      let func2 = new AsyncFunction(\n        [\"__self\", \"scope\"],\n        `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`\n      );\n      Object.defineProperty(func2, \"name\", {\n        value: `[Alpine] ${expression}`\n      });\n      return func2;\n    } catch (error2) {\n      handleError(error2, el, expression);\n      return Promise.resolve();\n    }\n  };\n  let func = safeAsyncFunction();\n  evaluatorMemo[expression] = func;\n  return func;\n}\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n  let func = generateFunctionFromString(expression, el);\n  return (receiver = () => {\n  }, { scope: scope2 = {}, params = [] } = {}) => {\n    func.result = void 0;\n    func.finished = false;\n    let completeScope = mergeProxies([scope2, ...dataStack]);\n    if (typeof func === \"function\") {\n      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));\n      if (func.finished) {\n        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);\n        func.result = void 0;\n      } else {\n        promise.then((result) => {\n          runIfTypeOfFunction(receiver, result, completeScope, params, el);\n        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);\n      }\n    }\n  };\n}\nfunction runIfTypeOfFunction(receiver, value, scope2, params, el) {\n  if (shouldAutoEvaluateFunctions && typeof value === \"function\") {\n    let result = value.apply(scope2, params);\n    if (result instanceof Promise) {\n      result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));\n    } else {\n      receiver(result);\n    }\n  } else if (typeof value === \"object\" && value instanceof Promise) {\n    value.then((i) => receiver(i));\n  } else {\n    receiver(value);\n  }\n}\n\n// packages/alpinejs/src/directives.js\nvar prefixAsString = \"x-\";\nfunction prefix(subject = \"\") {\n  return prefixAsString + subject;\n}\nfunction setPrefix(newPrefix) {\n  prefixAsString = newPrefix;\n}\nvar directiveHandlers = {};\nfunction directive(name, callback) {\n  directiveHandlers[name] = callback;\n  return {\n    before(directive2) {\n      if (!directiveHandlers[directive2]) {\n        console.warn(String.raw`Cannot find directive \\`${directive2}\\`. \\`${name}\\` will use the default order of execution`);\n        return;\n      }\n      const pos = directiveOrder.indexOf(directive2);\n      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf(\"DEFAULT\"), 0, name);\n    }\n  };\n}\nfunction directiveExists(name) {\n  return Object.keys(directiveHandlers).includes(name);\n}\nfunction directives(el, attributes, originalAttributeOverride) {\n  attributes = Array.from(attributes);\n  if (el._x_virtualDirectives) {\n    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));\n    let staticAttributes = attributesOnly(vAttributes);\n    vAttributes = vAttributes.map((attribute) => {\n      if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n        return {\n          name: `x-bind:${attribute.name}`,\n          value: `\"${attribute.value}\"`\n        };\n      }\n      return attribute;\n    });\n    attributes = attributes.concat(vAttributes);\n  }\n  let transformedAttributeMap = {};\n  let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);\n  return directives2.map((directive2) => {\n    return getDirectiveHandler(el, directive2);\n  });\n}\nfunction attributesOnly(attributes) {\n  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));\n}\nvar isDeferringHandlers = false;\nvar directiveHandlerStacks = /* @__PURE__ */ new Map();\nvar currentHandlerStackKey = Symbol();\nfunction deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n  let key = Symbol();\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n  let flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length)\n      directiveHandlerStacks.get(key).shift()();\n    directiveHandlerStacks.delete(key);\n  };\n  let stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n  callback(flushHandlers);\n  stopDeferring();\n}\nfunction getElementBoundUtilities(el) {\n  let cleanups = [];\n  let cleanup2 = (callback) => cleanups.push(callback);\n  let [effect3, cleanupEffect] = elementBoundEffect(el);\n  cleanups.push(cleanupEffect);\n  let utilities = {\n    Alpine: alpine_default,\n    effect: effect3,\n    cleanup: cleanup2,\n    evaluateLater: evaluateLater.bind(evaluateLater, el),\n    evaluate: evaluate.bind(evaluate, el)\n  };\n  let doCleanup = () => cleanups.forEach((i) => i());\n  return [utilities, doCleanup];\n}\nfunction getDirectiveHandler(el, directive2) {\n  let noop = () => {\n  };\n  let handler4 = directiveHandlers[directive2.type] || noop;\n  let [utilities, cleanup2] = getElementBoundUtilities(el);\n  onAttributeRemoved(el, directive2.original, cleanup2);\n  let fullHandler = () => {\n    if (el._x_ignore || el._x_ignoreSelf)\n      return;\n    handler4.inline && handler4.inline(el, directive2, utilities);\n    handler4 = handler4.bind(handler4, el, directive2, utilities);\n    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();\n  };\n  fullHandler.runCleanups = cleanup2;\n  return fullHandler;\n}\nvar startingWith = (subject, replacement) => ({ name, value }) => {\n  if (name.startsWith(subject))\n    name = name.replace(subject, replacement);\n  return { name, value };\n};\nvar into = (i) => i;\nfunction toTransformedAttributes(callback = () => {\n}) {\n  return ({ name, value }) => {\n    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {\n      return transform(carry);\n    }, { name, value });\n    if (newName !== name)\n      callback(newName, name);\n    return { name: newName, value: newValue };\n  };\n}\nvar attributeTransformers = [];\nfunction mapAttributes(callback) {\n  attributeTransformers.push(callback);\n}\nfunction outNonAlpineAttributes({ name }) {\n  return alpineAttributeRegex().test(name);\n}\nvar alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`);\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n  return ({ name, value }) => {\n    let typeMatch = name.match(alpineAttributeRegex());\n    let valueMatch = name.match(/:([a-zA-Z0-9\\-_:]+)/);\n    let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    let original = originalAttributeOverride || transformedAttributeMap[name] || name;\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map((i) => i.replace(\".\", \"\")),\n      expression: value,\n      original\n    };\n  };\n}\nvar DEFAULT = \"DEFAULT\";\nvar directiveOrder = [\n  \"ignore\",\n  \"ref\",\n  \"data\",\n  \"id\",\n  \"anchor\",\n  \"bind\",\n  \"init\",\n  \"for\",\n  \"model\",\n  \"modelable\",\n  \"transition\",\n  \"show\",\n  \"if\",\n  DEFAULT,\n  \"teleport\"\n];\nfunction byPriority(a, b) {\n  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;\n  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;\n  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n}\n\n// packages/alpinejs/src/utils/dispatch.js\nfunction dispatch(el, name, detail = {}) {\n  el.dispatchEvent(\n    new CustomEvent(name, {\n      detail,\n      bubbles: true,\n      // Allows events to pass the shadow DOM barrier.\n      composed: true,\n      cancelable: true\n    })\n  );\n}\n\n// packages/alpinejs/src/utils/walk.js\nfunction walk(el, callback) {\n  if (typeof ShadowRoot === \"function\" && el instanceof ShadowRoot) {\n    Array.from(el.children).forEach((el2) => walk(el2, callback));\n    return;\n  }\n  let skip = false;\n  callback(el, () => skip = true);\n  if (skip)\n    return;\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n\n// packages/alpinejs/src/utils/warn.js\nfunction warn(message, ...args) {\n  console.warn(`Alpine Warning: ${message}`, ...args);\n}\n\n// packages/alpinejs/src/lifecycle.js\nvar started = false;\nfunction start() {\n  if (started)\n    warn(\"Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.\");\n  started = true;\n  if (!document.body)\n    warn(\"Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?\");\n  dispatch(document, \"alpine:init\");\n  dispatch(document, \"alpine:initializing\");\n  startObservingMutations();\n  onElAdded((el) => initTree(el, walk));\n  onElRemoved((el) => destroyTree(el));\n  onAttributesAdded((el, attrs) => {\n    directives(el, attrs).forEach((handle) => handle());\n  });\n  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);\n  Array.from(document.querySelectorAll(allSelectors().join(\",\"))).filter(outNestedComponents).forEach((el) => {\n    initTree(el);\n  });\n  dispatch(document, \"alpine:initialized\");\n  setTimeout(() => {\n    warnAboutMissingPlugins();\n  });\n}\nvar rootSelectorCallbacks = [];\nvar initSelectorCallbacks = [];\nfunction rootSelectors() {\n  return rootSelectorCallbacks.map((fn) => fn());\n}\nfunction allSelectors() {\n  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());\n}\nfunction addRootSelector(selectorCallback) {\n  rootSelectorCallbacks.push(selectorCallback);\n}\nfunction addInitSelector(selectorCallback) {\n  initSelectorCallbacks.push(selectorCallback);\n}\nfunction closestRoot(el, includeInitSelectors = false) {\n  return findClosest(el, (element) => {\n    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();\n    if (selectors.some((selector) => element.matches(selector)))\n      return true;\n  });\n}\nfunction findClosest(el, callback) {\n  if (!el)\n    return;\n  if (callback(el))\n    return el;\n  if (el._x_teleportBack)\n    el = el._x_teleportBack;\n  if (!el.parentElement)\n    return;\n  return findClosest(el.parentElement, callback);\n}\nfunction isRoot(el) {\n  return rootSelectors().some((selector) => el.matches(selector));\n}\nvar initInterceptors2 = [];\nfunction interceptInit(callback) {\n  initInterceptors2.push(callback);\n}\nvar markerDispenser = 1;\nfunction initTree(el, walker = walk, intercept = () => {\n}) {\n  if (findClosest(el, (i) => i._x_ignore))\n    return;\n  deferHandlingDirectives(() => {\n    walker(el, (el2, skip) => {\n      if (el2._x_marker)\n        return;\n      intercept(el2, skip);\n      initInterceptors2.forEach((i) => i(el2, skip));\n      directives(el2, el2.attributes).forEach((handle) => handle());\n      if (!el2._x_ignore)\n        el2._x_marker = markerDispenser++;\n      el2._x_ignore && skip();\n    });\n  });\n}\nfunction destroyTree(root, walker = walk) {\n  walker(root, (el) => {\n    cleanupElement(el);\n    cleanupAttributes(el);\n    delete el._x_marker;\n  });\n}\nfunction warnAboutMissingPlugins() {\n  let pluginDirectives = [\n    [\"ui\", \"dialog\", [\"[x-dialog], [x-popover]\"]],\n    [\"anchor\", \"anchor\", [\"[x-anchor]\"]],\n    [\"sort\", \"sort\", [\"[x-sort]\"]]\n  ];\n  pluginDirectives.forEach(([plugin2, directive2, selectors]) => {\n    if (directiveExists(directive2))\n      return;\n    selectors.some((selector) => {\n      if (document.querySelector(selector)) {\n        warn(`found \"${selector}\", but missing ${plugin2} plugin`);\n        return true;\n      }\n    });\n  });\n}\n\n// packages/alpinejs/src/nextTick.js\nvar tickStack = [];\nvar isHolding = false;\nfunction nextTick(callback = () => {\n}) {\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks();\n    });\n  });\n  return new Promise((res) => {\n    tickStack.push(() => {\n      callback();\n      res();\n    });\n  });\n}\nfunction releaseNextTicks() {\n  isHolding = false;\n  while (tickStack.length)\n    tickStack.shift()();\n}\nfunction holdNextTicks() {\n  isHolding = true;\n}\n\n// packages/alpinejs/src/utils/classes.js\nfunction setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  } else if (typeof value === \"function\") {\n    return setClasses(el, value());\n  }\n  return setClassesFromString(el, value);\n}\nfunction setClassesFromString(el, classString) {\n  let split = (classString2) => classString2.split(\" \").filter(Boolean);\n  let missingClasses = (classString2) => classString2.split(\" \").filter((i) => !el.classList.contains(i)).filter(Boolean);\n  let addClassesAndReturnUndo = (classes) => {\n    el.classList.add(...classes);\n    return () => {\n      el.classList.remove(...classes);\n    };\n  };\n  classString = classString === true ? classString = \"\" : classString || \"\";\n  return addClassesAndReturnUndo(missingClasses(classString));\n}\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);\n  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);\n  let added = [];\n  let removed = [];\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n\n// packages/alpinejs/src/utils/styles.js\nfunction setStyles(el, value) {\n  if (typeof value === \"object\" && value !== null) {\n    return setStylesFromObject(el, value);\n  }\n  return setStylesFromString(el, value);\n}\nfunction setStylesFromObject(el, value) {\n  let previousStyles = {};\n  Object.entries(value).forEach(([key, value2]) => {\n    previousStyles[key] = el.style[key];\n    if (!key.startsWith(\"--\")) {\n      key = kebabCase(key);\n    }\n    el.style.setProperty(key, value2);\n  });\n  setTimeout(() => {\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  });\n  return () => {\n    setStyles(el, previousStyles);\n  };\n}\nfunction setStylesFromString(el, value) {\n  let cache = el.getAttribute(\"style\", value);\n  el.setAttribute(\"style\", value);\n  return () => {\n    el.setAttribute(\"style\", cache || \"\");\n  };\n}\nfunction kebabCase(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n// packages/alpinejs/src/utils/once.js\nfunction once(callback, fallback = () => {\n}) {\n  let called = false;\n  return function() {\n    if (!called) {\n      called = true;\n      callback.apply(this, arguments);\n    } else {\n      fallback.apply(this, arguments);\n    }\n  };\n}\n\n// packages/alpinejs/src/directives/x-transition.js\ndirective(\"transition\", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {\n  if (typeof expression === \"function\")\n    expression = evaluate2(expression);\n  if (expression === false)\n    return;\n  if (!expression || typeof expression === \"boolean\") {\n    registerTransitionsFromHelper(el, modifiers, value);\n  } else {\n    registerTransitionsFromClassString(el, expression, value);\n  }\n});\nfunction registerTransitionsFromClassString(el, classString, stage) {\n  registerTransitionObject(el, setClasses, \"\");\n  let directiveStorageMap = {\n    \"enter\": (classes) => {\n      el._x_transition.enter.during = classes;\n    },\n    \"enter-start\": (classes) => {\n      el._x_transition.enter.start = classes;\n    },\n    \"enter-end\": (classes) => {\n      el._x_transition.enter.end = classes;\n    },\n    \"leave\": (classes) => {\n      el._x_transition.leave.during = classes;\n    },\n    \"leave-start\": (classes) => {\n      el._x_transition.leave.start = classes;\n    },\n    \"leave-end\": (classes) => {\n      el._x_transition.leave.end = classes;\n    }\n  };\n  directiveStorageMap[stage](classString);\n}\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n  registerTransitionObject(el, setStyles);\n  let doesntSpecify = !modifiers.includes(\"in\") && !modifiers.includes(\"out\") && !stage;\n  let transitioningIn = doesntSpecify || modifiers.includes(\"in\") || [\"enter\"].includes(stage);\n  let transitioningOut = doesntSpecify || modifiers.includes(\"out\") || [\"leave\"].includes(stage);\n  if (modifiers.includes(\"in\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf(\"out\"));\n  }\n  if (modifiers.includes(\"out\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf(\"out\"));\n  }\n  let wantsAll = !modifiers.includes(\"opacity\") && !modifiers.includes(\"scale\");\n  let wantsOpacity = wantsAll || modifiers.includes(\"opacity\");\n  let wantsScale = wantsAll || modifiers.includes(\"scale\");\n  let opacityValue = wantsOpacity ? 0 : 1;\n  let scaleValue = wantsScale ? modifierValue(modifiers, \"scale\", 95) / 100 : 1;\n  let delay = modifierValue(modifiers, \"delay\", 0) / 1e3;\n  let origin = modifierValue(modifiers, \"origin\", \"center\");\n  let property = \"opacity, transform\";\n  let durationIn = modifierValue(modifiers, \"duration\", 150) / 1e3;\n  let durationOut = modifierValue(modifiers, \"duration\", 75) / 1e3;\n  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n  if (transitioningIn) {\n    el._x_transition.enter.during = {\n      transformOrigin: origin,\n      transitionDelay: `${delay}s`,\n      transitionProperty: property,\n      transitionDuration: `${durationIn}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.enter.start = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n    el._x_transition.enter.end = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n  }\n  if (transitioningOut) {\n    el._x_transition.leave.during = {\n      transformOrigin: origin,\n      transitionDelay: `${delay}s`,\n      transitionProperty: property,\n      transitionDuration: `${durationOut}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.leave.start = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n    el._x_transition.leave.end = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n  }\n}\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\n  if (!el._x_transition)\n    el._x_transition = {\n      enter: { during: defaultValue, start: defaultValue, end: defaultValue },\n      leave: { during: defaultValue, start: defaultValue, end: defaultValue },\n      in(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.enter.during,\n          start: this.enter.start,\n          end: this.enter.end\n        }, before, after);\n      },\n      out(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.leave.during,\n          start: this.leave.start,\n          end: this.leave.end\n        }, before, after);\n      }\n    };\n}\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {\n  const nextTick2 = document.visibilityState === \"visible\" ? requestAnimationFrame : setTimeout;\n  let clickAwayCompatibleShow = () => nextTick2(show);\n  if (value) {\n    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    } else {\n      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    }\n    return;\n  }\n  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {\n    el._x_transition.out(() => {\n    }, () => resolve(hide));\n    el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));\n  }) : Promise.resolve(hide);\n  queueMicrotask(() => {\n    let closest = closestHide(el);\n    if (closest) {\n      if (!closest._x_hideChildren)\n        closest._x_hideChildren = [];\n      closest._x_hideChildren.push(el);\n    } else {\n      nextTick2(() => {\n        let hideAfterChildren = (el2) => {\n          let carry = Promise.all([\n            el2._x_hidePromise,\n            ...(el2._x_hideChildren || []).map(hideAfterChildren)\n          ]).then(([i]) => i?.());\n          delete el2._x_hidePromise;\n          delete el2._x_hideChildren;\n          return carry;\n        };\n        hideAfterChildren(el).catch((e) => {\n          if (!e.isFromCancelledTransition)\n            throw e;\n        });\n      });\n    }\n  });\n};\nfunction closestHide(el) {\n  let parent = el.parentNode;\n  if (!parent)\n    return;\n  return parent._x_hidePromise ? parent : closestHide(parent);\n}\nfunction transition(el, setFunction, { during, start: start2, end } = {}, before = () => {\n}, after = () => {\n}) {\n  if (el._x_transitioning)\n    el._x_transitioning.cancel();\n  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {\n    before();\n    after();\n    return;\n  }\n  let undoStart, undoDuring, undoEnd;\n  performTransition(el, {\n    start() {\n      undoStart = setFunction(el, start2);\n    },\n    during() {\n      undoDuring = setFunction(el, during);\n    },\n    before,\n    end() {\n      undoStart();\n      undoEnd = setFunction(el, end);\n    },\n    after,\n    cleanup() {\n      undoDuring();\n      undoEnd();\n    }\n  });\n}\nfunction performTransition(el, stages) {\n  let interrupted, reachedBefore, reachedEnd;\n  let finish = once(() => {\n    mutateDom(() => {\n      interrupted = true;\n      if (!reachedBefore)\n        stages.before();\n      if (!reachedEnd) {\n        stages.end();\n        releaseNextTicks();\n      }\n      stages.after();\n      if (el.isConnected)\n        stages.cleanup();\n      delete el._x_transitioning;\n    });\n  });\n  el._x_transitioning = {\n    beforeCancels: [],\n    beforeCancel(callback) {\n      this.beforeCancels.push(callback);\n    },\n    cancel: once(function() {\n      while (this.beforeCancels.length) {\n        this.beforeCancels.shift()();\n      }\n      ;\n      finish();\n    }),\n    finish\n  };\n  mutateDom(() => {\n    stages.start();\n    stages.during();\n  });\n  holdNextTicks();\n  requestAnimationFrame(() => {\n    if (interrupted)\n      return;\n    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    if (duration === 0)\n      duration = Number(getComputedStyle(el).animationDuration.replace(\"s\", \"\")) * 1e3;\n    mutateDom(() => {\n      stages.before();\n    });\n    reachedBefore = true;\n    requestAnimationFrame(() => {\n      if (interrupted)\n        return;\n      mutateDom(() => {\n        stages.end();\n      });\n      releaseNextTicks();\n      setTimeout(el._x_transitioning.finish, duration + delay);\n      reachedEnd = true;\n    });\n  });\n}\nfunction modifierValue(modifiers, key, fallback) {\n  if (modifiers.indexOf(key) === -1)\n    return fallback;\n  const rawValue = modifiers[modifiers.indexOf(key) + 1];\n  if (!rawValue)\n    return fallback;\n  if (key === \"scale\") {\n    if (isNaN(rawValue))\n      return fallback;\n  }\n  if (key === \"duration\" || key === \"delay\") {\n    let match = rawValue.match(/([0-9]+)ms/);\n    if (match)\n      return match[1];\n  }\n  if (key === \"origin\") {\n    if ([\"top\", \"right\", \"left\", \"center\", \"bottom\"].includes(modifiers[modifiers.indexOf(key) + 2])) {\n      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(\" \");\n    }\n  }\n  return rawValue;\n}\n\n// packages/alpinejs/src/clone.js\nvar isCloning = false;\nfunction skipDuringClone(callback, fallback = () => {\n}) {\n  return (...args) => isCloning ? fallback(...args) : callback(...args);\n}\nfunction onlyDuringClone(callback) {\n  return (...args) => isCloning && callback(...args);\n}\nvar interceptors = [];\nfunction interceptClone(callback) {\n  interceptors.push(callback);\n}\nfunction cloneNode(from, to) {\n  interceptors.forEach((i) => i(from, to));\n  isCloning = true;\n  dontRegisterReactiveSideEffects(() => {\n    initTree(to, (el, callback) => {\n      callback(el, () => {\n      });\n    });\n  });\n  isCloning = false;\n}\nvar isCloningLegacy = false;\nfunction clone(oldEl, newEl) {\n  if (!newEl._x_dataStack)\n    newEl._x_dataStack = oldEl._x_dataStack;\n  isCloning = true;\n  isCloningLegacy = true;\n  dontRegisterReactiveSideEffects(() => {\n    cloneTree(newEl);\n  });\n  isCloning = false;\n  isCloningLegacy = false;\n}\nfunction cloneTree(el) {\n  let hasRunThroughFirstEl = false;\n  let shallowWalker = (el2, callback) => {\n    walk(el2, (el3, skip) => {\n      if (hasRunThroughFirstEl && isRoot(el3))\n        return skip();\n      hasRunThroughFirstEl = true;\n      callback(el3, skip);\n    });\n  };\n  initTree(el, shallowWalker);\n}\nfunction dontRegisterReactiveSideEffects(callback) {\n  let cache = effect;\n  overrideEffect((callback2, el) => {\n    let storedEffect = cache(callback2);\n    release(storedEffect);\n    return () => {\n    };\n  });\n  callback();\n  overrideEffect(cache);\n}\n\n// packages/alpinejs/src/utils/bind.js\nfunction bind(el, name, value, modifiers = []) {\n  if (!el._x_bindings)\n    el._x_bindings = reactive({});\n  el._x_bindings[name] = value;\n  name = modifiers.includes(\"camel\") ? camelCase(name) : name;\n  switch (name) {\n    case \"value\":\n      bindInputValue(el, value);\n      break;\n    case \"style\":\n      bindStyles(el, value);\n      break;\n    case \"class\":\n      bindClasses(el, value);\n      break;\n    case \"selected\":\n    case \"checked\":\n      bindAttributeAndProperty(el, name, value);\n      break;\n    default:\n      bindAttribute(el, name, value);\n      break;\n  }\n}\nfunction bindInputValue(el, value) {\n  if (isRadio(el)) {\n    if (el.attributes.value === void 0) {\n      el.value = value;\n    }\n    if (window.fromModel) {\n      if (typeof value === \"boolean\") {\n        el.checked = safeParseBoolean(el.value) === value;\n      } else {\n        el.checked = checkedAttrLooseCompare(el.value, value);\n      }\n    }\n  } else if (isCheckbox(el)) {\n    if (Number.isInteger(value)) {\n      el.value = value;\n    } else if (!Array.isArray(value) && typeof value !== \"boolean\" && ![null, void 0].includes(value)) {\n      el.value = String(value);\n    } else {\n      if (Array.isArray(value)) {\n        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));\n      } else {\n        el.checked = !!value;\n      }\n    }\n  } else if (el.tagName === \"SELECT\") {\n    updateSelect(el, value);\n  } else {\n    if (el.value === value)\n      return;\n    el.value = value === void 0 ? \"\" : value;\n  }\n}\nfunction bindClasses(el, value) {\n  if (el._x_undoAddedClasses)\n    el._x_undoAddedClasses();\n  el._x_undoAddedClasses = setClasses(el, value);\n}\nfunction bindStyles(el, value) {\n  if (el._x_undoAddedStyles)\n    el._x_undoAddedStyles();\n  el._x_undoAddedStyles = setStyles(el, value);\n}\nfunction bindAttributeAndProperty(el, name, value) {\n  bindAttribute(el, name, value);\n  setPropertyIfChanged(el, name, value);\n}\nfunction bindAttribute(el, name, value) {\n  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name))\n      value = name;\n    setIfChanged(el, name, value);\n  }\n}\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\nfunction setPropertyIfChanged(el, propName, value) {\n  if (el[propName] !== value) {\n    el[propName] = value;\n  }\n}\nfunction updateSelect(el, value) {\n  const arrayWrappedValue = [].concat(value).map((value2) => {\n    return value2 + \"\";\n  });\n  Array.from(el.options).forEach((option) => {\n    option.selected = arrayWrappedValue.includes(option.value);\n  });\n}\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction checkedAttrLooseCompare(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction safeParseBoolean(rawValue) {\n  if ([1, \"1\", \"true\", \"on\", \"yes\", true].includes(rawValue)) {\n    return true;\n  }\n  if ([0, \"0\", \"false\", \"off\", \"no\", false].includes(rawValue)) {\n    return false;\n  }\n  return rawValue ? Boolean(rawValue) : null;\n}\nvar booleanAttributes = /* @__PURE__ */ new Set([\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"inert\",\n  \"ismap\",\n  \"itemscope\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\",\n  \"shadowrootclonable\",\n  \"shadowrootdelegatesfocus\",\n  \"shadowrootserializable\"\n]);\nfunction isBooleanAttr(attrName) {\n  return booleanAttributes.has(attrName);\n}\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return ![\"aria-pressed\", \"aria-checked\", \"aria-expanded\", \"aria-selected\"].includes(name);\n}\nfunction getBinding(el, name, fallback) {\n  if (el._x_bindings && el._x_bindings[name] !== void 0)\n    return el._x_bindings[name];\n  return getAttributeBinding(el, name, fallback);\n}\nfunction extractProp(el, name, fallback, extract = true) {\n  if (el._x_bindings && el._x_bindings[name] !== void 0)\n    return el._x_bindings[name];\n  if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {\n    let binding = el._x_inlineBindings[name];\n    binding.extract = extract;\n    return dontAutoEvaluateFunctions(() => {\n      return evaluate(el, binding.expression);\n    });\n  }\n  return getAttributeBinding(el, name, fallback);\n}\nfunction getAttributeBinding(el, name, fallback) {\n  let attr = el.getAttribute(name);\n  if (attr === null)\n    return typeof fallback === \"function\" ? fallback() : fallback;\n  if (attr === \"\")\n    return true;\n  if (isBooleanAttr(name)) {\n    return !![name, \"true\"].includes(attr);\n  }\n  return attr;\n}\nfunction isCheckbox(el) {\n  return el.type === \"checkbox\" || el.localName === \"ui-checkbox\" || el.localName === \"ui-switch\";\n}\nfunction isRadio(el) {\n  return el.type === \"radio\" || el.localName === \"ui-radio\";\n}\n\n// packages/alpinejs/src/utils/debounce.js\nfunction debounce(func, wait) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      func.apply(context, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// packages/alpinejs/src/utils/throttle.js\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function() {\n    let context = this, args = arguments;\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n// packages/alpinejs/src/entangle.js\nfunction entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {\n  let firstRun = true;\n  let outerHash;\n  let innerHash;\n  let reference = effect(() => {\n    let outer = outerGet();\n    let inner = innerGet();\n    if (firstRun) {\n      innerSet(cloneIfObject(outer));\n      firstRun = false;\n    } else {\n      let outerHashLatest = JSON.stringify(outer);\n      let innerHashLatest = JSON.stringify(inner);\n      if (outerHashLatest !== outerHash) {\n        innerSet(cloneIfObject(outer));\n      } else if (outerHashLatest !== innerHashLatest) {\n        outerSet(cloneIfObject(inner));\n      } else {\n      }\n    }\n    outerHash = JSON.stringify(outerGet());\n    innerHash = JSON.stringify(innerGet());\n  });\n  return () => {\n    release(reference);\n  };\n}\nfunction cloneIfObject(value) {\n  return typeof value === \"object\" ? JSON.parse(JSON.stringify(value)) : value;\n}\n\n// packages/alpinejs/src/plugin.js\nfunction plugin(callback) {\n  let callbacks = Array.isArray(callback) ? callback : [callback];\n  callbacks.forEach((i) => i(alpine_default));\n}\n\n// packages/alpinejs/src/store.js\nvar stores = {};\nvar isReactive = false;\nfunction store(name, value) {\n  if (!isReactive) {\n    stores = reactive(stores);\n    isReactive = true;\n  }\n  if (value === void 0) {\n    return stores[name];\n  }\n  stores[name] = value;\n  initInterceptors(stores[name]);\n  if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"init\") && typeof value.init === \"function\") {\n    stores[name].init();\n  }\n}\nfunction getStores() {\n  return stores;\n}\n\n// packages/alpinejs/src/binds.js\nvar binds = {};\nfunction bind2(name, bindings) {\n  let getBindings = typeof bindings !== \"function\" ? () => bindings : bindings;\n  if (name instanceof Element) {\n    return applyBindingsObject(name, getBindings());\n  } else {\n    binds[name] = getBindings;\n  }\n  return () => {\n  };\n}\nfunction injectBindingProviders(obj) {\n  Object.entries(binds).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback(...args);\n        };\n      }\n    });\n  });\n  return obj;\n}\nfunction applyBindingsObject(el, obj, original) {\n  let cleanupRunners = [];\n  while (cleanupRunners.length)\n    cleanupRunners.pop()();\n  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));\n  let staticAttributes = attributesOnly(attributes);\n  attributes = attributes.map((attribute) => {\n    if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n      return {\n        name: `x-bind:${attribute.name}`,\n        value: `\"${attribute.value}\"`\n      };\n    }\n    return attribute;\n  });\n  directives(el, attributes, original).map((handle) => {\n    cleanupRunners.push(handle.runCleanups);\n    handle();\n  });\n  return () => {\n    while (cleanupRunners.length)\n      cleanupRunners.pop()();\n  };\n}\n\n// packages/alpinejs/src/datas.js\nvar datas = {};\nfunction data(name, callback) {\n  datas[name] = callback;\n}\nfunction injectDataProviders(obj, context) {\n  Object.entries(datas).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback.bind(context)(...args);\n        };\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/alpine.js\nvar Alpine = {\n  get reactive() {\n    return reactive;\n  },\n  get release() {\n    return release;\n  },\n  get effect() {\n    return effect;\n  },\n  get raw() {\n    return raw;\n  },\n  version: \"3.14.9\",\n  flushAndStopDeferringMutations,\n  dontAutoEvaluateFunctions,\n  disableEffectScheduling,\n  startObservingMutations,\n  stopObservingMutations,\n  setReactivityEngine,\n  onAttributeRemoved,\n  onAttributesAdded,\n  closestDataStack,\n  skipDuringClone,\n  onlyDuringClone,\n  addRootSelector,\n  addInitSelector,\n  interceptClone,\n  addScopeToNode,\n  deferMutations,\n  mapAttributes,\n  evaluateLater,\n  interceptInit,\n  setEvaluator,\n  mergeProxies,\n  extractProp,\n  findClosest,\n  onElRemoved,\n  closestRoot,\n  destroyTree,\n  interceptor,\n  // INTERNAL: not public API and is subject to change without major release.\n  transition,\n  // INTERNAL\n  setStyles,\n  // INTERNAL\n  mutateDom,\n  directive,\n  entangle,\n  throttle,\n  debounce,\n  evaluate,\n  initTree,\n  nextTick,\n  prefixed: prefix,\n  prefix: setPrefix,\n  plugin,\n  magic,\n  store,\n  start,\n  clone,\n  // INTERNAL\n  cloneNode,\n  // INTERNAL\n  bound: getBinding,\n  $data: scope,\n  watch,\n  walk,\n  data,\n  bind: bind2\n};\nvar alpine_default = Alpine;\n\n// node_modules/@vue/shared/dist/shared.esm-bundler.js\nfunction makeMap(str, expectsLowerCase) {\n  const map = /* @__PURE__ */ Object.create(null);\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];\n}\nvar specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nvar isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);\nvar EMPTY_OBJ = true ? Object.freeze({}) : {};\nvar EMPTY_ARR = true ? Object.freeze([]) : [];\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar hasOwn = (val, key) => hasOwnProperty.call(val, key);\nvar isArray = Array.isArray;\nvar isMap = (val) => toTypeString(val) === \"[object Map]\";\nvar isString = (val) => typeof val === \"string\";\nvar isSymbol = (val) => typeof val === \"symbol\";\nvar isObject = (val) => val !== null && typeof val === \"object\";\nvar objectToString = Object.prototype.toString;\nvar toTypeString = (value) => objectToString.call(value);\nvar toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nvar isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nvar cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nvar capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\nvar toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\nvar hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\n\n// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\nvar targetMap = /* @__PURE__ */ new WeakMap();\nvar effectStack = [];\nvar activeEffect;\nvar ITERATE_KEY = Symbol(true ? \"iterate\" : \"\");\nvar MAP_KEY_ITERATE_KEY = Symbol(true ? \"Map key iterate\" : \"\");\nfunction isEffect(fn) {\n  return fn && fn._isEffect === true;\n}\nfunction effect2(fn, options = EMPTY_OBJ) {\n  if (isEffect(fn)) {\n    fn = fn.raw;\n  }\n  const effect3 = createReactiveEffect(fn, options);\n  if (!options.lazy) {\n    effect3();\n  }\n  return effect3;\n}\nfunction stop(effect3) {\n  if (effect3.active) {\n    cleanup(effect3);\n    if (effect3.options.onStop) {\n      effect3.options.onStop();\n    }\n    effect3.active = false;\n  }\n}\nvar uid = 0;\nfunction createReactiveEffect(fn, options) {\n  const effect3 = function reactiveEffect() {\n    if (!effect3.active) {\n      return fn();\n    }\n    if (!effectStack.includes(effect3)) {\n      cleanup(effect3);\n      try {\n        enableTracking();\n        effectStack.push(effect3);\n        activeEffect = effect3;\n        return fn();\n      } finally {\n        effectStack.pop();\n        resetTracking();\n        activeEffect = effectStack[effectStack.length - 1];\n      }\n    }\n  };\n  effect3.id = uid++;\n  effect3.allowRecurse = !!options.allowRecurse;\n  effect3._isEffect = true;\n  effect3.active = true;\n  effect3.raw = fn;\n  effect3.deps = [];\n  effect3.options = options;\n  return effect3;\n}\nfunction cleanup(effect3) {\n  const { deps } = effect3;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect3);\n    }\n    deps.length = 0;\n  }\n}\nvar shouldTrack = true;\nvar trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction track(target, type, key) {\n  if (!shouldTrack || activeEffect === void 0) {\n    return;\n  }\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, dep = /* @__PURE__ */ new Set());\n  }\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (activeEffect.options.onTrack) {\n      activeEffect.options.onTrack({\n        effect: activeEffect,\n        target,\n        type,\n        key\n      });\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  const effects = /* @__PURE__ */ new Set();\n  const add2 = (effectsToAdd) => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach((effect3) => {\n        if (effect3 !== activeEffect || effect3.allowRecurse) {\n          effects.add(effect3);\n        }\n      });\n    }\n  };\n  if (type === \"clear\") {\n    depsMap.forEach(add2);\n  } else if (key === \"length\" && isArray(target)) {\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || key2 >= newValue) {\n        add2(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      add2(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!isArray(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          add2(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!isArray(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if (isMap(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const run = (effect3) => {\n    if (effect3.options.onTrigger) {\n      effect3.options.onTrigger({\n        effect: effect3,\n        target,\n        key,\n        type,\n        newValue,\n        oldValue,\n        oldTarget\n      });\n    }\n    if (effect3.options.scheduler) {\n      effect3.options.scheduler(effect3);\n    } else {\n      effect3();\n    }\n  };\n  effects.forEach(run);\n}\nvar isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nvar builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));\nvar get2 = /* @__PURE__ */ createGetter();\nvar readonlyGet = /* @__PURE__ */ createGetter(true);\nvar arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get3(target, key, receiver) {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver);\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n      return shouldUnwrap ? res.value : res;\n    }\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reactive2(res);\n    }\n    return res;\n  };\n}\nvar set2 = /* @__PURE__ */ createSetter();\nfunction createSetter(shallow = false) {\n  return function set3(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!shallow) {\n      value = toRaw(value);\n      oldValue = toRaw(oldValue);\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction has(target, key) {\n  const result = Reflect.has(target, key);\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\", key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nvar mutableHandlers = {\n  get: get2,\n  set: set2,\n  deleteProperty,\n  has,\n  ownKeys\n};\nvar readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (true) {\n      console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (true) {\n      console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n};\nvar toReactive = (value) => isObject(value) ? reactive2(value) : value;\nvar toReadonly = (value) => isObject(value) ? readonly(value) : value;\nvar toShallow = (value) => value;\nvar getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\n  target = target[\n    \"__v_raw\"\n    /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"get\", key);\n  }\n  !isReadonly && track(rawTarget, \"get\", rawKey);\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has$1(key, isReadonly = false) {\n  const target = this[\n    \"__v_raw\"\n    /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"has\", key);\n  }\n  !isReadonly && track(rawTarget, \"has\", rawKey);\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\n    \"__v_raw\"\n    /* RAW */\n  ];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set$1(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const { has: has2, get: get3 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get3.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get3 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get3 ? get3.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\n      \"__v_raw\"\n      /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function(...args) {\n    const target = this[\n      \"__v_raw\"\n      /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (true) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n    return type === \"delete\" ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get$1(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get$1(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get$1(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\n      \"add\"\n      /* ADD */\n    ),\n    set: createReadonlyMethod(\n      \"set\"\n      /* SET */\n    ),\n    delete: createReadonlyMethod(\n      \"delete\"\n      /* DELETE */\n    ),\n    clear: createReadonlyMethod(\n      \"clear\"\n      /* CLEAR */\n    ),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get$1(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\n      \"add\"\n      /* ADD */\n    ),\n    set: createReadonlyMethod(\n      \"set\"\n      /* SET */\n    ),\n    delete: createReadonlyMethod(\n      \"delete\"\n      /* DELETE */\n    ),\n    clear: createReadonlyMethod(\n      \"clear\"\n      /* CLEAR */\n    ),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nvar [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nvar mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nvar readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n  }\n}\nvar reactiveMap = /* @__PURE__ */ new WeakMap();\nvar shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nvar readonlyMap = /* @__PURE__ */ new WeakMap();\nvar shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction getTargetType(value) {\n  return value[\n    \"__v_skip\"\n    /* SKIP */\n  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));\n}\nfunction reactive2(target) {\n  if (target && target[\n    \"__v_isReadonly\"\n    /* IS_READONLY */\n  ]) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (true) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\n    \"__v_raw\"\n    /* RAW */\n  ] && !(isReadonly && target[\n    \"__v_isReactive\"\n    /* IS_REACTIVE */\n  ])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0) {\n    return target;\n  }\n  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction toRaw(observed) {\n  return observed && toRaw(observed[\n    \"__v_raw\"\n    /* RAW */\n  ]) || observed;\n}\nfunction isRef(r) {\n  return Boolean(r && r.__v_isRef === true);\n}\n\n// packages/alpinejs/src/magics/$nextTick.js\nmagic(\"nextTick\", () => nextTick);\n\n// packages/alpinejs/src/magics/$dispatch.js\nmagic(\"dispatch\", (el) => dispatch.bind(dispatch, el));\n\n// packages/alpinejs/src/magics/$watch.js\nmagic(\"watch\", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {\n  let evaluate2 = evaluateLater2(key);\n  let getter = () => {\n    let value;\n    evaluate2((i) => value = i);\n    return value;\n  };\n  let unwatch = watch(getter, callback);\n  cleanup2(unwatch);\n});\n\n// packages/alpinejs/src/magics/$store.js\nmagic(\"store\", getStores);\n\n// packages/alpinejs/src/magics/$data.js\nmagic(\"data\", (el) => scope(el));\n\n// packages/alpinejs/src/magics/$root.js\nmagic(\"root\", (el) => closestRoot(el));\n\n// packages/alpinejs/src/magics/$refs.js\nmagic(\"refs\", (el) => {\n  if (el._x_refs_proxy)\n    return el._x_refs_proxy;\n  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));\n  return el._x_refs_proxy;\n});\nfunction getArrayOfRefObject(el) {\n  let refObjects = [];\n  findClosest(el, (i) => {\n    if (i._x_refs)\n      refObjects.push(i._x_refs);\n  });\n  return refObjects;\n}\n\n// packages/alpinejs/src/ids.js\nvar globalIdMemo = {};\nfunction findAndIncrementId(name) {\n  if (!globalIdMemo[name])\n    globalIdMemo[name] = 0;\n  return ++globalIdMemo[name];\n}\nfunction closestIdRoot(el, name) {\n  return findClosest(el, (element) => {\n    if (element._x_ids && element._x_ids[name])\n      return true;\n  });\n}\nfunction setIdRoot(el, name) {\n  if (!el._x_ids)\n    el._x_ids = {};\n  if (!el._x_ids[name])\n    el._x_ids[name] = findAndIncrementId(name);\n}\n\n// packages/alpinejs/src/magics/$id.js\nmagic(\"id\", (el, { cleanup: cleanup2 }) => (name, key = null) => {\n  let cacheKey = `${name}${key ? `-${key}` : \"\"}`;\n  return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {\n    let root = closestIdRoot(el, name);\n    let id = root ? root._x_ids[name] : findAndIncrementId(name);\n    return key ? `${name}-${id}-${key}` : `${name}-${id}`;\n  });\n});\ninterceptClone((from, to) => {\n  if (from._x_id) {\n    to._x_id = from._x_id;\n  }\n});\nfunction cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {\n  if (!el._x_id)\n    el._x_id = {};\n  if (el._x_id[cacheKey])\n    return el._x_id[cacheKey];\n  let output = callback();\n  el._x_id[cacheKey] = output;\n  cleanup2(() => {\n    delete el._x_id[cacheKey];\n  });\n  return output;\n}\n\n// packages/alpinejs/src/magics/$el.js\nmagic(\"el\", (el) => el);\n\n// packages/alpinejs/src/magics/index.js\nwarnMissingPluginMagic(\"Focus\", \"focus\", \"focus\");\nwarnMissingPluginMagic(\"Persist\", \"persist\", \"persist\");\nfunction warnMissingPluginMagic(name, magicName, slug) {\n  magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\n}\n\n// packages/alpinejs/src/directives/x-modelable.js\ndirective(\"modelable\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {\n  let func = evaluateLater2(expression);\n  let innerGet = () => {\n    let result;\n    func((i) => result = i);\n    return result;\n  };\n  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);\n  let innerSet = (val) => evaluateInnerSet(() => {\n  }, { scope: { \"__placeholder\": val } });\n  let initialValue = innerGet();\n  innerSet(initialValue);\n  queueMicrotask(() => {\n    if (!el._x_model)\n      return;\n    el._x_removeModelListeners[\"default\"]();\n    let outerGet = el._x_model.get;\n    let outerSet = el._x_model.set;\n    let releaseEntanglement = entangle(\n      {\n        get() {\n          return outerGet();\n        },\n        set(value) {\n          outerSet(value);\n        }\n      },\n      {\n        get() {\n          return innerGet();\n        },\n        set(value) {\n          innerSet(value);\n        }\n      }\n    );\n    cleanup2(releaseEntanglement);\n  });\n});\n\n// packages/alpinejs/src/directives/x-teleport.js\ndirective(\"teleport\", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {\n  if (el.tagName.toLowerCase() !== \"template\")\n    warn(\"x-teleport can only be used on a <template> tag\", el);\n  let target = getTarget(expression);\n  let clone2 = el.content.cloneNode(true).firstElementChild;\n  el._x_teleport = clone2;\n  clone2._x_teleportBack = el;\n  el.setAttribute(\"data-teleport-template\", true);\n  clone2.setAttribute(\"data-teleport-target\", true);\n  if (el._x_forwardEvents) {\n    el._x_forwardEvents.forEach((eventName) => {\n      clone2.addEventListener(eventName, (e) => {\n        e.stopPropagation();\n        el.dispatchEvent(new e.constructor(e.type, e));\n      });\n    });\n  }\n  addScopeToNode(clone2, {}, el);\n  let placeInDom = (clone3, target2, modifiers2) => {\n    if (modifiers2.includes(\"prepend\")) {\n      target2.parentNode.insertBefore(clone3, target2);\n    } else if (modifiers2.includes(\"append\")) {\n      target2.parentNode.insertBefore(clone3, target2.nextSibling);\n    } else {\n      target2.appendChild(clone3);\n    }\n  };\n  mutateDom(() => {\n    placeInDom(clone2, target, modifiers);\n    skipDuringClone(() => {\n      initTree(clone2);\n    })();\n  });\n  el._x_teleportPutBack = () => {\n    let target2 = getTarget(expression);\n    mutateDom(() => {\n      placeInDom(el._x_teleport, target2, modifiers);\n    });\n  };\n  cleanup2(\n    () => mutateDom(() => {\n      clone2.remove();\n      destroyTree(clone2);\n    })\n  );\n});\nvar teleportContainerDuringClone = document.createElement(\"div\");\nfunction getTarget(expression) {\n  let target = skipDuringClone(() => {\n    return document.querySelector(expression);\n  }, () => {\n    return teleportContainerDuringClone;\n  })();\n  if (!target)\n    warn(`Cannot find x-teleport element for selector: \"${expression}\"`);\n  return target;\n}\n\n// packages/alpinejs/src/directives/x-ignore.js\nvar handler = () => {\n};\nhandler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {\n  modifiers.includes(\"self\") ? el._x_ignoreSelf = true : el._x_ignore = true;\n  cleanup2(() => {\n    modifiers.includes(\"self\") ? delete el._x_ignoreSelf : delete el._x_ignore;\n  });\n};\ndirective(\"ignore\", handler);\n\n// packages/alpinejs/src/directives/x-effect.js\ndirective(\"effect\", skipDuringClone((el, { expression }, { effect: effect3 }) => {\n  effect3(evaluateLater(el, expression));\n}));\n\n// packages/alpinejs/src/utils/on.js\nfunction on(el, event, modifiers, callback) {\n  let listenerTarget = el;\n  let handler4 = (e) => callback(e);\n  let options = {};\n  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);\n  if (modifiers.includes(\"dot\"))\n    event = dotSyntax(event);\n  if (modifiers.includes(\"camel\"))\n    event = camelCase2(event);\n  if (modifiers.includes(\"passive\"))\n    options.passive = true;\n  if (modifiers.includes(\"capture\"))\n    options.capture = true;\n  if (modifiers.includes(\"window\"))\n    listenerTarget = window;\n  if (modifiers.includes(\"document\"))\n    listenerTarget = document;\n  if (modifiers.includes(\"debounce\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"debounce\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler4 = debounce(handler4, wait);\n  }\n  if (modifiers.includes(\"throttle\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"throttle\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler4 = throttle(handler4, wait);\n  }\n  if (modifiers.includes(\"prevent\"))\n    handler4 = wrapHandler(handler4, (next, e) => {\n      e.preventDefault();\n      next(e);\n    });\n  if (modifiers.includes(\"stop\"))\n    handler4 = wrapHandler(handler4, (next, e) => {\n      e.stopPropagation();\n      next(e);\n    });\n  if (modifiers.includes(\"once\")) {\n    handler4 = wrapHandler(handler4, (next, e) => {\n      next(e);\n      listenerTarget.removeEventListener(event, handler4, options);\n    });\n  }\n  if (modifiers.includes(\"away\") || modifiers.includes(\"outside\")) {\n    listenerTarget = document;\n    handler4 = wrapHandler(handler4, (next, e) => {\n      if (el.contains(e.target))\n        return;\n      if (e.target.isConnected === false)\n        return;\n      if (el.offsetWidth < 1 && el.offsetHeight < 1)\n        return;\n      if (el._x_isShown === false)\n        return;\n      next(e);\n    });\n  }\n  if (modifiers.includes(\"self\"))\n    handler4 = wrapHandler(handler4, (next, e) => {\n      e.target === el && next(e);\n    });\n  if (isKeyEvent(event) || isClickEvent(event)) {\n    handler4 = wrapHandler(handler4, (next, e) => {\n      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n        return;\n      }\n      next(e);\n    });\n  }\n  listenerTarget.addEventListener(event, handler4, options);\n  return () => {\n    listenerTarget.removeEventListener(event, handler4, options);\n  };\n}\nfunction dotSyntax(subject) {\n  return subject.replace(/-/g, \".\");\n}\nfunction camelCase2(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction isNumeric(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction kebabCase2(subject) {\n  if ([\" \", \"_\"].includes(\n    subject\n  ))\n    return subject;\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[_\\s]/, \"-\").toLowerCase();\n}\nfunction isKeyEvent(event) {\n  return [\"keydown\", \"keyup\"].includes(event);\n}\nfunction isClickEvent(event) {\n  return [\"contextmenu\", \"click\", \"mouse\"].some((i) => event.includes(i));\n}\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n  let keyModifiers = modifiers.filter((i) => {\n    return ![\"window\", \"document\", \"prevent\", \"stop\", \"once\", \"capture\", \"self\", \"away\", \"outside\", \"passive\"].includes(i);\n  });\n  if (keyModifiers.includes(\"debounce\")) {\n    let debounceIndex = keyModifiers.indexOf(\"debounce\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.includes(\"throttle\")) {\n    let debounceIndex = keyModifiers.indexOf(\"throttle\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.length === 0)\n    return false;\n  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))\n    return false;\n  const systemKeyModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\", \"cmd\", \"super\"];\n  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));\n  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));\n  if (selectedSystemKeyModifiers.length > 0) {\n    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {\n      if (modifier === \"cmd\" || modifier === \"super\")\n        modifier = \"meta\";\n      return e[`${modifier}Key`];\n    });\n    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n      if (isClickEvent(e.type))\n        return false;\n      if (keyToModifiers(e.key).includes(keyModifiers[0]))\n        return false;\n    }\n  }\n  return true;\n}\nfunction keyToModifiers(key) {\n  if (!key)\n    return [];\n  key = kebabCase2(key);\n  let modifierToKeyMap = {\n    \"ctrl\": \"control\",\n    \"slash\": \"/\",\n    \"space\": \" \",\n    \"spacebar\": \" \",\n    \"cmd\": \"meta\",\n    \"esc\": \"escape\",\n    \"up\": \"arrow-up\",\n    \"down\": \"arrow-down\",\n    \"left\": \"arrow-left\",\n    \"right\": \"arrow-right\",\n    \"period\": \".\",\n    \"comma\": \",\",\n    \"equal\": \"=\",\n    \"minus\": \"-\",\n    \"underscore\": \"_\"\n  };\n  modifierToKeyMap[key] = key;\n  return Object.keys(modifierToKeyMap).map((modifier) => {\n    if (modifierToKeyMap[modifier] === key)\n      return modifier;\n  }).filter((modifier) => modifier);\n}\n\n// packages/alpinejs/src/directives/x-model.js\ndirective(\"model\", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {\n  let scopeTarget = el;\n  if (modifiers.includes(\"parent\")) {\n    scopeTarget = el.parentNode;\n  }\n  let evaluateGet = evaluateLater(scopeTarget, expression);\n  let evaluateSet;\n  if (typeof expression === \"string\") {\n    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);\n  } else if (typeof expression === \"function\" && typeof expression() === \"string\") {\n    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);\n  } else {\n    evaluateSet = () => {\n    };\n  }\n  let getValue = () => {\n    let result;\n    evaluateGet((value) => result = value);\n    return isGetterSetter(result) ? result.get() : result;\n  };\n  let setValue = (value) => {\n    let result;\n    evaluateGet((value2) => result = value2);\n    if (isGetterSetter(result)) {\n      result.set(value);\n    } else {\n      evaluateSet(() => {\n      }, {\n        scope: { \"__placeholder\": value }\n      });\n    }\n  };\n  if (typeof expression === \"string\" && el.type === \"radio\") {\n    mutateDom(() => {\n      if (!el.hasAttribute(\"name\"))\n        el.setAttribute(\"name\", expression);\n    });\n  }\n  var event = el.tagName.toLowerCase() === \"select\" || [\"checkbox\", \"radio\"].includes(el.type) || modifiers.includes(\"lazy\") ? \"change\" : \"input\";\n  let removeListener = isCloning ? () => {\n  } : on(el, event, modifiers, (e) => {\n    setValue(getInputValue(el, modifiers, e, getValue()));\n  });\n  if (modifiers.includes(\"fill\")) {\n    if ([void 0, null, \"\"].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === \"select\" && el.multiple) {\n      setValue(\n        getInputValue(el, modifiers, { target: el }, getValue())\n      );\n    }\n  }\n  if (!el._x_removeModelListeners)\n    el._x_removeModelListeners = {};\n  el._x_removeModelListeners[\"default\"] = removeListener;\n  cleanup2(() => el._x_removeModelListeners[\"default\"]());\n  if (el.form) {\n    let removeResetListener = on(el.form, \"reset\", [], (e) => {\n      nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));\n    });\n    cleanup2(() => removeResetListener());\n  }\n  el._x_model = {\n    get() {\n      return getValue();\n    },\n    set(value) {\n      setValue(value);\n    }\n  };\n  el._x_forceModelUpdate = (value) => {\n    if (value === void 0 && typeof expression === \"string\" && expression.match(/\\./))\n      value = \"\";\n    window.fromModel = true;\n    mutateDom(() => bind(el, \"value\", value));\n    delete window.fromModel;\n  };\n  effect3(() => {\n    let value = getValue();\n    if (modifiers.includes(\"unintrusive\") && document.activeElement.isSameNode(el))\n      return;\n    el._x_forceModelUpdate(value);\n  });\n});\nfunction getInputValue(el, modifiers, event, currentValue) {\n  return mutateDom(() => {\n    if (event instanceof CustomEvent && event.detail !== void 0)\n      return event.detail !== null && event.detail !== void 0 ? event.detail : event.target.value;\n    else if (isCheckbox(el)) {\n      if (Array.isArray(currentValue)) {\n        let newValue = null;\n        if (modifiers.includes(\"number\")) {\n          newValue = safeParseNumber(event.target.value);\n        } else if (modifiers.includes(\"boolean\")) {\n          newValue = safeParseBoolean(event.target.value);\n        } else {\n          newValue = event.target.value;\n        }\n        return event.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));\n      } else {\n        return event.target.checked;\n      }\n    } else if (el.tagName.toLowerCase() === \"select\" && el.multiple) {\n      if (modifiers.includes(\"number\")) {\n        return Array.from(event.target.selectedOptions).map((option) => {\n          let rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        });\n      } else if (modifiers.includes(\"boolean\")) {\n        return Array.from(event.target.selectedOptions).map((option) => {\n          let rawValue = option.value || option.text;\n          return safeParseBoolean(rawValue);\n        });\n      }\n      return Array.from(event.target.selectedOptions).map((option) => {\n        return option.value || option.text;\n      });\n    } else {\n      let newValue;\n      if (isRadio(el)) {\n        if (event.target.checked) {\n          newValue = event.target.value;\n        } else {\n          newValue = currentValue;\n        }\n      } else {\n        newValue = event.target.value;\n      }\n      if (modifiers.includes(\"number\")) {\n        return safeParseNumber(newValue);\n      } else if (modifiers.includes(\"boolean\")) {\n        return safeParseBoolean(newValue);\n      } else if (modifiers.includes(\"trim\")) {\n        return newValue.trim();\n      } else {\n        return newValue;\n      }\n    }\n  });\n}\nfunction safeParseNumber(rawValue) {\n  let number = rawValue ? parseFloat(rawValue) : null;\n  return isNumeric2(number) ? number : rawValue;\n}\nfunction checkedAttrLooseCompare2(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isNumeric2(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction isGetterSetter(value) {\n  return value !== null && typeof value === \"object\" && typeof value.get === \"function\" && typeof value.set === \"function\";\n}\n\n// packages/alpinejs/src/directives/x-cloak.js\ndirective(\"cloak\", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix(\"cloak\")))));\n\n// packages/alpinejs/src/directives/x-init.js\naddInitSelector(() => `[${prefix(\"init\")}]`);\ndirective(\"init\", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {\n  if (typeof expression === \"string\") {\n    return !!expression.trim() && evaluate2(expression, {}, false);\n  }\n  return evaluate2(expression, {}, false);\n}));\n\n// packages/alpinejs/src/directives/x-text.js\ndirective(\"text\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.textContent = value;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-html.js\ndirective(\"html\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.innerHTML = value;\n        el._x_ignoreSelf = true;\n        initTree(el);\n        delete el._x_ignoreSelf;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-bind.js\nmapAttributes(startingWith(\":\", into(prefix(\"bind:\"))));\nvar handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {\n  if (!value) {\n    let bindingProviders = {};\n    injectBindingProviders(bindingProviders);\n    let getBindings = evaluateLater(el, expression);\n    getBindings((bindings) => {\n      applyBindingsObject(el, bindings, original);\n    }, { scope: bindingProviders });\n    return;\n  }\n  if (value === \"key\")\n    return storeKeyForXFor(el, expression);\n  if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {\n    return;\n  }\n  let evaluate2 = evaluateLater(el, expression);\n  effect3(() => evaluate2((result) => {\n    if (result === void 0 && typeof expression === \"string\" && expression.match(/\\./)) {\n      result = \"\";\n    }\n    mutateDom(() => bind(el, value, result, modifiers));\n  }));\n  cleanup2(() => {\n    el._x_undoAddedClasses && el._x_undoAddedClasses();\n    el._x_undoAddedStyles && el._x_undoAddedStyles();\n  });\n};\nhandler2.inline = (el, { value, modifiers, expression }) => {\n  if (!value)\n    return;\n  if (!el._x_inlineBindings)\n    el._x_inlineBindings = {};\n  el._x_inlineBindings[value] = { expression, extract: false };\n};\ndirective(\"bind\", handler2);\nfunction storeKeyForXFor(el, expression) {\n  el._x_keyExpression = expression;\n}\n\n// packages/alpinejs/src/directives/x-data.js\naddRootSelector(() => `[${prefix(\"data\")}]`);\ndirective(\"data\", (el, { expression }, { cleanup: cleanup2 }) => {\n  if (shouldSkipRegisteringDataDuringClone(el))\n    return;\n  expression = expression === \"\" ? \"{}\" : expression;\n  let magicContext = {};\n  injectMagics(magicContext, el);\n  let dataProviderContext = {};\n  injectDataProviders(dataProviderContext, magicContext);\n  let data2 = evaluate(el, expression, { scope: dataProviderContext });\n  if (data2 === void 0 || data2 === true)\n    data2 = {};\n  injectMagics(data2, el);\n  let reactiveData = reactive(data2);\n  initInterceptors(reactiveData);\n  let undo = addScopeToNode(el, reactiveData);\n  reactiveData[\"init\"] && evaluate(el, reactiveData[\"init\"]);\n  cleanup2(() => {\n    reactiveData[\"destroy\"] && evaluate(el, reactiveData[\"destroy\"]);\n    undo();\n  });\n});\ninterceptClone((from, to) => {\n  if (from._x_dataStack) {\n    to._x_dataStack = from._x_dataStack;\n    to.setAttribute(\"data-has-alpine-state\", true);\n  }\n});\nfunction shouldSkipRegisteringDataDuringClone(el) {\n  if (!isCloning)\n    return false;\n  if (isCloningLegacy)\n    return true;\n  return el.hasAttribute(\"data-has-alpine-state\");\n}\n\n// packages/alpinejs/src/directives/x-show.js\ndirective(\"show\", (el, { modifiers, expression }, { effect: effect3 }) => {\n  let evaluate2 = evaluateLater(el, expression);\n  if (!el._x_doHide)\n    el._x_doHide = () => {\n      mutateDom(() => {\n        el.style.setProperty(\"display\", \"none\", modifiers.includes(\"important\") ? \"important\" : void 0);\n      });\n    };\n  if (!el._x_doShow)\n    el._x_doShow = () => {\n      mutateDom(() => {\n        if (el.style.length === 1 && el.style.display === \"none\") {\n          el.removeAttribute(\"style\");\n        } else {\n          el.style.removeProperty(\"display\");\n        }\n      });\n    };\n  let hide = () => {\n    el._x_doHide();\n    el._x_isShown = false;\n  };\n  let show = () => {\n    el._x_doShow();\n    el._x_isShown = true;\n  };\n  let clickAwayCompatibleShow = () => setTimeout(show);\n  let toggle = once(\n    (value) => value ? show() : hide(),\n    (value) => {\n      if (typeof el._x_toggleAndCascadeWithTransitions === \"function\") {\n        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);\n      } else {\n        value ? clickAwayCompatibleShow() : hide();\n      }\n    }\n  );\n  let oldValue;\n  let firstTime = true;\n  effect3(() => evaluate2((value) => {\n    if (!firstTime && value === oldValue)\n      return;\n    if (modifiers.includes(\"immediate\"))\n      value ? clickAwayCompatibleShow() : hide();\n    toggle(value);\n    oldValue = value;\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/directives/x-for.js\ndirective(\"for\", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {\n  let iteratorNames = parseForExpression(expression);\n  let evaluateItems = evaluateLater(el, iteratorNames.items);\n  let evaluateKey = evaluateLater(\n    el,\n    // the x-bind:key expression is stored for our use instead of evaluated.\n    el._x_keyExpression || \"index\"\n  );\n  el._x_prevKeys = [];\n  el._x_lookup = {};\n  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));\n  cleanup2(() => {\n    Object.values(el._x_lookup).forEach((el2) => mutateDom(\n      () => {\n        destroyTree(el2);\n        el2.remove();\n      }\n    ));\n    delete el._x_prevKeys;\n    delete el._x_lookup;\n  });\n});\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n  let isObject2 = (i) => typeof i === \"object\" && !Array.isArray(i);\n  let templateEl = el;\n  evaluateItems((items) => {\n    if (isNumeric3(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), (i) => i + 1);\n    }\n    if (items === void 0)\n      items = [];\n    let lookup = el._x_lookup;\n    let prevKeys = el._x_prevKeys;\n    let scopes = [];\n    let keys = [];\n    if (isObject2(items)) {\n      items = Object.entries(items).map(([key, value]) => {\n        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);\n        evaluateKey((value2) => {\n          if (keys.includes(value2))\n            warn(\"Duplicate key on x-for\", el);\n          keys.push(value2);\n        }, { scope: { index: key, ...scope2 } });\n        scopes.push(scope2);\n      });\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);\n        evaluateKey((value) => {\n          if (keys.includes(value))\n            warn(\"Duplicate key on x-for\", el);\n          keys.push(value);\n        }, { scope: { index: i, ...scope2 } });\n        scopes.push(scope2);\n      }\n    }\n    let adds = [];\n    let moves = [];\n    let removes = [];\n    let sames = [];\n    for (let i = 0; i < prevKeys.length; i++) {\n      let key = prevKeys[i];\n      if (keys.indexOf(key) === -1)\n        removes.push(key);\n    }\n    prevKeys = prevKeys.filter((key) => !removes.includes(key));\n    let lastKey = \"template\";\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let prevIndex = prevKeys.indexOf(key);\n      if (prevIndex === -1) {\n        prevKeys.splice(i, 0, key);\n        adds.push([lastKey, i]);\n      } else if (prevIndex !== i) {\n        let keyInSpot = prevKeys.splice(i, 1)[0];\n        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];\n        prevKeys.splice(i, 0, keyForSpot);\n        prevKeys.splice(prevIndex, 0, keyInSpot);\n        moves.push([keyInSpot, keyForSpot]);\n      } else {\n        sames.push(key);\n      }\n      lastKey = key;\n    }\n    for (let i = 0; i < removes.length; i++) {\n      let key = removes[i];\n      if (!(key in lookup))\n        continue;\n      mutateDom(() => {\n        destroyTree(lookup[key]);\n        lookup[key].remove();\n      });\n      delete lookup[key];\n    }\n    for (let i = 0; i < moves.length; i++) {\n      let [keyInSpot, keyForSpot] = moves[i];\n      let elInSpot = lookup[keyInSpot];\n      let elForSpot = lookup[keyForSpot];\n      let marker = document.createElement(\"div\");\n      mutateDom(() => {\n        if (!elForSpot)\n          warn(`x-for \":key\" is undefined or invalid`, templateEl, keyForSpot, lookup);\n        elForSpot.after(marker);\n        elInSpot.after(elForSpot);\n        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);\n        marker.before(elInSpot);\n        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);\n        marker.remove();\n      });\n      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);\n    }\n    for (let i = 0; i < adds.length; i++) {\n      let [lastKey2, index] = adds[i];\n      let lastEl = lastKey2 === \"template\" ? templateEl : lookup[lastKey2];\n      if (lastEl._x_currentIfEl)\n        lastEl = lastEl._x_currentIfEl;\n      let scope2 = scopes[index];\n      let key = keys[index];\n      let clone2 = document.importNode(templateEl.content, true).firstElementChild;\n      let reactiveScope = reactive(scope2);\n      addScopeToNode(clone2, reactiveScope, templateEl);\n      clone2._x_refreshXForScope = (newScope) => {\n        Object.entries(newScope).forEach(([key2, value]) => {\n          reactiveScope[key2] = value;\n        });\n      };\n      mutateDom(() => {\n        lastEl.after(clone2);\n        skipDuringClone(() => initTree(clone2))();\n      });\n      if (typeof key === \"object\") {\n        warn(\"x-for key cannot be an object, it must be a string or an integer\", templateEl);\n      }\n      lookup[key] = clone2;\n    }\n    for (let i = 0; i < sames.length; i++) {\n      lookup[sames[i]]._x_refreshXForScope(scopes[keys.indexOf(sames[i])]);\n    }\n    templateEl._x_prevKeys = keys;\n  });\n}\nfunction parseForExpression(expression) {\n  let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  let stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n  let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  let inMatch = expression.match(forAliasRE);\n  if (!inMatch)\n    return;\n  let res = {};\n  res.items = inMatch[2].trim();\n  let item = inMatch[1].replace(stripParensRE, \"\").trim();\n  let iteratorMatch = item.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.item = item.replace(forIteratorRE, \"\").trim();\n    res.index = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.collection = iteratorMatch[2].trim();\n    }\n  } else {\n    res.item = item;\n  }\n  return res;\n}\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n  let scopeVariables = {};\n  if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n    let names = iteratorNames.item.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name, i) => {\n      scopeVariables[name] = item[i];\n    });\n  } else if (/^\\{.*\\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === \"object\") {\n    let names = iteratorNames.item.replace(\"{\", \"\").replace(\"}\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name) => {\n      scopeVariables[name] = item[name];\n    });\n  } else {\n    scopeVariables[iteratorNames.item] = item;\n  }\n  if (iteratorNames.index)\n    scopeVariables[iteratorNames.index] = index;\n  if (iteratorNames.collection)\n    scopeVariables[iteratorNames.collection] = items;\n  return scopeVariables;\n}\nfunction isNumeric3(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-ref.js\nfunction handler3() {\n}\nhandler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {\n  let root = closestRoot(el);\n  if (!root._x_refs)\n    root._x_refs = {};\n  root._x_refs[expression] = el;\n  cleanup2(() => delete root._x_refs[expression]);\n};\ndirective(\"ref\", handler3);\n\n// packages/alpinejs/src/directives/x-if.js\ndirective(\"if\", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {\n  if (el.tagName.toLowerCase() !== \"template\")\n    warn(\"x-if can only be used on a <template> tag\", el);\n  let evaluate2 = evaluateLater(el, expression);\n  let show = () => {\n    if (el._x_currentIfEl)\n      return el._x_currentIfEl;\n    let clone2 = el.content.cloneNode(true).firstElementChild;\n    addScopeToNode(clone2, {}, el);\n    mutateDom(() => {\n      el.after(clone2);\n      skipDuringClone(() => initTree(clone2))();\n    });\n    el._x_currentIfEl = clone2;\n    el._x_undoIf = () => {\n      mutateDom(() => {\n        destroyTree(clone2);\n        clone2.remove();\n      });\n      delete el._x_currentIfEl;\n    };\n    return clone2;\n  };\n  let hide = () => {\n    if (!el._x_undoIf)\n      return;\n    el._x_undoIf();\n    delete el._x_undoIf;\n  };\n  effect3(() => evaluate2((value) => {\n    value ? show() : hide();\n  }));\n  cleanup2(() => el._x_undoIf && el._x_undoIf());\n});\n\n// packages/alpinejs/src/directives/x-id.js\ndirective(\"id\", (el, { expression }, { evaluate: evaluate2 }) => {\n  let names = evaluate2(expression);\n  names.forEach((name) => setIdRoot(el, name));\n});\ninterceptClone((from, to) => {\n  if (from._x_ids) {\n    to._x_ids = from._x_ids;\n  }\n});\n\n// packages/alpinejs/src/directives/x-on.js\nmapAttributes(startingWith(\"@\", into(prefix(\"on:\"))));\ndirective(\"on\", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {\n  let evaluate2 = expression ? evaluateLater(el, expression) : () => {\n  };\n  if (el.tagName.toLowerCase() === \"template\") {\n    if (!el._x_forwardEvents)\n      el._x_forwardEvents = [];\n    if (!el._x_forwardEvents.includes(value))\n      el._x_forwardEvents.push(value);\n  }\n  let removeListener = on(el, value, modifiers, (e) => {\n    evaluate2(() => {\n    }, { scope: { \"$event\": e }, params: [e] });\n  });\n  cleanup2(() => removeListener());\n}));\n\n// packages/alpinejs/src/directives/index.js\nwarnMissingPluginDirective(\"Collapse\", \"collapse\", \"collapse\");\nwarnMissingPluginDirective(\"Intersect\", \"intersect\", \"intersect\");\nwarnMissingPluginDirective(\"Focus\", \"trap\", \"focus\");\nwarnMissingPluginDirective(\"Mask\", \"mask\", \"mask\");\nfunction warnMissingPluginDirective(name, directiveName, slug) {\n  directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\n}\n\n// packages/alpinejs/src/index.js\nalpine_default.setEvaluator(normalEvaluator);\nalpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });\nvar src_default = alpine_default;\n\n// packages/alpinejs/builds/module.js\nvar module_default = src_default;\nexport {\n  src_default as Alpine,\n  module_default as default\n};\n", "/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names$1 = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n", "/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n", "import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */\nfunction isNonPrimitive(n: unknown) {\n  return typeof n === 'symbol' || (typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n));\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNonPrimitive(n) && !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n", "import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n", "import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\nimport {isNullOrUndef} from './helpers.core.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, vScale, _parsed} = meta;\n    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n      if (spanGaps) {\n        const distanceToDefinedLo = (_parsed\n          .slice(0, start + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        start -= Math.max(0, distanceToDefinedLo);\n      }\n      start = _limitValue(start, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n      let end = Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n      if (spanGaps) {\n        const distanceToDefinedHi = (_parsed\n          .slice(end - 1)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        end += Math.max(0, distanceToDefinedHi);\n      }\n      count = _limitValue(end, start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n", "import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n", "import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n", "const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n", "export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n", "\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n", "import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n", "import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    clip: true,\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n", "import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n", "import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas?: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  if (!ctx && !canvas) {\n    return;\n  }\n\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n", "import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n", "import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n", "import type {ChartArea, Scale} from '../types/index.js';\nimport type PrivateChart from '../core/core.controller.js';\nimport type {Chart, ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart | PrivateChart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart | PrivateChart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = round1(chart.height * pixelRatio);\n  const deviceWidth = round1(chart.width * pixelRatio);\n\n  (chart as PrivateChart).height = round1(chart.height);\n  (chart as PrivateChart).width = round1(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    (chart as PrivateChart).currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    if (_isDomSupported()) {\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    }\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n", "import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n", "export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n", "import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n", "import type {Chart, ChartArea, ChartMeta, Scale, TRBL} from '../types/index.js';\n\nfunction getSizeForArea(scale: Scale, chartArea: ChartArea, field: keyof ChartArea) {\n  return scale.options.clip ? scale[field] : chartArea[field];\n}\n\nfunction getDatasetArea(meta: ChartMeta, chartArea: ChartArea): TRBL {\n  const {xScale, yScale} = meta;\n  if (xScale && yScale) {\n    return {\n      left: getSizeForArea(xScale, chartArea, 'left'),\n      right: getSizeForArea(xScale, chartArea, 'right'),\n      top: getSizeForArea(yScale, chartArea, 'top'),\n      bottom: getSizeForArea(yScale, chartArea, 'bottom')\n    };\n  }\n  return chartArea;\n}\n\nexport function getDatasetClipArea(chart: Chart, meta: ChartMeta): TRBL | false {\n  const clip = meta._clip;\n  if (clip.disabled) {\n    return false;\n  }\n  const area = getDatasetArea(meta, chart.chartArea);\n\n  return {\n    left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),\n    right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),\n    top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),\n    bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)\n  };\n}\n", "import {requestAnimFrame} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('./core.animation.js').default } Animation\n * @typedef { import('./core.controller.js').default } Chart\n */\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is export for typedoc\n */\nexport class Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  /**\n\t * @private\n\t */\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _update(date = Date.now()) {\n    let remaining = 0;\n\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            // if the animation has been updated and its duration prolonged,\n            // update to total duration of current animations run (for progress event)\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          // Remove the item by replacing it with last item and removing the last\n          // A lot faster than splice.\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    this._lastDate = date;\n\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} event - event name\n\t * @param {Function} cb - callback\n\t */\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  /**\n\t * Add animations\n\t * @param {Chart} chart\n\t * @param {Animation[]} items - animations\n\t */\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n\n  /**\n\t * Counts number of active animations for the chart\n\t * @param {Chart} chart\n\t */\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  /**\n\t * Start animating (all charts)\n\t * @param {Chart} chart\n\t */\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n\t * Stop all animations for the chart\n\t * @param {Chart} chart\n\t */\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  /**\n\t * Remove chart from Animator\n\t * @param {Chart} chart\n\t */\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Animator();\n", "import effects from '../helpers/helpers.easing.js';\nimport {resolve} from '../helpers/helpers.options.js';\nimport {color as helpersColor} from '../helpers/helpers.color.js';\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @param {number} factor\n   */\n  color(from, to, factor) {\n    const c0 = helpersColor(from || transparent);\n    const c1 = c0.valid && helpersColor(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\n\nexport default class Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    if (this._active) {\n      // update current evaluated value, for smoother animations\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n\n    this._active = from !== to && (loop || (elapsed < duration));\n\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\n    this._target[prop] = this._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n", "import animator from './core.animator.js';\nimport Animation from './core.animation.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isObject} from '../helpers/helpers.core.js';\n\nexport default class Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  /**\n\t * Utility to handle animation of `options`.\n\t * @private\n\t */\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      // Going to shared options:\n      // After all animations are done, assign the shared options object to the element\n      // So any new updates to the shared options are observed\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n        // rejected, noop\n      });\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @private\n\t */\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          // There is an existing active animation, let's update that\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        // not animated, set directly to new value\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n\n\n  /**\n\t * Update `target` properties to new values, using configured animations\n\t * @param {object} target - object to update\n\t * @param {object} values - new target properties\n\t * @returns {boolean|undefined} - `true` if animations were started\n\t **/\n  update(target, values) {\n    if (this._properties.size === 0) {\n      // Nothing is animated, just apply the new values.\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  // @ts-ignore\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    // Going from shared options to distinct one:\n    // Create new options object containing the old shared values and start updating that.\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n", "import Animations from './core.animations.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\nimport {createContext, sign} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('./core.scale.js').default } Scale\n */\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  let found = false;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      found = true;\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n\n  if (!found && !options.all) {\n    return 0;\n  }\n\n  return value;\n}\n\nfunction convertObjectDataToArray(data, meta) {\n  const {iScale, vScale} = meta;\n  const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n  const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      [iAxisKey]: key,\n      [vAxisKey]: data[key]\n    };\n  }\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\n\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  // Not using meta.index here, because it might be already updated if the dataset changed location\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\n\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\nexport default class DatasetController {\n\n  /**\n   * @type {any}\n   */\n  static defaults = {};\n\n  /**\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\n   */\n  static datasetElementType = null;\n\n  /**\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\n   */\n  static dataElementType = null;\n\n  /**\n\t * @param {Chart} chart\n\t * @param {number} datasetIndex\n\t */\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    /** @type {boolean | object} */\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n\n    this.initialize();\n  }\n\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  /**\n\t * @param {string} scaleID\n\t * @return {Scale}\n\t */\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  /**\n\t * @private\n\t */\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  /**\n\t * @private\n\t */\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n\n    // In order to correctly handle data addition/deletion animation (and thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal metadata accordingly.\n\n    if (isObject(data)) {\n      const meta = this._cachedMeta;\n      this._data = convertObjectDataToArray(data, meta);\n    } else if (_data !== data) {\n      if (_data) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(_data, this);\n        // Discard old parsed data and stacks\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n\n  addElements() {\n    const meta = this._cachedMeta;\n\n    this._dataCheck();\n\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n\n    this._dataCheck();\n\n    // make sure cached _stacked status is current\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    // detect change in stack option\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      // remove values from old stack\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    // Re-sync meta data in case the user replaced the data array or if we missed\n    // any updates and so make sure that we handle number of datapoints changing.\n    this._resyncElements(resetNewElements);\n\n    // if stack changed, update stack values for the whole dataset\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n      meta._stacked = isStacked(meta.vScale, meta);\n    }\n  }\n\n  /**\n\t * Merges user-supplied and default dataset-level options\n\t * @private\n\t */\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n\n  /**\n\t * @param {number} start\n\t * @param {number} count\n\t */\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [1,3,4]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {xScale0: 0, yScale0: 1}\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {x: 0, y: 1}\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id. _custom is optional\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        // if the data is sorted, we don't need to check further from this end of array\n        break;\n      }\n    }\n    if (sorted) {\n      // in the sorted case, find first non-skipped value from other end of array\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return false;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {} // eslint-disable-line no-unused-vars\n\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  /**\n\t * Returns a set of predefined style properties that should be used to represent the dataset\n\t * or the data if the index is specified\n\t * @param {number} index - data index\n\t * @param {boolean} [active] - true if hover\n\t * @return {object} style object\n\t */\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  /**\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    // context is provided as a function, and is called only if needed,\n    // so we don't create a context for each element if not needed.\n    const context = () => this.getContext(index, active, mode);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      // `$shared` indicates this set of options can be shared between multiple elements.\n      // Sharing is used to reduce number of properties to change during animation.\n      values.$shared = sharing;\n\n      // We cache options by `mode`, which can be 'active' for example. This enables us\n      // to have the 'active' element options and 'default' options to switch between\n      // when interacting.\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n\n  /**\n\t * Utility for getting the options object shared between elements\n\t * @protected\n\t */\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  /**\n\t * Utility for determining if `options` should be included in the updated properties\n\t * @protected\n\t */\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  /**\n   * @todo v4, rename to getSharedOptions and remove excess functions\n   */\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n\n  /**\n\t * Utility for updating an element with new properties, using animations when appropriate.\n\t * @protected\n\t */\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  /**\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\n\t * @protected\n\t */\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      // When going from active to inactive, we need to update to the shared options.\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  /**\n\t * @private\n\t */\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n\n    // Apply changes detected through array listeners\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      // TODO: It is not optimal to always parse the old data\n      // This is done because we are not detecting direct assignments:\n      // chart.data.datasets[0].data[5] = 10;\n      // chart.data.datasets[0].data[5].y = 10;\n      this.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @private\n\t */\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n\n  /**\n\t * @private\n   */\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\n", "import DatasetController from '../core/core.datasetController.js';\nimport {\n  _arrayUnique, isArray, isNullOrUndef,\n  valueOrDefault, resolveObjectKey, sign, defined\n} from '../helpers/index.js';\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      // Ignore truncated pixels\n      return;\n    }\n    if (defined(prev)) {\n      // curr - prev === 0 is ignored\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale size.\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\n\nexport default class BarController extends DatasetController {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'bar',\n\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'base', 'width', 'height']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: 'linear',\n        beginAtZero: true,\n      }\n    }\n  };\n\n\n  /**\n\t * Overriding primitive data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding array data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding object data parsing since we support mixed primitive/array\n\t * value-scale data for float bars\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      // float bar: only one end of the bar is considered by `super`\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    this.enableOptionSharing = true;\n\n    super.initialize();\n\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  /**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @param {number} [dataIndex] - The data index of the ruler\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n    const iScaleValue = currentParsed && currentParsed[iScale.axis];\n\n    const skipNull = (meta) => {\n      const parsed = meta._parsed.find(item => item[iScale.axis] === iScaleValue);\n      const val = parsed && parsed[meta.vScale.axis];\n\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n\n      // stacked   | meta.stack\n      //           | found | not found | undefined\n      // false     |   x   |     x     |     x\n      // true      |       |     x     |\n      // undefined |       |     x     |     x\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\n    // stack where possible invisible bars will be located.\n    // https://github.com/chartjs/Chart.js/issues/6368\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  /**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  _getAxisCount() {\n    return this._getAxis().length;\n  }\n\n  getFirstScaleIdForIndexAxis() {\n    const scales = this.chart.scales;\n    const indexScaleId = this.chart.options.indexAxis;\n    return Object.keys(scales).filter(key => scales[key].axis === indexScaleId).shift();\n  }\n\n  _getAxis() {\n    const axis = {};\n    const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();\n    for (const dataset of this.chart.data.datasets) {\n      axis[valueOrDefault(\n        this.chart.options.indexAxis === 'x' ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId\n      )] = true;\n    }\n    return Object.keys(axis);\n  }\n\n  /**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n   * @param {number} [dataIndex]\n\t * @returns {number} The stack index\n\t * @private\n\t */\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1; // indexOf returns -1 if element is not present\n\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      // bar thickness ratio used for non-grouped bars\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  /**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      // bars crossing origin are not stacked\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      // When not visible, no height\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n\n      if (_stacked && !floating) {\n        // visual data coordinates after applying minBarLength\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    const axisCount = this._getAxisCount();\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);\n      const axisID = this.chart.options.indexAxis === 'x' ? this.getDataset().xAxisID : this.getDataset().yAxisID;\n      const axisNumber = this._getAxis().indexOf(valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      // For non-grouped bar charts, exact pixel values are used\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n\n}\n", "import DatasetController from '../core/core.datasetController.js';\nimport {valueOrDefault} from '../helpers/helpers.core.js';\n\nexport default class BubbleController extends DatasetController {\n\n  static id = 'bubble';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'borderWidth', 'radius']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const points = this._cachedMeta.data;\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    // In case values were cached (and thus frozen), we need to clone the values\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n\n    // Custom radius resolution\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\n    return values;\n  }\n}\n", "import DatasetController from '../core/core.datasetController.js';\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\n\nexport default class DoughnutController extends DatasetController {\n\n  static id = 'doughnut';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'arc',\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n      },\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutout: '50%',\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%',\n\n    // Spacing between arcs\n    spacing: 0,\n\n    indexAxis: 'r',\n  };\n\n  static descriptors = {\n    _scriptable: (name) => name !== 'spacing',\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    // Need to override these to give a nice default\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            const {labels: {pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n            if (data.labels.length && data.datasets.length) {\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  fontColor: color,\n                  hidden: !chart.getDataVisibility(i),\n                  lineDash: style.borderDash,\n                  lineDashOffset: style.borderDashOffset,\n                  lineJoin: style.borderJoinStyle,\n                  lineWidth: style.borderWidth,\n                  strokeStyle: style.borderColor,\n                  textAlign: textAlign,\n                  pointStyle: pointStyle,\n                  borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  /**\n\t * Override data parsing, since we are not using scales\n\t */\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  /**\n\t * @private\n\t */\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  /**\n\t * Get the maximal rotation & circumference extents\n\t * across all visible datasets.\n\t */\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n\n    // Compute the maximal rotation & circumference limits.\n    // If we only consider our dataset, this can cause problems when two datasets\n    // are both less than a circle with different rotations (starting angles)\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n\n    meta.total = this.calculateTotal();\n\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @private\n   */\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      // Find the outmost visible dataset\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n\n  /**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  /**\n\t * Returns the sum of all visible data set weights.\n\t * @private\n\t */\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\n", "import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class LineController extends DatasetController {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n\n    showLine: true,\n    spanGaps: false,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n      },\n      _value_: {\n        type: 'linear',\n      },\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    // Update Line\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\n", "import DatasetController from '../core/core.datasetController.js';\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class PolarAreaController extends DatasetController {\n\n  static id = 'polarArea';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    dataElementType: 'arc',\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n      },\n    },\n    indexAxis: 'r',\n    startAngle: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @protected\n   */\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n\n    return range;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n\n    const defaultAngle = 360 / this.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\n", "import DoughnutController from './controller.doughnut.js';\n\n// Pie charts are Doughnut chart with different defaults\nexport default class PieController extends DoughnutController {\n\n  static id = 'pie';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    // The percentage of the chart that we cut out of the middle.\n    cutout: 0,\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%'\n  };\n}\n", "import DatasetController from '../core/core.datasetController.js';\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class RadarController extends DatasetController {\n\n  static id = 'radar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n    indexAxis: 'r',\n    showLine: true,\n    elements: {\n      line: {\n        fill: 'start'\n      }\n    },\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n\n    // Update Line\n    line.points = points;\n    // In resize mode only point locations change, so no need to set the points or options.\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n\n      this.updateElement(line, undefined, properties, mode);\n    }\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\n", "import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class ScatterController extends DatasetController {\n\n  static id = 'scatter';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n    showLine: false,\n    fill: false\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n\n    interaction: {\n      mode: 'point'\n    },\n\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + ')'\n    };\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    if (this.options.showLine) {\n\n      // https://github.com/chartjs/Chart.js/issues/11333\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {dataset: line, _dataset} = meta;\n\n      // Update Line\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      // https://github.com/chartjs/Chart.js/issues/11333\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  addElements() {\n    const {showLine} = this.options;\n\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement('line');\n    }\n\n    super.addElements();\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\n", "/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartOptions} from '../types/index.js';\n\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\n\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\n  readonly options: T;\n  /**\n   * Will called with chart options after adapter creation.\n   */\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\n  /**\n   * Returns a map of time formats for the supported formatting units defined\n   * in Unit as well as 'datetime' representing a detailed date/time string.\n   */\n  formats(this: DateAdapter<T>): Record<TimeUnit | 'datetime', string>;\n  /**\n   * Parses the given `value` and return the associated timestamp.\n   * @param value - the value to parse (usually comes from the data)\n   * @param [format] - the expected data format\n   */\n  parse(this: DateAdapter<T>, value: unknown, format?: string): number | null;\n  /**\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\n   * @param timestamp - the timestamp to format\n   * @param format - the date/time token\n   */\n  format(this: DateAdapter<T>, timestamp: number, format: string): string;\n  /**\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param amount - the amount to add\n   * @param unit - the unit as string\n   */\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\n  /**\n   * Returns the number of `unit` between the given timestamps.\n   * @param a - the input timestamp (reference)\n   * @param b - the timestamp to subtract\n   * @param unit - the unit as string\n   */\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\n  /**\n   * Returns start of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   * @param [weekday] - the ISO day of the week with 1 being Monday\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n   */\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number | boolean): number;\n  /**\n   * Returns end of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   */\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit): number;\n}\n\nfunction abstract<T = void>(): T {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\nclass DateAdapterBase implements DateAdapter {\n\n  /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */\n  static override<T extends AnyObject = AnyObject>(\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\n  ) {\n    Object.assign(DateAdapterBase.prototype, members);\n  }\n\n  readonly options: AnyObject;\n\n  constructor(options?: AnyObject) {\n    this.options = options || {};\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {}\n\n  formats(): Record<TimeUnit | 'datetime', string> {\n    return abstract();\n  }\n\n  parse(): number | null {\n    return abstract();\n  }\n\n  format(): string {\n    return abstract();\n  }\n\n  add(): number {\n    return abstract();\n  }\n\n  diff(): number {\n    return abstract();\n  }\n\n  startOf(): number {\n    return abstract();\n  }\n\n  endOf(): number {\n    return abstract();\n  }\n}\n\nexport default {\n  _date: DateAdapterBase as {\n    new (options?: AnyObject): DateAdapter;\n    override<T extends AnyObject = AnyObject>(\n      members: Partial<Omit<DateAdapter<T>, 'options'>>\n    ): void;\n  }\n};\n", "import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\nimport {_isPointInArea, isNullOrUndef} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\n * @typedef { import('../types/index.js').Point } Point\n */\n\n/**\n * Helper function to do binary search when possible\n * @param {object} metaset - the dataset meta\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {number} value - the value to find\n * @param {boolean} [intersect] - should the element intersect\n * @returns {{lo:number, hi:number}} indices to search data array between\n */\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      const result = lookupMethod(data, axis, value);\n      if (spanGaps) {\n        const {vScale} = controller._cachedMeta;\n        const {_parsed} = metaset;\n\n        const distanceToDefinedLo = (_parsed\n          .slice(0, result.lo + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.lo -= Math.max(0, distanceToDefinedLo);\n\n        const distanceToDefinedHi = (_parsed\n          .slice(result.hi)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.hi += Math.max(0, distanceToDefinedHi);\n      }\n      return result;\n    } else if (controller._sharedOptions) {\n      // _sharedOptions indicates that each element has equal options -> equal proportions\n      // So we can do a ranged binary search based on the range of first element and\n      // be confident to get the full range of indices that can intersect with the value.\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  // Default to all elements, when binary search can not be used.\n  return {lo: 0, hi: data.length - 1};\n}\n\n/**\n * Helper function to select candidate elements for interaction\n * @param {Chart} chart - the chart\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {function} handler - the callback to execute for each visible item\n * @param {boolean} [intersect] - consider intersecting items\n */\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy|r\n */\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {Chart} chart - the chart\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a radial chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a cartesian chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in the chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n\n/**\n * Helper function to get the items matching along the given X or Y axis\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis to match\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n\n  // If we want to trigger on an intersect and we don't have any items\n  // that intersect the position, return nothing\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nexport default {\n  // Part of the public API to facilitate developers creating their own modes\n  evaluateInteractionItems,\n\n  // Helper function for different modes\n  modes: {\n    /**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      // Default axis for index mode is 'x' to match old behaviour\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        // don't count items that are skipped (null data)\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n\n      return elements;\n    },\n\n    /**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n\n      return items;\n    },\n\n    /**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n\n    /**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n", "import {defined, each, isObject} from '../helpers/helpers.core.js';\nimport {toPadding} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n */\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\n\n/**\n * store dimensions used instead of available chartArea in fitBoxes\n **/\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  // dynamically placed boxes size is not considered\n  if (!isObject(pos)) {\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n\n  // return booleans on the changes per direction\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\n    // Dimensions changed and there were non full width boxes before this\n    // -> we have to refit those\n    refit |= same && refitBoxes.length;\n\n    // Chart area changed in the opposite direction\n    changed = changed || other;\n\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\n/**\n * @interface LayoutItem\n * @typedef {object} LayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} draw - Draws the element\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nexport default {\n\n  /**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {LayoutItem} item - the item to add to be laid out\n\t */\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    // initialize item with default values\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    // @ts-ignore\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  /**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\n\t */\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {LayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  /**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n   * @param {number} minPadding - minimum padding required for each side of chart area\n\t */\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n\n    // Before any changes are made, notify boxes that an update is about to being\n    // This is used to clear any cached data (e.g. scale limits)\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n\n    // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\n    // Then fit vertical boxes\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    // Then fit horizontal boxes\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      // if the area changed, re-fit vertical boxes\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n\n    // Finally place the boxes to correct coordinates\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\n    // Move to opposite side of chart\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n\n    // Finally update boxes in chartArea (radial scale for example)\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n", "\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\n/**\n * Abstract class that allows abstracting platform dependencies away from the chart.\n */\nexport default class BasePlatform {\n  /**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n\t * @param {number} [aspectRatio] - The chart options\n\t */\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n  releaseContext(context) { // eslint-disable-line no-unused-vars\n    return false;\n  }\n\n  /**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\n\t */\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n\t */\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  /**\n\t * Returns the maximum size in pixels of given canvas element.\n\t * @param {HTMLCanvasElement} element\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\n\t */\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n  /**\n   * Updates config with platform specific requirements\n   * @param {import('../core/core.config.js').default} config\n   */\n  updateConfig(config) { // eslint-disable-line no-unused-vars\n    // no-op\n  }\n}\n", "/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nimport BasePlatform from './platform.base.js';\n\n/**\n * Platform class for charts without access to the DOM or to many element properties\n * This platform is used by default for any chart passed an OffscreenCanvas.\n * @extends BasePlatform\n */\nexport default class BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n", "/**\n * Chart.Platform implementation for targeting a web browser\n */\n\nimport BasePlatform from './platform.base.js';\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\nimport {throttled} from '../helpers/helpers.extras.js';\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nconst EXPANDO_KEY = '$chartjs';\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n * @param {HTMLCanvasElement} canvas\n * @param {number} [aspectRatio]\n */\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n  // returns null or '' if no explicit value has been set to the canvas attribute.\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n\n  // Chart.js modifies some canvas values that we want to restore on destroy\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n\n  // Force canvas to display as block to avoid extra space caused by inline\n  // elements, which would interfere with the responsive resize process.\n  // https://github.com/chartjs/Chart.js/issues/2538\n  style.display = style.display || 'block';\n  // Include possible borders in the size\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      // If no explicit render height and style height, let's apply the aspect ratio,\n      // which one can be specified by the user but also by charts as default option\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n  if (node) {\n    node.addEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction removeListener(chart, type, listener) {\n  if (chart && chart.canvas) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\n\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      // If the container size shrank during chart resize, let's assume\n      // scrollbar appeared. So we resize again with the scrollbar visible -\n      // effectively making chart smaller and the scrollbar hidden again.\n      // Because we are inside `throttled`, and currently `ticking`, scroll\n      // events are ignored during this whole 2 resize process.\n      // If we assumed wrong and something else happened, we are resizing\n      // twice in a frame (potential performance issue)\n      listener();\n    }\n  }, window);\n\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    // When its container's display is set to 'none' the callback will be called with a\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\n    // resizing in such case.\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    // This case can occur if the chart is destroyed while waiting\n    // for the throttled function to occur. We prevent crashes by checking\n    // for a destroyed chart\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n\n  addListener(canvas, type, proxy);\n\n  return proxy;\n}\n\n/**\n * Platform class for charts that can access the DOM and global window/document properties\n * @extends BasePlatform\n */\nexport default class DomPlatform extends BasePlatform {\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [aspectRatio]\n\t * @return {CanvasRenderingContext2D|null}\n\t */\n  acquireContext(canvas, aspectRatio) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\n    // inside an iframe or when running in a protected environment. We could guess the\n    // types from their toString() value but let's keep things flexible and assume it's\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\n    // https://github.com/chartjs/Chart.js/issues/3887\n    // https://github.com/chartjs/Chart.js/issues/4102\n    // https://github.com/chartjs/Chart.js/issues/4152\n    if (context && context.canvas === canvas) {\n      // Load platform resources on first chart creation, to make it possible to\n      // import the library before setting platform options.\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  /**\n\t * @param {CanvasRenderingContext2D} context\n\t */\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n\n    // The canvas render size might have been changed (and thus the state stack discarded),\n    // we can't use save() and restore() to restore the initial state. So make sure that at\n    // least the canvas context is reset to the default state by setting the canvas width.\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  /**\n\t *\n\t * @param {Chart} chart\n\t * @param {string} type\n\t * @param {function} listener\n\t */\n  addEventListener(chart, type, listener) {\n    // Can have only one listener per type, so make sure previous is removed\n    this.removeEventListener(chart, type);\n\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} type\n\t */\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t */\n  isAttached(canvas) {\n    const container = canvas && _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n", "import {_isDomSupported} from '../helpers/index.js';\nimport BasePlatform from './platform.base.js';\nimport BasicPlatform from './platform.basic.js';\nimport DomPlatform from './platform.dom.js';\n\nexport function _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nexport {BasePlatform, BasicPlatform, DomPlatform};\n", "import type {AnyObject} from '../types/basic.js';\nimport type {Point} from '../types/geometric.js';\nimport type {Animation} from '../types/animation.js';\nimport {isNumber} from '../helpers/helpers.math.js';\n\nexport default class Element<T = AnyObject, O = AnyObject> {\n\n  static defaults = {};\n  static defaultRoutes = undefined;\n\n  x: number;\n  y: number;\n  active = false;\n  options: O;\n  $animations: Record<keyof T, Animation>;\n\n  tooltipPosition(useFinalPosition: boolean): Point {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y} as Point;\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  /**\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\n   * @param props - properties to get\n   * @param [final] - get the final value (animation target)\n   */\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      // let's not create an object, if not needed\n      return this as Record<string, unknown>;\n    }\n    const ret: Record<string, unknown> = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\n    });\n    return ret;\n  }\n}\n", "import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\nimport {_factorize} from '../helpers/helpers.math.js';\n\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\n * @param {import('./core.scale.js').default} scale\n * @param {Tick[]} ticks\n * @return {Tick[]}\n * @private\n */\nexport function autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  // If there are too many major ticks to display them all\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\n/**\n * @param {number[]} majorIndices\n * @param {Tick[]} ticks\n * @param {number} ticksLimit\n */\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  // If the major ticks are evenly spaced apart, place the minor ticks\n  // so that they divide the major ticks into even chunks\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\n\n/**\n * @param {Tick[]} ticks\n */\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number[]} majorIndices\n * @param {number} spacing\n */\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number} spacing\n * @param {number} [majorStart]\n * @param {number} [majorEnd]\n */\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\n\n/**\n * @param {number[]} arr\n */\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n", "import Element from './core.element.js';\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\nimport {autoSkip} from './core.scale.autoskip.js';\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\n\n/**\n * @typedef { import('../types/index.js').Chart } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a new array containing numItems from arr\n * @param {any[]} arr\n * @param {number} numItems\n */\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @param {boolean} offsetGridLines\n */\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n\n    // Return undefined if the pixel is out of the range\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\n\n/**\n * @param {object} caches\n * @param {number} length\n */\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\n/**\n * @param {object} options\n */\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\n/**\n * @param {object} options\n */\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n\n  return (lines * font.lineHeight) + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  /** @type {CanvasTextAlign} */\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\n\nexport default class Scale extends Element {\n\n  // eslint-disable-next-line max-statements\n  constructor(cfg) {\n    super();\n\n    /** @type {string} */\n    this.id = cfg.id;\n    /** @type {string} */\n    this.type = cfg.type;\n    /** @type {any} */\n    this.options = undefined;\n    /** @type {CanvasRenderingContext2D} */\n    this.ctx = cfg.ctx;\n    /** @type {Chart} */\n    this.chart = cfg.chart;\n\n    // implements box\n    /** @type {number} */\n    this.top = undefined;\n    /** @type {number} */\n    this.bottom = undefined;\n    /** @type {number} */\n    this.left = undefined;\n    /** @type {number} */\n    this.right = undefined;\n    /** @type {number} */\n    this.width = undefined;\n    /** @type {number} */\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /** @type {number} */\n    this.maxWidth = undefined;\n    /** @type {number} */\n    this.maxHeight = undefined;\n    /** @type {number} */\n    this.paddingTop = undefined;\n    /** @type {number} */\n    this.paddingBottom = undefined;\n    /** @type {number} */\n    this.paddingLeft = undefined;\n    /** @type {number} */\n    this.paddingRight = undefined;\n\n    // scale-specific properties\n    /** @type {string=} */\n    this.axis = undefined;\n    /** @type {number=} */\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    /** @type {Tick[]} */\n    this.ticks = [];\n    /** @type {object[]|null} */\n    this._gridLineItems = null;\n    /** @type {object[]|null} */\n    this._labelItems = null;\n    /** @type {object|null} */\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    /** @type {number} */\n    this._startPixel = undefined;\n    /** @type {number} */\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @param {any} options\n\t * @since 3.0\n\t */\n  init(options) {\n    this.options = options.setContext(this.getContext());\n\n    this.axis = options.axis;\n\n    // parse min/max value, so we can properly determine min/max for other scales\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n\n  /**\n\t * Parse a supported input value to internal representation.\n\t * @param {*} raw\n\t * @param {number} [index]\n\t * @since 3.0\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    return raw;\n  }\n\n  /**\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isFinite(_userMin),\n      maxDefined: isFinite(_userMax)\n    };\n  }\n\n  /**\n\t * @param {boolean} canStack\n\t * @return {{min: number, max: number}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  /**\n\t * Get the padding needed for the scale\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\n\t * @private\n\t */\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n\n  /**\n\t * Returns the scale tick objects\n\t * @return {Tick[]}\n\t * @since 2.7\n\t */\n  getTicks() {\n    return this.ticks;\n  }\n\n  /**\n\t * @return {string[]}\n\t */\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  /**\n   * @return {import('../types.js').LabelItem[]}\n   */\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n\n  // When a new layout is created, reset the data limits cache\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n\n  beforeUpdate() {\n    call(this.options.beforeUpdate, [this]);\n  }\n\n  /**\n\t * @param {number} maxWidth - the max width in pixels\n\t * @param {number} maxHeight - the max height in pixels\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\n\t *   This space comes from two sources:\n\t *     - padding - space that's required to show the labels at the edges of the scale\n\t *     - thickness of scales or legends in another orientation\n\t */\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n    this.beforeUpdate();\n\n    // Absorb the master measurements\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n\n    // Dimensions\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n\n    // Data min/max\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n\n    this.beforeBuildTicks();\n\n    this.ticks = this.buildTicks() || [];\n\n    // Allow modification of ticks in callback.\n    this.afterBuildTicks();\n\n    // Compute tick rotation and fit using a sampled subset of labels\n    // We generally don't need to compute the size of every single label for determining scale size\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\n    // configure is called twice, once here, once from core.controller.updateLayout.\n    // Here we haven't been positioned yet, but dimensions are correct.\n    // Variables set in configure are needed for calculateLabelRotation, and\n    // it's ok that coordinates are not correct there, only dimensions matter.\n    this.configure();\n\n    // Tick Rotation\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\n    this.afterCalculateLabelRotation();\n\n    // Auto-skip\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n\n    if (samplingEnabled) {\n      // Generate labels using all non-skipped ticks\n      this._convertTicksToLabels(this.ticks);\n    }\n\n    this.beforeFit();\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\n    this.afterFit();\n\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n    this.afterUpdate();\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      // by default vertical scales are from bottom to top, so pixels are reversed\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    call(this.options.afterUpdate, [this]);\n  }\n\n  //\n\n  beforeSetDimensions() {\n    call(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    if (this.isHorizontal()) {\n      // Reset position before calculating rotation\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n\n      // Reset position before calculating rotation\n      this.top = 0;\n      this.bottom = this.height;\n    }\n\n    // Reset padding\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    call(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    call(this.options[name], [this]);\n  }\n\n  // Data limits\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  //\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  /**\n\t * @return {object[]} the ticks\n\t */\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    call(this.options.beforeTickToLabelConversion, [this]);\n  }\n  /**\n\t * Convert ticks to label strings\n\t * @param {Tick[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    call(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  //\n\n  beforeCalculateLabelRotation() {\n    call(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    // Estimate the width of each grid based on the canvas width, the maximum\n    // label width and the number of tick intervals\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    // Allow 3 pixels x2 padding either side for label readability\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    call(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n\n  //\n\n  beforeFit() {\n    call(this.options.beforeFit, [this]);\n  }\n  fit() {\n    // Reset\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight; // fill all the height\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      // Don't bother fitting the ticks if we are not showing the labels\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    this._handleMargins();\n\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n      // which means that the right padding is dominated by the font height\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      // Adjust padding taking into account changes in offsets\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  /**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    call(this.options.afterFit, [this]);\n  }\n\n  // Shared Methods\n  /**\n\t * @return {boolean}\n\t */\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  /**\n\t * @return {boolean}\n\t */\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  /**\n\t * @param {Tick[]} ticks\n\t * @private\n\t */\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n\n    this.generateTickLabels(ticks);\n\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    this.afterTickToLabelConversion();\n  }\n\n  /**\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n\n    return labelSizes;\n  }\n\n  /**\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\n\t * labels where offset indicates the anchor point offset from the top in pixels.\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      // Undefined labels and arrays should not be measured\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = /** @type {string} */ (label[j]);\n          // Undefined labels and arrays should not be measured\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n\n  /**\n\t * Used to get the label to display in the tooltip for the given value\n\t * @param {*} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value;\n  }\n\n  /**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {*} value\n\t * @param {number} [index]\n\t * @return {number}\n\t */\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\n    return NaN;\n  }\n\n  /**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} pixel\n\t * @return {*}\n\t */\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} index\n\t * @return {number}\n\t */\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  /**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} decimal\n\t * @return {number}\n\t */\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  /**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @return {number}\n\t */\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  /**\n\t * @return {number}\n\t */\n  getBaseValue() {\n    const {min, max} = this;\n\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index) {\n    const ticks = this.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n\n  /**\n\t * @return {number}\n\t * @private\n\t */\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n\n    // Calculate space needed by label in axis direction.\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\n    // Calculate space needed for 1 tick in axis direction.\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  /**\n\t * @return {boolean}\n\t * @private\n\t */\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position, border} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\n      lineValue = getPixelForGridLine(this, i, offset);\n\n      // Skip if the pixel is out of the range\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n\n    return items;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += (lineHeight / 2) * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        default:\n          break;\n        }\n\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        case 'inner':\n          if (i === ilen - 1) {\n            left -= width;\n          } else if (i > 0) {\n            left -= width / 2;\n          }\n          break;\n        default:\n          break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n\n          color: optsAtIndex.backdropColor,\n        };\n      }\n\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop,\n        }\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {textAlign, x};\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = this.chart;\n    const position = this.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n\n  /**\n   * @protected\n   */\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {\n    const {chart, ctx, options: {border, grid}} = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = this.ctx;\n\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n\n  /**\n\t * @return {object[]}\n\t * @private\n\t */\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      // backward compatibility: draw has been overridden by custom scale\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n\n  /**\n\t * Returns visible dataset metas that are attached to this scale\n\t * @param {string} [type] - if specified, also filter by dataset type\n\t * @return {object[]}\n\t */\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n\n  /**\n\t * @param {number} index\n\t * @return {object}\n\t * @protected\n \t */\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  /**\n   * @protected\n   */\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n", "import {merge} from '../helpers/index.js';\nimport defaults, {overrides} from './core.defaults.js';\n\n/**\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\n */\n\nexport default class TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t * @returns {string} The scope where items defaults were registered to.\n\t */\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      // Make sure the parent is registered and note the scope where its defaults are.\n      parentScope = this.register(proto);\n    }\n\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      // already registered\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object?}\n\t */\n  get(id) {\n    return this.items[id];\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t */\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  // Inherit the parent's defaults and keep existing defaults\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n", "import DatasetController from './core.datasetController.js';\nimport Element from './core.element.js';\nimport Scale from './core.scale.js';\nimport TypedRegistry from './core.typedRegistry.js';\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    // Order is important, Scale has Element in prototype chain,\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof DatasetController}\n\t */\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Element}\n\t */\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object}\n\t */\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Scale}\n\t */\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  /**\n\t * @private\n\t */\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        // Handle loopable args\n        // Use case:\n        //  import * as plugins from './plugins.js';\n        //  Chart.register(plugins);\n        each(arg, item => {\n          // If there are mixed types in the loopable, make sure those are\n          // registered in correct registry\n          // Use case: (treemap exporting controller, elements etc)\n          //  import * as treemap from 'chartjs-chart-treemap.js';\n          //  Chart.register(treemap);\n\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\n    registry[method](component);\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\n  }\n\n  /**\n\t * @private\n\t */\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    // plugins is the fallback registry\n    return this.plugins;\n  }\n\n  /**\n\t * @private\n\t */\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Registry();\n", "import registry from './core.registry.js';\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\n */\n\n/**\n * @callback filterCallback\n * @param {{plugin: object, options: object}} value\n * @param {number} [index]\n * @param {array} [array]\n * @param {object} [thisArg]\n * @return {boolean}\n */\n\n\nexport default class PluginService {\n  constructor() {\n    this._init = undefined;\n  }\n\n  /**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n\n    if (this._init === undefined) { // Do not trigger events before install\n      return;\n    }\n\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n      this._init = undefined; // Do not trigger events after uninstall\n    }\n    return result;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    // When plugins are registered, there is the possibility of a double\n    // invalidate situation. In this case, we only want to invalidate once.\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\n    // plugins are restarted without being correctly stopped.\n    // See https://github.com/chartjs/Chart.js/issues/8147\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    // options === false => all plugins are disabled\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\n\n/**\n * @param {import('./core.config.js').default} config\n */\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n\n  return {plugins, localIds};\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\n\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    // make sure plugin defaults are in scopes for local (not registered) plugins\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    // These are just defaults that plugins can override\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n", "import defaults, {overrides, descriptors} from './core.defaults.js';\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\n\nexport function getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction idMatchesAxis(id) {\n  if (id === 'x' || id === 'y' || id === 'r') {\n    return id;\n  }\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nexport function determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis\n      || axisFromPosition(opts.position)\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\n\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + 'AxisID'] === id) {\n    return {axis};\n  }\n}\n\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n    }\n  }\n  return {};\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales = Object.create(null);\n\n  // First figure out first scale id's per axis.\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n\n  // Then merge dataset defaults to scale configs\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n\n  // apply scale defaults, if not overridden by dataset defaults\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n\n  initOptions(config);\n\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nexport default class Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @return {string[][]}\n   */\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset animation options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @param {string} transition\n   * @return {string[][]}\n   */\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        // The following are used for looking up the `animations` and `animation` keys\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving element options that belong\n   * to an dataset. These keys do not include the dataset itself, because it\n   * is not under options.\n   * @param {string} datasetType\n   * @param {string} elementType\n   * @return {string[][]}\n   */\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving plugin options.\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\n   * @return {string[][]}\n   */\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n\n  /**\n   * @private\n   */\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n\n  /**\n   * Resolves the objects from options and defaults for option value resolution.\n   * @param {object} mainScope - The main scope object for options\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\n   */\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n\n  /**\n   * Returns the option scopes for resolving chart options\n   * @return {object[]}\n   */\n  chartOptionScopes() {\n    const {options, type} = this;\n\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {string[]} names\n   * @param {function|object} context\n   * @param {string[]} [prefixes]\n   * @return {object}\n   */\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {object} [context]\n   * @param {string[]} [prefixes]\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\n   */\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\n\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));\n\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n", "import animator from './core.animator.js';\nimport defaults, {overrides} from './core.defaults.js';\nimport Interaction from './core.interaction.js';\nimport layouts from './core.layouts.js';\nimport {_detectPlatform} from '../platform/index.js';\nimport PluginService from './core.plugins.js';\nimport registry from './core.registry.js';\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea, _isDomSupported, retinaScale, getDatasetClipArea} from '../helpers/index.js';\n// @ts-ignore\nimport {version} from '../../package.json';\nimport {debounce} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').Point } Point\n */\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\n\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n\n  chart.notifyPlugins('afterRender');\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\n/**\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\n */\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    // Support for array based queries (such as jQuery)\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    // Support for any object associated to a canvas (including a context2d)\n    item = item.canvas;\n  }\n  return item;\n}\n\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\n\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\n\n/**\n * @param {ChartEvent} e\n * @param {ChartEvent|null} lastEvent\n * @param {boolean} inChartArea\n * @param {boolean} isClick\n * @returns {ChartEvent|null}\n */\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\n\nclass Chart {\n\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    // Store the previously used aspect ratio to determine if a resize\n    // is needed during updates. Do this after _options is set since\n    // aspectRatio uses a getter\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n\n    // Add the chart instance to the global namespace\n    instances[this.id] = this;\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      // If aspectRatio is defined in options, use that.\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\n      return _aspectRatio;\n    }\n\n    // Calculate\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  get registry() {\n    return registry;\n  }\n\n  /**\n\t * @private\n\t */\n  _initialize() {\n    // Before init plugin notification\n    this.notifyPlugins('beforeInit');\n\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n\n    this.bindEvents();\n\n    // After init plugin notification\n    this.notifyPlugins('afterInit');\n\n    return this;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  /**\n\t * Resize the chart to its container or to explicit dimensions.\n\t * @param {number} [width]\n\t * @param {number} [height]\n\t */\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n\n    this.notifyPlugins('resize', {size: newSize});\n\n    callCallback(options.onResize, [this, newSize], this);\n\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        // The resize update is delayed, only draw without updating.\n        this.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  /**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    // clear up discarded scales\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  /**\n\t * @private\n\t */\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n\n    this._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    this._updateMetasets();\n    return newControllers;\n  }\n\n  /**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n\n  /**\n\t* Resets the chart back to its state before the initial animation\n\t*/\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const config = this.config;\n\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n\n    // plugins options references might have change, let's invalidate the cache\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n    this._plugins.invalidate();\n\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    // Make sure dataset controllers are updated and new controllers are reset\n    const newControllers = this.buildOrUpdateControllers();\n\n    this.notifyPlugins('beforeElementsUpdate');\n\n    // Make sure all dataset controllers have correct meta data counts\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      // New controllers will be reset after the layout pass, so we only want to modify\n      // elements added to new datasets\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n\n    // Only reset the controllers if we have animations\n    if (!animsDisabled) {\n      // Can only reset the new controllers after the scales have been updated\n      // Reset is done to get the starting point for the initial animation\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n\n    this._updateDatasets(mode);\n\n    // Do this before render so that any plugins that need final scale updates can use it\n    this.notifyPlugins('afterUpdate', {mode});\n\n    this._layers.sort(compare2Level('z', '_idx'));\n\n    // Replay last event from before update, or set hover styles on active elements\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n\n  /**\n   * @private\n   */\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      // The configured events have changed. Rebind.\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n\n  /**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n\n    layouts.update(this, this.width, this.height, minPadding);\n\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\n        return;\n      }\n\n      // configure is called twice, once in core.scale.update and once here.\n      // Here the boxes are fully updated and at their final positions.\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    this.notifyPlugins('afterLayout');\n  }\n\n  /**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n\n  /**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      // Unset pending resize request now to avoid possible recursion within _resize\n      this._resizeBeforeDraw = null;\n      this._resize(width, height);\n    }\n    this.clear();\n\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n    // currently be part of layers. Instead, we draw\n    // layers <= 0 before(default, backward compat), and the rest after\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this._drawDatasets();\n\n    // Rest of layers\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this.notifyPlugins('afterDraw');\n  }\n\n  /**\n\t * @private\n\t */\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n\t * Gets the visible dataset metas in drawing order\n\t * @return {object[]}\n\t */\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  /**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n\n  /**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    // @ts-expect-error\n    const clip = getDatasetClipArea(this, meta);\n\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (clip) {\n      clipArea(ctx, clip);\n    }\n\n    meta.controller.draw();\n\n    if (clip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  /**\n   * Checks whether the given point is in the chart area.\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\n   * @returns {boolean}\n   */\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\t\t\t// See isDatasetVisible() comment\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  /**\n\t * @private\n\t */\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  /**\n\t * @private\n\t */\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n\n    this._stop();\n    this.config.clearCache();\n\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n\n    delete instances[this.id];\n\n    this.notifyPlugins('afterDestroy');\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  /**\n\t * @private\n\t */\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  /**\n   * @private\n   */\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n\n    each(this.options.events, (type) => _add(type, listener));\n  }\n\n  /**\n   * @private\n   */\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n\n    let detached; // eslint-disable-line prefer-const\n    const attached = () => {\n      _remove('attach', attached);\n\n      this.attached = true;\n      this.resize();\n\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      this.attached = false;\n\n      _remove('resize', listener);\n\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\n      this._stop();\n      this._resize(0, 0);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  /**\n\t * Get active (hovered) elements\n\t * @returns array\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active (hovered) elements\n\t * @param {array} activeElements New active data points\n\t */\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      this._active = active;\n      // Make sure we don't use the previous mouse event to override the active elements in update.\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  /**\n\t * Calls enabled plugins on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  /**\n   * Check if a plugin with the specific ID is registered and enabled\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\n   * @returns {boolean}\n   */\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      this.render();\n    }\n\n    return this;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e the event to handle\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\n\t * @return {boolean} true if the chart needs to re-render\n\t * @private\n\t */\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n\n    // If the event is replayed from `update`, we should evaluate with the final positions.\n    //\n    // The `replay`:\n    // It's the last event (excluding click) that has occurred before `update`.\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\n    //\n    // The why:\n    // If animations are active, the elements haven't moved yet compared to state before update.\n    // But if they will, we are activating the elements that would be active, if this check\n    // was done after the animations have completed. => \"final positions\".\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\n    // This is done so we do not have to evaluate the active elements each animation frame\n    // - it would be expensive.\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\n    if (inChartArea) {\n      // Set _lastEvent to null while we are processing the event handlers.\n      // This prevents recursion if the handler calls chart.update()\n      this._lastEvent = null;\n\n      // Invoke onHover hook\n      callCallback(options.onHover, [e, active, this], this);\n\n      if (isClick) {\n        callCallback(options.onClick, [e, active, this], this);\n      }\n    }\n\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n\n    this._lastEvent = lastEvent;\n\n    return changed;\n  }\n\n  /**\n   * @param {ChartEvent} e - The event\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\n   * @param {boolean} inChartArea - Is the event inside chartArea\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\n   * @pravate\n   */\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\n\n// @ts-ignore\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\n\nexport default Chart;\n", "import Element from '../core/core.element.js';\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\nimport {PI, _angleDiff, _normalizeAngle, _isBetween, _limitValue} from '../helpers/helpers.math.js';\nimport {_readValueToProps} from '../helpers/helpers.options.js';\nimport type {ArcOptions, Point} from '../types/index.js';\n\nfunction clipSelf(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, x, y, outerRadius, innerRadius, options} = element;\n  const {borderWidth, borderJoinStyle} = options;\n  const outerAngleClip = Math.min(borderWidth / outerRadius, _normalizeAngle(startAngle - endAngle));\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);\n\n  if (innerRadius > 0) {\n    const innerAngleClip = Math.min(borderWidth / innerRadius, _normalizeAngle(startAngle - endAngle));\n    ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);\n  } else {\n    const clipWidth = Math.min(borderWidth / 2, outerRadius * _normalizeAngle(startAngle - endAngle));\n\n    if (borderJoinStyle === 'round') {\n      ctx.arc(x, y, clipWidth, endAngle - PI / 2, startAngle + PI / 2, true);\n    } else if (borderJoinStyle === 'bevel') {\n      const r = 2 * clipWidth * clipWidth;\n      const endX = -r * Math.cos(endAngle + PI / 2) + x;\n      const endY = -r * Math.sin(endAngle + PI / 2) + y;\n      const startX = r * Math.cos(startAngle + PI / 2) + x;\n      const startY = r * Math.sin(startAngle + PI / 2) + y;\n      ctx.lineTo(endX, endY);\n      ctx.lineTo(startX, startY);\n    }\n  }\n  ctx.closePath();\n\n  ctx.moveTo(0, 0);\n  ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  ctx.clip('evenodd');\n}\n\n\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n\n  // Draw an inner border by clipping the arc and drawing a double-width border\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\n/**\n * Parse border radius from the provided options\n */\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  // Outer limits are complicated. We want to compute the available angular distance at\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n  //\n  // If the borderRadius is large, that value can become negative.\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n  // we know that the thickness term will dominate and compute the limits at that point\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\n\n/**\n * Convert (r, ) to (x, y)\n */\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\n\n\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */\nfunction pathArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  end: number,\n  circular: boolean,\n) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    // When spacing is present, it is the same for all items\n    // So we adjust the start and end angle of the arc such that\n    // the distance is the same as it would be without the spacing\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\n\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\n  ctx.beginPath();\n\n  if (circular) {\n    // The first arc segments from point 1 to point a to point 2\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n\n    // The corner segment from point 2 to point 3\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n\n    // The line from point 3 to point 4\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n\n    // The corner segment from point 4 to point 5\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n\n    // The inner arc from point 5 to point b to point 6\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\n\n    // The corner segment from point 6 to point 7\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n\n    // The line from point 7 to point 8\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n\n    // The corner segment from point 8 to point 1\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawBorder(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference, options} = element;\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius} = options;\n  const inner = options.borderAlign === 'inner';\n\n  if (!borderWidth) {\n    return;\n  }\n\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  if (options.selfJoin && endAngle - startAngle >= PI && borderRadius === 0 && borderJoinStyle !== 'miter') {\n    clipSelf(ctx, element, endAngle);\n  }\n\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\n\nexport interface ArcProps extends Point {\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  outerRadius: number;\n  circumference: number;\n}\n\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\n\n  static id = 'arc';\n\n  static defaults = {\n    borderAlign: 'center',\n    borderColor: '#fff',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n    selfJoin: false,\n  };\n\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor'\n  };\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash'\n  };\n\n  circumference: number;\n  endAngle: number;\n  fullCircles: number;\n  innerRadius: number;\n  outerRadius: number;\n  pixelMargin: number;\n  startAngle: number;\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n    const betweenAngles = _circumference >= TAU || nonZeroBetween;\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\n    return (betweenAngles && withinRadius);\n  }\n\n  getCenterPoint(useFinalPosition: boolean) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius'\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition: boolean) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n\n    ctx.restore();\n  }\n}\n", "import Element from '../core/core.element.js';\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\nimport {valueOrDefault} from '../helpers/index.js';\n\n/**\n * @typedef { import('./element.point.js').default } PointElement\n */\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @returns {any}\n */\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  // eslint-disable-next-line prefer-const\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      // Draw line to maxY and minY, using the average x-coordinate\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      // Line to y-value of last point in group. So the line continues\n      // from correct position. Not using move, to have solid path.\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0; // truncated x-coordinate\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      // Draw line to next x-position, using the first (or only)\n      // y-value in that group\n      ctx.lineTo(x, y);\n\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    // Keep track of the last y-value in group\n    lastY = y;\n  }\n  drawX();\n}\n\n/**\n * @param {LineElement} line - the line\n * @returns {function}\n * @private\n */\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\n/**\n * @private\n */\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nexport default class LineElement extends Element {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: 'default',\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n  };\n\n\n  constructor(cfg) {\n    super();\n\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  /**\n\t * First non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  /**\n\t * Last non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  /**\n\t * Interpolate a point in this line at the same value on `property` as\n\t * the reference `point` provided\n\t * @param {PointElement} point - the reference point\n\t * @param {string} property - the property to match on\n\t * @returns {PointElement|undefined}\n\t */\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n\t * Append a segment of this line to current path.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} segment\n\t * @param {number} segment.start - start index of the segment, referring the points array\n \t * @param {number} segment.end - end index of the segment, referring the points array\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\n\t * @param {object} params\n\t * @param {boolean} params.move - move to starting point (vs line to it)\n\t * @param {boolean} params.reverse - path the segment from end to start\n\t * @param {number} params.start - limit segment to points starting from `start` index\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\n\t */\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  /**\n\t * Append all segments of this line to current path.\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\n\t */\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n\n    start = start || 0;\n    count = count || (this.points.length - start);\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n\n  /**\n\t * Draw\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} chartArea\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t */\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n\n    if (points.length && options.borderWidth) {\n      ctx.save();\n\n      draw(ctx, this, start, count);\n\n      ctx.restore();\n    }\n\n    if (this.animated) {\n      // When line is animated, the control points and path are not cached.\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\n", "import Element from '../core/core.element.js';\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport type {\n  CartesianParsedData,\n  ChartArea,\n  Point,\n  PointHoverOptions,\n  PointOptions,\n} from '../types/index.js';\n\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\n\nexport type PointProps = Point\n\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\n\n  static id = 'point';\n\n  parsed: CartesianParsedData;\n  skip?: boolean;\n  stop?: boolean;\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: 'circle',\n    radius: 3,\n    rotation: 0\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition?: boolean) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\n    const options = this.options;\n\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    // @ts-expect-error Fallbacks should never be hit in practice\n    return options.radius + options.hitRadius;\n  }\n}\n", "import Element from '../core/core.element.js';\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\n\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param {BarElement} bar the bar\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\n\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {left, top, right, bottom};\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n\n  // If the value is an object, assume the user knows what they are doing\n  // and apply as directed.\n  const enableBorder = enableBorderRadius || isObject(value);\n\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\n/**\n * Add a path of a rectangle to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nexport default class BarElement extends Element {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderSkipped: 'start',\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: 'auto',\n    pointStyle: undefined\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\n", "import {DoughnutController, PolarAreaController, defaults} from '../index.js';\nimport type {Chart, ChartDataset} from '../types.js';\n\nexport interface ColorsPluginOptions {\n  enabled?: boolean;\n  forceOverride?: boolean;\n}\n\ninterface ColorsDescriptor {\n  backgroundColor?: unknown;\n  borderColor?: unknown;\n}\n\nconst BORDER_COLORS = [\n  'rgb(54, 162, 235)', // blue\n  'rgb(255, 99, 132)', // red\n  'rgb(255, 159, 64)', // orange\n  'rgb(255, 205, 86)', // yellow\n  'rgb(75, 192, 192)', // green\n  'rgb(153, 102, 255)', // purple\n  'rgb(201, 203, 207)' // grey\n];\n\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\n\nfunction getBorderColor(i: number) {\n  return BORDER_COLORS[i % BORDER_COLORS.length];\n}\n\nfunction getBackgroundColor(i: number) {\n  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\n\nfunction colorizeDefaultDataset(dataset: ChartDataset, i: number) {\n  dataset.borderColor = getBorderColor(i);\n  dataset.backgroundColor = getBackgroundColor(i);\n\n  return ++i;\n}\n\nfunction colorizeDoughnutDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));\n\n  return i;\n}\n\nfunction colorizePolarAreaDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));\n\n  return i;\n}\n\nfunction getColorizer(chart: Chart) {\n  let i = 0;\n\n  return (dataset: ChartDataset, datasetIndex: number) => {\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n\n    if (controller instanceof DoughnutController) {\n      i = colorizeDoughnutDataset(dataset, i);\n    } else if (controller instanceof PolarAreaController) {\n      i = colorizePolarAreaDataset(dataset, i);\n    } else if (controller) {\n      i = colorizeDefaultDataset(dataset, i);\n    }\n  };\n}\n\nfunction containsColorsDefinitions(\n  descriptors: ColorsDescriptor[] | Record<string, ColorsDescriptor>\n) {\n  let k: number | string;\n\n  for (k in descriptors) {\n    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction containsColorsDefinition(\n  descriptor: ColorsDescriptor\n) {\n  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\n\nfunction containsDefaultColorsDefenitions() {\n  return defaults.borderColor !== 'rgba(0,0,0,0.1)' || defaults.backgroundColor !== 'rgba(0,0,0,0.1)';\n}\n\nexport default {\n  id: 'colors',\n\n  defaults: {\n    enabled: true,\n    forceOverride: false\n  } as ColorsPluginOptions,\n\n  beforeLayout(chart: Chart, _args, options: ColorsPluginOptions) {\n    if (!options.enabled) {\n      return;\n    }\n\n    const {\n      data: {datasets},\n      options: chartOptions\n    } = chart.config;\n    const {elements} = chartOptions;\n\n    const containsColorDefenition = (\n      containsColorsDefinitions(datasets) ||\n      containsColorsDefinition(chartOptions) ||\n      (elements && containsColorsDefinitions(elements)) ||\n      containsDefaultColorsDefenitions());\n\n    if (!options.forceOverride && containsColorDefenition) {\n      return;\n    }\n\n    const colorizer = getColorizer(chart);\n\n    datasets.forEach(colorizer);\n  }\n};\n", "import {_limitValue, _lookupByKey, isNullOrUndef, resolve} from '../helpers/index.js';\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  /**\n   * Implementation of the Largest Triangle Three Buckets algorithm.\n   *\n   * This implementation is based on the original implementation by Sveinn Steinarsson\n   * in https://github.com/sveinn-steinarsson/flot-downsample/blob/master/jquery.flot.downsample.js\n   *\n   * The original implementation is MIT licensed.\n   */\n  const samples = options.samples || availableWidth;\n  // There are less points than the threshold, returning the whole array\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n\n  const decimated = [];\n\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  // Starting from offset\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n\n  decimated[sampledIndex++] = data[a];\n\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n\n    // Adding offset\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n\n    // Adding offset\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n\n    // Note that this is changed from the original algorithm which initializes these\n    // values to 1. The reason for this change is that if the area is small, nextA\n    // would never be set and thus a crash would occur in the next loop as `a` would become\n    // `undefined`. Since the area is always positive, but could be 0 in the case of a flat trace,\n    // initializing with a negative number is the correct solution.\n    maxArea = area = -1;\n\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n\n  // Include the last point\n  decimated[sampledIndex++] = data[endIndex];\n\n  return decimated;\n}\n\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      // Use point.x here because we're computing the average data `x` value\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      // Push up to 4 points, 3 for the last interval and the first point for this interval\n      const lastIndex = i - 1;\n\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        // The interval is defined by 4 points: start, min, max, end.\n        // The starting point is already considered at this point, so we need to determine which\n        // of the other points to add. We need to sort these points to ensure the decimated data\n        // is still sorted and then ensure there are no duplicates.\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n\n      // lastIndex === startIndex will occur when a range has only 1 point which could\n      // happen with very uneven data\n      if (i > 0 && lastIndex !== startIndex) {\n        // Last point in the previous interval\n        decimated.push(data[lastIndex]);\n      }\n\n      // Start of the new interval\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n\n  return decimated;\n}\n\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: data,\n    });\n  }\n}\n\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\n\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count;\n\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n\n  return {start, count};\n}\n\nexport default {\n  id: 'decimation',\n\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      // The decimation plugin may have been previously enabled. Need to remove old `dataset._data` handlers\n      cleanDecimatedData(chart);\n      return;\n    }\n\n    // Assume the entire chart is available to show a few more points than needed\n    const availableWidth = chart.width;\n\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        // Decimation is only supported for lines that have an X indexAxis\n        return;\n      }\n\n      if (!meta.controller.supportsDecimation) {\n        // Only line datasets are supported\n        return;\n      }\n\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        // Only linear interpolation is supported\n        return;\n      }\n\n      if (chart.options.parsing) {\n        // Plugin only supports data that does not need parsing\n        return;\n      }\n\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        // No decimation is required until we are above this threshold\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n\n      if (isNullOrUndef(_data)) {\n        // First time we are seeing this dataset\n        // We override the 'data' property with a setter that stores the\n        // raw data in _data, but reads the decimated data from _decimated\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n\n      // Point the chart to the decimated data\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n\n      dataset._decimated = decimated;\n    });\n  },\n\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n", "import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\n\nexport function _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      // Special case for boundary not supporting `segments` (simpleArc)\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\n\nexport function _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\n\nexport function _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\n\nexport function _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n", "/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {isArray} from '../../helpers/index.js';\nimport {_pointsFromSegments} from './filler.segment.js';\n\n/**\n * @param {PointElement[] | { x: number; y: number; }} boundary\n * @param {LineElement} line\n * @return {LineElement?}\n */\nexport function _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    // @ts-ignore\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nexport function _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n", "import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.line.js').default } LineElement\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\n */\n\nexport function _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\n/**\n * @param {LineElement} line\n * @param {number} index\n * @param {number} count\n */\nexport function _decodeFill(line, index, count) {\n  /** @type {string | {value: number}} */\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n\n  return target;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @returns {number | null}\n */\nexport function _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @param {number} startValue\n * @returns {number | undefined}\n */\nexport function _getTargetValue(fill, scale, startValue) {\n  let value;\n\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\n\n/**\n * @param {LineElement} line\n */\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n", "/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {_isBetween} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\n\n/**\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\n * @return {LineElement}\n */\nexport function _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @return {LineElement[]}\n */\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\n\n/**\n * @param {PointElement[]} points\n * @param {PointElement} sourcePoint\n * @param {LineElement[]} linesBelow\n */\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      // First point of a segment -> need to add another point before this,\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        // In the middle of a segment, no need to add more points.\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\n\n/**\n * @param {LineElement} line\n * @param {PointElement} sourcePoint\n * @param {string} property\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\n */\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n", "import {TAU} from '../../helpers/index.js';\n\n// TODO: use elements.ArcElement instead\nexport class simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n", "import {isFinite} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\nimport {_buildStackLine} from './filler.target.stack.js';\nimport {simpleArc} from './simpleArc.js';\n\n/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nexport function _getTarget(source) {\n  const {chart, fill, line} = source;\n\n  if (isFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n\n  return _createBoundaryLine(boundary, line);\n}\n\n/**\n * @param {Chart} chart\n * @param {number} index\n */\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\n\n\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n\n  if (isFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n\n  return null;\n}\n\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\n", "import {clipArea, unclipArea, getDatasetClipArea} from '../../helpers/index.js';\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\nimport {_getTarget} from './filler.target.js';\n\nexport function _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {chart, index, line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  const meta = chart.getDatasetMeta(index);\n  const clip = getDatasetClipArea(chart, meta);\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis, clip});\n    unclipArea(ctx);\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale, clip} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n\n  ctx.save();\n\n  let fillColor = below;\n  if (below !== above) {\n    if (property === 'x') {\n      clipVertical(ctx, target, area.top);\n      fill(ctx, {line, target, color: above, scale, property, clip});\n      ctx.restore();\n      ctx.save();\n      clipVertical(ctx, target, area.bottom);\n    } else if (property === 'y') {\n      clipHorizontal(ctx, target, area.left);\n      fill(ctx, {line, target, color: below, scale, property, clip});\n      ctx.restore();\n      ctx.save();\n      clipHorizontal(ctx, target, area.right);\n      fillColor = above;\n    }\n  }\n  fill(ctx, {line, target, color: fillColor, scale, property, clip});\n\n  ctx.restore();\n}\n\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction clipHorizontal(ctx, target, clipX) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(clipX, firstPoint.y);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(clipX, lastPoint.y);\n    }\n  }\n\n  ctx.lineTo(clipX, target.first().y);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale, clip} = cfg;\n  const segments = _segments(line, target, property);\n\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n\n    clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));\n\n    ctx.beginPath();\n\n    const lineLoop = !!line.pathSegment(ctx, src);\n\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n\n    ctx.restore();\n  }\n}\n\nfunction clipBounds(ctx, scale, clip, bounds) {\n  const chartArea = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n\n  if (property === 'x' || property === 'y') {\n    let left, top, right, bottom;\n\n    if (property === 'x') {\n      left = start;\n      top = chartArea.top;\n      right = end;\n      bottom = chartArea.bottom;\n    } else {\n      left = chartArea.left;\n      top = start;\n      right = chartArea.right;\n      bottom = end;\n    }\n\n    ctx.beginPath();\n\n    if (clip) {\n      left = Math.max(left, clip.left);\n      right = Math.min(right, clip.right);\n      top = Math.max(top, clip.top);\n      bottom = Math.min(bottom, clip.bottom);\n    }\n\n    ctx.rect(left, top, right - left, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\n", "/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\nimport LineElement from '../../elements/element.line.js';\nimport {_drawfill} from './filler.drawing.js';\nimport {_shouldApplyFill} from './filler.helper.js';\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\n\nexport default {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n", "import defaults from '../core/core.defaults.js';\nimport Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\nimport {\n  _isBetween,\n  callback as call,\n  clipArea,\n  getRtlAdapter,\n  overrideTextDirection,\n  restoreTextDirection,\n  toFont,\n  toPadding,\n  unclipArea,\n  valueOrDefault,\n} from '../helpers/index.js';\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n */\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nexport class Legend extends Element {\n\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this._added = false;\n\n    // Contains hit boxes for each dataset (in dataset order)\n    this.legendHitBoxes = [];\n\n    /**\n \t\t * @private\n \t\t */\n    this._hoveredItem = null;\n\n    // Are we in doughnut mode which has a different data type\n    this.doughnutMode = false;\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n\n    this.legendItems = legendItems;\n  }\n\n  fit() {\n    const {options, ctx} = this;\n\n    // The legend may not be displayed for a variety of reasons including\n    // the fact that the defaults got set to `false`.\n    // When the legend is not displayed, there are no guarantees that the options\n    // are correctly formatted so we need to bail out as early as possible.\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    let width, height;\n\n    ctx.font = labelFont.string;\n\n    if (this.isHorizontal()) {\n      width = this.maxWidth; // fill all the width\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight; // fill all the height\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n\n  /**\n\t * @private\n\t */\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n\n    let left = 0;\n    let col = 0;\n\n    this.legendItems.forEach((legendItem, i) => {\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n\n      // If too tall, go to new column\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      // Store the hitbox width and height here. Final position will be updated in `draw`\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\n      // Get max width\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n\n      this._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n\n    this.drawTitle();\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    // current position\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      // Set the ctx for the box\n      ctx.save();\n\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        // Recalculate x and y for drawPoint() because its expecting\n        // x and y to be center of figure (instead of top left)\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n\n        // Draw pointStyle as legend symbol\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        // Draw box as legend symbol\n        // Adjust position when boxHeight < fontSize (want it centered)\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    // Horizontal\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(this.ctx, opts.textDirection);\n\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\n\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n\n      rtlHelper.setWidth(this.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n\n      drawLegendBox(realX, y, legendItem);\n\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\n      // Fill the actual label\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== 'string') {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n\n    // These defaults are used when the legend is vertical.\n    // When horizontal, they are computed below.\n    let left = this.left;\n    let maxWidth = this.width;\n\n    if (this.isHorizontal()) {\n      // Move left / right so that the title is above the legend lines\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      // Move down so that the title is above the legend stack in every alignment\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n\n    // Now that we know the left edge of the inner legend box, compute the correct\n    // X coordinate from the title alignment\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  /**\n\t * @private\n\t */\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      // See if we are touching one of the dataset boxes\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          // Touching an element\n          return this.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t */\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    // Chart event already has relative position in it\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        call(opts.onLeave, [e, previous, this], this);\n      }\n\n      this._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        call(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      call(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\n\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {itemWidth, itemHeight};\n}\n\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== 'string') {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\n}\n\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== 'string') {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\n\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\n\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\n\nexport default {\n  id: 'legend',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  // During the beforeUpdate step, the layout configuration needs to run\n  // This ensures that if the legend position changes (via an option update)\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  // The labels need to be built after datasets are updated to ensure that colors\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    // a callback that will handle\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n\n            // Below is extra data used for toggling the datasets\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n", "import Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\nimport {renderText} from '../helpers/helpers.canvas.js';\n\nexport class Title extends Element {\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n\n    this.left = 0;\n    this.top = 0;\n\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nexport default {\n  id: 'title',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000         // by default greater than legend (1000) to be above\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n", "import {Title} from './plugin.title.js';\nimport layouts from '../core/core.layouts.js';\n\nconst map = new WeakMap();\n\nexport default {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n", "import Animations from '../core/core.animations.js';\nimport Element from '../core/core.element.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\nimport {createContext, drawPoint} from '../helpers/index.js';\n\n/**\n * @typedef { import('../platform/platform.base.js').Chart } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\n */\n\nconst positioners = {\n  /**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t */\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let xSet = new Set();\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        xSet.add(pos.x);\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    // No visible items where found, return false so we don't have to divide by 0 which reduces in NaN\n    if (count === 0 || xSet.size === 0) {\n      return false;\n    }\n\n    const xAverage = [...xSet].reduce((a, b) => a + b) / xSet.size;\n\n    return {\n      x: xAverage,\n      y: y / count\n    };\n  },\n\n  /**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t */\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      // base = base.concat(toPush);\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {*} str - The value to split by newline.\n * @returns {string|string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param {Chart} chart\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n\n  // Count of all lines in the body\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    // Body lines may include some extra height depending on boxHeight\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  // Title width\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n\n  // Body width\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\n  // Body lines may include some extra width due to the color box\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n\n  // Reset back to 0\n  widthPadding = 0;\n\n  // Footer width\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n\n  ctx.restore();\n\n  // Add padding\n  width += padding.width;\n\n  return {width, height};\n}\n\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  // eslint-disable-next-line prefer-const\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nconst defaultCallbacks = {\n  // Args are: (tooltipItems, data)\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n\n      if (this && this.options && this.options.mode === 'dataset') {\n        return item.dataset.label || '';\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n\n    return '';\n  },\n  afterTitle: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeBody: noop,\n\n  // Args are: (tooltipItem, data)\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === 'dataset') {\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n\n    let label = tooltipItem.dataset.label || '';\n\n    if (label) {\n      label += ': ';\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0,\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation,\n    };\n  },\n  afterLabel: noop,\n\n  // Args are: (tooltipItems, data)\n  afterBody: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\n\n/**\n * Invoke callback from object with context and arguments.\n * If callback returns `undefined`, then will be invoked default callback.\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\n * @param {keyof typeof defaultCallbacks} name\n * @param {*} ctx\n * @param {*} arg\n * @returns {any}\n */\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n\n  if (typeof result === 'undefined') {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n\n  return result;\n}\n\nexport class Tooltip extends Element {\n\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n  static positioners = positioners;\n\n  constructor(config) {\n    super();\n\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\n    // and `labelTextColors` to create a single variable\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const {callbacks} = options;\n\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\n    );\n  }\n\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n\n      bodyItems.push(bodyItem);\n    });\n\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\n    );\n  }\n\n  // Get the footer and beforeFooter and afterFooter lines\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n    return lines;\n  }\n\n  /**\n\t * @private\n\t */\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n\n    // If the user provided a filter function, use it to modify the tooltip items\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    // If the user provided a sorting function, use it to modify the tooltip items\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    // Determine colors for boxes\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n    });\n\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n\n        // Left draws bottom -> top, this y1 is on the bottom\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n\n        // Right draws top -> bottom, thus y1 is on the top\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n\n        // Top draws left -> right, thus x1 is on the left\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n\n        // Bottom draws right -> left, thus x1 is on the right\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.titleAlign, options);\n\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n        }\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      // Recalculate x and y for drawPoint() because its expecting\n      // x and y to be center of figure (instead of top left)\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n\n      // Draw the point\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      // Border\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        // Normal rect\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    // restore fillStyle\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\n    // Before body lines\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n\n    // Draw body lines now\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n\n      lines = bodyItem.lines;\n      // Draw Legend-like boxes if needed\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        // Reset for any lines that don't include colorbox\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n\n    // After body lines\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n\n      footerFont = toFont(options.footerFont);\n\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  /**\n\t * Update x/y animation targets when _active elements are animating too\n\t * @private\n\t */\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n\n  /**\n   * Determine if the tooltip will draw anything\n   * @returns {boolean} True if the tooltip will render\n   */\n  _willRender() {\n    return !!this.opacity;\n  }\n\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    this._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n\n    // IE11/Edge does not like very small opacities, so snap to 0\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\n    const padding = toPadding(options.padding);\n\n    // Truthy/falsey value for empty tooltip\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n\n      // Draw Background\n      this.drawBackground(pt, ctx, tooltipSize, options);\n\n      overrideTextDirection(ctx, options.textDirection);\n\n      pt.y += padding.top;\n\n      // Titles\n      this.drawTitle(pt, ctx, options);\n\n      // Body\n      this.drawBody(pt, ctx, options);\n\n      // Footer\n      this.drawFooter(pt, ctx, options);\n\n      restoreTextDirection(ctx, options.textDirection);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * Get active elements in the tooltip\n\t * @returns {Array} Array of elements that are active in the tooltip\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active elements in the tooltip\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\n\t * @param {object} eventPosition Synthetic event position used in positioning\n\t */\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {boolean} true if the tooltip changed\n\t */\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\n    // When there are multiple items shown, but the tooltip position is nearest mode\n    // an update may need to be made because our position may have changed even though\n    // the items are the same as before.\n    const positionChanged = this._positionChanged(active, e);\n\n    // Remember Last Actives\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    // Only handle target event on tooltip change\n    if (changed) {\n      this._active = active;\n\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n\n        this.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n\t * Helper for determining the active elements for event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {InteractionItem[]} lastActive - Previously active elements\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {InteractionItem[]} - Active elements\n\t * @private\n\t */\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      // But make sure that active elements are still valid.\n      return lastActive.filter(i =>\n        this.chart.data.datasets[i.datasetIndex] &&\n        this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined\n      );\n    }\n\n    // Find Active Elements for tooltips\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n    if (options.reverse) {\n      active.reverse();\n    }\n\n    return active;\n  }\n\n  /**\n\t * Determine if the active elements + event combination changes the\n\t * tooltip position\n\t * @param {array} active - Active elements\n\t * @param {ChartEvent} e - Event that triggered the position change\n\t * @returns {boolean} True if the position has changed\n\t */\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\n\nexport default {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\n        return;\n      }\n\n      tooltip.draw(chart.ctx);\n\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      // If the event is replayed from `update`, we should evaluate with the final positions.\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        // notify chart about the change, so it will render\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n\n  // Resolve additionally from `interaction` options and defaults.\n  additionalOptionScopes: ['interaction']\n};\n", "import Scale from '../core/core.scale.js';\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\n\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\n\nexport default class CategoryScale extends Scale {\n\n  static id = 'category';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n\n    // If we are viewing some subset of labels, slice the original array\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    super.configure();\n\n    if (!this.isHorizontal()) {\n      // For backward compatibility, vertical category scale reverse is inverted.\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n\n  // Used to get data value locations. Value can either be an index or a numerical value\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  // Must override base implementation because it calls getPixelForValue\n  // and category scale can have duplicate values\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n}\n", "import {isNullOrUndef} from '../helpers/helpers.core.js';\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\n\n/**\n * Generate a set of linear ticks for an axis\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\n *    Note that the generationOptions.maxCount setting is respected in this scenario\n *\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\n *    spacing = (max - min) / count\n *    Ticks are generated as [min, min + spacing, ..., max]\n *\n * 3. If generationOptions.count is defined\n *    spacing = (niceMax - niceMin) / count\n *\n * 4. Compute optimal spacing of ticks using niceNum algorithm\n *\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, dataRange) {\n  const ticks = [];\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  // Beyond MIN_SPACING floating point numbers being to lose precision\n  // such that we can't do the math necessary to generate ticks\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    // If the user specified a precision, round to that number of decimal places\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\n    // spacing = step;\n    // numSpaces = (max - min) / spacing;\n    // Note that we round here to handle the case where almostWhole translated an FP error\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\n    // Sometimes these are no-ops, but it makes the code a lot clearer\n    // and when a user defined range is specified, we want the correct ticks\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    // Case 4\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    // If very close to our rounded value, use it.\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\n  // until this point\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n\n      if (niceMin < min) {\n        j++; // Skip niceMin\n      }\n      // If the next nice tick is close to min, skip it\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({value: tickValue});\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    // If the previous tick is too close to max, replace it with max, else add max\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nexport default class LinearScaleBase extends Scale {\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    /** @type {number} */\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    // eslint-disable-next-line prefer-const\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  /**\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    // Figure out what the max number of ticks we can support it is based on the size of\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n    // the graph. Make sure we always have at least 2 ticks\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n\n    super.configure();\n\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n", "import {isFinite} from '../helpers/helpers.core.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {toRadians} from '../helpers/index.js';\n\nexport default class LinearScale extends LinearScaleBase {\n\n  static id = 'linear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? min : 0;\n    this.max = isFinite(max) ? max : 1;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n \t */\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  // Utils\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\n", "import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\n\nconst log10Floor = v => Math.floor(log10(v));\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\n  return remain === 1;\n}\n\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\n\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\n\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, {min, max}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({value, major: isMajor(value), significand});\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\n\n  return ticks;\n}\n\nexport default class LogarithmicScale extends Scale {\n\n  static id = 'logarithmic';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? Math.max(0, min) : null;\n    this.max = isFinite(max) ? Math.max(0, max) : null;\n\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n\n    this.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (min === max) {\n      if (min <= 0) { // includes null\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n\n      setMax(changeExponent(min, +1));\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const start = this.min;\n\n    super.configure();\n\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\n", "import defaults from '../core/core.defaults.js';\nimport {_longestText, addRoundedRectPath, renderText, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n  // Right, this is really confusing and there is a lot of maths going on here\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n  //\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n  //\n  // Solution:\n  //\n  // We assume the radius of the polygon is half the size of the canvas at first\n  // at each index we check if the text overlaps.\n  //\n  // Where it does, we store that angle and that index.\n  //\n  // After finding the largest index and angle we calculate how much we need to remove\n  // from the shape radius to move the point inwards by that x.\n  //\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\n  // along with labels.\n  //\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\n  //\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n  // and position it in the most space efficient manner\n  //\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n\n  // Now that text size is determined, compute the full positions\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\n\nfunction createPointLabelItem(scale, index, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {extra, additionalAngle, padding, size} = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    // if to draw or overlapped\n    visible: true,\n\n    // Text position\n    x: pointLabelPosition.x,\n    y,\n\n    // Text rendering data\n    textAlign,\n\n    // Bounding box\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\n\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {left, top, right, bottom} = item;\n  const apexesInArea = _isPointInArea({x: left, y: top}, area) || _isPointInArea({x: left, y: bottom}, area) ||\n    _isPointInArea({x: right, y: top}, area) || _isPointInArea({x: right, y: bottom}, area);\n  return !apexesInArea;\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {centerPointLabels, display} = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === 'auto') {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\n\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {left, top, right, bottom} = item;\n  const {backdropColor} = opts;\n\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n\n    if (Object.values(borderRadius).some(v => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius,\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      // overlapping\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign} = item;\n\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    // Draw circular arcs between the points\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    // Draw straight lines connecting each index\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n\n  const {color, lineWidth} = gridLineOpts;\n\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash || []);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nexport default class RadialLinearScale extends LinearScaleBase {\n\n  static id = 'radialLinear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    display: true,\n\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n\n    grid: {\n      circular: false\n    },\n\n    startAngle: 0,\n\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n\n      callback: Ticks.formatters.numeric\n    },\n\n    pointLabels: {\n      backdropColor: undefined,\n\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPadding: 2,\n\n      // Boolean - if true, show point labels\n      display: true,\n\n      // Number - Point label font size in pixels\n      font: {\n        size: 10\n      },\n\n      // Function - Used to convert point labels\n      callback(label) {\n        return label;\n      },\n\n      // Number - Additionl padding between scale and pointLabel\n      padding: 5,\n\n      // Boolean - if true, center point labels to slices in polar chart\n      centerPointLabels: false\n    }\n  };\n\n  static defaultRoutes = {\n    'angleLines.color': 'borderColor',\n    'pointLabels.color': 'color',\n    'ticks.color': 'color'\n  };\n\n  static descriptors = {\n    angleLines: {\n      _fallback: 'grid'\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.xCenter = undefined;\n    /** @type {number} */\n    this.yCenter = undefined;\n    /** @type {number} */\n    this.drawingArea = undefined;\n    /** @type {string[]} */\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\n    // Point labels\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n\n  fit() {\n    const opts = this.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    // Take into account half font size + the yPadding of the top value\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid, border} = opts;\n    const labelCount = this._pointLabels.length;\n\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0 || (index === 0 && this.min < 0)) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\n        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {}\n\n  /**\n\t * @protected\n\t */\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    this.ticks.forEach((tick, index) => {\n      if ((index === 0 && this.min >= 0) && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth,\n      });\n    });\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {}\n}\n", "import adapters from '../core/core.adapters.js';\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\n\n/**\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\n */\n\n/**\n * @type {Object<Unit, Interval>}\n */\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\n\n/**\n * @type {Unit[]}\n */\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\n\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction sorter(a, b) {\n  return a - b;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {*} input\n * @return {number}\n */\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  // Only parse if it's not a timestamp already\n  if (!isFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @param {number} capacity\n * @return {object}\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n * @param {TimeScale} scale\n * @param {number} numTicks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @return {Unit}\n */\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\n/**\n * @param {Unit} unit\n * @return {object}\n */\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\n/**\n * @param {object} ticks\n * @param {number} time\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\n */\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\n/**\n * @param {TimeScale} scale\n * @param {object[]} ticks\n * @param {object} map\n * @param {Unit} majorUnit\n * @return {object[]}\n */\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {number[]} values\n * @param {Unit|undefined} [majorUnit]\n * @return {object[]}\n */\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  /** @type {Object<number,object>} */\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  // We set the major ticks separately from the above loop because calling startOf for every tick\n  // is expensive when there is a large number of ticks\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nexport default class TimeScale extends Scale {\n\n  static id = 'time';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n\n    adapters: {},\n    time: {\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\n      unit: false, // false == automatic or override with week, month, year, etc.\n      round: false, // none, or override with week, month, year, etc.\n      isoWeekday: false, // override week start day\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n\n      callback: false,\n\n      major: {\n        enabled: false\n      }\n    }\n  };\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {{data: number[], labels: number[], all: number[]}} */\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n\n    /** @type {Unit} */\n    this._unit = 'day';\n    /** @type {Unit=} */\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    /** @type {DateAdapter} */\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\n    adapter.init(opts);\n\n    // Backward compatibility: before introducing adapter, `displayFormats` was\n    // supposed to contain *all* unit/string pairs but this can't be resolved\n    // when loading the scale (adapters are loaded afterward), so let's populate\n    // missing formats on update\n    mergeIf(time.displayFormats, adapter.formats());\n\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n\n    super.init(scaleOpts);\n\n    this._normalized = opts.normalized;\n  }\n\n  /**\n\t * @param {*} raw\n\t * @param {number?} [index]\n\t * @return {number}\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\n    /**\n\t\t * @param {object} bounds\n\t\t */\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\n    if (!minDefined || !maxDefined) {\n      // Labels are always considered, when user did not force bounds\n      _applyBounds(this._getLabelBounds());\n\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\n      // data bounds are ignored (and don't need to be determined)\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n\n  /**\n\t * @private\n\t */\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n\n  /**\n\t * @return {object[]}\n\t */\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = this.min;\n    const max = this.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    // PRIVATE\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n\n  afterAutoSkip() {\n    // Offsets for bar charts need to be handled with the auto skipped\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n\n  /**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t * @param {number[]} timestamps\n\t * @protected\n\t */\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n\n  /**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t * @protected\n\t */\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    // @ts-ignore\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    // For 'week' unit, handle the first day of week option\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    // Align first ticks on unit\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    // Prevent browser from freezing in case user options request millions of milliseconds\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    // @ts-ignore\n    return Object.keys(ticks).sort(sorter).map(x => +x);\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  /**\n\t * @param {number} value\n\t * @param {string|undefined} format\n\t * @return {string}\n\t */\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n\n  /**\n\t * Function to format an individual tick mark\n\t * @param {number} time\n\t * @param {number} index\n\t * @param {object[]} ticks\n\t * @param {string|undefined} [format]\n\t * @return {string}\n\t * @private\n\t */\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n\n    if (formatter) {\n      return call(formatter, [time, index, ticks], this);\n    }\n\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n\n  /**\n\t * @param {object[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n\n  /**\n\t * @param {string} label\n\t * @return {{w:number, h:number}}\n\t * @private\n\t */\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n\n  /**\n\t * @param {number} exampleTime\n\t * @return {number}\n\t * @private\n\t */\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n\n    // pick the longest format (milliseconds) for guesstimation\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    // subtract 1 - if offset then there's one less label than tick\n    // if not offset then one half label padding is added to each end leaving room for one less label\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n\n    return (this._cache.data = this.normalize(timestamps));\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n\n  /**\n\t * @param {number[]} values\n\t * @protected\n\t */\n  normalize(values) {\n    // It seems to be somewhat faster to do sorting first\n    return _arrayUnique(values.sort(sorter));\n  }\n}\n", "import TimeScale from './scale.time.js';\nimport {_lookupByKey} from '../helpers/helpers.collection.js';\n\n/**\n * Linearly interpolates the given source `val` using the table. If value is out of bounds, values\n * at edges are used for the interpolation.\n * @param {object} table\n * @param {number} val\n * @param {boolean} [reverse] lookup time based on position instead of vice versa\n * @return {object}\n */\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\n\nclass TimeSeriesScale extends TimeScale {\n\n  static id = 'timeseries';\n\n  /**\n   * @type {any}\n   */\n  static defaults = TimeScale.defaults;\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {object[]} */\n    this._table = [];\n    /** @type {number} */\n    this._minPos = undefined;\n    /** @type {number} */\n    this._tableRange = undefined;\n  }\n\n  /**\n\t * @protected\n\t */\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n\n  /**\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n\t * @param {number[]} timestamps\n\t * @return {object[]}\n\t * @protected\n\t */\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n\n    if (items.length < 2) {\n      // In case there is less that 2 timestamps between min and max, the scale is defined by min and max\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n\n      // only add points that breaks the scale linearity\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n\n  /**\n    * Generates all timestamps defined in the data.\n    * Important: this method can return ticks outside the min and max range, it's the\n    * responsibility of the calling code to clamp values if needed.\n    * @protected\n    */\n  _generate() {\n    const min = this.min;\n    const max = this.max;\n    let timestamps = super.getDataTimestamps();\n    if (!timestamps.includes(min) || !timestamps.length) {\n      timestamps.splice(0, 0, min);\n    }\n    if (!timestamps.includes(max) || timestamps.length === 1) {\n      timestamps.push(max);\n    }\n    return timestamps.sort((a, b) => a - b);\n  }\n\n  /**\n\t * Returns all timestamps\n\t * @return {number[]}\n\t * @private\n\t */\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      // If combining labels and data (data might not contain all labels),\n      // we need to recheck uniqueness and sort\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n\n    return timestamps;\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\n\nexport default TimeSeriesScale;\n", "export * from './controllers/index.js';\nexport * from './core/index.js';\nexport * from './elements/index.js';\nexport * from './platform/index.js';\nexport * from './plugins/index.js';\nexport * from './scales/index.js';\n\nimport * as controllers from './controllers/index.js';\nimport * as elements from './elements/index.js';\nimport * as plugins from './plugins/index.js';\nimport * as scales from './scales/index.js';\n\nexport {\n  controllers,\n  elements,\n  plugins,\n  scales,\n};\n\nexport const registerables = [\n  controllers,\n  elements,\n  plugins,\n  scales,\n];\n", "import {Chart, registerables} from '../dist/chart.js';\n\nChart.register(...registerables);\n\nexport * from '../dist/chart.js';\nexport default Chart;\n"],
  "mappings": "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,cACA,QACA,MACA,UACA,UACA,WACA,UACA,QACA,QACA,OACA,YACA,WACA,QACA,YACA,MACA,aACA,OACA,WACA,OACA,UACA,OACA,OACA,MACA,MACA,WACA,MACA,YACA,cACA,UACA,QACA,UACA,QACA,MACA,MACA,MACA,MACA,MACA,MACA,QACA,UACA,UACA,MACA,QACA,KACA,OACA,SACA,OACA,OACA,SACA,UACA,MACA,QACA,OACA,QACA,WACA,QACA,YACA,SACA,OACA,QACA,MACA,YACA,UACA,UACA,KACA,WACA,OACA,YACA,KACA,MACA,MACA,QACA,KACA,QACA,UACA,WACA,UACA,UACA,QACA,SACA,UACA,UACA,QACA,UACA,UACA,SACA,OACA,WACA,OACA,SACA,SACA,MACA,YACA,YACA,SACA,MACA,SACA,QACA,MACA,SACA,MACA,KACA,MACA,OACA,SACA,KAAK,CACG;AAEH,IAAM+E,QAAM/E,OAAO,CACxB,OACA,KACA,YACA,eACA,gBACA,gBACA,iBACA,oBACA,UACA,YACA,QACA,QACA,WACA,gBACA,eACA,UACA,QACA,KACA,SACA,YACA,SACA,SACA,aACA,QACA,kBACA,UACA,QACA,YACA,SACA,QACA,QACA,WACA,WACA,YACA,kBACA,QACA,QACA,SACA,UACA,UACA,QACA,YACA,SACA,QACA,SACA,QACA,OAAO,CACC;AAEH,IAAMgF,aAAahF,OAAO,CAC/B,WACA,iBACA,uBACA,eACA,oBACA,qBACA,qBACA,kBACA,gBACA,WACA,WACA,WACA,WACA,WACA,kBACA,WACA,WACA,eACA,gBACA,YACA,gBACA,sBACA,eACA,UACA,cAAc,CACN;AAMH,IAAMiF,gBAAgBjF,OAAO,CAClC,WACA,iBACA,UACA,WACA,aACA,oBACA,kBACA,iBACA,iBACA,iBACA,SACA,aACA,QACA,gBACA,aACA,WACA,iBACA,UACA,OACA,cACA,WACA,KAAK,CACG;AAEH,IAAMkF,WAASlF,OAAO,CAC3B,QACA,YACA,UACA,WACA,SACA,UACA,MACA,cACA,iBACA,MACA,MACA,SACA,WACA,YACA,SACA,QACA,MACA,UACA,SACA,UACA,QACA,QACA,WACA,UACA,OACA,SACA,OACA,UACA,cACA,aAAa,CACL;AAIH,IAAMmF,mBAAmBnF,OAAO,CACrC,WACA,eACA,cACA,YACA,aACA,WACA,WACA,UACA,UACA,SACA,aACA,cACA,kBACA,eACA,MAAM,CACE;AAEH,IAAMoF,OAAOpF,OAAO,CAAC,OAAO,CAAU;AC1RtC,IAAM8E,OAAO9E,OAAO,CACzB,UACA,UACA,SACA,OACA,kBACA,gBACA,wBACA,YACA,cACA,WACA,UACA,WACA,eACA,eACA,WACA,QACA,SACA,SACA,SACA,QACA,WACA,YACA,gBACA,UACA,eACA,YACA,YACA,WACA,OACA,YACA,2BACA,yBACA,YACA,aACA,WACA,gBACA,eACA,QACA,OACA,WACA,UACA,UACA,QACA,QACA,YACA,MACA,SACA,aACA,aACA,SACA,QACA,SACA,QACA,QACA,WACA,QACA,OACA,OACA,aACA,SACA,UACA,OACA,aACA,YACA,SACA,QACA,SACA,WACA,cACA,UACA,QACA,WACA,QACA,WACA,eACA,eACA,WACA,iBACA,uBACA,UACA,WACA,WACA,cACA,YACA,OACA,YACA,OACA,YACA,QACA,QACA,WACA,cACA,SACA,YACA,SACA,QACA,SACA,QACA,QACA,WACA,SACA,OACA,UACA,QACA,SACA,WACA,YACA,SACA,aACA,QACA,UACA,UACA,SACA,SACA,QACA,SACA,MAAM,CACE;AAEH,IAAM+E,MAAM/E,OAAO,CACxB,iBACA,cACA,YACA,sBACA,aACA,UACA,iBACA,iBACA,WACA,iBACA,kBACA,SACA,QACA,MACA,SACA,QACA,iBACA,aACA,aACA,SACA,uBACA,+BACA,iBACA,mBACA,MACA,MACA,KACA,MACA,MACA,mBACA,aACA,WACA,WACA,OACA,YACA,aACA,OACA,YACA,QACA,gBACA,aACA,UACA,eACA,eACA,iBACA,eACA,aACA,oBACA,gBACA,cACA,gBACA,eACA,MACA,MACA,MACA,MACA,cACA,YACA,iBACA,qBACA,UACA,QACA,MACA,mBACA,MACA,OACA,aACA,KACA,MACA,MACA,MACA,MACA,WACA,aACA,cACA,YACA,QACA,gBACA,kBACA,gBACA,oBACA,kBACA,SACA,cACA,cACA,gBACA,gBACA,eACA,eACA,oBACA,aACA,OACA,QACA,aACA,SACA,UACA,QACA,OACA,QACA,cACA,UACA,YACA,WACA,SACA,UACA,eACA,UACA,YACA,eACA,QACA,cACA,uBACA,oBACA,gBACA,UACA,iBACA,uBACA,kBACA,KACA,MACA,MACA,UACA,QACA,QACA,eACA,aACA,WACA,UACA,UACA,SACA,QACA,mBACA,SACA,oBACA,oBACA,gBACA,eACA,gBACA,eACA,cACA,gBACA,oBACA,qBACA,kBACA,mBACA,qBACA,kBACA,UACA,gBACA,SACA,gBACA,kBACA,YACA,eACA,WACA,WACA,aACA,oBACA,eACA,mBACA,kBACA,cACA,QACA,MACA,MACA,WACA,UACA,WACA,cACA,WACA,cACA,iBACA,iBACA,SACA,gBACA,QACA,gBACA,oBACA,oBACA,KACA,MACA,MACA,SACA,KACA,MACA,MACA,KACA,YAAY,CACJ;AAEH,IAAMkF,SAASlF,OAAO,CAC3B,UACA,eACA,SACA,YACA,SACA,gBACA,eACA,cACA,cACA,SACA,OACA,WACA,gBACA,YACA,SACA,SACA,UACA,QACA,MACA,WACA,UACA,iBACA,UACA,UACA,kBACA,aACA,YACA,eACA,WACA,WACA,iBACA,YACA,YACA,QACA,YACA,YACA,cACA,WACA,UACA,UACA,eACA,iBACA,wBACA,aACA,aACA,cACA,YACA,kBACA,kBACA,aACA,WACA,SACA,OAAO,CACR;AAEM,IAAMqF,MAAMrF,OAAO,CACxB,cACA,UACA,eACA,aACA,aAAa,CACL;ACpXH,IAAMsF,gBAAgBrF,KAAK,2BAA2B;AACtD,IAAMsF,WAAWtF,KAAK,uBAAuB;AAC7C,IAAMuF,cAAcvF,KAAK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",
  "names": ["Prism", "_self", "_", "o", "clone", "id", "v", "i", "m", "lang", "callback", "text", "toArray", "s", "e", "j", "from", "to", "p", "k", "addInlined", "error", "range", "start", "elements", "start", "elements", "error", "x", "k", "a", "b", "c", "d", "s", "i", "n", "j", "hex", "from", "to", "SparkMD5", "raw", "callback", "controllers", "t", "e", "n", "r", "i", "s", "u", "a", "o", "c", "f", "h", "d", "l", "$", "y", "M", "m", "v", "g", "D", "p", "S", "_", "w", "b", "k", "LesliChart", "config", "elements", "require_dayjs_min", "t", "e", "n", "r", "i", "s", "u", "a", "o", "f", "h", "c", "d", "$", "l", "y", "M", "m", "g", "D", "v", "p", "_", "S", "w", "b", "dayjs", "module", "warn", "error", "data", "isArray", "i", "require_browser", "html", "resolve", "i", "_", "elements", "callback", "submitter", "config", "prefix", "location", "error", "entries", "size", "toCacheKey", "index", "cookie", "id", "x", "y", "clone", "defaults", "ctx", "morphChildren", "findBestMatch", "e", "morphNode", "_resolve", "createMorphContext", "normalizeElement", "normalizeParent", "session", "visit", "recentRequests", "document", "c", "import_prismjs", "Prism", "index", "i", "j", "k", "t", "s", "Prism", "Prism", "Prism", "i", "Prism", "prefix", "entries", "setPrototypeOf", "isFrozen", "getPrototypeOf", "getOwnPropertyDescriptor", "Object", "freeze", "seal", "create", "apply", "construct", "Reflect", "x", "func", "thisArg", "_len", "arguments", "length", "args", "Array", "_key", "Func", "_len2", "_key2", "arrayForEach", "unapply", "prototype", "forEach", "arrayLastIndexOf", "lastIndexOf", "arrayPop", "pop", "arrayPush", "push", "arraySplice", "splice", "stringToLowerCase", "String", "toLowerCase", "stringToString", "toString", "stringMatch", "match", "stringReplace", "replace", "stringIndexOf", "indexOf", "stringTrim", "trim", "objectHasOwnProperty", "hasOwnProperty", "regExpTest", "RegExp", "test", "typeErrorCreate", "unconstruct", "TypeError", "lastIndex", "_len3", "_key3", "_len4", "_key4", "addToSet", "set", "array", "transformCaseFunc", "l", "element", "lcElement", "cleanArray", "index", "isPropertyExist", "clone", "object", "newObject", "property", "value", "isArray", "constructor", "lookupGetter", "prop", "desc", "get", "fallbackValue", "html", "svg", "svgFilters", "svgDisallowed", "mathMl", "mathMlDisallowed", "text", "xml", "MUSTACHE_EXPR", "ERB_EXPR", "TMPLIT_EXPR", "DATA_ATTR", "ARIA_ATTR", "IS_ALLOWED_URI", "IS_SCRIPT_OR_DATA", "ATTR_WHITESPACE", "DOCTYPE_NAME", "CUSTOM_ELEMENT", "NODE_TYPE", "attribute", "cdataSection", "entityReference", "entityNode", "progressingInstruction", "comment", "document", "documentType", "documentFragment", "notation", "getGlobal", "window", "_createTrustedTypesPolicy", "trustedTypes", "purifyHostElement", "createPolicy", "suffix", "ATTR_NAME", "hasAttribute", "getAttribute", "policyName", "createHTML", "createScriptURL", "scriptUrl", "_", "console", "warn", "_createHooksMap", "afterSanitizeAttributes", "afterSanitizeElements", "afterSanitizeShadowDOM", "beforeSanitizeAttributes", "beforeSanitizeElements", "beforeSanitizeShadowDOM", "uponSanitizeAttribute", "uponSanitizeElement", "uponSanitizeShadowNode", "createDOMPurify", "undefined", "DOMPurify", "root", "version", "VERSION", "removed", "nodeType", "Element", "isSupported", "originalDocument", "currentScript", "DocumentFragment", "HTMLTemplateElement", "Node", "NodeFilter", "NamedNodeMap", "MozNamedAttrMap", "HTMLFormElement", "DOMParser", "ElementPrototype", "cloneNode", "remove", "getNextSibling", "getChildNodes", "getParentNode", "template", "createElement", "content", "ownerDocument", "trustedTypesPolicy", "emptyHTML", "implementation", "createNodeIterator", "createDocumentFragment", "getElementsByTagName", "importNode", "hooks", "createHTMLDocument", "EXPRESSIONS", "ALLOWED_TAGS", "DEFAULT_ALLOWED_TAGS", "TAGS", "ALLOWED_ATTR", "DEFAULT_ALLOWED_ATTR", "ATTRS", "CUSTOM_ELEMENT_HANDLING", "tagNameCheck", "writable", "configurable", "enumerable", "attributeNameCheck", "allowCustomizedBuiltInElements", "FORBID_TAGS", "FORBID_ATTR", "EXTRA_ELEMENT_HANDLING", "tagCheck", "attributeCheck", "ALLOW_ARIA_ATTR", "ALLOW_DATA_ATTR", "ALLOW_UNKNOWN_PROTOCOLS", "ALLOW_SELF_CLOSE_IN_ATTR", "SAFE_FOR_TEMPLATES", "SAFE_FOR_XML", "WHOLE_DOCUMENT", "SET_CONFIG", "FORCE_BODY", "RETURN_DOM", "RETURN_DOM_FRAGMENT", "RETURN_TRUSTED_TYPE", "SANITIZE_DOM", "SANITIZE_NAMED_PROPS", "SANITIZE_NAMED_PROPS_PREFIX", "KEEP_CONTENT", "IN_PLACE", "USE_PROFILES", "FORBID_CONTENTS", "DEFAULT_FORBID_CONTENTS", "DATA_URI_TAGS", "DEFAULT_DATA_URI_TAGS", "URI_SAFE_ATTRIBUTES", "DEFAULT_URI_SAFE_ATTRIBUTES", "MATHML_NAMESPACE", "SVG_NAMESPACE", "HTML_NAMESPACE", "NAMESPACE", "IS_EMPTY_INPUT", "ALLOWED_NAMESPACES", "DEFAULT_ALLOWED_NAMESPACES", "MATHML_TEXT_INTEGRATION_POINTS", "HTML_INTEGRATION_POINTS", "COMMON_SVG_AND_HTML_ELEMENTS", "PARSER_MEDIA_TYPE", "SUPPORTED_PARSER_MEDIA_TYPES", "DEFAULT_PARSER_MEDIA_TYPE", "CONFIG", "formElement", "isRegexOrFunction", "testValue", "Function", "_parseConfig", "cfg", "ADD_URI_SAFE_ATTR", "ADD_DATA_URI_TAGS", "ALLOWED_URI_REGEXP", "ADD_TAGS", "ADD_ATTR", "ADD_FORBID_CONTENTS", "table", "tbody", "TRUSTED_TYPES_POLICY", "ALL_SVG_TAGS", "ALL_MATHML_TAGS", "_checkValidNamespace", "parent", "tagName", "namespaceURI", "parentTagName", "Boolean", "_forceRemove", "node", "removeChild", "_removeAttribute", "name", "getAttributeNode", "from", "removeAttribute", "setAttribute", "_initDocument", "dirty", "doc", "leadingWhitespace", "matches", "dirtyPayload", "parseFromString", "documentElement", "createDocument", "innerHTML", "body", "insertBefore", "createTextNode", "childNodes", "call", "_createNodeIterator", "SHOW_ELEMENT", "SHOW_COMMENT", "SHOW_TEXT", "SHOW_PROCESSING_INSTRUCTION", "SHOW_CDATA_SECTION", "_isClobbered", "nodeName", "textContent", "attributes", "hasChildNodes", "_isNode", "_executeHooks", "currentNode", "data", "hook", "_sanitizeElements", "allowedTags", "firstElementChild", "_isBasicCustomElement", "parentNode", "childCount", "i", "childClone", "__removalCount", "expr", "_isValidAttribute", "lcTag", "lcName", "_sanitizeAttributes", "hookEvent", "attrName", "attrValue", "keepAttr", "allowedAttributes", "forceKeepAttr", "attr", "initValue", "getAttributeType", "setAttributeNS", "_sanitizeShadowDOM", "fragment", "shadowNode", "shadowIterator", "nextNode", "sanitize", "importedNode", "returnNode", "appendChild", "firstChild", "nodeIterator", "shadowroot", "shadowrootmode", "serializedHTML", "outerHTML", "doctype", "setConfig", "clearConfig", "isValidAttribute", "tag", "addHook", "entryPoint", "hookFunction", "removeHook", "removeHooks", "removeAllHooks", "$cloneWithProperties", "$selectAll", "s", "text", "observer", "i", "version", "size", "v", "k", "a", "b", "from", "to", "error", "anchorNode", "data", "index", "config", "n", "self", "theme", "start", "x", "range", "re", "_e", "mutatedNodes", "dirtyElements", "dirtyLeaves", "e", "j", "resolvedNode", "map", "activeEditor", "html", "nodes", "leftTree", "rightTree", "o", "overrides", "$addUpdateTag", "$applyNodeReplacement", "$caretFromPoint", "$caretRangeFromSelection", "$cloneWithProperties", "$cloneWithPropertiesEphemeral", "$comparePointCaretNext", "$copyNode", "$create", "$createLineBreakNode", "$createNodeSelection", "$createParagraphNode", "$createPoint", "$createRangeSelection", "$createRangeSelectionFromDom", "$createTabNode", "$createTextNode", "$extendCaretToRange", "$findMatchingParent", "$getAdjacentChildCaret", "$getAdjacentNode", "$getAdjacentSiblingOrParentSiblingCaret", "$getCaretInDirection", "$getCaretRange", "$getCaretRangeInDirection", "$getCharacterOffsets", "$getChildCaret", "$getChildCaretAtIndex", "$getChildCaretOrSelf", "$getCollapsedCaretRange", "$getCommonAncestor", "$getCommonAncestorResultBranchOrder", "$getEditor", "$getNearestNodeFromDOMNode", "$getNearestRootOrShadowRoot", "$getNodeByKey", "$getNodeByKeyOrThrow", "$getNodeFromDOMNode", "$getPreviousSelection", "$getRoot", "$getSelection", "$getSiblingCaret", "$getState", "$getStateChange", "$getTextContent", "$getTextNodeOffset", "$getTextPointCaret", "$getTextPointCaretSlice", "$getWritableNodeState", "$hasAncestor", "$hasUpdateTag", "$insertNodes", "$isBlockElementNode", "$isChildCaret", "$isDecoratorNode", "$isEditorState", "$isElementNode", "$isExtendableTextPointCaret", "$isInlineElementOrDecoratorNode", "$isLeafNode", "$isLineBreakNode", "$isNodeCaret", "$isNodeSelection", "$isParagraphNode", "$isRangeSelection", "$isRootNode", "$isRootOrShadowRoot", "$isSiblingCaret", "$isTabNode", "$isTextNode", "$isTextPointCaret", "$isTextPointCaretSlice", "$isTokenOrSegmented", "$isTokenOrTab", "$nodesOfType", "$normalizeCaret", "$onUpdate", "$parseSerializedNode", "$removeTextFromCaretRange", "$rewindSiblingCaret", "$selectAll", "$setCompositionKey", "$setPointFromCaret", "$setSelection", "$setSelectionFromCaretRange", "$setState", "$splitAtPointCaretNext", "$splitNode", "$updateRangeSelectionFromCaretRange", "ArtificialNode__DO_NOT_USE", "BLUR_COMMAND", "CAN_REDO_COMMAND", "CAN_UNDO_COMMAND", "CLEAR_EDITOR_COMMAND", "CLEAR_HISTORY_COMMAND", "CLICK_COMMAND", "COLLABORATION_TAG", "COMMAND_PRIORITY_CRITICAL", "COMMAND_PRIORITY_EDITOR", "COMMAND_PRIORITY_HIGH", "COMMAND_PRIORITY_LOW", "COMMAND_PRIORITY_NORMAL", "CONTROLLED_TEXT_INSERTION_COMMAND", "COPY_COMMAND", "CUT_COMMAND", "DELETE_CHARACTER_COMMAND", "DELETE_LINE_COMMAND", "DELETE_WORD_COMMAND", "DRAGEND_COMMAND", "DRAGOVER_COMMAND", "DRAGSTART_COMMAND", "DROP_COMMAND", "DecoratorNode", "ElementNode", "FOCUS_COMMAND", "FORMAT_ELEMENT_COMMAND", "FORMAT_TEXT_COMMAND", "HISTORIC_TAG", "HISTORY_MERGE_TAG", "HISTORY_PUSH_TAG", "INDENT_CONTENT_COMMAND", "INSERT_LINE_BREAK_COMMAND", "INSERT_PARAGRAPH_COMMAND", "INSERT_TAB_COMMAND", "INTERNAL_$isBlock", "IS_ALL_FORMATTING", "IS_BOLD", "IS_CODE", "IS_HIGHLIGHT", "IS_ITALIC", "IS_STRIKETHROUGH", "IS_SUBSCRIPT", "IS_SUPERSCRIPT", "IS_UNDERLINE", "KEY_ARROW_DOWN_COMMAND", "KEY_ARROW_LEFT_COMMAND", "KEY_ARROW_RIGHT_COMMAND", "KEY_ARROW_UP_COMMAND", "KEY_BACKSPACE_COMMAND", "KEY_DELETE_COMMAND", "KEY_DOWN_COMMAND", "KEY_ENTER_COMMAND", "KEY_ESCAPE_COMMAND", "KEY_MODIFIER_COMMAND", "KEY_SPACE_COMMAND", "KEY_TAB_COMMAND", "LineBreakNode", "MOVE_TO_END", "MOVE_TO_START", "NODE_STATE_KEY", "OUTDENT_CONTENT_COMMAND", "PASTE_COMMAND", "PASTE_TAG", "ParagraphNode", "REDO_COMMAND", "REMOVE_TEXT_COMMAND", "RootNode", "SELECTION_CHANGE_COMMAND", "SELECTION_INSERT_CLIPBOARD_NODES_COMMAND", "SELECT_ALL_COMMAND", "SKIP_COLLAB_TAG", "SKIP_DOM_SELECTION_TAG", "SKIP_SCROLL_INTO_VIEW_TAG", "SKIP_SELECTION_FOCUS_TAG", "TEXT_TYPE_TO_FORMAT", "TabNode", "TextNode", "UNDO_COMMAND", "buildImportMap", "configExtension", "createCommand", "createEditor", "createSharedNodeState", "createState", "declarePeerDependency", "defineExtension", "flipDirection", "getDOMOwnerDocument", "getDOMSelection", "getDOMSelectionFromTarget", "getDOMTextNode", "getEditorPropertyFromDOMNode", "getNearestEditorFromDOMNode", "getRegisteredNode", "getRegisteredNodeOrThrow", "getStaticNodeConfig", "getTextDirection", "getTransformSetFromKlass", "isBlockDomNode", "isCurrentlyReadOnlyMode", "isDOMDocumentNode", "isDOMNode", "isDOMTextNode", "isDOMUnmanaged", "isDocumentFragment", "isExactShortcutMatch", "isHTMLAnchorElement", "isHTMLElement", "isInlineDomNode", "isLexicalEditor", "isModifierMatch", "isSelectionCapturedInDecoratorInput", "isSelectionWithinEditor", "makeStepwiseIterator", "removeFromParent", "resetRandomKey", "safeCast", "setDOMUnmanaged", "setNodeIndentFromDOM", "shallowMergeConfig", "formatDevErrorMessage", "getDOMTextNode", "range", "$isTextNode", "_e", "a", "b", "i", "$getEditor", "$isRootNode", "$isTokenOrSegmented", "$getCharacterOffsets", "text", "$cloneWithPropertiesEphemeral", "$isElementNode", "$getNodeByKey", "$getPreviousSelection", "$createTextNode", "$isRangeSelection", "$getSelection", "$caretRangeFromSelection", "$createRangeSelection", "$findMatchingParent", "INTERNAL_$isBlock", "$setSelection", "$isRootOrShadowRoot", "createElement", "$hasAncestor", "elements", "$isLeafNode", "$caretFromPoint", "$isExtendableTextPointCaret", "$extendCaretToRange", "$isChildCaret", "$isDecoratorNode", "mod", "$addNodeStyle", "$cloneWithProperties", "$copyBlockFormatIndent", "$ensureForwardRangeSelection", "$forEachSelectedTextNode", "$getComputedStyleForElement", "$getComputedStyleForParent", "$getSelectionStyleValueForProperty", "$isAtNodeEnd", "$isParentElementRTL", "$isParentRTL", "$moveCaretSelection", "$moveCharacter", "$patchStyleText", "$selectAll", "$setBlocksType", "$shouldOverrideDefaultCharacterSelection", "$sliceSelectedTextNodeContent", "$trimTextContentFromAnchor", "$wrapNodes", "createDOMRange", "createRectsFromDOMRange", "getCSSFromStyleObject", "getStyleObjectFromCSS", "trimTextContentFromAnchor", "configExtension", "declarePeerDependency", "defineExtension", "safeCast", "shallowMergeConfig", "$findMatchingParent", "$getAdjacentSiblingOrParentSiblingCaret", "$splitNode", "CAN_USE_BEFORE_INPUT", "CAN_USE_DOM", "IS_ANDROID", "IS_ANDROID_CHROME", "IS_APPLE", "IS_APPLE_WEBKIT", "IS_CHROME", "IS_FIREFOX", "IS_IOS", "IS_SAFARI", "isBlockDomNode", "isHTMLAnchorElement", "isHTMLElement", "isInlineDomNode", "formatDevErrorMessage", "documentMode", "normalizeClassNames", "s", "i", "range", "observer", "createRectsFromDOMRange", "stop", "isHTMLElement", "$isElementNode", "getDOMTextNode", "start", "$getSelection", "$isRangeSelection", "onSelectionChange", "CAN_USE_BEFORE_INPUT", "CAN_USE_DOM", "IS_ANDROID", "IS_ANDROID_CHROME", "IS_APPLE", "IS_APPLE_WEBKIT", "IS_CHROME", "IS_FIREFOX", "IS_IOS", "IS_SAFARI", "resolve", "$getAdjacentSiblingOrParentSiblingCaret", "$getSiblingCaret", "$getRoot", "$getChildCaret", "$getAdjacentChildCaret", "$getChildCaretOrSelf", "makeStepwiseIterator", "$isChildCaret", "$findMatchingParent", "cloneNode", "FULL_RECONCILE", "activeEditorState", "$cloneWithProperties", "$setSelection", "$getPreviousSelection", "$caretFromPoint", "$createParagraphNode", "$normalizeCaret", "$setSelectionFromCaretRange", "$getCollapsedCaretRange", "$getCaretInDirection", "$splitAtPointCaretNext", "$isTextPointCaret", "$isSiblingCaret", "$rewindSiblingCaret", "$getState", "$setState", "mod", "$descendantsMatching", "$dfs", "$dfsIterator", "$filter", "$findMatchingParent", "$firstToLastIterator", "$getAdjacentCaret", "$getAdjacentSiblingOrParentSiblingCaret", "$getDepth", "$getNearestBlockElementAncestorOrThrow", "$getNearestNodeOfType", "$getNextRightPreorderNode", "$getNextSiblingOrParentSibling", "$insertFirst", "$insertNodeToNearestRoot", "$insertNodeToNearestRootAtCaret", "$isEditorIsNestedEditor", "$lastToFirstIterator", "$restoreEditorState", "$reverseDfs", "$reverseDfsIterator", "$splitNode", "$unwrapAndFilterDescendants", "$unwrapNode", "$wrapNodeInElement", "CAN_USE_BEFORE_INPUT", "CAN_USE_DOM", "IS_ANDROID", "IS_ANDROID_CHROME", "IS_APPLE", "IS_APPLE_WEBKIT", "IS_CHROME", "IS_FIREFOX", "IS_IOS", "IS_SAFARI", "addClassNamesToElement", "calculateZoomLevel", "isBlockDomNode", "isHTMLAnchorElement", "isHTMLElement", "isInlineDomNode", "isMimeType", "makeStateWrapper", "markSelection", "mediaFileReader", "mergeRegister", "objectKlassEquals", "registerNestedElementResolver", "removeClassNamesFromElement", "selectionAlwaysOnDisplay", "i", "t", "o", "n", "s", "defaults", "k", "v", "store", "defineExtension", "config", "safeCast", "stores", "$getRoot", "$getSelection", "$createParagraphNode", "$isRangeSelection", "CLEAR_EDITOR_COMMAND", "COMMAND_PRIORITY_EDITOR", "formatDevErrorMessage", "a", "b", "shallowMergeConfig", "signal", "cleanup", "HISTORY_MERGE_TAG", "$isEditorState", "RootNode", "TextNode", "LineBreakNode", "TabNode", "ParagraphNode", "createEditor", "mergeRegister", "visit", "theme", "$getNodeByKey", "createCommand", "DecoratorNode", "addClassNamesToElement", "$create", "$isNodeSelection", "$createNodeSelection", "$setSelection", "CLICK_COMMAND", "isDOMNode", "$getNodeFromDOMNode", "COMMAND_PRIORITY_LOW", "effects", "removeClassNamesFromElement", "$filter", "$isBlockElementNode", "$getNearestBlockElementAncestorOrThrow", "$createRangeSelection", "KEY_TAB_COMMAND", "OUTDENT_CONTENT_COMMAND", "INDENT_CONTENT_COMMAND", "INSERT_TAB_COMMAND", "COMMAND_PRIORITY_CRITICAL", "mod", "$createHorizontalRuleNode", "$isHorizontalRuleNode", "AutoFocusExtension", "ClearEditorExtension", "EditorStateExtension", "HorizontalRuleExtension", "HorizontalRuleNode", "INSERT_HORIZONTAL_RULE_COMMAND", "InitialStateExtension", "LexicalBuilder", "NodeSelectionExtension", "TabIndentationExtension", "buildEditorFromExtensions", "configExtension", "declarePeerDependency", "defineExtension", "getExtensionDependencyFromEditor", "getKnownTypesAndNodes", "getPeerDependencyFromEditor", "getPeerDependencyFromEditorOrThrow", "namedSignals", "registerClearEditor", "registerTabIndentation", "safeCast", "shallowMergeConfig", "watchedSignal", "formatDevErrorMessage", "i", "$getSelection", "$isRangeSelection", "$isRootOrShadowRoot", "$createParagraphNode", "$isElementNode", "$isLeafNode", "$getNearestNodeOfType", "$setPointFromCaret", "$normalizeCaret", "$getChildCaret", "normalizeClassNames", "s", "getStyleObjectFromCSS", "k", "ElementNode", "buildImportMap", "config", "_", "self", "$isParagraphNode", "removeClassNamesFromElement", "addClassNamesToElement", "isCheckbox", "$applyNodeReplacement", "start", "isHTMLElement", "$createTextNode", "createCommand", "mergeRegister", "COMMAND_PRIORITY_LOW", "KEY_ARROW_DOWN_COMMAND", "KEY_ARROW_UP_COMMAND", "KEY_ESCAPE_COMMAND", "KEY_SPACE_COMMAND", "$getNearestNodeFromDOMNode", "KEY_ARROW_LEFT_COMMAND", "$findMatchingParent", "callback", "calculateZoomLevel", "getNearestEditorFromDOMNode", "removeListener", "$getNodeByKey", "INSERT_PARAGRAPH_COMMAND", "$isTextNode", "TextNode", "queue", "defineExtension", "namedSignals", "safeCast", "stores", "mod", "$createListItemNode", "$createListNode", "$getListDepth", "$handleListInsertParagraph", "$insertList", "$isListItemNode", "$isListNode", "$removeList", "CheckListExtension", "INSERT_CHECK_LIST_COMMAND", "INSERT_ORDERED_LIST_COMMAND", "INSERT_UNORDERED_LIST_COMMAND", "ListExtension", "ListItemNode", "ListNode", "REMOVE_LIST_COMMAND", "UPDATE_LIST_START_COMMAND", "insertList", "registerCheckList", "registerList", "registerListStrictIndentTransform", "removeList", "elements", "isDOMDocumentNode", "$getRoot", "i", "$isElementNode", "$isTextNode", "$sliceSelectedTextNodeContent", "getRegisteredNode", "isHTMLElement", "isDocumentFragment", "$isRootOrShadowRoot", "$isBlockElementNode", "isBlockDomNode", "$createParagraphNode", "ArtificialNode__DO_NOT_USE", "$createLineBreakNode", "isInlineDomNode", "mod", "$generateHtmlFromNodes", "$generateNodesFromDOM", "formatDevErrorMessage", "$getSelection", "$isRangeSelection", "$generateHtmlFromNodes", "text", "error", "$generateNodesFromDOM", "i", "$createTabNode", "html", "SELECTION_INSERT_CLIPBOARD_NODES_COMMAND", "$caretFromPoint", "$isTextPointCaret", "range", "$getCaretRange", "$getChildCaret", "$getRoot", "$isTextNode", "$isElementNode", "exportNodeToJSON", "$sliceSelectedTextNodeContent", "$parseSerializedNode", "$addNodeStyle", "data", "resolve", "getDOMSelection", "removeListener", "COPY_COMMAND", "objectKlassEquals", "COMMAND_PRIORITY_CRITICAL", "isSelectionWithinEditor", "$getEditor", "v", "k", "mod", "$generateJSONFromSelectedNodes", "$generateNodesFromSerializedNodes", "$getClipboardDataFromSelection", "$getHtmlContent", "$getLexicalContent", "$insertDataTransferForPlainText", "$insertDataTransferForRichText", "$insertGeneratedNodes", "copyToClipboard", "setLexicalClipboardDataTransfer", "handler", "data", "_e", "text", "$getSelection", "$isRangeSelection", "$isTextNode", "defineExtension", "config", "namedSignals", "safeCast", "mod", "DragonExtension", "registerDragonSupport", "x", "y", "range", "CAN_USE_DOM", "documentMode", "IS_APPLE", "CAN_USE_BEFORE_INPUT", "IS_SAFARI", "IS_IOS", "IS_CHROME", "IS_APPLE_WEBKIT", "createCommand", "ElementNode", "config", "addClassNamesToElement", "isHTMLElement", "_", "$createParagraphNode", "$applyNodeReplacement", "self", "theme", "setNodeIndentFromDOM", "$getSelection", "objectKlassEquals", "$insertDataTransferForRichText", "PASTE_TAG", "copyToClipboard", "$isRangeSelection", "$isNodeSelection", "i", "$findMatchingParent", "$isElementNode", "$getNearestNodeFromDOMNode", "$isDecoratorNode", "$getRoot", "$isRootNode", "$getNearestBlockElementAncestorOrThrow", "removeListener", "mergeRegister", "CLICK_COMMAND", "COMMAND_PRIORITY_EDITOR", "DELETE_CHARACTER_COMMAND", "DELETE_WORD_COMMAND", "DELETE_LINE_COMMAND", "CONTROLLED_TEXT_INSERTION_COMMAND", "data", "REMOVE_TEXT_COMMAND", "FORMAT_TEXT_COMMAND", "FORMAT_ELEMENT_COMMAND", "INSERT_LINE_BREAK_COMMAND", "INSERT_PARAGRAPH_COMMAND", "INSERT_TAB_COMMAND", "$insertNodes", "$createTabNode", "INDENT_CONTENT_COMMAND", "OUTDENT_CONTENT_COMMAND", "KEY_ARROW_UP_COMMAND", "$getAdjacentNode", "KEY_ARROW_DOWN_COMMAND", "KEY_ARROW_LEFT_COMMAND", "$isParentRTL", "$shouldOverrideDefaultCharacterSelection", "$moveCharacter", "KEY_ARROW_RIGHT_COMMAND", "KEY_BACKSPACE_COMMAND", "KEY_DELETE_COMMAND", "KEY_ENTER_COMMAND", "KEY_ESCAPE_COMMAND", "DROP_COMMAND", "selection", "$createRangeSelection", "$isTextNode", "$setSelection", "DRAGSTART_COMMAND", "DRAGOVER_COMMAND", "SELECT_ALL_COMMAND", "$selectAll", "COPY_COMMAND", "CUT_COMMAND", "PASTE_COMMAND", "isDOMNode", "isSelectionCapturedInDecoratorInput", "KEY_SPACE_COMMAND", "KEY_TAB_COMMAND", "defineExtension", "DragonExtension", "mod", "$createHeadingNode", "$createQuoteNode", "$isHeadingNode", "$isQuoteNode", "DRAG_DROP_PASTE", "HeadingNode", "QuoteNode", "RichTextExtension", "eventFiles", "registerRichText", "Prism", "i", "l", "id", "html", "text", "m", "Prism", "Prism", "Prism", "i", "Prism", "Prism", "Prism", "formatDevErrorMessage", "isHTMLElement", "ElementNode", "config", "addClassNamesToElement", "theme", "$createParagraphNode", "$isTextNode", "$isTabNode", "$createTabNode", "text", "x", "index", "$createLineBreakNode", "$create", "TextNode", "self", "removeClassNamesFromElement", "$applyNodeReplacement", "$getSiblingCaret", "$getAdjacentCaret", "start", "getTextDirection", "$isElementNode", "$isLineBreakNode", "formatDevErrorMessage", "defineExtension", "Prism", "prefix", "t", "m", "i", "$createTextNode", "$getNodeByKey", "from", "to", "$getSelection", "$isRangeSelection", "$createPoint", "INDENT_CONTENT_COMMAND", "OUTDENT_CONTENT_COMMAND", "INSERT_TAB_COMMAND", "$setSelectionFromCaretRange", "$getCaretRangeInDirection", "$getCaretRange", "$getTextPointCaret", "$normalizeCaret", "KEY_ARROW_UP_COMMAND", "range", "isMoveToStart", "MOVE_TO_START", "KEY_TAB_COMMAND", "COMMAND_PRIORITY_LOW", "$insertNodes", "KEY_ARROW_DOWN_COMMAND", "MOVE_TO_END", "mergeRegister", "import_prismjs", "e", "n", "r", "isHTMLElement", "ElementNode", "t", "addClassNamesToElement", "i", "o", "s", "l", "u", "c", "$createParagraphNode", "a", "$isTextNode", "$isTabNode", "$createTabNode", "$createLineBreakNode", "f", "$create", "TextNode", "removeClassNamesFromElement", "$applyNodeReplacement", "$getSiblingCaret", "$getAdjacentCaret", "defineExtension", "t", "e", "n", "r", "i", "mod", "$createCodeHighlightNode", "$createCodeNode", "$getCodeLineDirection", "$getEndOfCodeInLine", "$getFirstCodeNodeOfLine", "$getLastCodeNodeOfLine", "$getStartOfCodeInLine", "$isCodeHighlightNode", "$isCodeNode", "CODE_LANGUAGE_FRIENDLY_NAME_MAP", "CODE_LANGUAGE_MAP", "CodeExtension", "CodeHighlightNode", "CodeNode", "DEFAULT_CODE_LANGUAGE", "PrismTokenizer", "getCodeLanguageOptions", "getCodeLanguages", "getCodeThemeOptions", "getDefaultCodeLanguage", "getEndOfCodeInLine", "getFirstCodeNodeOfLine", "getLanguageFriendlyName", "getLastCodeNodeOfLine", "getStartOfCodeInLine", "normalizeCodeLang", "registerCodeHighlighting", "formatDevErrorMessage", "ElementNode", "config", "addClassNamesToElement", "isHTMLAnchorElement", "_", "$isRangeSelection", "$applyNodeReplacement", "self", "$isElementNode", "createCommand", "$getSelection", "$setSelection", "n", "i", "$isNodeSelection", "nodes", "$findMatchingParent", "stores", "mergeRegister", "COMMAND_PRIORITY_LOW", "PASTE_COMMAND", "objectKlassEquals", "defineExtension", "namedSignals", "overrides", "shallowMergeConfig", "onClick", "isDOMNode", "getNearestEditorFromDOMNode", "$getNearestNodeFromDOMNode", "a", "safeCast", "text", "$isLineBreakNode", "$isTextNode", "$createTextNode", "j", "handler", "TextNode", "k", "v", "mod", "$createAutoLinkNode", "$createLinkNode", "$isAutoLinkNode", "$isLinkNode", "$toggleLink", "AutoLinkExtension", "AutoLinkNode", "ClickableLinkExtension", "LinkExtension", "LinkNode", "TOGGLE_LINK_COMMAND", "createLinkMatcherWithRegExp", "formatUrl", "registerAutoLink", "registerClickableLink", "registerLink", "toggleLink", "ElementNode", "config", "addClassNamesToElement", "isHTMLElement", "self", "$isLineBreakNode", "$isInlineElementOrDecoratorNode", "$isTextNode", "$createParagraphNode", "$applyNodeReplacement", "createCommand", "formatDevErrorMessage", "$descendantsMatching", "CAN_USE_DOM", "documentMode", "IS_FIREFOX", "$createTextNode", "$findMatchingParent", "n", "x", "y", "r", "c", "$getSelection", "$isRangeSelection", "i", "$insertFirst", "$isParagraphNode", "map", "j", "k", "$getNodeByKey", "$createPoint", "text", "TEXT_TYPE_TO_FORMAT", "$isElementNode", "isCurrentlyReadOnlyMode", "$getEditor", "removeListener", "observer", "$setSelection", "SELECTION_CHANGE_COMMAND", "removeClassNamesFromElement", "getDOMSelection", "$createRangeSelection", "$isRootNode", "INSERT_PARAGRAPH_COMMAND", "KEY_ARROW_DOWN_COMMAND", "KEY_ARROW_UP_COMMAND", "KEY_ARROW_LEFT_COMMAND", "KEY_ARROW_RIGHT_COMMAND", "DELETE_WORD_COMMAND", "DELETE_LINE_COMMAND", "DELETE_CHARACTER_COMMAND", "KEY_BACKSPACE_COMMAND", "KEY_DELETE_COMMAND", "isDOMNode", "onPointerDown", "$getPreviousSelection", "COMMAND_PRIORITY_HIGH", "KEY_ESCAPE_COMMAND", "CUT_COMMAND", "copyToClipboard", "objectKlassEquals", "$getClipboardDataFromSelection", "FORMAT_TEXT_COMMAND", "FORMAT_ELEMENT_COMMAND", "CONTROLLED_TEXT_INSERTION_COMMAND", "KEY_TAB_COMMAND", "FOCUS_COMMAND", "SELECTION_INSERT_CLIPBOARD_NODES_COMMAND", "$getNearestNodeFromDOMNode", "$createRangeSelectionFromDom", "$caretFromPoint", "$isExtendableTextPointCaret", "$extendCaretToRange", "$isSiblingCaret", "$getSiblingCaret", "$setPointFromCaret", "$normalizeCaret", "$getAdjacentChildCaret", "$isChildCaret", "$getChildCaret", "$isRootOrShadowRoot", "range", "$convertTableElement", "setDOMUnmanaged", "index", "$insertNodeToNearestRoot", "$unwrapAndFilterDescendants", "mergeRegister", "COMMAND_PRIORITY_EDITOR", "CLICK_COMMAND", "defineExtension", "namedSignals", "safeCast", "stores", "mod", "$computeTableMap", "$computeTableMapSkipCellCheck", "$createTableCellNode", "$createTableNode", "$createTableNodeWithDimensions", "$createTableRowNode", "$createTableSelection", "$createTableSelectionFrom", "$deleteTableColumn", "$deleteTableColumnAtSelection", "$deleteTableColumn__EXPERIMENTAL", "$deleteTableRowAtSelection", "$deleteTableRow__EXPERIMENTAL", "$findCellNode", "$findTableNode", "$getElementForTableNode", "$getNodeTriplet", "$getTableAndElementByKey", "$getTableCellNodeFromLexicalNode", "$getTableCellNodeRect", "$getTableColumnIndexFromTableCellNode", "$getTableNodeFromLexicalNodeOrThrow", "$getTableRowIndexFromTableCellNode", "$getTableRowNodeFromTableCellNodeOrThrow", "$insertTableColumn", "$insertTableColumnAtSelection", "$insertTableColumn__EXPERIMENTAL", "$insertTableRow", "$insertTableRowAtSelection", "$insertTableRow__EXPERIMENTAL", "$isScrollableTablesActive", "$isTableCellNode", "$isTableNode", "$isTableRowNode", "$isTableSelection", "$mergeCells", "$removeTableRowAtIndex", "$unmergeCell", "INSERT_TABLE_COMMAND", "TableCellHeaderStates", "TableCellNode", "TableExtension", "TableNode", "TableObserver", "TableRowNode", "applyTableHandlers", "getDOMCellFromTarget", "getTableElement", "getTableObserverFromTableElement", "registerTableCellUnmergeTransform", "registerTablePlugin", "registerTableSelectionObserver", "setScrollableTablesActive", "import_prismjs", "html", "dispatch", "prefix", "CAN_USE_DOM", "documentMode", "IS_APPLE", "CAN_USE_BEFORE_INPUT", "IS_SAFARI", "IS_IOS", "IS_CHROME", "IS_APPLE_WEBKIT", "objectKlassEquals", "$getSelection", "$getHtmlContent", "$isRangeSelection", "$insertDataTransferForPlainText", "PASTE_TAG", "removeListener", "mergeRegister", "DELETE_CHARACTER_COMMAND", "COMMAND_PRIORITY_EDITOR", "DELETE_WORD_COMMAND", "DELETE_LINE_COMMAND", "CONTROLLED_TEXT_INSERTION_COMMAND", "data", "REMOVE_TEXT_COMMAND", "INSERT_LINE_BREAK_COMMAND", "INSERT_PARAGRAPH_COMMAND", "KEY_ARROW_LEFT_COMMAND", "$shouldOverrideDefaultCharacterSelection", "$moveCharacter", "KEY_ARROW_RIGHT_COMMAND", "KEY_BACKSPACE_COMMAND", "KEY_DELETE_COMMAND", "KEY_ENTER_COMMAND", "SELECT_ALL_COMMAND", "$selectAll", "COPY_COMMAND", "CUT_COMMAND", "PASTE_COMMAND", "DROP_COMMAND", "DRAGSTART_COMMAND", "defineExtension", "DragonExtension", "mod", "PlainTextExtension", "registerPlainText", "callback", "index", "t", "PUNCTUATION_OR_SPACE", "$isParagraphNode", "$isTextNode", "a", "b", "$getRoot", "i", "$isElementNode", "$isDecoratorNode", "$isLineBreakNode", "_", "$getSelection", "text", "$createTextNode", "$createParagraphNode", "$isQuoteNode", "$isListNode", "$findMatchingParent", "$isListItemNode", "$createLineBreakNode", "formatDevErrorMessage", "createState", "v", "$createListItemNode", "$setState", "$createListNode", "exportChildren", "$getState", "prefix", "HeadingNode", "$isHeadingNode", "$createHeadingNode", "QuoteNode", "$createQuoteNode", "CodeNode", "$isCodeNode", "$createCodeNode", "ListNode", "ListItemNode", "LinkNode", "$isLinkNode", "$isAutoLinkNode", "$createLinkNode", "$isRootOrShadowRoot", "$createRangeSelection", "$setSelection", "$isRangeSelection", "trigger", "COLLABORATION_TAG", "HISTORIC_TAG", "mod", "$convertFromMarkdownString", "$convertToMarkdownString", "BOLD_ITALIC_STAR", "BOLD_ITALIC_UNDERSCORE", "BOLD_STAR", "BOLD_UNDERSCORE", "CHECK_LIST", "CODE", "ELEMENT_TRANSFORMERS", "HEADING", "HIGHLIGHT", "INLINE_CODE", "ITALIC_STAR", "ITALIC_UNDERSCORE", "LINK", "MULTILINE_ELEMENT_TRANSFORMERS", "ORDERED_LIST", "QUOTE", "STRIKETHROUGH", "TEXT_FORMAT_TRANSFORMERS", "TEXT_MATCH_TRANSFORMERS", "TRANSFORMERS", "UNORDERED_LIST", "registerMarkdownShortcuts", "$isRootNode", "$isRangeSelection", "$isTextNode", "HISTORIC_TAG", "HISTORY_PUSH_TAG", "HISTORY_MERGE_TAG", "CAN_UNDO_COMMAND", "CAN_REDO_COMMAND", "mergeRegister", "UNDO_COMMAND", "COMMAND_PRIORITY_EDITOR", "REDO_COMMAND", "CLEAR_EDITOR_COMMAND", "CLEAR_HISTORY_COMMAND", "defineExtension", "namedSignals", "safeCast", "config", "stores", "getPeerDependencyFromEditor", "configExtension", "mod", "HistoryExtension", "SharedHistoryExtension", "createEmptyHistoryState", "registerHistory", "_getDefaults", "_defaults", "changeDefaults", "newDefaults", "noopTest", "edit", "regex", "opt", "source", "obj", "name", "val", "valSource", "other", "supportsLookbehind", "bull", "indent", "newline", "blockCode", "fences", "hr", "heading", "bullet", "lheadingCore", "lheading", "lheadingGfm", "_paragraph", "blockText", "_blockLabel", "def", "list", "_tag", "_comment", "html", "paragraph", "blockquote", "blockNormal", "gfmTable", "blockGfm", "blockPedantic", "escape", "inlineCode", "br", "inlineText", "_punctuation", "_punctuationOrSpace", "_notPunctuationOrSpace", "punctuation", "_punctuationGfmStrongEm", "_punctuationOrSpaceGfmStrongEm", "_notPunctuationOrSpaceGfmStrongEm", "blockSkip", "emStrongLDelimCore", "emStrongLDelim", "emStrongLDelimGfm", "emStrongRDelimAstCore", "emStrongRDelimAst", "emStrongRDelimAstGfm", "emStrongRDelimUnd", "anyPunctuation", "autolink", "_inlineComment", "tag", "_inlineLabel", "link", "reflink", "nolink", "reflinkSearch", "_caseInsensitiveProtocol", "inlineNormal", "inlinePedantic", "inlineGfm", "inlineBreaks", "block", "inline", "escapeReplacements", "getEscapeReplacement", "ch", "encode", "cleanUrl", "href", "splitCells", "tableRow", "count", "row", "match", "offset", "str", "escaped", "curr", "cells", "i", "rtrim", "c", "invert", "l", "suffLen", "currChar", "findClosingBracket", "b", "level", "outputLink", "cap", "raw", "lexer", "rules", "title", "text", "token", "indentCodeCompensation", "matchIndentToCode", "indentToCode", "node", "matchIndentInNode", "indentInNode", "_Tokenizer", "options", "src", "trimmed", "lines", "tokens", "inBlockquote", "currentLines", "currentRaw", "currentText", "top", "lastToken", "oldToken", "newText", "newToken", "isordered", "itemRegex", "endsWithBlankLine", "endEarly", "itemContents", "line", "t", "nextLine", "blankLine", "nextBulletRegex", "hrRegex", "fencesBeginRegex", "headingBeginRegex", "htmlBeginRegex", "rawLine", "nextLineWithoutTabs", "istask", "ischecked", "lastItem", "spacers", "hasMultipleLineBreaks", "headers", "aligns", "rows", "item", "align", "cell", "trimmedUrl", "rtrimSlash", "lastParenIndex", "linkLen", "links", "linkString", "maskedSrc", "prevChar", "lLength", "rDelim", "rLength", "delimTotal", "midDelimTotal", "endReg", "lastCharLength", "hasNonSpaceChars", "hasSpaceCharsOnBothEnds", "prevCapZero", "_Lexer", "__Lexer", "next", "lastParagraphClipped", "extTokenizer", "cutSrc", "startIndex", "tempSrc", "tempStart", "getStartIndex", "errMsg", "keepPrevChar", "_Renderer", "lang", "langString", "code", "depth", "ordered", "start", "body", "j", "type", "startAttr", "itemBody", "checkbox", "checked", "header", "k", "content", "cleanHref", "out", "_TextRenderer", "_Parser", "__Parser", "anyToken", "genericToken", "ret", "textToken", "renderer", "_Hooks", "markdown", "Marked", "args", "callback", "values", "tableToken", "listToken", "childTokens", "extensions", "pack", "opts", "ext", "prevRenderer", "extLevel", "prop", "rendererProp", "rendererFunc", "tokenizer", "tokenizerProp", "tokenizerFunc", "prevTokenizer", "hooks", "hooksProp", "hooksFunc", "prevHook", "arg", "walkTokens", "packWalktokens", "blockType", "origOpt", "throwError", "processedSrc", "processedTokens", "e", "silent", "async", "msg", "markedInstance", "marked", "setOptions", "use", "parseInline", "parser", "_Parser", "lexer", "_Lexer", "from", "to", "i", "global", "n", "getStyleObjectFromCSS", "getCSSFromStyleObject", "data", "$isListItemNode", "$isListNode", "TextNode", "x", "$isTextNode", "childNode", "callback", "$isRangeSelection", "index", "elements", "resolve", "SKIP_DOM_SELECTION_TAG", "SELECTION_CHANGE_COMMAND", "COMMAND_PRIORITY_HIGH", "$getSelection", "isBold", "isItalic", "$isQuoteNode", "$isHeadingNode", "$isCodeNode", "$getTableCellNodeFromLexicalNode", "$isLinkNode", "a", "b", "DecoratorNode", "DirectUpload", "error", "$getNodeByKey", "HISTORY_MERGE_TAG", "FORMAT_TEXT_COMMAND", "$createAutoLinkNode", "$createTextNode", "$toggleLink", "INSERT_UNORDERED_LIST_COMMAND", "INSERT_ORDERED_LIST_COMMAND", "$createQuoteNode", "CodeNode", "$isRootOrShadowRoot", "$createHeadingNode", "INSERT_TABLE_COMMAND", "UNDO_COMMAND", "REDO_COMMAND", "PASTE_COMMAND", "COMMAND_PRIORITY_LOW", "handler", "KEY_TAB_COMMAND", "COMMAND_PRIORITY_NORMAL", "OUTDENT_CONTENT_COMMAND", "INDENT_CONTENT_COMMAND", "$isNodeSelection", "range", "$getRoot", "$isLineBreakNode", "$getNearestNodeOfType", "ListNode", "$getListDepth", "TableCellNode", "$isElementNode", "KEY_ARROW_LEFT_COMMAND", "KEY_ARROW_RIGHT_COMMAND", "KEY_ARROW_UP_COMMAND", "KEY_ARROW_DOWN_COMMAND", "KEY_DELETE_COMMAND", "KEY_BACKSPACE_COMMAND", "$createNodeSelection", "$setSelection", "$createParagraphNode", "y", "computed", "html", "_", "text", "overrides", "KEY_ENTER_COMMAND", "$isParagraphNode", "$createListNode", "$generateNodesFromDOM", "$insertNodes", "$createLinkNode", "$createLineBreakNode", "dispatch", "PASTE_TAG", "$insertDataTransferForRichText", "createCommand", "createState", "defineExtension", "RichTextExtension", "config", "$hasUpdateTag", "$getSelectionStyleValueForProperty", "$patchStyleText", "$setState", "$getState", "normalizeCodeLang", "TableNode", "TableRowNode", "registerTablePlugin", "registerTableSelectionObserver", "setScrollableTablesActive", "TableCellHeaderStates", "$insertTableRowAtSelection", "$insertTableColumnAtSelection", "$deleteTableRowAtSelection", "$deleteTableColumnAtSelection", "$findTableNode", "CLEAR_HISTORY_COMMAND", "$generateHtmlFromNodes", "$addUpdateTag", "buildEditorFromExtensions", "QuoteNode", "HeadingNode", "ListItemNode", "CodeHighlightNode", "LinkNode", "AutoLinkNode", "registerRichText", "registerList", "registerMarkdownShortcuts", "TRANSFORMERS", "registerPlainText", "createEmptyHistoryState", "registerHistory", "registerCodeHighlighting", "$getTableRowIndexFromTableCellNode", "$getTableColumnIndexFromTableCellNode", "$findCellNode", "KEY_DOWN_COMMAND", "$getElementForTableNode", "KEY_SPACE_COMMAND", "CODE_LANGUAGE_FRIENDLY_NAME_MAP", "callback", "index", "i", "effect", "names", "isObject2", "e", "cache", "noop", "a", "b", "dispatch", "skip", "started", "start", "resolve", "start2", "from", "to", "clone", "callback2", "debounce", "map", "hasOwn", "_", "c", "capitalize", "effect2", "effects", "l", "set3", "v", "r", "id", "clone2", "clone3", "removeListener", "undo", "v", "l", "h", "v", "b", "a", "f", "h", "s", "l", "n", "k", "w", "i", "r", "g", "d", "range", "c", "m", "j", "interpolate", "t", "clone", "color", "w2", "p", "noop", "uid", "id", "isNullOrUndef", "value", "undefined", "isArray", "Array", "type", "Object", "prototype", "toString", "call", "slice", "isObject", "isNumberFinite", "Number", "isFinite", "finiteOrDefault", "defaultValue", "valueOrDefault", "toPercentage", "dimension", "endsWith", "parseFloat", "toDimension", "callback", "fn", "args", "thisArg", "apply", "each", "loopable", "reverse", "i", "len", "keys", "length", "_elementsEqual", "a0", "a1", "ilen", "v0", "v1", "datasetIndex", "index", "clone", "source", "map", "target", "create", "klen", "k", "isValidKey", "key", "indexOf", "_merger", "options", "tval", "sval", "merge", "sources", "merger", "current", "mergeIf", "_mergerIf", "hasOwnProperty", "keyResolvers", "v", "x", "o", "y", "_splitKey", "key", "parts", "split", "keys", "tmp", "part", "endsWith", "slice", "push", "_getKeyResolver", "obj", "k", "resolveObjectKey", "resolver", "_capitalize", "str", "charAt", "toUpperCase", "defined", "value", "isFunction", "setsEqual", "a", "b", "size", "item", "has", "_isClickEvent", "e", "type", "PI", "Math", "TAU", "PITAU", "INFINITY", "Number", "POSITIVE_INFINITY", "RAD_PER_DEG", "HALF_PI", "QUARTER_PI", "TWO_THIRDS_PI", "log10", "sign", "almostEquals", "epsilon", "abs", "niceNum", "range", "roundedRange", "round", "niceRange", "pow", "floor", "fraction", "niceFraction", "_factorize", "result", "sqrt", "i", "sort", "pop", "isNonPrimitive", "n", "Symbol", "toPrimitive", "isNumber", "isNaN", "parseFloat", "isFinite", "almostWhole", "rounded", "_setMinAndMaxByKey", "array", "target", "property", "ilen", "length", "min", "max", "toRadians", "degrees", "toDegrees", "radians", "_decimalPlaces", "isFiniteNumber", "p", "getAngleFromPoint", "centrePoint", "anglePoint", "distanceFromXCenter", "distanceFromYCenter", "radialDistanceFromCenter", "angle", "atan2", "distance", "distanceBetweenPoints", "pt1", "pt2", "_angleDiff", "_normalizeAngle", "_angleBetween", "start", "end", "sameAngleIsFullCircle", "s", "angleToStart", "angleToEnd", "startToAngle", "endToAngle", "_limitValue", "_int16Range", "_isBetween", "_lookup", "table", "cmp", "index", "hi", "lo", "mid", "_lookupByKey", "last", "ti", "_rlookupByKey", "_filterBetween", "values", "arrayEvents", "listenArrayEvents", "listener", "_chartjs", "listeners", "Object", "defineProperty", "configurable", "enumerable", "forEach", "method", "base", "args", "res", "apply", "object", "unlistenArrayEvents", "stub", "indexOf", "splice", "_arrayUnique", "items", "set", "Set", "Array", "from", "requestAnimFrame", "window", "callback", "requestAnimationFrame", "throttled", "fn", "thisArg", "argsToUse", "ticking", "args", "call", "apply", "debounce", "delay", "timeout", "clearTimeout", "setTimeout", "_toLeftRightCenter", "align", "_alignStartEnd", "start", "end", "_textX", "left", "right", "rtl", "check", "_getStartAndCountOfVisiblePoints", "meta", "points", "animationsDisabled", "pointCount", "length", "count", "_sorted", "iScale", "vScale", "_parsed", "spanGaps", "dataset", "options", "axis", "min", "max", "minDefined", "maxDefined", "getUserBounds", "Math", "_lookupByKey", "lo", "getPixelForValue", "distanceToDefinedLo", "slice", "reverse", "findIndex", "point", "isNullOrUndef", "_limitValue", "hi", "distanceToDefinedHi", "_scaleRangesChanged", "xScale", "yScale", "_scaleRanges", "newRanges", "xmin", "xmax", "ymin", "ymax", "changed", "Object", "assign", "atEdge", "t", "elasticIn", "s", "p", "pow", "sin", "TAU", "elasticOut", "effects", "linear", "easeInQuad", "easeOutQuad", "easeInOutQuad", "easeInCubic", "easeOutCubic", "easeInOutCubic", "easeInQuart", "easeOutQuart", "easeInOutQuart", "easeInQuint", "easeOutQuint", "easeInOutQuint", "easeInSine", "cos", "HALF_PI", "easeOutSine", "easeInOutSine", "PI", "easeInExpo", "easeOutExpo", "easeInOutExpo", "easeInCirc", "sqrt", "easeOutCirc", "easeInOutCirc", "easeInElastic", "easeOutElastic", "easeInOutElastic", "easeInBack", "easeOutBack", "easeInOutBack", "easeInBounce", "easeOutBounce", "m", "d", "easeInOutBounce", "isPatternOrGradient", "value", "type", "toString", "color", "Color", "getHoverColor", "saturate", "darken", "hexString", "numbers", "colors", "applyAnimationsDefaults", "defaults", "set", "undefined", "duration", "easing", "from", "loop", "to", "describe", "_fallback", "_indexable", "_scriptable", "name", "properties", "active", "animation", "resize", "show", "animations", "visible", "hide", "v", "applyLayoutsDefaults", "autoPadding", "padding", "top", "bottom", "intlCache", "Map", "getNumberFormat", "locale", "cacheKey", "JSON", "stringify", "formatter", "get", "Intl", "NumberFormat", "formatNumber", "num", "format", "formatters", "values", "isArray", "numeric", "tickValue", "index", "ticks", "chart", "notation", "delta", "maxTick", "abs", "calculateDelta", "logDelta", "log10", "numDecimal", "isNaN", "floor", "minimumFractionDigits", "maximumFractionDigits", "logarithmic", "remain", "significand", "includes", "applyScaleDefaults", "display", "offset", "beginAtZero", "bounds", "clip", "grace", "grid", "lineWidth", "drawOnChartArea", "drawTicks", "tickLength", "tickWidth", "_ctx", "tickColor", "border", "dash", "dashOffset", "width", "title", "text", "minRotation", "maxRotation", "mirror", "textStrokeWidth", "textStrokeColor", "autoSkip", "autoSkipPadding", "labelOffset", "Ticks", "minor", "major", "crossAlign", "showLabelBackdrop", "backdropColor", "backdropPadding", "route", "startsWith", "overrides", "create", "descriptors", "getScope", "node", "key", "keys", "split", "i", "n", "k", "root", "scope", "merge", "Defaults", "constructor", "_descriptors", "_appliers", "backgroundColor", "borderColor", "datasets", "devicePixelRatio", "context", "platform", "getDevicePixelRatio", "elements", "events", "font", "family", "size", "style", "lineHeight", "weight", "hover", "hoverBackgroundColor", "ctx", "hoverBorderColor", "hoverColor", "indexAxis", "interaction", "mode", "intersect", "includeInvisible", "maintainAspectRatio", "onHover", "onClick", "parsing", "plugins", "responsive", "scale", "scales", "showLine", "drawActiveElementsOnTop", "override", "targetScope", "targetName", "scopeObject", "targetScopeObject", "privateName", "defineProperties", "writable", "enumerable", "local", "target", "isObject", "valueOrDefault", "appliers", "forEach", "toFontString", "_measureText", "data", "gc", "longest", "string", "textWidth", "measureText", "push", "_longestText", "arrayOfThings", "cache", "garbageCollect", "save", "ilen", "j", "jlen", "thing", "nestedThing", "restore", "gcLen", "splice", "_alignPixel", "pixel", "currentDevicePixelRatio", "halfWidth", "round", "clearCanvas", "canvas", "getContext", "resetTransform", "clearRect", "height", "drawPoint", "x", "y", "drawPointLegend", "w", "xOffset", "yOffset", "cornerRadius", "xOffsetW", "yOffsetW", "pointStyle", "rotation", "radius", "rad", "RAD_PER_DEG", "translate", "rotate", "drawImage", "beginPath", "ellipse", "arc", "closePath", "moveTo", "TWO_THIRDS_PI", "lineTo", "QUARTER_PI", "SQRT1_2", "rect", "fill", "borderWidth", "stroke", "_isPointInArea", "area", "margin", "clipArea", "unclipArea", "_steppedLineTo", "previous", "flip", "midpoint", "_bezierCurveTo", "bezierCurveTo", "cp1x", "cp2x", "cp1y", "cp2y", "setRenderOpts", "opts", "translation", "fillStyle", "textAlign", "textBaseline", "decorateText", "line", "strikethrough", "underline", "metrics", "actualBoundingBoxLeft", "actualBoundingBoxRight", "actualBoundingBoxAscent", "actualBoundingBoxDescent", "yDecoration", "strokeStyle", "decorationWidth", "drawBackdrop", "oldColor", "fillRect", "renderText", "lines", "strokeWidth", "strokeColor", "backdrop", "strokeText", "maxWidth", "fillText", "Number", "addRoundedRectPath", "h", "topLeft", "bottomLeft", "bottomRight", "topRight", "LINE_HEIGHT", "FONT_STYLE", "toLineHeight", "matches", "match", "numberOrZero", "_readValueToProps", "props", "ret", "objProps", "read", "prop", "toTRBL", "toTRBLCorners", "toPadding", "obj", "toFont", "fallback", "parseInt", "console", "warn", "resolve", "inputs", "info", "cacheable", "_addGrace", "minmax", "change", "toDimension", "keepZero", "add", "createContext", "parentContext", "_createResolver", "scopes", "prefixes", "rootScopes", "getTarget", "finalRootScopes", "_resolve", "Symbol", "toStringTag", "_cacheable", "_scopes", "_rootScopes", "_getTarget", "Proxy", "deleteProperty", "_keys", "_cached", "_resolveWithPrefixes", "getOwnPropertyDescriptor", "Reflect", "getPrototypeOf", "has", "getKeysFromAllScopes", "ownKeys", "storage", "_storage", "_attachContext", "proxy", "subProxy", "descriptorDefaults", "_proxy", "_context", "_subProxy", "_stack", "Set", "setContext", "receiver", "_resolveWithContext", "allKeys", "configurable", "scriptable", "indexable", "_allKeys", "isScriptable", "isFunction", "isIndexable", "readKey", "prefix", "_capitalize", "needsSubResolver", "prototype", "hasOwnProperty", "_resolveScriptable", "_resolveArray", "getValue", "Error", "Array", "join", "delete", "createSubResolver", "arr", "filter", "item", "resolver", "resolveFallback", "parent", "resolveObjectKey", "addScopes", "parentScopes", "parentFallback", "allScopes", "addScopesFromKey", "subGetTarget", "resolveKeysFromAllScopes", "_parseObjectDataRadialScale", "_parsing", "parsed", "r", "parse", "EPSILON", "getPoint", "skip", "getValueAxis", "splineCurve", "firstPoint", "middlePoint", "afterPoint", "current", "next", "d01", "distanceBetweenPoints", "d12", "s01", "s12", "fa", "fb", "monotoneAdjust", "deltaK", "mK", "pointsLen", "alphaK", "betaK", "tauK", "squaredMagnitude", "pointCurrent", "pointAfter", "almostEquals", "monotoneCompute", "valueAxis", "pointBefore", "iPixel", "vPixel", "splineCurveMonotone", "slopeDelta", "sign", "capControlPoint", "pt", "capBezierPoints", "inArea", "inAreaPrev", "inAreaNext", "_updateBezierControlPoints", "controlPoints", "cubicInterpolationMode", "prev", "tension", "_isDomSupported", "document", "_getParentNode", "domNode", "parentNode", "host", "parseMaxStyle", "styleValue", "parentProperty", "valueInPixels", "indexOf", "getComputedStyle", "element", "ownerDocument", "defaultView", "getStyle", "el", "property", "getPropertyValue", "positions", "getPositionedStyle", "styles", "suffix", "result", "pos", "parseFloat", "useOffsetPos", "shadowRoot", "getCanvasPosition", "e", "touches", "source", "offsetX", "offsetY", "box", "getBoundingClientRect", "clientX", "clientY", "getRelativePosition", "event", "borderBox", "boxSizing", "paddings", "borders", "getContainerSize", "maxHeight", "container", "clientWidth", "clientHeight", "containerStyle", "containerBorder", "containerPadding", "INFINITY", "round1", "getMaximumSize", "bbWidth", "bbHeight", "aspectRatio", "margins", "containerSize", "maintainHeight", "retinaScale", "forceRatio", "forceStyle", "pixelRatio", "deviceHeight", "deviceWidth", "setTransform", "supportsEventListenerOptions", "passiveSupported", "passive", "addEventListener", "removeEventListener", "readUsedSize", "_pointInLine", "p1", "p2", "_steppedInterpolation", "_bezierInterpolation", "cp1", "cp2", "a", "b", "c", "getRightToLeftAdapter", "rectX", "setWidth", "xPlus", "leftForLtr", "itemWidth", "getLeftToRightAdapter", "_itemWidth", "getRtlAdapter", "overrideTextDirection", "direction", "original", "getPropertyPriority", "setProperty", "prevTextDirection", "restoreTextDirection", "propertyFn", "between", "_angleBetween", "compare", "_angleDiff", "normalize", "_normalizeAngle", "_isBetween", "normalizeSegment", "getSegment", "segment", "startBound", "endBound", "_boundSegment", "inside", "subStart", "prevValue", "startIsBefore", "endIsBefore", "shouldStart", "shouldStop", "_boundSegments", "segments", "sub", "findStartAndEnd", "solidSegments", "last", "cur", "stop", "_computeSegments", "segmentOptions", "_loop", "splitByStyles", "completeLoop", "_fullLoop", "doSplitByStyles", "chartContext", "_chart", "baseStyle", "readStyle", "_datasetIndex", "datasetIndex", "prevStyle", "addStyle", "l", "st", "dir", "p0", "p0DataIndex", "p1DataIndex", "styleChanged", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "replacer", "getSizeForArea", "chartArea", "field", "getDatasetArea", "getDatasetClipArea", "_clip", "disabled", "Animator", "constructor", "_request", "_charts", "Map", "_running", "_lastDate", "undefined", "_notify", "chart", "anims", "date", "type", "callbacks", "listeners", "numSteps", "duration", "forEach", "fn", "initial", "currentStep", "Math", "min", "start", "_refresh", "requestAnimFrame", "call", "window", "_update", "Date", "now", "remaining", "running", "items", "length", "i", "draw", "item", "_active", "_total", "tick", "pop", "_getAnims", "charts", "get", "complete", "progress", "set", "listen", "event", "cb", "push", "add", "has", "reduce", "acc", "cur", "max", "_duration", "stop", "cancel", "remove", "delete", "transparent", "interpolators", "boolean", "from", "to", "factor", "color", "c0", "helpersColor", "c1", "valid", "mix", "hexString", "number", "Animation", "cfg", "target", "prop", "currentValue", "resolve", "_fn", "_easing", "effects", "easing", "linear", "_start", "floor", "delay", "_loop", "loop", "_target", "_prop", "_from", "_to", "_promises", "active", "update", "elapsed", "remain", "wait", "promises", "Promise", "res", "rej", "resolved", "method", "Animations", "config", "_chart", "_properties", "configure", "isObject", "animationOptions", "Object", "keys", "defaults", "animation", "animatedProps", "getOwnPropertyNames", "key", "option", "isArray", "properties", "_animateOptions", "values", "newOptions", "options", "resolveTargetOptions", "animations", "_createAnimations", "$shared", "awaitAll", "$animations", "then", "props", "charAt", "value", "size", "assign", "animator", "anim", "all", "scaleClip", "scale", "allowedOverflow", "opts", "reverse", "end", "defaultClip", "xScale", "yScale", "x", "y", "top", "right", "bottom", "left", "toClip", "t", "r", "b", "l", "disabled", "getSortedDatasetIndices", "filterVisible", "metasets", "_getSortedDatasetMetas", "ilen", "index", "applyStack", "stack", "dsIndex", "singleMode", "mode", "datasetIndex", "otherValue", "found", "isFinite", "sign", "convertObjectDataToArray", "data", "meta", "iScale", "vScale", "iAxisKey", "axis", "vAxisKey", "adata", "Array", "isStacked", "stacked", "getStackKey", "indexScale", "valueScale", "id", "getUserBounds", "minDefined", "maxDefined", "Number", "NEGATIVE_INFINITY", "POSITIVE_INFINITY", "getOrCreateStack", "stacks", "stackKey", "indexValue", "subStack", "getLastIndexInStack", "positive", "getMatchingVisibleMetas", "updateStacks", "controller", "parsed", "_cachedMeta", "_stacks", "iAxis", "vAxis", "itemStacks", "_top", "_bottom", "visualValues", "_visualValues", "getFirstScaleId", "scales", "filter", "shift", "createDatasetContext", "parent", "createContext", "dataset", "createDataContext", "element", "dataIndex", "raw", "clearStacks", "_parsed", "isDirectUpdateMode", "cloneIfNotShared", "cached", "shared", "createStack", "canStack", "hidden", "_stacked", "DatasetController", "datasetElementType", "dataElementType", "_ctx", "ctx", "_cachedDataOpts", "getMeta", "_type", "_parsing", "_data", "_objectData", "_sharedOptions", "_drawStart", "_drawCount", "enableOptionSharing", "supportsDecimation", "$context", "_syncList", "initialize", "linkScales", "addElements", "fill", "isPluginEnabled", "console", "warn", "updateIndex", "getDataset", "chooseId", "xid", "xAxisID", "valueOrDefault", "yid", "yAxisID", "rid", "rAxisID", "indexAxis", "iid", "iAxisID", "vid", "vAxisID", "getScaleForId", "rScale", "datasets", "getDatasetMeta", "scaleID", "_getOtherScale", "reset", "_destroy", "unlistenArrayEvents", "_dataCheck", "isExtensible", "listenArrayEvents", "buildOrUpdateElements", "resetNewElements", "stackChanged", "oldStacked", "_resyncElements", "scopeKeys", "datasetScopeKeys", "scopes", "getOptionScopes", "createResolver", "getContext", "parsing", "parse", "count", "sorted", "_sorted", "prev", "parseArrayData", "parseObjectData", "parsePrimitiveData", "isNotInOrderComparedToPrev", "labels", "getLabels", "singleScale", "xAxisKey", "yAxisKey", "resolveObjectKey", "getParsed", "getDataElement", "updateRangeFromParsed", "range", "parsedValue", "NaN", "getMinMax", "otherScale", "otherMin", "otherMax", "_skip", "getAllParsedValues", "getMaxOverflow", "getLabelAndValue", "label", "getLabelForValue", "_clip", "clip", "elements", "area", "chartArea", "drawActiveElementsOnTop", "getStyle", "resolveDatasetElementOptions", "resolveDataElementOptions", "context", "_resolveElementOptions", "elementType", "cache", "cacheKey", "sharing", "defined", "datasetElementScopeKeys", "prefixes", "names", "resolveNamedOptions", "freeze", "_resolveAnimations", "transition", "datasetAnimationScopeKeys", "_cacheable", "getSharedOptions", "includeOptions", "sharedOptions", "_animationsDisabled", "_getSharedOptions", "firstOpts", "previouslySharedOptions", "updateSharedOptions", "updateElement", "_setStyle", "removeHoverStyle", "setHoverStyle", "_removeDatasetHoverStyle", "_setDatasetHoverStyle", "arg1", "arg2", "numMeta", "numData", "_insertElements", "_removeElements", "move", "arr", "updateElements", "removed", "splice", "_sync", "args", "_dataChanges", "_onDataPush", "arguments", "_onDataPop", "_onDataShift", "_onDataSplice", "newCount", "_onDataUnshift", "getAllScaleValues", "_cache", "$bar", "visibleMetas", "concat", "_arrayUnique", "sort", "a", "computeMinSampleSize", "_length", "curr", "updateMinAndPrev", "abs", "getPixelForValue", "ticks", "getPixelForTick", "computeFitCategoryTraits", "ruler", "stackCount", "thickness", "barThickness", "ratio", "isNullOrUndef", "categoryPercentage", "barPercentage", "chunk", "pixels", "computeFlexCategoryTraits", "next", "percent", "parseFloatBar", "entry", "startValue", "endValue", "barStart", "barEnd", "_custom", "parseValue", "parseArrayOrPrimitive", "isFloatBar", "custom", "barSign", "actualBase", "isHorizontal", "borderProps", "horizontal", "base", "setBorderSkipped", "edge", "borderSkipped", "enableBorderRadius", "parseEdge", "swap", "startEnd", "orig", "v1", "v2", "v", "setInflateAmount", "inflateAmount", "BarController", "grouped", "numbers", "overrides", "_index_", "offset", "grid", "_value_", "beginAtZero", "obj", "bars", "getBasePixel", "_getRuler", "vpixels", "head", "_calculateBarValuePixels", "ipixels", "_calculateBarIndexPixels", "center", "height", "width", "_getStacks", "last", "currentParsed", "iScaleValue", "skipNull", "find", "val", "isNaN", "indexOf", "_getStackCount", "_getAxisCount", "_getAxis", "getFirstScaleIdForIndexAxis", "indexScaleId", "firstScaleAxisId", "_getStackIndex", "name", "_startPixel", "_endPixel", "baseValue", "minBarLength", "floating", "getDataVisibility", "startPixel", "getPixelForDecimal", "endPixel", "getValueForPixel", "halfGrid", "getLineWidthForValue", "maxBarThickness", "Infinity", "axisCount", "axisID", "axisNumber", "stackIndex", "rects", "BubbleController", "radius", "points", "point", "iPixel", "vPixel", "skip", "getRatioAndOffset", "rotation", "circumference", "cutout", "ratioX", "ratioY", "offsetX", "offsetY", "TAU", "startAngle", "endAngle", "startX", "cos", "startY", "sin", "endX", "endY", "calcMax", "angle", "_angleBetween", "calcMin", "maxX", "maxY", "HALF_PI", "minX", "PI", "minY", "DoughnutController", "animateRotate", "animateScale", "spacing", "descriptors", "_scriptable", "_indexable", "startsWith", "aspectRatio", "plugins", "legend", "generateLabels", "pointStyle", "textAlign", "useBorderRadius", "borderRadius", "map", "style", "text", "fillStyle", "backgroundColor", "fontColor", "lineDash", "borderDash", "lineDashOffset", "borderDashOffset", "lineJoin", "borderJoinStyle", "lineWidth", "borderWidth", "strokeStyle", "borderColor", "onClick", "e", "legendItem", "toggleDataVisibility", "innerRadius", "outerRadius", "getter", "_getRotation", "toRadians", "_getCircumference", "_getRotationExtents", "isDatasetVisible", "arcs", "getMaxBorderWidth", "getMaxOffset", "maxSize", "toPercentage", "chartWeight", "_getRingWeight", "maxWidth", "maxHeight", "maxRadius", "toDimension", "radiusLength", "_getVisibleDatasetWeightTotal", "total", "calculateTotal", "_getRingWeightOffset", "_circumference", "calculateCircumference", "animationOpts", "centerX", "centerY", "arc", "metaData", "formatNumber", "locale", "borderAlign", "hoverBorderWidth", "hoverOffset", "ringWeightOffset", "weight", "LineController", "showLine", "spanGaps", "line", "_dataset", "animationsDisabled", "_getStartAndCountOfVisiblePoints", "_scaleRangesChanged", "_datasetIndex", "_decimated", "segment", "animated", "maxGapLength", "isNumber", "directUpdate", "pointsCount", "prevParsed", "nullData", "border", "firstPoint", "lastPoint", "updateControlPoints", "PolarAreaController", "angleLines", "display", "circular", "pointLabels", "_parseObjectDataRadialScale", "bind", "_updateRadius", "minSize", "cutoutPercentage", "getVisibleDatasetCount", "xCenter", "yCenter", "datasetStartAngle", "getIndexAngle", "defaultAngle", "countVisibleElements", "_computeAngle", "getDistanceFromCenterForValue", "PieController", "RadarController", "_fullLoop", "pointPosition", "getPointPositionForValue", "ScatterController", "interaction", "registry", "getElement", "abstract", "Error", "DateAdapterBase", "override", "members", "prototype", "init", "formats", "format", "diff", "startOf", "endOf", "_date", "binarySearch", "metaset", "intersect", "lookupMethod", "_reversePixels", "_rlookupByKey", "_lookupByKey", "result", "distanceToDefinedLo", "slice", "lo", "findIndex", "distanceToDefinedHi", "hi", "el", "getRange", "evaluateInteractionItems", "position", "handler", "getSortedVisibleDatasetMetas", "j", "getDistanceMetricForAxis", "useX", "useY", "pt1", "pt2", "deltaX", "deltaY", "sqrt", "pow", "getIntersectItems", "useFinalPosition", "includeInvisible", "isPointInArea", "evaluationFunc", "_isPointInArea", "inRange", "getNearestRadialItems", "getProps", "getAngleFromPoint", "getNearestCartesianItems", "distanceMetric", "minDistance", "getCenterPoint", "pointInArea", "distance", "getNearestItems", "getAxisItems", "rangeMethod", "intersectsItem", "modes", "getRelativePosition", "nearest", "STATIC_POSITIONS", "filterByPosition", "array", "pos", "filterDynamicPositionByAxis", "box", "sortByWeight", "v0", "wrapBoxes", "boxes", "layoutBoxes", "stackWeight", "buildStacks", "layouts", "wrap", "includes", "_stack", "placed", "setLayoutDims", "params", "vBoxMaxWidth", "hBoxMaxHeight", "layout", "fullSize", "availableWidth", "availableHeight", "buildLayoutBoxes", "centerHorizontal", "centerVertical", "leftAndTop", "rightAndBottom", "vertical", "getCombinedMax", "maxPadding", "updateMaxPadding", "boxPadding", "updateDims", "getPadding", "newWidth", "outerWidth", "newHeight", "outerHeight", "widthChanged", "w", "heightChanged", "h", "same", "other", "handleMaxPadding", "updatePos", "change", "getMargins", "marginForPositions", "positions", "margin", "fitBoxes", "refitBoxes", "refit", "changed", "setBoxDims", "placeBoxes", "userPadding", "padding", "addBox", "_layers", "z", "removeBox", "layoutItem", "minPadding", "toPadding", "verticalBoxes", "horizontalBoxes", "each", "beforeLayout", "visibleVerticalBoxCount", "BasePlatform", "acquireContext", "canvas", "releaseContext", "addEventListener", "listener", "removeEventListener", "getDevicePixelRatio", "getMaximumSize", "isAttached", "updateConfig", "BasicPlatform", "EXPANDO_KEY", "EVENT_TYPES", "touchstart", "touchmove", "touchend", "pointerenter", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointerout", "isNullOrEmpty", "initCanvas", "renderHeight", "getAttribute", "renderWidth", "boxSizing", "displayWidth", "readUsedSize", "displayHeight", "eventListenerOptions", "supportsEventListenerOptions", "passive", "addListener", "node", "removeListener", "fromNativeEvent", "native", "nodeListContains", "nodeList", "contains", "createAttachObserver", "observer", "MutationObserver", "entries", "trigger", "addedNodes", "removedNodes", "observe", "document", "childList", "subtree", "createDetachObserver", "drpListeningCharts", "oldDevicePixelRatio", "onWindowResize", "dpr", "devicePixelRatio", "resize", "currentDevicePixelRatio", "listenDevicePixelRatioChanges", "unlistenDevicePixelRatioChanges", "createResizeObserver", "container", "_getParentNode", "throttled", "clientWidth", "ResizeObserver", "contentRect", "releaseObserver", "disconnect", "createProxyAndListen", "proxy", "DomPlatform", "removeAttribute", "setAttribute", "proxies", "$proxies", "handlers", "attach", "detach", "isConnected", "_detectPlatform", "_isDomSupported", "OffscreenCanvas", "Element", "defaultRoutes", "tooltipPosition", "hasValue", "final", "ret", "autoSkip", "tickOpts", "determinedMaxTicks", "determineMaxTicks", "ticksLimit", "maxTicksLimit", "majorIndices", "major", "enabled", "getMajorIndices", "numMajorIndices", "first", "newTicks", "skipMajors", "calculateSpacing", "avgMajorSpacing", "round", "tickLength", "_tickSize", "maxScale", "maxChart", "_maxLength", "evenMajorSpacing", "getEvenSpacing", "factors", "_factorize", "ceil", "majorStart", "majorEnd", "len", "reverseAlign", "align", "offsetFromEdge", "getTicksLimit", "ticksLength", "sample", "numItems", "increment", "getPixelForGridLine", "offsetGridLines", "validIndex", "epsilon", "lineValue", "garbageCollect", "caches", "gc", "gcLen", "getTickMarkLength", "drawTicks", "getTitleHeight", "fallback", "font", "toFont", "lines", "lineHeight", "createScaleContext", "createTickContext", "titleAlign", "_toLeftRightCenter", "titleArgs", "titleX", "titleY", "_alignStartEnd", "positionAxisID", "Scale", "_margins", "paddingTop", "paddingBottom", "paddingLeft", "paddingRight", "labelRotation", "_range", "_gridLineItems", "_labelItems", "_labelSizes", "_longestTextCache", "_userMax", "_userMin", "_suggestedMax", "_suggestedMin", "_ticksLength", "_borderValue", "_dataLimitsCached", "setContext", "suggestedMin", "suggestedMax", "finiteOrDefault", "metas", "getTicks", "xLabels", "yLabels", "getLabelItems", "_computeLabelItems", "beforeUpdate", "margins", "grace", "sampleSize", "beforeSetDimensions", "setDimensions", "afterSetDimensions", "beforeDataLimits", "determineDataLimits", "afterDataLimits", "_addGrace", "beforeBuildTicks", "buildTicks", "afterBuildTicks", "samplingEnabled", "_convertTicksToLabels", "beforeCalculateLabelRotation", "calculateLabelRotation", "afterCalculateLabelRotation", "source", "afterAutoSkip", "beforeFit", "fit", "afterFit", "afterUpdate", "reversePixels", "_alignToPixels", "alignToPixels", "_callHooks", "notifyPlugins", "beforeTickToLabelConversion", "generateTickLabels", "callback", "afterTickToLabelConversion", "numTicks", "minRotation", "maxRotation", "tickWidth", "maxLabelDiagonal", "_isVisible", "labelSizes", "_getLabelSizes", "maxLabelWidth", "widest", "maxLabelHeight", "highest", "_limitValue", "title", "toDegrees", "asin", "titleOpts", "gridOpts", "titleHeight", "tickPadding", "angleRadians", "labelHeight", "mirror", "labelWidth", "_calculatePadding", "_handleMargins", "isRotated", "labelsBelowTicks", "offsetLeft", "offsetRight", "isFullSize", "_computeLabelSizes", "widths", "heights", "widestLabelSize", "highestLabelSize", "jlen", "tickFont", "fontString", "nestedLabel", "_resolveTickFontOptions", "string", "_measureText", "valueAt", "idx", "pixel", "decimal", "_int16Range", "_alignPixel", "getDecimalForPixel", "getBaseValue", "optionTicks", "rot", "autoSkipPadding", "_computeGridLineItems", "tl", "borderOpts", "axisWidth", "axisHalfWidth", "alignBorderValue", "borderValue", "alignedLineValue", "tx1", "ty1", "tx2", "ty2", "x1", "y1", "x2", "y2", "limit", "step", "optsAtIndex", "optsAtIndexBorder", "lineColor", "dash", "dashOffset", "tickColor", "tickBorderDash", "tickBorderDashOffset", "crossAlign", "tickAndPadding", "hTickAndPadding", "lineCount", "textOffset", "textBaseline", "_getXAxisLabelAlignment", "_getYAxisLabelAlignment", "labelOffset", "halfCount", "strokeColor", "textStrokeColor", "strokeWidth", "textStrokeWidth", "tickTextAlign", "showLabelBackdrop", "backdrop", "labelPadding", "backdropPadding", "backdropColor", "translation", "_computeLabelArea", "drawBackground", "save", "fillRect", "restore", "drawGrid", "drawLine", "p1", "p2", "setLineDash", "beginPath", "moveTo", "lineTo", "stroke", "drawOnChartArea", "drawBorder", "lastLineWidth", "drawLabels", "clipArea", "renderTextOptions", "renderText", "unclipArea", "drawTitle", "tz", "gz", "bz", "_maxDigits", "fontSize", "TypedRegistry", "scope", "create", "isForType", "isPrototypeOf", "register", "proto", "getPrototypeOf", "parentScope", "isIChartComponent", "registerDefaults", "unregister", "itemDefaults", "merge", "routeDefaults", "describe", "routes", "property", "propertyParts", "split", "sourceName", "sourceScope", "join", "parts", "targetName", "targetScope", "route", "Registry", "controllers", "_typedRegistries", "_each", "addControllers", "addPlugins", "addScales", "getController", "_get", "getPlugin", "getScale", "removeControllers", "removeElements", "removePlugins", "removeScales", "typedRegistry", "arg", "reg", "_getRegistryForType", "_exec", "itemReg", "component", "camelMethod", "_capitalize", "PluginService", "_init", "notify", "hook", "_createDescriptors", "_descriptors", "descriptor", "plugin", "callCallback", "cancelable", "invalidate", "_oldCache", "_notifyStateChanges", "allPlugins", "createDescriptors", "previousDescriptors", "some", "localIds", "local", "getOpts", "pluginOpts", "pluginScopeKeys", "scriptable", "indexable", "allKeys", "getIndexAxis", "datasetDefaults", "datasetOptions", "getAxisFromDefaultScaleID", "getDefaultScaleIDFromAxis", "idMatchesAxis", "axisFromPosition", "determineAxis", "scaleOptions", "toLowerCase", "getAxisFromDataset", "retrieveAxisFromDatasets", "boundDs", "d", "mergeScaleConfig", "chartDefaults", "configScales", "chartIndexAxis", "scaleConf", "error", "_proxy", "defaultId", "defaultScaleOptions", "mergeIf", "defaultID", "initOptions", "initData", "initConfig", "keyCache", "keysCached", "Set", "cachedKeys", "generate", "addIfFound", "Config", "_config", "_scopeCache", "_resolverCache", "platform", "clearCache", "clear", "datasetType", "additionalOptionScopes", "_cachedScopes", "mainScope", "resetCache", "keyLists", "chartOptionScopes", "resolver", "subPrefixes", "getResolver", "needContext", "isFunction", "subResolver", "_attachContext", "descriptorDefaults", "resolverCache", "_createResolver", "p", "hasFunction", "isScriptable", "isIndexable", "KNOWN_POSITIONS", "positionIsHorizontal", "compare2Level", "l1", "l2", "onAnimationsComplete", "onComplete", "onAnimationProgress", "onProgress", "getCanvas", "getElementById", "instances", "getChart", "c", "moveNumericKeys", "intKey", "determineLastEvent", "lastEvent", "inChartArea", "isClick", "Chart", "version", "invalidatePlugins", "userConfig", "initialCanvas", "existingChart", "uid", "_options", "_aspectRatio", "_metasets", "_lastEvent", "_listeners", "_responsiveListeners", "_sortedMetasets", "_plugins", "_hiddenIndices", "attached", "_doResize", "debounce", "resizeDelay", "_initialize", "maintainAspectRatio", "responsive", "retinaScale", "bindEvents", "clearCanvas", "_resize", "_resizeBeforeDraw", "newSize", "newRatio", "onResize", "render", "ensureScalesHaveIDs", "scalesOptions", "axisOptions", "buildOrUpdateScales", "scaleOpts", "updated", "isRadial", "dposition", "dtype", "scaleType", "scaleClass", "hasUpdated", "_updateMetasets", "_destroyDatasetMeta", "_removeUnreferencedMetasets", "buildOrUpdateControllers", "newControllers", "order", "visible", "ControllerClass", "_resetElements", "animsDisabled", "_updateScales", "_checkEventBindings", "_updateHiddenIndices", "_minPadding", "autoPadding", "_updateLayout", "_updateDatasets", "_eventHandler", "_updateHoverStyles", "existingEvents", "newEvents", "events", "setsEqual", "unbindEvents", "changes", "_getUniformDataChanges", "datasetCount", "makeSet", "changeSet", "noArea", "_idx", "_updateDataset", "layers", "_drawDatasets", "_drawDataset", "getDatasetClipArea", "getElementsAtEventForMode", "Interaction", "setDatasetVisibility", "_updateVisibility", "hide", "show", "_stop", "destroy", "toBase64Image", "toDataURL", "bindUserEvents", "bindResponsiveEvents", "_add", "_remove", "detached", "updateHoverStyle", "prefix", "getActiveElements", "setActiveElements", "activeElements", "lastActive", "_elementsEqual", "pluginId", "replay", "hoverOptions", "hover", "deactivated", "activated", "eventFilter", "_handleEvent", "_getActiveElements", "_isClickEvent", "onHover", "clipSelf", "outerAngleClip", "_normalizeAngle", "innerAngleClip", "clipWidth", "closePath", "rect", "clipArc", "pixelMargin", "angleMargin", "toRadiusCorners", "_readValueToProps", "parseBorderRadius", "angleDelta", "o", "halfThickness", "innerLimit", "computeOuterLimit", "outerArcLimit", "outerStart", "outerEnd", "innerStart", "innerEnd", "rThetaToXY", "theta", "pathArc", "innerR", "spacingOffset", "alpha", "noSpacingInnerRadius", "noSpacingOuterRadius", "avNogSpacingRadius", "adjustedAngle", "beta", "angleOffset", "outerStartAdjustedRadius", "outerEndAdjustedRadius", "outerStartAdjustedAngle", "outerEndAdjustedAngle", "innerStartAdjustedRadius", "innerEndAdjustedRadius", "innerStartAdjustedAngle", "innerEndAdjustedAngle", "outerMidAdjustedAngle", "pCenter", "p4", "innerMidAdjustedAngle", "p8", "outerStartX", "outerStartY", "outerEndX", "outerEndY", "drawArc", "fullCircles", "inner", "selfJoin", "ArcElement", "chartX", "chartY", "rAdjust", "nonZeroBetween", "betweenAngles", "withinRadius", "_isBetween", "halfAngle", "halfRadius", "translate", "fix", "radiusOffset", "setStyle", "lineCap", "borderCapStyle", "previous", "getLineMethod", "stepped", "_steppedLineTo", "tension", "cubicInterpolationMode", "_bezierCurveTo", "pathVars", "paramsStart", "paramsEnd", "segmentStart", "segmentEnd", "outside", "pathSegment", "lineMethod", "fastPathSegment", "avgX", "countX", "prevX", "lastY", "pointIndex", "drawX", "truncX", "_getSegmentMethod", "useFastPath", "_getInterpolationMethod", "_steppedInterpolation", "_bezierInterpolation", "_pointInLine", "strokePathWithCache", "path", "_path", "Path2D", "strokePathDirect", "segments", "segmentMethod", "usePath2D", "LineElement", "capBezierPoints", "_points", "_segments", "_pointsUpdated", "_updateBezierControlPoints", "_computeSegments", "interpolate", "_boundSegments", "_interpolate", "interpolated", "hitRadius", "PointElement", "hoverRadius", "mouseX", "mouseY", "inXRange", "inYRange", "drawPoint", "getBarBounds", "bar", "half", "skipOrLimit", "parseBorderWidth", "maxW", "maxH", "toTRBL", "toTRBLCorners", "maxR", "enableBorder", "topLeft", "topRight", "bottomLeft", "bottomRight", "boundingRects", "bounds", "outer", "skipX", "skipY", "skipBoth", "hasRadius", "addNormalRectPath", "inflateRect", "amount", "refRect", "BarElement", "addRectPath", "addRoundedRectPath", "BORDER_COLORS", "BACKGROUND_COLORS", "replace", "getBorderColor", "getBackgroundColor", "colorizeDefaultDataset", "colorizeDoughnutDataset", "colorizePolarAreaDataset", "getColorizer", "containsColorsDefinitions", "k", "containsColorsDefinition", "containsDefaultColorsDefenitions", "forceOverride", "_args", "chartOptions", "containsColorDefenition", "colorizer", "lttbDecimation", "samples", "decimated", "bucketWidth", "sampledIndex", "endIndex", "maxAreaPoint", "maxArea", "nextA", "avgY", "avgRangeStart", "avgRangeEnd", "avgRangeLength", "rangeOffs", "rangeTo", "pointAx", "pointAy", "minMaxDecimation", "minIndex", "maxIndex", "startIndex", "xMin", "xMax", "dx", "lastIndex", "intermediateIndex1", "intermediateIndex2", "cleanDecimatedDataset", "defineProperty", "configurable", "enumerable", "writable", "cleanDecimatedData", "getStartAndCountOfVisiblePointsSimplified", "pointCount", "algorithm", "beforeElementsUpdate", "xAxis", "threshold", "tpoints", "_findSegmentEnd", "_getBounds", "targetSegments", "tgt", "subBounds", "fillSources", "_boundSegment", "fillSource", "_getEdge", "_pointsFromSegments", "boundary", "linePoints", "_createBoundaryLine", "_shouldApplyFill", "_resolveTarget", "sources", "propagate", "visited", "_decodeFill", "parseFillOption", "parseFloat", "decodeTargetIndex", "firstCh", "_getTargetPixel", "_getTargetValue", "fillOption", "_buildStackLine", "sourcePoints", "linesBelow", "getLinesBelow", "addPointsBelow", "below", "unshift", "sourcePoint", "postponed", "findPoint", "pointValue", "firstValue", "lastValue", "simpleArc", "_getTarget", "getLineByIndex", "computeBoundary", "computeCircularBoundary", "computeLinearBoundary", "_drawfill", "lineOpts", "above", "doFill", "fillColor", "clipVertical", "clipHorizontal", "clipY", "lineLoop", "clipX", "src", "notShape", "clipBounds", "interpolatedLineTo", "targetLoop", "interpolatedPoint", "afterDatasetsUpdate", "$filler", "beforeDraw", "drawTime", "beforeDatasetsDraw", "beforeDatasetDraw", "getBoxSize", "labelOpts", "boxHeight", "boxWidth", "usePointStyle", "pointStyleWidth", "itemHeight", "itemsEqual", "Legend", "_added", "legendHitBoxes", "_hoveredItem", "doughnutMode", "legendItems", "columnSizes", "lineWidths", "buildLabels", "labelFont", "_computeTitleHeight", "_fitRows", "_fitCols", "hitboxes", "totalHeight", "row", "itemWidth", "measureText", "_itemHeight", "heightLimit", "totalWidth", "currentColWidth", "currentColHeight", "col", "calculateItemSize", "adjustHitBoxes", "rtl", "rtlHelper", "getRtlAdapter", "hitbox", "leftForLtr", "_draw", "defaultColor", "halfFontSize", "cursor", "drawLegendBox", "drawOptions", "SQRT2", "xPlus", "drawPointLegend", "yBoxTop", "xBoxLeft", "fillText", "strikethrough", "overrideTextDirection", "textDirection", "textWidth", "setWidth", "realX", "_textX", "fontLineHeight", "calculateLegendItemHeight", "restoreTextDirection", "titleFont", "titlePadding", "topPaddingPlusHalfFontSize", "_getLegendItemAt", "hitBox", "lh", "handleEvent", "isListened", "hoveredItem", "sameItem", "onLeave", "calculateItemWidth", "calculateItemHeight", "legendItemText", "_element", "afterEvent", "ci", "Title", "_padding", "textSize", "_drawArgs", "fontOpts", "createTitle", "titleBlock", "WeakMap", "positioners", "average", "xSet", "xAverage", "eventPosition", "nearestElement", "distanceBetweenPoints", "tp", "pushOrConcat", "toPush", "apply", "splitNewlines", "str", "String", "createTooltipItem", "formattedValue", "getTooltipSize", "tooltip", "body", "footer", "bodyFont", "footerFont", "titleLineCount", "footerLineCount", "bodyLineItemCount", "combinedBodyLength", "bodyItem", "before", "after", "beforeBody", "afterBody", "titleSpacing", "titleMarginBottom", "bodyLineHeight", "displayColors", "bodySpacing", "footerMarginTop", "footerSpacing", "widthPadding", "maxLineWidth", "determineYAlign", "doesNotFitWithAlign", "xAlign", "caret", "caretSize", "caretPadding", "determineXAlign", "yAlign", "chartWidth", "determineAlignment", "alignX", "alignY", "paddingAndSize", "getBackgroundPoint", "alignment", "cornerRadius", "getAlignedX", "getBeforeAfterBodyLines", "createTooltipContext", "tooltipItems", "overrideCallbacks", "defaultCallbacks", "beforeTitle", "noop", "labelCount", "afterTitle", "beforeLabel", "tooltipItem", "labelColor", "labelTextColor", "bodyColor", "labelPointStyle", "afterLabel", "beforeFooter", "afterFooter", "invokeCallbackWithFallback", "Tooltip", "opacity", "_eventPosition", "_size", "_cachedAnimations", "_tooltipItems", "dataPoints", "caretX", "caretY", "labelColors", "labelPointStyles", "labelTextColors", "getTitle", "getBeforeBody", "getBody", "bodyItems", "scoped", "getAfterBody", "getFooter", "_createItems", "itemSort", "positionAndSize", "backgroundPoint", "external", "drawCaret", "tooltipPoint", "caretPosition", "getCaretPosition", "x3", "y3", "ptX", "ptY", "pt", "titleColor", "_drawColorBox", "colorX", "rtlColorX", "yOffSet", "colorY", "multiKeyBackground", "outerX", "innerX", "strokeRect", "drawBody", "bodyAlign", "xLinePadding", "fillLineOfText", "bodyAlignForCalculation", "textColor", "drawFooter", "footerAlign", "footerColor", "tooltipSize", "quadraticCurveTo", "_updateAnimationTarget", "animX", "animY", "_willRender", "hasTooltipContent", "globalAlpha", "positionChanged", "_positionChanged", "_ignoreReplayEvents", "afterInit", "afterDraw", "_fallback", "addIfString", "addedLabels", "findOrAddLabel", "lastIndexOf", "_getLabelForValue", "CategoryScale", "_startValue", "_valueRange", "_addedLabels", "added", "generateTicks", "generationOptions", "dataRange", "MIN_SPACING", "precision", "maxTicks", "maxDigits", "includeBounds", "unit", "maxSpaces", "rmin", "rmax", "countDefined", "minSpacing", "niceNum", "niceMin", "niceMax", "numSpaces", "almostWhole", "almostEquals", "decimalPlaces", "_decimalPlaces", "relativeLabelSize", "tickValue", "rad", "LinearScaleBase", "_endValue", "handleTickRangeOptions", "setMin", "setMax", "minSign", "maxSign", "getTickLimit", "stepSize", "computeTickLimit", "numericGeneratorOptions", "_setMinAndMaxByKey", "LinearScale", "Ticks", "formatters", "numeric", "log10Floor", "log10", "changeExponent", "m", "isMajor", "tickVal", "steps", "rangeExp", "rangeStep", "startExp", "minExp", "exp", "significand", "lastTick", "LogarithmicScale", "logarithmic", "_zero", "getTickBackdropHeight", "measureLabelSize", "_longestText", "determineLimits", "fitWithPointLabels", "limits", "valueCount", "_pointLabels", "pointLabelOpts", "additionalAngle", "centerPointLabels", "getPointLabelContext", "getPointPosition", "drawingArea", "plFont", "hLimits", "vLimits", "updateLimits", "setCenterPoint", "_pointLabelItems", "buildPointLabelItems", "createPointLabelItem", "itemOpts", "outerDistance", "extra", "pointLabelPosition", "yForAngle", "getTextAlignForAngle", "leftForTextAlign", "isNotOverlapped", "apexesInArea", "drawPointLabelBox", "backdropLeft", "backdropTop", "backdropWidth", "backdropHeight", "drawPointLabels", "pathRadiusLine", "drawRadiusLine", "gridLineOpts", "createPointLabelContext", "RadialLinearScale", "animate", "leftMovement", "rightMovement", "topMovement", "bottomMovement", "angleMultiplier", "scalingFactor", "getValueForDistanceFromCenter", "scaledDistance", "pointLabel", "distanceFromCenter", "getBasePosition", "getPointLabelPosition", "rotate", "INTERVALS", "millisecond", "common", "second", "minute", "hour", "day", "week", "month", "quarter", "year", "UNITS", "sorter", "input", "adapter", "_adapter", "parser", "isoWeekday", "_parseOpts", "determineUnitForAutoTicks", "minUnit", "capacity", "interval", "MAX_SAFE_INTEGER", "determineUnitForFormatting", "determineMajorUnit", "addTick", "time", "timestamps", "_lookup", "timestamp", "setMajorTicks", "majorUnit", "ticksFromTimestamps", "TimeScale", "adapters", "displayFormats", "_unit", "_majorUnit", "_offsets", "_normalized", "normalized", "_applyBounds", "_getLabelBounds", "getLabelTimestamps", "timeOpts", "_generate", "_filterBetween", "_getLabelCapacity", "initOffsets", "offsetAfterAutoskip", "getDecimalForValue", "minor", "weekday", "hasWeekday", "getDataTimestamps", "tooltipFormat", "datetime", "fmt", "_tickFormatFunction", "formatter", "minorFormat", "majorFormat", "offsets", "_getLabelSize", "ticksOpts", "tickLabelWidth", "cosRotation", "sinRotation", "tickFontSize", "exampleTime", "exampleLabel", "normalize", "table", "prevSource", "nextSource", "prevTarget", "nextTarget", "span", "TimeSeriesScale", "_table", "_minPos", "_tableRange", "_getTimestampsForTable", "buildLookupTable", "registerables", "dayjs", "debug", "LesliChart"]
}
